'' Get and write the hard-coded strings in PE files or other binary files
'' (c) 2010-2019 by wanfu (Last modified on 2019.11.08)

'#Uses ".\Module\modPEInfo.bas"
'#Uses ".\Module\modMacInfo.bas"
'#Uses ".\Module\modCommon.bas"
'#Uses ".\Module\modUpdate.bas"
'#Uses ".\Module\modStringSearch.bas"

Option Explicit

'Public Const Version = "2019.11.08"
'Public Const Build = "191108"
Private Const MacroLoc = MacroDir
Private Const RefFrontChar = "[\x0F\x4C\x48\x8B\xF2][\x05\x10\x0F\x8B\x8D\xB7][\x00-\xFF]{3}"
Private Const SpaceWithPointChar = "・"

Private src As PslSourceList,trn As PslTransList,HideSecMoveVal As Long
Private SelectedBak() As String,UpdateSetBak() As String,LFListBak() As LOG_FONT
Private UniLangListBak() As LANG_PROPERTIE,AllLangList() As LANG_PROPERTIE
Private StopHwnd As Long,EscHwnd As Long,StopMsg As String,StopTitle As String

Private OrgStrTypeList() As STRING_TYPE,OrgStrTypeListBak() As STRING_TYPE
Private UseStrTypeList() As STRING_TYPE,StrTypeListBak() As STRING_TYPE

Private RefTypeListBak() As REF_TYPE,UseRefTypeList() As REF_TYPE

Private UseSectionList() As String,UseSubSecList() As String
Private GetFreeByteSecList() As String,GetFreeByteSecListBak() As String
Private ExtractSetBak() As String,WriteSet As Long
Private FilterStrSet() As String,FindStrSet() As String,AddStrSet() As String
Private ImportSrcSet() As String,ImportTranSet() As String
Private FilterStrDic As Object,ReserveStrDic As Object

Private AllStrDataList() As STRING_PROPERTIE,AllStrDataListBak() As STRING_PROPERTIE
Private UseStrDataList() As STRING_PROPERTIE
Private UseStrIDIndexDic As Object,StrIDIndexDic As Object,StrIDIndexDicBak As Object

Private FreeByteList() As FREE_BTYE_SPACE,FreeByteListBak() As FREE_BTYE_SPACE
Private ParentStrNum As Long,FreeByteDic As Object,StringTerminator As String
Private FindLog() As String,WriteLog() As String
Private FindLogDic As Object,WriteLogDic As Object


' 主程序
Sub Main
	Dim Obj As Object,i As Long,Temp As String,MsgList() As String
	'检测系统语言
	On Error Resume Next
	Set Obj = CreateObject("WScript.Shell")
	If Obj Is Nothing Then
		MsgBox Err.Description & " - " & "WScript.Shell",vbInformation
		Exit Sub
	End If
	Temp = "HKLM\SYSTEM\CurrentControlSet\Control\Nls\Language\Default"
	OSLanguage = Obj.RegRead(Temp)
	If OSLanguage = "" Then
		Temp = "HKLM\SYSTEM\CurrentControlSet\Control\Nls\Language\InstallLanguage"
		OSLanguage = Obj.RegRead(Temp)
		If Err.Source = "WshShell.RegRead" Then
			MsgBox Err.Description,vbInformation
			Exit Sub
		End If
	End If
	Set Obj = Nothing
	'检测 Adodb.Stream 是否存在
	Set Obj = CreateObject("Adodb.Stream")
	If Obj Is Nothing Then
		MsgBox Err.Description & " - " & "Adodb.Stream",vbInformation
		Exit Sub
	End If
	Set Obj = Nothing
	'检测 VBScript.RegExp 是否存在
	Set RegExp = CreateObject("VBScript.RegExp")
	If RegExp Is Nothing Then
		MsgBox Err.Description & " - " & "VBScript.RegExp",vbInformation
		Exit Sub
	End If
	'检测 Scripting.Dictionary 是否存在
	Set StrIDIndexDic = CreateObject("Scripting.Dictionary")
	If StrIDIndexDic Is Nothing Then
		MsgBox Err.Description & " - " & "Scripting.Dictionary",vbInformation
		Exit Sub
	End If
	Set StrIDIndexDicBak = CreateObject("Scripting.Dictionary")
	Set UseStrIDIndexDic = CreateObject("Scripting.Dictionary")
	Set FilterStrDic = CreateObject("Scripting.Dictionary")
	Set ReserveStrDic = CreateObject("Scripting.Dictionary")
	On Error GoTo SysErrorMsg
	'初始化数据
	ReDim Tools(3) As TOOLS_PROPERTIE,FileDataList(0) As String
	ReDim UseSectionList(0) As String,GetFreeByteSecList(0) As String,UseSubSecList(0) As String
	ReDim AllLangList(0) As LANG_PROPERTIE,UseLangList(0) As LANG_PROPERTIE
	ReDim ExtractSet(53) As String,WriteLog(0) As String
	ReDim FilterStrSet(23) As String,FindStrSet(10) As String,SearchSet(17) As String
	ReDim ImportSrcSet(6) As String,ImportTranSet(10) As String,AddStrSet(9) As String
	ReDim StrTypeList(0) As STRING_TYPE,UseStrTypeList(0) As STRING_TYPE,OrgStrTypeList(0) As STRING_TYPE
	ReDim RefTypeList(0) As REF_TYPE,UseRefTypeList(1) As REF_TYPE
	ReDim AllStrDataList(0) As STRING_PROPERTIE
	ReDim AllStrDataList(0).Source.Reference(0) 'As REFERENCE_PROPERTIE
	ReDim AllStrDataList(0).Trans.Reference(0) 'As REFERENCE_PROPERTIE
	ReDim FreeByteList(0) As FREE_BTYE_SPACE
	ReDim UIFileList(0) As UI_FILE,UIDataList(0) As INIFILE_DATA
	ReDim Selected(30) As String,UpdateSet(5) As String,LFList(2) As LOG_FONT
	ImportSrcSet(4) = "1"
	For i = 2 To UBound(ImportTranSet)
		Select Case i
		Case 2,3,5,6,7,9
			ImportTranSet(i) = "1"
		End Select
	Next i
	FindStrSet(6) = "1"
	For i = 1 To UBound(FilterStrSet)
		Select Case i
		Case 0,18 To 22
			FilterStrSet(i) = "0"
		Case 17
			FilterStrSet(i) = "0;1"
		Case 23
			FilterStrSet(i) = "0;0;"
		Case Else
			FilterStrSet(i) = "0;"
		End Select
	Next i
	ExtractSet(41) = "0"
	AddStrSet(1) = "0": AddStrSet(2) = "1"
	'转换 HEX 字符值为 Long 数组和正则表达式模板，用于转换文本的转义符
	MsgList = ReSplit(ConvertStrHexRange,";")
	ReDim CheckHexStr(UBound(MsgList)) As CHECK_STRING_VALUE
	For i = 0 To UBound(MsgList)
		CheckHexStr(i).Range = Replace$(MsgList(i),",","")
		If i = 0 Then
			CheckHexStr(i).Range = "\\x[" & CheckHexStr(i).Range & "]{2}"
		ElseIf i = 1 Then
			CheckHexStr(i).Range = "\\u[" & CheckHexStr(i).Range & "]{4}"
		ElseIf i = 2 Then
			CheckHexStr(i).Range = "\\[" & CheckHexStr(i).Range & "]+"
		End If
		CheckHexStr(i).AscRange = "[" & Convert(Replace$(MsgList(i),",","")) & "]"
	Next i
	'转换跳过字符值为正则表达式模板，用于文本的正则表达式比较
	CheckSkipStr = ReSplit("[" & Replace$(Replace$(CheckStrHexRange,",",""),";","];[") & "]",";")
	'读取设置
	GetSettings("")
	'读取界面语言字串
	If GetUI(MacroDir & "\Data\",Selected(0),OSLanguage,UIDataList,UIFileList,LangFile) = False Then Exit Sub
	If getMsgList(UIDataList,MsgList,"Main",0) = False Then Exit Sub
	'检测 PSL 版本
	If PSL.Version < 500 Then
		MsgBox MsgList(1),vbOkOnly+vbInformation,MsgList(0)
		Exit Sub
	End If
	'检查方案是否打开以及方案是否为空
	If PSL.ActiveProject Is Nothing Then
		MsgBox MsgList(2),vbOkOnly+vbInformation,MsgList(0)
		Exit Sub
	End If
	'获取更新数据并检查新版本
	If CheckUpdate(UpdateSet,-2) = True Then Exit Sub
	'备份设置
	SelectedBak = Selected
	UpdateSetBak = UpdateSet
	ExtractSetBak = ExtractSet
	StrTypeListBak = StrTypeList
	RefTypeListBak = RefTypeList
	LFListBak = LFList
	'备份数据
	UseStrDataList = AllStrDataList: AllStrDataListBak = AllStrDataList
	GetFreeByteSecListBak = GetFreeByteSecList: FreeByteListBak = FreeByteList
	'更新 HCS 文件解析规则
	If StrComp(ToUpdateRuleVersion,GetSetting(AppName,"Option","Version","")) > 0 Then
		If UpdateHCSRule() = True Then
			SaveSetting(AppName,"Option","Version",Version)
		End If
	End If
	'初始化编辑工具菜单名称
	Tools(0).sName = MsgList(3)
	Tools(1).sName = MsgList(4)
	Tools(2).sName = MsgList(5)
	Tools(3).sName = MsgList(6)
	Tools(1).FilePath = "notepad.exe"
	'停止按钮按下时的显示对话框上的消息
	StopTitle = MsgList(12)
	StopMsg = MsgList(13)
	'获取语言数据列表，用于 Adodb.Stream 对象
	CodeList = getCodePageList(0,49)
	'获取默认代码页和默认语言数据
	UniLangListBak = GetLngList(GetWinCPList(0,20))
	'更改代码页名称和语言名称，并更新备份语言数据
	Call UpdateLangList(LangIDIndexDic,UniLangList,UniLangListBak)
	If (Not PSL.ActiveSourceList Is Nothing) Or (Not PSL.ActiveTransList Is Nothing) Then
		If CheckFile(SourceFile,TargetFile) = False Then Exit Sub
		'获取字串过滤列表的设置
		GetSettings("FilterStrDic")
		'获取字串保留列表的设置
		GetSettings("ReserveStrDic")
	End If
	'提取和编辑字串
	If Dir$(SourceFile.hcsFile.FilePath) = "" Then
		TargetFile = SourceFile
	Else
		If Dir$(TargetFile.hcsFile.FilePath) = "" Then
			For i = 1 To trn.Project.SourceLists.Count
				If trn.Project.SourceLists(i).SourceFile = SourceFile.hcsFile.FilePath Then
					trn.Project.TransLists(trn.Project.SourceLists(i),trn.Language.LangID).GenerateTarget
					Exit For
				End If
			Next i
			If Dir$(TargetFile.hcsFile.FilePath) = "" Then
				Temp = Left$(TargetFile.hcsFile.FilePath,InStrRev(TargetFile.hcsFile.FilePath,"\"))
				If MkSubDir(Temp) = True Then
					FileCopy SourceFile.hcsFile.FilePath,TargetFile.hcsFile.FilePath
				End If
			End If
		End If
		If Dir$(TargetFile.hcsFile.FilePath) <> "" Then
			SourceFile.hcsFile.DateLastModified = FileDateTime(SourceFile.hcsFile.FilePath)
			TargetFile.hcsFile.DateLastModified = FileDateTime(TargetFile.hcsFile.FilePath)
			If SourceFile.hcsFile.DateLastModified > TargetFile.hcsFile.DateLastModified Then
				MsgBox Replace(MsgList(11),"%s",TargetFile.hcsFile.FilePath),vbOkOnly+vbInformation,MsgList(0)
				Exit Sub
			End If
		Else
			TargetFile = SourceFile
		End If
	End If
	'获取过滤字串列表字典为字串过滤显示用
	MsgList = ReSplit(ReadBinaryFile(ExtractSet(35),CP_UNICODELITTLE,True),vbNullChar)
	StrList2StrDic(FilterStrDic,MsgList,StrToLong(ReSplit(FilterStrSet(17),ItemJoinStr)(1)),1)
	'获取保留字串列表字典为添加保留字串用
	If Dir$(ExtractSet(37)) <> "" Then
		MsgList = ReSplit(ReadBinaryFile(ExtractSet(37),CP_UNICODELITTLE,True),vbNullChar)
	Else
		MsgList = ReSplit(ExcludeStr,ItemJoinStr)
	End If
	StrList2StrDic(ReserveStrDic,MsgList,StrToLong(ExtractSet(24)),1)
	Erase MsgList
	EditString(SourceFile,TargetFile)
	Call ExitMacro(0)
	Exit Sub
	'显示程序错误消息
	SysErrorMsg:
	If Err.Source <> "ExitSub" Then Call sysErrorMassage(Err,0)
	Call ExitMacro(0)
End Sub


'检查并获取本地化文件和 HCS 文件
Private Function CheckFile(orgFile As FILE_PROPERTIE,trnFile As FILE_PROPERTIE) As Boolean
	Dim i As Long,j As Long,n As Long,k As Long
	Dim Temp As String,Dic As Object,MsgList() As String
	If getMsgList(UIDataList,MsgList,"CheckFile",0) = False Then Exit Function
	'设置激活的来源列表和翻译列表
	Set src = PSL.ActiveSourceList
	Set trn = PSL.ActiveTransList
	'检查是否选择了 HCS 的来源列表和翻译列表，并自动切换到其对应的原列表
	If Not src Is Nothing Then
		If LCase$(RTrim$(src.SourceFile)) Like "*.hcs" Then
			Temp = Left$(src.SourceFile,InStrRev(src.SourceFile,".hcs") - 1)
			For i = 1 To src.Project.SourceLists.Count
				If src.Project.SourceLists(i).SourceFile = Temp Then
					Set src = src.Project.SourceLists(i)
					j = 1
					Exit For
				End If
			Next i
		Else
			j = 2
		End If
	ElseIf Not trn Is Nothing Then
		If LCase$(RTrim$(trn.SourceList.SourceFile)) Like "*.hcs" Then
			Temp = Left$(trn.SourceList.SourceFile,InStrRev(trn.SourceList.SourceFile,".hcs") - 1)
			For i = 1 To trn.Project.SourceLists.Count
				If trn.Project.SourceLists(i).SourceFile = Temp Then
					Set trn = trn.Project.TransLists(trn.Project.SourceLists(i),trn.Language.LangID)
					j = 1
					Exit For
				End If
			Next i
		Else
			j = 2
		End If
	Else
		MsgBox MsgList(2),vbOkOnly+vbInformation,MsgList(1)
		Exit Function
	End If
	'获取来源列表、翻译列表的文件名和文本语言的代码页
	If Not src Is Nothing Then
		If j > 0 Then
			orgFile.FilePath = src.SourceFile
			orgFile.hcsFile.FilePath = orgFile.FilePath & ".hcs"
		Else
			orgFile.FilePath = Left$(src.SourceFile,InStrRev(src.SourceFile,".hcs") - 1)
			orgFile.hcsFile.FilePath = src.SourceFile
		End If
		If Dir$(orgFile.FilePath) = "" Then
			MsgBox Replace(MsgList(3),"%s",orgFile.FilePath),vbOkOnly+vbInformation,MsgList(1)
			Exit Function
		ElseIf IsOpen(orgFile.FilePath) = True Then
			MsgBox Replace(MsgList(18),"%s",orgFile.FilePath),vbOkOnly+vbInformation,MsgList(1)
			Exit Function
		ElseIf FileLen(orgFile.FilePath) = 0 Then
			MsgBox Replace(MsgList(4),"%s",orgFile.FilePath),vbOkOnly+vbInformation,MsgList(1)
			Exit Function
		End If
		If GetFileInfo(orgFile.FilePath,orgFile) = False Then Exit Function
		k = IIf(j > 0,src.LangID,Val("&H" & orgFile.LanguageID))
		orgFile.CopePage = PSL.GetDefaultCodePage(k)
		trnFile = orgFile
	ElseIf Not trn Is Nothing Then
		Set src = trn.SourceList
		If j > 0 Then
			orgFile.FilePath = src.SourceFile
			trnFile.FilePath = trn.TargetFile
			orgFile.hcsFile.FilePath = orgFile.FilePath & ".hcs"
			trnFile.hcsFile.FilePath = FindTargetFile(trn,orgFile.hcsFile.FilePath)
		Else
			orgFile.FilePath = Left$(src.SourceFile,InStrRev(src.SourceFile,".hcs") - 1)
			trnFile.FilePath = Left$(trn.TargetFile,InStrRev(trn.TargetFile,".hcs") - 1)
			orgFile.hcsFile.FilePath = src.SourceFile
			trnFile.hcsFile.FilePath = trn.TargetFile
		End If
		If Dir$(orgFile.FilePath) = "" Then
			MsgBox Replace(MsgList(3),"%s",orgFile.FilePath),vbOkOnly+vbInformation,MsgList(1)
			Exit Function
		ElseIf IsOpen(orgFile.FilePath) = True Then
			MsgBox Replace(MsgList(18),"%s",orgFile.FilePath),vbOkOnly+vbInformation,MsgList(1)
			Exit Function
		ElseIf FileLen(orgFile.FilePath) = 0 Then
			MsgBox Replace(MsgList(4),"%s",orgFile.FilePath),vbOkOnly+vbInformation,MsgList(1)
			Exit Function
		End If
		i = 0
		Do
			If Dir$(trnFile.FilePath) = "" Then
				If MsgBox(Replace(MsgList(5),"%s",trnFile.FilePath),vbYesNo+vbInformation,MsgList(0)) = vbNo Then Exit Function
				Temp = Left$(trnFile.FilePath,InStrRev(trnFile.FilePath,"\"))
				If j > 0 Then
					If trn.GenerateTarget = False Then
						If MkSubDir(Temp) = False Then
							MsgBox Replace(MsgList(17),"%s",trnFile.FilePath),vbOkOnly+vbInformation,MsgList(1)
							Exit Function
						End If
						FileCopy orgFile.FilePath,trnFile.FilePath
					End If
				ElseIf MkSubDir(Temp) = False Then
					MsgBox Replace(MsgList(17),"%s",trnFile.FilePath),vbOkOnly+vbInformation,MsgList(1)
					Exit Function
				Else
					FileCopy orgFile.FilePath,trnFile.FilePath
				End If
				If Dir(trnFile.FilePath & ".bak") <> "" Then Kill trnFile.FilePath & ".bak"
			ElseIf IsOpen(trnFile.FilePath) = True Then
				MsgBox Replace(MsgList(18),"%s",trnFile.FilePath),vbOkOnly+vbInformation,MsgList(1)
				Exit Function
			ElseIf FileLen(trnFile.FilePath) = 0 Then
				If i = 0 Then
					If MsgBox(Replace(MsgList(6),"%s",trnFile.FilePath),vbYesNo+vbInformation,MsgList(0)) = vbNo Then Exit Function
					If j > 0 Then
						If trn.GenerateTarget = False Then FileCopy orgFile.FilePath,trnFile.FilePath
					Else
						FileCopy orgFile.FilePath,trnFile.FilePath
					End If
				Else
					If MsgBox(Replace(MsgList(19),"%s",trnFile.FilePath),vbYesNo+vbInformation,MsgList(0)) = vbNo Then Exit Function
					FileCopy orgFile.FilePath,trnFile.FilePath
				End If
				If Dir(trnFile.FilePath & ".bak") <> "" Then Kill trnFile.FilePath & ".bak"
			Else
				Exit Do
			End If
			i = i + 1
		Loop
		If GetFileInfo(orgFile.FilePath,orgFile) = False Then Exit Function
		If GetFileInfo(trnFile.FilePath,trnFile) = False Then Exit Function
		k = IIf(j > 0,src.LangID,Val("&H" & orgFile.LanguageID))
		orgFile.CopePage = PSL.GetDefaultCodePage(k)
		trnFile.CopePage = PSL.GetDefaultCodePage(trn.Language.LangID)
		If trnFile.hcsFile.FilePath = "" Then trnFile = orgFile
	End If
	'检查目标文件和备份文件
	If trnFile.hcsFile.FilePath <> orgFile.hcsFile.FilePath Then
		'检查目标文件是否和原始文件匹配
		Temp = ""
		If orgFile.FileVersion <> trnFile.FileVersion Then
			Temp = MsgList(7)
		ElseIf orgFile.DateLastModified > trnFile.DateLastModified Then
			If orgFile.DateLastModified <= Now Then Temp = MsgList(8)
		End If
		If Temp <> "" Then
			If MsgBox(Temp,vbYesNo+vbInformation,MsgList(0)) = vbNo Then Exit Function
			If j > 0 Then
				If trn.GenerateTarget = False Then FileCopy orgFile.FilePath,trnFile.FilePath
			Else
				FileCopy orgFile.FilePath,trnFile.FilePath
			End If
			If Dir(trnFile.FilePath & ".bak") <> "" Then Kill trnFile.FilePath & ".bak"
		End If
		'删除创建日期早于目标文件的目标文件备份文件
		If Dir(trnFile.FilePath & ".bak") <> "" Then
			If trnFile.DateCreated > GetFileDate(trnFile.FilePath & ".bak",0) Then Kill trnFile.FilePath & ".bak"
		End If
		If Dir(trnFile.FilePath & ".bak") <> "" Then trnFile.FilePath = trnFile.FilePath & ".bak"
		If GetFileInfo(trnFile.FilePath,trnFile) = False Then Exit Function
	End If
	'获取要提取语言中的代码页
	Set Dic = CreateObject("Scripting.Dictionary")
	'添加原始文件列表选定的语言
	If orgFile.CopePage <> 0 Then
		ReDim Preserve AllLangList(n) As LANG_PROPERTIE
		Dic.Add(k,n)
		AllLangList(n) = UniLangList(GetDicVal(LangIDIndexDic,src.LangID,LangIDIndexDic.Item(1033)))
		n = n + 1
	End If
	'添加原始文件列表选定的附加语言
	If j > 0 Then
		ReDim Preserve AllLangList(n + src.ExtLangCount) As LANG_PROPERTIE
		For i = 1 To src.ExtLangCount
			If src.ExtLang(i) > 0 Then
				If Not Dic.Exists(src.ExtLang(i)) Then
					Dic.Add(src.ExtLang(i),n)
					If LangIDIndexDic.Exists(src.ExtLang(i)) Then
						AllLangList(n) = UniLangList(LangIDIndexDic.Item(src.ExtLang(i)))
						n = n + 1
					End If
				End If
			End If
		Next i
	'添加其他原始文件列表选定的语言
	ElseIf orgFile.CopePage = 0 Then
		j = src.Project.SourceLists.Count
		ReDim Preserve AllLangList(n + j) As LANG_PROPERTIE
		For i = 1 To j
			k = src.Project.SourceLists(i).LangID
			If k > 0 Then
				If Not Dic.Exists(k) Then
					Dic.Add(k,n)
					If LangIDIndexDic.Exists(k) Then
						AllLangList(n) = UniLangList(LangIDIndexDic.Item(k))
						If k = 1033 Then UseLangList(0) = AllLangList(n)
						n = n + 1
					End If
				End If
			End If
		Next i
	End If
	If trnFile.hcsFile.FilePath <> orgFile.hcsFile.FilePath Then
		If Not Dic.Exists(trn.Language.LangID) Then
			If LangIDIndexDic.Exists(trn.Language.LangID) Then
				ReDim Preserve AllLangList(n + 1) As LANG_PROPERTIE
				AllLangList(n) = UniLangList(LangIDIndexDic.Item(trn.Language.LangID))
				n = n + 1
			End If
		End If
	End If
	If n > 0 Then n = n - 1
	ReDim Preserve AllLangList(n) As LANG_PROPERTIE
	If UseLangList(0).CodePage = 0 Then UseLangList(0) = AllLangList(0)
	Dic.RemoveAll
	'按代码页值从大到小排序，以便检测字串的语言时英语可以优先检测
	If n > 0 Then Call SortLangArrayByCP(AllLangList,1,n,True)

	Select Case GetFileFormat(orgFile.FilePath,StrToLong(Selected(1)),orgFile.FileType)
	Case "PE","NET",""
		'检查文件类型并读取来源文件头
		If GetPEHeaders(orgFile.FilePath,orgFile,StrToLong(Selected(1))) = True Then
			'判断是否是 Delphi 程序
			If orgFile.LangType = 0 Then
				If InStr(LCase$(src.Parser),"delphi/c++") Then
					orgFile.LangType = DELPHI_FILE_SIGNATURE
				End If
			End If
			If orgFile.LangType = DELPHI_FILE_SIGNATURE Then
				ExtractSet(5) = "1"
				ExtractSet(6) = "1"
				ExtractSet(7) = "1"
				ExtractSet(8) = "1"
			ElseIf orgFile.LangType = NET_FILE_SIGNATURE Then
				ExtractSet(9) = "1"
				ExtractSet(4) = "0100000"
				ExtractSet(48) = "0"
			End If
			'更改重复区段名称
			ChangSectionNames orgFile,MsgList(9),MsgList(10)
			'根据段名预定要提取的文件区段
			For i = 0 To orgFile.MaxSecIndex - 1
				If Not Dic.Exists(LCase$(orgFile.SecList(i).sName)) Then
					Dic.Add(LCase$(orgFile.SecList(i).sName),i)
				End If
			Next i
			Select Case orgFile.LangType
			Case DELPHI_FILE_SIGNATURE, NET_FILE_SIGNATURE
				If Dic.Exists("code") Then
					UseSectionList(0) = orgFile.SecList(Dic.Item("code")).sName
				ElseIf Dic.Exists(".text") Then
					UseSectionList(0) = orgFile.SecList(Dic.Item(".text")).sName
				ElseIf Dic.Exists(".code") Then
					UseSectionList(0) = orgFile.SecList(Dic.Item(".code")).sName
				ElseIf Dic.Exists(".rdata") Then
					UseSectionList(0) = orgFile.SecList(Dic.Item(".rdata")).sName
				Else
					UseSectionList(0) = orgFile.SecList(0).sName
				End If
			Case Else
				If Dic.Exists(".rdata") Then
					UseSectionList(0) = orgFile.SecList(Dic.Item(".rdata")).sName
				ElseIf Dic.Exists(".code") Then
					UseSectionList(0) = orgFile.SecList(Dic.Item(".code")).sName
				ElseIf Dic.Exists(".text") Then
					UseSectionList(0) = orgFile.SecList(Dic.Item(".text")).sName
				Else
					UseSectionList(0) = orgFile.SecList(0).sName
				End If
			End Select
		Else
			'更改区段名称
			ChangSectionNames orgFile,MsgList(9),MsgList(10)
			UseSectionList(0) = orgFile.SecList(0).sName
		End If
		trnFile.FileType = orgFile.FileType
		'读取目标文件头
		If trnFile.hcsFile.FilePath = orgFile.hcsFile.FilePath Then
			trnFile = orgFile
		ElseIf GetPEHeaders(trnFile.FilePath,trnFile,StrToLong(Selected(1))) = True Then
			'更改重复区段名称
			ChangSectionNames trnFile,MsgList(9),MsgList(10)
			'检查翻译文件的隐藏区段是否需要重建并获取偏移值
			'必须使用虚拟大小，因为其大小为最大节后的所有字节(包括子 PE)
			If orgFile.SecList(orgFile.MaxSecIndex).lSizeOfRawData > 0 Then
				If trnFile.SecList(trnFile.MaxSecIndex).lSizeOfRawData = 0 Then
					Select Case MsgBox(MsgList(11),vbYesNoCancel+vbInformation,MsgList(0))
					Case vbCancel
						Set Dic = Nothing
						Exit Function
					Case vbYes
						If FixFile(trnFile.FilePath,orgFile,trnFile) = False Then
							If MsgBox(MsgList(12),vbYesNo+vbInformation,MsgList(0)) = vbNo Then
								Set Dic = Nothing
								Exit Function
							End If
						End If
					End Select
				End If
				HideSecMoveVal = trnFile.SecList(trnFile.MaxSecIndex).lPointerToRawData - orgFile.SecList(orgFile.MaxSecIndex).lPointerToRawData
			End If
			'重定义目标文件的编程语言
			If trnFile.LangType = 0 Then trnFile.LangType = orgFile.LangType
			'检查来源和目标文件的区段开始地址及大小是否相同
			Select Case CompSecHeader(orgFile,trnFile)
			Case 1
				If MsgBox(MsgList(13) & MsgList(15) & MsgList(16),vbYesNo+vbInformation,MsgList(0)) = vbNo Then
					Set Dic = Nothing
					Exit Function
				End If
			Case 2
				If MsgBox(MsgList(14) & MsgList(15) & MsgList(16),vbYesNo+vbInformation,MsgList(0)) = vbNo Then
					Set Dic = Nothing
					Exit Function
				End If
			End Select
		Else
			'更改区段名称
			ChangSectionNames trnFile,MsgList(9),MsgList(10)
			UseSectionList(0) = trnFile.SecList(0).sName
		End If
	Case "MAC"
		'检查文件类型并读取来源文件头
		If GetMacHeaders(orgFile.FilePath,orgFile,StrToLong(Selected(1))) = True Then
			'更改重复区段名称
			ChangSectionNames orgFile,MsgList(9),MsgList(10)
			'根据段名预定要提取的文件区段
			For i = 0 To orgFile.MaxSecIndex
				If Not Dic.Exists(LCase$(orgFile.SecList(i).sName)) Then
					Dic.Add(LCase$(orgFile.SecList(i).sName),i)
				End If
			Next i
			If Dic.Exists("__text") Then
				UseSectionList(0) = orgFile.SecList(Dic.Item("__text")).sName
			ElseIf Dic.Exists("__data") Then
				UseSectionList(0) = orgFile.SecList(Dic.Item("__data")).sName
			ElseIf Dic.Exists("__linkedit") Then
				UseSectionList(0) = orgFile.SecList(Dic.Item("__linkedit")).sName
			Else
				UseSectionList(0) = orgFile.SecList(0).sName
			End If
			'根据要提取的文件区段，获取MAC的子节
			With orgFile
				i = Dic.Item(UseSectionList(0))
				If .SecList(i).SubSecs > 0 Then
					ReDim UseSubSecList(.SecList(i).SubSecs - 1) As String
					k = 0
					For j = 0 To .SecList(i).SubSecs - 1
						Select Case LCase$(.SecList(i).SubSecList(j).sName)
						Case "__cstring","__text"
							UseSubSecList(k) = .SecList(i).sName & "-" & .SecList(i).SubSecList(j).sName
							k = k + 1
						End Select
					Next j
					If k > 0 Then
						ReDim Preserve UseSubSecList(k - 1) As String
					Else
						ReDim UseSubSecList(0) As String
						UseSubSecList(0) = .SecList(i).sName
					End If
				Else
					ReDim UseSubSecList(0) As String
					UseSubSecList(0) = .SecList(i).sName
				End If
			End With
		Else
			'更改区段名称
			ChangSectionNames orgFile,MsgList(9),MsgList(10)
			UseSectionList(0) = orgFile.SecList(0).sName
		End If
		trnFile.FileType = orgFile.FileType
		'读取目标文件头
		If trnFile.hcsFile.FilePath = orgFile.hcsFile.FilePath Then
			trnFile = orgFile
		ElseIf GetMacHeaders(trnFile.FilePath,trnFile,StrToLong(Selected(1))) = True Then
			'更改重复区段名称
			ChangSectionNames trnFile,MsgList(9),MsgList(10)
			'检查翻译文件的隐藏区段是否需要重建并获取偏移值
			'必须使用虚拟大小，因为其大小为最大节后的所有字节(包括子 PE)
			'检查翻译文件的隐藏区段是否需要重建并获取偏移值
			'必须使用虚拟大小，因为其大小为最大节后的所有字节(包括子 PE)
			If orgFile.SecList(orgFile.MaxSecIndex).lSizeOfRawData > 0 Then
				If trnFile.SecList(trnFile.MaxSecIndex).lSizeOfRawData = 0 Then
					Select Case MsgBox(MsgList(11),vbYesNoCancel+vbInformation,MsgList(0))
					Case vbCancel
						Set Dic = Nothing
						Exit Function
					Case vbYes
						If FixFile(trnFile.FilePath,orgFile,trnFile) = False Then
							If MsgBox(MsgList(12),vbYesNo+vbInformation,MsgList(0)) = vbNo Then
								Set Dic = Nothing
								Exit Function
							End If
						End If
					End Select
				End If
				HideSecMoveVal = trnFile.SecList(trnFile.MaxSecIndex).lPointerToRawData - orgFile.SecList(orgFile.MaxSecIndex).lPointerToRawData
			End If
			'重定义目标文件的编程语言
			If trnFile.LangType = 0 Then trnFile.LangType = orgFile.LangType
			'检查来源和目标文件的区段开始地址及大小是否相同
			Select Case CompSecHeader(orgFile,trnFile)
			Case 1
				If MsgBox(MsgList(13) & MsgList(15) & MsgList(16),vbYesNo+vbInformation,MsgList(0)) = vbNo Then
					Set Dic = Nothing
					Exit Function
				End If
			Case 2
				If MsgBox(MsgList(14) & MsgList(15) & MsgList(16),vbYesNo+vbInformation,MsgList(0)) = vbNo Then
					Set Dic = Nothing
					Exit Function
				End If
			End Select
		Else
			'更改区段名称
			ChangSectionNames trnFile,MsgList(9),MsgList(10)
			UseSectionList(0) = trnFile.SecList(0).sName
		End If
	End Select
	Set Dic = Nothing
	ExtractSet(31) = "0" & ItemJoinStr & ReSplit(ExtractSet(31),ItemJoinStr,2)(1)
	ExtractSetBak = ExtractSet
	'初始化获取空字节的文件节列表
	ReDim GetFreeByteSecList(orgFile.MaxSecIndex - 1) As String
	CheckFile = True
End Function


'修复目标文件丢失的隐藏区段和隐藏区段后的多个子 PE 区段
'由 Passolo 不支持隐藏段生成目标文件时发生
Private Function FixFile(ByVal trnFilePath As String,orgFile As FILE_PROPERTIE,trnFile As FILE_PROPERTIE) As Boolean
	Dim i As Long,k As Long,FN1 As FILE_IMAGE,FN2 As FILE_IMAGE
	With orgFile
		'打开文件
		i = LoadFile(.FilePath,FN1,0,0,0,StrToLong(Selected(1)))
		If i < -1 Then Exit Function
		k = LoadFile(trnFilePath,FN2,0,1,0,StrToLong(Selected(1)))
		If k > -2 Then
			'复制原始文件的整个隐藏区段到目标文件
			PutBytes(FN2,trnFile.SecList(trnFile.MaxSecIndex).lPointerToRawData, _
					GetBytes(FN1,.FileSize - .SecList(.MaxSecIndex).lPointerToRawData,.SecList(.MaxSecIndex).lPointerToRawData,i), _
					.FileSize - .SecList(.MaxSecIndex).lPointerToRawData,k)
			trnFile.FileSize = FN2.SizeOfFile
			UnLoadFile(FN2,FN2.SizeOfFile,k)
			'重新获取修复后文件的文件头信息
			Select Case trnFile.Magic
			Case "PE32","PE64","NET32","NET64",""
				GetPEHeaders(trnFilePath,trnFile,StrToLong(Selected(1)))
			Case "MAC32","MAC64"
				GetMacHeaders(trnFilePath,trnFile,StrToLong(Selected(1)))
			End Select
			FixFile = True
		End If
		UnLoadFile(FN1,0,i)
	End With
End Function


'根据 HCS 原始列表的原始文件查找对应语言的 HCS 翻译列表的目标文件
Private Function FindTargetFile(tran As PslTransList,ByVal orgFilePath As String) As String
	Dim i As Long
	With tran.Project
		For i = 1 To .SourceLists.Count
			If .SourceLists(i).SourceFile = orgFilePath Then
				FindTargetFile = .TransLists(.SourceLists(i),tran.Language.LangID).TargetFile
				Exit For
			End If
		Next i
	End With
End Function


'添加 HCS 文件到 PSL 方案并更新来源列表
'AddToPslProject 返回值:
'-2 = 来源列表创建成功，但 HCS 文件专用的解析器规则未生效，更新失败
'-1 = 来源列表已经存在，等待更新
'0 = 来源列表创建失败，无法添加
'1 = 来源列表添加成功，并已更新所有对应的翻译列表
'2 = 来源列表创建成功，但放弃添加
'3 = 来源列表创建和更新成功，并已更新所有对应的翻译列表，但字串被忽略，该返回值用于恢复
'4 = 来源列表创建和更新成功，并已更新所有对应的翻译列表，但字串被删除，该返回值用于恢复
Private Function AddToPslProject(srcFile As FILE_PROPERTIE) As Long
	Dim i As Long,j As Long,LangID As Long,hcsSrc As PslSourceList
	Dim TempList() As String,MsgList() As String,PSLAddInPath As String
	Dim Stemp As Boolean,Prj As PslProject,Dic As Object,Title As String
	If getMsgList(UIDataList,MsgList,"AddToPslProject",1) = False Then Exit Function
	If Dir$(srcFile.hcsFile.FilePath) = "" Then Exit Function
	'删除以前更新时保存的被删除字串文件
	On Error Resume Next
	If Dir$(srcFile.hcsFile.FilePath & "_DeledString.txt") <> "" Then
		Kill srcFile.hcsFile.FilePath & "_DeledString.txt"
	End If
	'错误处理
	On Error GoTo ExitFunction
	'更新时允许自动删除20个以上字串
	Stemp = PSL.Option(pslOptionBatchDelete)
	If Stemp = False Then PSL.Option(pslOptionBatchDelete) = True
	'设置原始列表的标题和语言
	Title = srcFile.FileName & ".hcs"
	If Not src Is Nothing Then
		Set Prj = src.Project
		LangID = IIf(src.SourceFile = srcFile.FilePath,src.LangID,Val("&H" & srcFile.LanguageID))
	Else
		Set Prj = PSL.ActiveProject
		LangID = Val("&H" & srcFile.LanguageID)
	End If
	If LangID = 0 Then LangID = pslLangEnglishUSA
	'检查 HCS 文件是否已经添加，如果已经添加则退出
	For i = 1 To Prj.SourceLists.Count
		If Prj.SourceLists(i).SourceFile = srcFile.hcsFile.FilePath Then
			AddToPslProject = -1
			GoTo ExitFunction
		End If
	Next i
	'获取现有HCS文件所用的文本解析器
	ReDim ParserList(0) As FILE_LIST
	For i = 1 To Prj.SourceLists.Count
		If LCase$(RTrim$(Prj.SourceLists(i).SourceFile)) Like "*.hcs" Then
			ParserList(0).sName = Prj.SourceLists(i).Parser
			Exit For
		ElseIf LCase$(RTrim$(Prj.SourceLists(i).SourceFile)) Like "*.txt" Then
			ParserList(0).sName = Prj.SourceLists(i).Parser
			Exit For
		End If
	Next i
	'如果已经知道文本文件解析器名称，则添加 HCS 文件
	If ParserList(0).sName <> "" Then
		Set hcsSrc = Prj.SourceLists.AddWithParser(srcFile.hcsFile.FilePath,ParserList(0).sName,Title,LangID)
		AddToPslProject = UpdatePSLList(srcFile,hcsSrc)
		If AddToPslProject <> 0 Then GoTo ExitFunction
		Prj.SourceLists.Remove(hcsSrc)
		'获取 PSL 自定义插件文件夹
		PSLAddInPath = GetPSLAddInPath()
		If PSLAddInPath = "" Then GoTo ExitFunction
		'检查并创建 HCS 规则
		If InStr(ParserList(0).sName,":") Then
			ParserList(0).FilePath = PSLAddInPath & ReSplit(ParserList(0).sName,":",2)(1)
		Else
			ParserList(0).FilePath = PSLAddInPath & ParserList(0).sName
		End If
		If CheckRule(ParserList(0).FilePath & "\PAITextParser.dat",MsgList(1),MsgList(2)) = False Then GoTo ExitFunction
		Set hcsSrc = Prj.SourceLists.AddWithParser(srcFile.hcsFile.FilePath,ParserList(0).sName,Title,LangID)
		AddToPslProject = UpdatePSLList(srcFile,hcsSrc)
		If AddToPslProject = 0 Then AddToPslProject = -2
		GoTo ExitFunction
	End If
	'获取 PSL 自定义插件文件夹
	PSLAddInPath = GetPSLAddInPath()
	If PSLAddInPath = "" Then GoTo ExitFunction
	Set Dic = CreateObject("Scripting.Dictionary")
	'获取自定义文本解析器名称列表并测试，测试成功则退出
	If CheckArray(getSubFiles(ParserList,PSLAddInPath,"PAITextParser.dat","")) = True Then
		For i = 0 To UBound(ParserList)
			If CheckRule(ParserList(i).FilePath,MsgList(1),MsgList(2)) = True Then
				'PSL.SendAddInMessage(ParserList(i).sName,0,"PAIFN_GetCustomParserData")
				Set hcsSrc = Prj.SourceLists.AddWithParser(srcFile.hcsFile.FilePath,ParserList(i).sName,Title,LangID)
				AddToPslProject = UpdatePSLList(srcFile,hcsSrc)
				If AddToPslProject <> 0 Then GoTo ExitFunction
				Prj.SourceLists.Remove(hcsSrc)
			End If
			If Not Dic.Exists(ParserList(i).sName) Then Dic.Add(ParserList(i).sName,"")
		Next i
		Set hcsSrc = Prj.SourceLists.Add(srcFile.hcsFile.FilePath,Title,LangID)
		AddToPslProject = IIf(hcsSrc Is Nothing,0,-2)
		GoTo ExitFunction
	End If
	'写入程序预设的自定义文本解析器名称列表并测试，测试成功则退出，不成功则删除
	TempList = ReSplit(MsgList(0),";")
	For i = 0 To UBound(TempList)
		If TempList(i) <> "" And Dic.Exists(TempList(i)) = False Then
			If CreateTXTFile(PSLAddInPath & TempList(i) & "\PAITextParser.dat",MsgList(2),"unicodeFFFE") = True Then
				'PSL.SendAddInMessage(TempList(i),0,"PAIFN_GetCustomParserData")
				Set hcsSrc = Prj.SourceLists.AddWithParser(srcFile.hcsFile.FilePath,TempList(i),Title,LangID)
				AddToPslProject = UpdatePSLList(srcFile,hcsSrc)
				If AddToPslProject <> 0 Then GoTo ExitFunction
				'DelDir(PSLAddInPath & TempList(i))
				Prj.SourceLists.Remove(hcsSrc)
			End If
			If Not Dic.Exists(TempList(i)) Then Dic.Add(TempList(i),"")
		End If
	Next i
	'用户输入自定义文本解析器名称列表并测试，测试成功则退出，不成功则删除
	Do
		TempList(0) = Trim$(InputBox(MsgList(4),MsgList(3),TempList(0)))
		If TempList(0) = "" Then
			Set hcsSrc = Prj.SourceLists.Add(srcFile.hcsFile.FilePath,Title,LangID)
			AddToPslProject = IIf(hcsSrc Is Nothing,0,-2)
			Exit Do
		End If
		If Dic.Exists(TempList(0)) Then
			MsgBox MsgList(7),vbOkOnly+vbInformation,MsgList(5)
		Else
			If CreateTXTFile(PSLAddInPath & TempList(0) & "\PAITextParser.dat",MsgList(2),"unicodeFFFE") = True Then
				'PSL.SendAddInMessage(NameList(0),0,"PAIFN_GetCustomParserData")
				Set hcsSrc = Prj.SourceLists.AddWithParser(srcFile.hcsFile.FilePath,TempList(0),Title,LangID)
				AddToPslProject = UpdatePSLList(srcFile,hcsSrc)
				If AddToPslProject <> 0 Then GoTo ExitFunction
				Prj.SourceLists.Remove(hcsSrc)
				If MsgBox(MsgList(6),vbYesNo+vbInformation,MsgList(5)) = vbNo Then DelDir(PSLAddInPath & TempList(0))
			End If
			Dic.Add(TempList(0),"")
		End If
	Loop
	ExitFunction:
	Select Case AddToPslProject
	Case 0
		MsgBox Replace$(MsgList(8),"%s",srcFile.hcsFile.FilePath),vbOkOnly+vbInformation,MsgList(5)
	Case -2, 2
		MsgBox Replace$(MsgList(9),"%s",srcFile.hcsFile.FilePath),vbOkOnly+vbInformation,MsgList(5)
	End Select
	Set Dic = Nothing
	'还原更新时允许自动删除20个以上字串选项的设置
	If Stemp = False Then PSL.Option(pslOptionBatchDelete) = Stemp
	'查看被删除的字串文件
	If Dir$(srcFile.hcsFile.FilePath & "_DeledString.txt") <> "" Then
		ReDim FileDataList(0) As String
		FileDataList(0) = srcFile.hcsFile.FilePath & "_DeledString.txt" & JoinStr & "unicodeFFFE"
		OpenFile(srcFile.hcsFile.FilePath & "_DeledString.txt",FileDataList,1,False)
	End If
End Function


'删除文本文件中的错误行并更新 PSL 来源列表
'UpdatePslList 返回值：
'-2 = 来源列表创建成功，但 HCS 文件专用的解析器规则未生效，更新失败
'-1 = 来源列表已经存在
'0 = 来源列表创建失败，无法更新
'1 = 来源列表创建和更新成功，并已更新所有对应的翻译列表
'2 = 来源列表创建成功，但放弃更新
'3 = 来源列表创建和更新成功，并已更新所有对应的翻译列表，但字串被忽略，该返回值用于恢复
'4 = 来源列表创建和更新成功，并已更新所有对应的翻译列表，但字串被删除，该返回值用于恢复
Private Function UpdatePSLList(srcFile As FILE_PROPERTIE,hcsSrc As PslSourceList,Optional ByVal Mode As Boolean) As Integer
	Dim i As Long,j As Long,k As Long,n As Long,m As Long,Stemp As Boolean,TempList() As String
	If hcsSrc Is Nothing Then Exit Function
	On Error Resume Next
	'删除以前更新时保存的被删除字串文件
	If Mode = True Then
		If Dir$(srcFile.hcsFile.FilePath & "_DeledString.txt") <> "" Then Kill srcFile.hcsFile.FilePath & "_DeledString.txt"
	End If
	'屏蔽更新错误时显示的消息对话框
	On Error GoTo ExitFunction
	Stemp = PSL.Option(pslOptionBatchMessageBox)
	If Stemp = True Then PSL.Option(pslOptionBatchMessageBox) = False
	hcsSrc.Extract(pslLangAll) = True
	Do
		PSL.OutputWnd(0).Clear
		If hcsSrc.Update = True Then
			For i = 1 To hcsSrc.Project.Languages.Count
				hcsSrc.Project.TransLists(hcsSrc,hcsSrc.Project.Languages(i).LangID).Update
			Next i
			If UpdatePSLList = 0 Then UpdatePSLList = 1
			If src Is Nothing Then Set src = hcsSrc
			Exit Do
		End If
		j = PSL.OutputWnd(0).LineCount
		If j < 2 Then
			UpdatePSLList = 0
			Exit Do
		End If
		ReDim TempList(j - 2) As String
		For i = 2 To j
			TempList(i - 2) = PSL.OutputWnd(0).Text(i)
		Next i
		j = StrToLong(GetSubStringRegExp(StrListJoin(TempList,""),"[0-9]+",-1),-1)
		If j = -1 Then
			UpdatePSLList = 0
			Exit Do
		ElseIf j < 12 Then
			UpdatePSLList = -2
			Exit Do
		End If
		TempList = ReSplit(ReadBinaryFile(srcFile.hcsFile.FilePath,CP_UNICODELITTLE),TextJoinStr)
		n = StrToLong(GetSubStringRegExp(TempList(j - 2),"[0-9]+",-1))
		If Not StrIDIndexDic.Exists(n) Then Exit Do
		If j = k Then
			UpdatePSLList = DelStrInHCSForPslListUpdate(srcFile,AllStrDataList(StrIDIndexDic.Item(n)),m,True) + 2
		Else
			UpdatePSLList = DelStrInHCSForPslListUpdate(srcFile,AllStrDataList(StrIDIndexDic.Item(n)),m,False) + 2
		End If
		Select Case UpdatePSLList
		Case 2		'放弃
			If j <> k Then Exit Do
			For i = j - 2 To j - 1
				If Left$(Trim$(TempList(i)),1) = ";" Then TempList(i) = Mid$(TempList(i),2)
			Next i
		Case 3		'忽略
			For i = j - 2 To j - 1
				If Left$(Trim$(TempList(i)),1) <> ";" Then TempList(i) = ";" & TempList(i)
			Next i
		Case 4		'删除
			For i = j - 2 To j - 1
				If TempList(i) <> "" Then TempList(i) = ""
			Next i
		End Select
		'If WriteTextFileByLine(srcFile.hcsFile.FilePath,CP_UNICODELITTLE,TempList) = False Then Exit Do
		If WriteBinaryFile(srcFile.hcsFile.FilePath,CP_UNICODELITTLE,StrListJoin(TempList,TextJoinStr)) = False Then Exit Do
		AllStrDataList(StrIDIndexDic.Item(n)).iError = UpdatePSLList - 2
		k = j
	Loop
	ExitFunction:
	'还原更新错误时显示消息对话框的设置
	If Stemp = True Then PSL.Option(pslOptionBatchMessageBox) = Stemp
	'查看被删除的字串文件
	If Mode = False Then Exit Function
	If Dir$(srcFile.hcsFile.FilePath & "_DeledString.txt") <> "" Then
		ReDim FileDataList(0) As String
		FileDataList(0) = srcFile.hcsFile.FilePath & "_DeledString.txt" & JoinStr & "unicodeFFFE"
		OpenFile(srcFile.hcsFile.FilePath & "_DeledString.txt",FileDataList,1,False)
	End If
End Function


'显示并决定在创建或更新 PSL 列表时要删除或忽略的字串
'返回：DelStringInHCSForPslListUpdate = 0 放弃，= 1 忽略，= 2 删除
Private Function DelStrInHCSForPslListUpdate(srcFile As FILE_PROPERTIE,strData As STRING_PROPERTIE,SaveDeledStr As Long, _
				Optional ByVal ShowMsg As Boolean) As Integer
	Dim MsgList() As String
	If getMsgList(UIDataList,MsgList,"DelStringInHCSForPslListUpdate",1) = False Then Exit Function
	If ShowMsg = True Then
		If MsgBox(Replace$(MsgList(18),"%s",srcFile.hcsFile.FilePath),vbRetryCancel+vbInformation,MsgList(17)) = vbCancel Then Exit Function
	End If
	MsgList(2) = Replace$(MsgList(2),"%s",CStr$(strData.Source.lStartAddress))
	MsgList(3) = Replace$(MsgList(3),"%s",CStr$(strData.Source.CodePage))
	MsgList(4) = Replace$(MsgList(4),"%s",CStr$(strData.Source.lHexLength))
	MsgList(5) = Replace$(MsgList(5),"%s",CStr$(strData.Source.lCharLength))
	Begin Dialog UserDialog 830,553,MsgList(0),.CommonDlgFunc ' %GRID:10,7,1,1
		Text 0,7,830,56,MsgList(1),.Text
		Text 10,70,190,14,MsgList(2),.AddressText
		Text 210,70,200,14,MsgList(3),.CodePageText
		Text 430,70,190,14,MsgList(4),.ByteLengThText
		Text 630,70,190,14,MsgList(5),.CharLengThText
		TextBox 0,91,830,427,.TextBox,1
		CheckBox 20,525,430,21,MsgList(6),.SaveDelStrCheckBox
		PushButton 460,525,100,21,MsgList(7),.IgnoreButton
		PushButton 580,525,100,21,MsgList(8),.DelButton
		CancelButton 700,525,100,21
	End Dialog
	Dim dlg As UserDialog
	dlg.TextBox = strData.Source.sString
	dlg.SaveDelStrCheckBox = SaveDeledStr
	DelStrInHCSForPslListUpdate = Dialog(dlg)
	If DelStrInHCSForPslListUpdate < 2 Then Exit Function
	If dlg.SaveDelStrCheckBox = 0 Then Exit Function
	SaveDeledStr = dlg.SaveDelStrCheckBox
	Dim Temp As String
	Temp = srcFile.hcsFile.FilePath & "_DeledString.txt"
	If Dir$(Temp) = "" Then
		WriteBinaryFile Temp,CP_UNICODELITTLE,MsgList(9) & vbCrLf & vbCrLf
		WriteBinaryFile Temp,CP_UNICODELITTLE,MsgList(10) & srcFile.FilePath & vbCrLf,True,True
		WriteBinaryFile Temp,CP_UNICODELITTLE,MsgList(11) & srcFile.FileVersion & vbCrLf,True,True
		WriteBinaryFile Temp,CP_UNICODELITTLE,MsgList(12) & srcFile.FileSize & vbCrLf,True,True
		WriteBinaryFile Temp,CP_UNICODELITTLE,MsgList(13) & srcFile.DateLastModified & vbCrLf,True,True
		WriteBinaryFile Temp,CP_UNICODELITTLE,MsgList(14) & vbCrLf & vbCrLf,True,True
	End If
	With strData
		MsgList(16) = Replace$(MsgList(16),"%1",CStr$(.Source.lStartAddress))
		MsgList(16) = Replace$(MsgList(16),"%2",CStr$(.Source.lEndAddress))
		MsgList(16) = Replace$(MsgList(16),"%3",CStr$(.Source.CodePage))
		MsgList(16) = Replace$(MsgList(16),"%4",CStr$(.StrType))
		MsgList(16) = Replace$(MsgList(16),"%5",CStr$(.Source.lHexLength))
		MsgList(16) = Replace$(MsgList(16),"%6",CStr$(.Source.lCharLength))
		WriteBinaryFile Temp,CP_UNICODELITTLE,MsgList(15) & vbCrLf & MsgList(16) & vbCrLf & MsgList(15) & vbCrLf,True,True
		WriteBinaryFile Temp,CP_UNICODELITTLE,.Source.sString & vbCrLf & vbCrLf,True,True
	End With
End Function


'更新 HCS 文件解析规则
Private Function UpdateHCSRule() As Boolean
	Dim i As Long,MsgList() As String,ParserList() As FILE_LIST,PSLAddInPath As String
	If getMsgList(UIDataList,MsgList,"AddToPslProject",1) = False Then Exit Function
	'获取 PSL 自定义插件文件夹
	PSLAddInPath = GetPSLAddInPath()
	If PSLAddInPath = "" Then Exit Function
	'获取自定义文本解析器名称列表
	If CheckArray(getSubFiles(ParserList,PSLAddInPath,"PAITextParser.dat","")) = False Then Exit Function
	'更新规则
	For i = 0 To UBound(ParserList)
		If CheckRule(ParserList(i).FilePath,MsgList(1),MsgList(2)) = True Then
			UpdateHCSRule = True
		End If
	Next i
End Function


'获取用户自定义文本解析器的父文件夹路径
Private Function GetPSLAddInPath() As String
	Dim WshShell As Object,TempList() As String
	'获取用户应用程序数据文件夹
	On Error Resume Next
	Set WshShell = CreateObject("WScript.Shell")
	GetPSLAddInPath = "HKCU\Software\Microsoft\Windows\CurrentVersion\Explorer\User Shell Folders\AppData"
	GetPSLAddInPath = WshShell.RegRead(GetPSLAddInPath)
	If Err.Source = "WshShell.RegRead" Then
		MsgBox Err.Description,vbInformation
		GetPSLAddInPath = ""
		Exit Function
	End If
	Set WshShell = Nothing
	On Error GoTo 0
	If GetPSLAddInPath = "" Then Exit Function
	'解析用户应用程序数据文件夹
	TempList = ReSplit(GetPSLAddInPath,"%",-1)
	If UBound(TempList) >= 2 Then
		GetPSLAddInPath = Replace$(GetPSLAddInPath,"%" & TempList(1) & "%",Environ(TempList(1)),,1)
	End If
	GetPSLAddInPath = RemoveBackslash(RemoveBackslash(GetPSLAddInPath,"""","""",1),"","\",1)
	'根据 PSL 版本号获取自定义插件文件夹
	Select Case Int(PSL.Version / 100)
	Case 4
		GetPSLAddInPath = GetPSLAddInPath & "\Passolo 4\AddIn\"
	Case 5
		GetPSLAddInPath = GetPSLAddInPath & "\Passolo 5\AddIn\"
	Case 6
		GetPSLAddInPath = GetPSLAddInPath & "\Passolo 6\AddIn\"
	Case 7
		GetPSLAddInPath = GetPSLAddInPath & "\Passolo 2007\AddIn\"
	Case 8
		GetPSLAddInPath = GetPSLAddInPath & "\Passolo 2009\AddIn\"
	Case 11
		GetPSLAddInPath = GetPSLAddInPath & "\Passolo 2011\AddIn\"
	Case 15
		GetPSLAddInPath = GetPSLAddInPath & "\SDL\Passolo 2015\AddIn\"
	Case 16
		GetPSLAddInPath = GetPSLAddInPath & "\SDL\Passolo 2016\AddIn\"
	Case 18
		GetPSLAddInPath = GetPSLAddInPath & "\SDL\Passolo 2018\AddIn\"
	Case Else
		TempList(0) = Left$(MacroDir,InStrRev(MacroDir,"\") - 1)
		TempList(0) = Mid$(TempList(0),InStrRev(TempList(0),"\") + 1)
		If PSL.Version < 1200 Then
			GetPSLAddInPath = GetPSLAddInPath & "\" & TempList(0) & "\AddIn\"
		Else
			GetPSLAddInPath = GetPSLAddInPath & "\SDL\" & TempList(0) & "\AddIn\"
		End If
	End Select
End Function


'检查文本解析器现有规则是否支持解析 HCS 文件
Private Function CheckRule(ByVal FilePath As String,ByVal RuleName As String,ByVal RuleData As String) As Boolean
	Dim i As Long,j As Long,k As Long,n As Long,Temp As String,TempList() As String
	Dim Find(3) As Integer,NameList() As String,DataList() As String
	'检查默认规则是否正确
	DataList = ReSplit(RuleData,vbCrLf)
	If UBound(DataList) < 5 Then Exit Function
	'写入默认规则
	Temp = ReadTextFile(FilePath,"unicodeFFFE")
	If Temp = "" Then
		CheckRule = WriteToFile(FilePath,Replace$(RuleData,vbCrLf & vbCrLf,vbCrLf),"unicodeFFFE")
		Exit Function
	End If
	'检查和修改现有规则
	Find(0) = -1
	NameList = ReSplit(LCase$(RuleName),";")
	TempList = ReSplit(Temp,vbCrLf)
	k = UBound(TempList)
	For i = 0 To k
		TempList(n) = TempList(i)
		Temp = LCase$(Trim$(TempList(i)))
		If InStr(Temp,"name=") = 1 Or i = k Then
			If Find(0) > 0 Then
				If DataList(2) <> "" Then
					If Find(1) > 0 Then
						TempList(Find(1)) = DataList(2)
						CheckRule = True
					ElseIf Find(1) = 0 Then
						TempList(Find(0)) = TempList(Find(0)) & vbCrLf & DataList(2)
						CheckRule = True
					End If
				End If
				If DataList(3) <> "" Then
					If Find(2) > 0 Then
						TempList(Find(2)) = DataList(3)
						CheckRule = True
					ElseIf Find(2) = 0 Then
						If Find(1) <> 0 Then Find(0) = Abs(Find(1))
						TempList(Find(0)) = TempList(Find(0)) & vbCrLf & DataList(3)
						CheckRule = True
					End If
				End If
				If DataList(4) <> "" Then
					If Find(3) > 0 Then
						TempList(Find(3)) = DataList(4)
						CheckRule = True
					ElseIf Find(3) = 0 Then
						If Find(2) <> 0 Then Find(0) = Abs(Find(2))
						TempList(Find(0)) = TempList(Find(0)) & vbCrLf & DataList(4)
						CheckRule = True
					End If
				End If
			End If
			If Find(0) > -1 Then Find(0) = 0
			Find(1) = 0: Find(2) = 0: Find(3) = 0
			If i <> k Then
				Temp = Trim$(ReSplit(ReSplit(Temp,"name=""")(1),"(")(0))
				For j = 0 To UBound(NameList)
					If Temp = Trim$(NameList(j)) Then
						Find(0) = n
						Exit For
					End If
				Next j
			End If
		ElseIf Find(0) > 0 Then
			If InStr(Temp,"ext=") = 1 Then
				If DataList(2) = "" Then
					Find(1) = -n
					n = n - 1
					CheckRule = True
				ElseIf Temp = LCase$(DataList(2)) Then
					Find(1) = -n
				ElseIf Find(1) = 0 Then
					Find(1) = n
				Else
					n = n - 1
				End If
			ElseIf InStr(Temp,"comment=") = 1 Then
				If DataList(3) = "" Then
					Find(2) = -n
					n = n - 1
					CheckRule = True
				ElseIf Temp = LCase$(DataList(3)) Then
					Find(2) = -n
				ElseIf Find(2) = 0 Then
					Find(2) = n
				Else
					n = n - 1
				End If
			ElseIf InStr(Temp,"string=") = 1 Then
				If DataList(4) = "" Then
					Find(3) = -n
					n = n - 1
					CheckRule = True
				ElseIf Temp = LCase$(DataList(4)) Then
					Find(3) = -n
				ElseIf Find(3) = 0 Then
					Find(3) = n
				Else
					n = n - 1
				End If
			End If
		End If
		n = n + 1
	Next i
	'找到符合要求的规则并且不需要修改时退出
	If Find(0) > -1 Then
		If CheckRule = False Then
			CheckRule = True
			Exit Function
		ElseIf i > n Then
			ReDim Preserve TempList(n - 1) As String
		End If
	'添加解析 HCS 文本解析器的默认规则
	Else
		ReDim Preserve TempList(n) As String
		TempList(n) = Replace$(RuleData,vbCrLf & vbCrLf,vbCrLf)
	End If
	'写入修改的规则
	CheckRule = WriteToFile(FilePath,StrListJoin(TempList,vbCrLf),"unicodeFFFE")
End Function


'提取字串对话框
'ShowMsg > 0 or < -1 可选择文件及提取，= 0 不可选择文件也不能提取，= -1 可选择文件但不能提取
'提取时返回值 > 0 提取字串成功数量，= 0 重新提取，否则，提取中止、取消提取
'设置时返回值 = 0 取消，< 0 确定
Private Function ExtractString(orgFile As FILE_PROPERTIE,ByVal ShowMsg As Long) As Long
	Dim MsgList() As String,TempList() As String,Temp As String
	If getMsgList(UIDataList,MsgList,"ExtractString",1) = False Then Exit Function
	Temp = Selected(0)
	TempList = ReSplit(MsgList(42),ItemJoinStr)
	MsgList(1) = IIf(ShowMsg = 0 Or ShowMsg = -1,MsgList(1),MsgList(0))
	Begin Dialog UserDialog 860,546,MsgList(1),.ExtractStringDlgFunc ' %GRID:10,7,1,1
		CheckBox 0,0,0,21,"",.ModeCheckBox,1
		TextBox 0,0,0,21,.SuppValueBox
		Text 20,14,70,14,MsgList(2),.FileText
		TextBox 100,11,630,21,.FilePathBox
		TextBox 100,11,630,21,.FilePathBoxBak
		PushButton 730,11,30,21,MsgList(3),.FilePathButton
		PushButton 760,11,80,21,MsgList(4),.StringSearchButton

		GroupBox 20,42,350,70,MsgList(5),.ExtractModeGroup
		OptionGroup .ExtractModeOption
			OptionButton 40,63,310,14,MsgList(6),.VAOption
			OptionButton 40,84,310,14,MsgList(7),.NotVAOption

		GroupBox 390,42,450,112,MsgList(9),.SectionListGroup
		GroupBox 390,42,450,112,MsgList(10),.RangeGroup
		PushButton 790,63,30,21,MsgList(11),.SectionListEditButton
		TextBox 410,63,380,21,.SectionListBox
		TextBox 410,63,380,21,.SectionListWithSubBox
		TextBox 410,63,380,21,.RangeTextBox
		TextBox 410,63,380,21,.RangeTextBoxBak
		PushButton 790,63,30,21,MsgList(12),.RangeTipButton
		CheckBox 410,91,410,14,IIf(StrToLong(Selected(16)) = 0,MsgList(13),MsgList(14)),.RangeCheckBox

		TextBox 410,119,350,21,.LangListBox
		PushButton 760,119,30,21,MsgList(12),.LangLevelButton
		PushButton 790,119,30,21,MsgList(16),.LangListEditButton

		GroupBox 20,119,350,245,MsgList(17),.CPListGroup
		CheckBox 40,140,100,14,ReSplit(MsgList(18),ItemJoinStr)(0),.ANSICheckBox
		CheckBox 140,140,110,14,ReSplit(MsgList(18),ItemJoinStr)(1),.UnicodeCheckBox
		CheckBox 250,140,100,14,ReSplit(MsgList(18),ItemJoinStr)(2),.UTF8CheckBox
		PushButton 320,161,30,21,MsgList(3),.CPListEditButton
		TextBox 40,161,250,21,.CPListBox
		PushButton 290,161,30,21,MsgList(12),.CPLevelButton

		CheckBox 40,189,310,14,MsgList(20),.CStringCheckBox
		CheckBox 40,210,310,14,MsgList(21),.PascalCheckBox
		CheckBox 40,231,310,14,MsgList(22),.PascalDWordCheckBox
		CheckBox 40,252,310,14,MsgList(23),.PascalAnsiCheckBox
		CheckBox 40,273,310,14,MsgList(24),.PascalShortCheckBox
		CheckBox 40,294,310,14,MsgList(25),.NetStrCheckBox
		CheckBox 40,315,310,14,MsgList(26),.AndroidStrCheckBox
		CheckBox 40,336,310,14,IIf(CheckStrTypeArray(StrTypeList) = False,MsgList(27),MsgList(28)),.CustomTypeCheckBox

		GroupBox 20,371,350,133,MsgList(29),.RefAndLengthGroup
		Text 40,392,80,14,MsgList(8),.ReferenceTypeText
		DropListBox 130,388,220,21,TempList(),.ReferenceTypeList
		CheckBox 40,413,310,14,MsgList(30),.ReferenceCheckBox
		Text 40,434,260,14,MsgList(31),.MinStrLengthText
		TextBox 310,431,40,20,.MinStrLengthTextBox
		Text 40,455,310,14,MsgList(32),.EndCharText
		DropListBox 40,473,280,21,TempList(),.EndCharList
		PushButton 320,473,30,21,MsgList(12),.EndCharButton

		GroupBox 390,161,450,245,MsgList(33),.FilterGroup
		CheckBox 410,182,200,21,MsgList(34),.NullStrCheckBox
		CheckBox 620,182,200,21,MsgList(35),.ControlStrCheckBox
		CheckBox 410,203,200,21,MsgList(36),.AllSymbolCheckBox
		CheckBox 620,203,200,21,MsgList(37),.AllUCaseCheckBox
		CheckBox 410,224,200,21,MsgList(38),.AllLCaseCheckBox
		CheckBox 620,224,200,21,MsgList(39),.AllULCaseCheckBox
		CheckBox 410,245,350,21,MsgList(40),.ContinuousCheckBox
		TextBox 760,245,60,21,.ContinuousTextBox
		CheckBox 410,266,350,21,MsgList(15),.MaxStrLengthCheckBox
		TextBox 760,266,60,21,.MaxStrLengthTextBox

		CheckBox 410,290,290,21,MsgList(41),.OtherStrCheckBox
		DropListBox 410,311,380,21,TempList(),.OtherStrTextBox,1
		DropListBox 410,311,380,21,TempList(),.OtherStrForWildcardTextBox,1
		DropListBox 410,311,350,21,TempList(),.OtherStrForRegExpTextBox,1
		DropListBox 700,290,120,21,TempList(),.OtherMatchModeList
		PushButton 760,311,30,21,MsgList(12),.RegExpTipButton
		PushButton 790,311,30,21,MsgList(3),.FavoriteButton
		CheckBox 410,332,200,21,MsgList(43),.OtherMatchCaseCheckBox
		CheckBox 620,332,200,21,MsgList(44),.IgnoreOtherAccKeyCheckBox

		CheckBox 410,290,280,21,MsgList(45),.IncludeStrCheckBox
		TextBox 410,311,410,21,.IncludeStrTextBox

		CheckBox 410,357,210,21,MsgList(46),.FilterStrCheckBox
		CheckBox 620,357,160,21,MsgList(44),.IgnoreFilterAccKeyCheckBox
		PushButton 790,357,30,21,MsgList(47),.FilterStrButton
		CheckBox 410,378,210,21,MsgList(48),.KeepStrCheckBox
		CheckBox 620,378,160,21,MsgList(44),.IgnoreKeepAccKeyCheckBox
		PushButton 790,378,30,21,MsgList(49),.KeepStrButton

		GroupBox 390,413,450,91,MsgList(50),.MassageGroup
		CheckBox 410,434,410,14,MsgList(51),.OutputMsgCheckBox
		CheckBox 410,455,410,14,MsgList(52),.LogingMsgCheckBox
		CheckBox 410,476,400,21,MsgList(53),.LogingFilteredStrOnlyCheckBox

		PushButton 20,518,100,21,MsgList(54),.HelpButton
		PushButton 130,518,100,21,MsgList(55),.SetButton
		PushButton 240,518,100,21,MsgList(56),.ResetButton
		PushButton 350,518,110,21,MsgList(57),.SaveButton
		PushButton 630,518,100,21,MsgList(58),.GetStrButton
		OKButton 630,518,100,21,.OKButton
		CancelButton 740,518,100,21,.CancelButton
	End Dialog
	Dim dlg As UserDialog
	dlg.ModeCheckBox = IIf(ShowMsg > 0 Or ShowMsg < -1,0,IIf(ShowMsg = 0,1,2))
	ExtractString = Dialog(dlg)
	If ExtractString < 1 Then Exit Function '设置时 = -1
	Erase TempList
	'根据是否更改语言重置字串
	If Temp <> Selected(0) Then getMsgList(UIDataList,MsgList,"ExtractString",1)
	'根据是否更改消息输出设置更改消息输出窗口
	If ShowMsg > 0 And Selected(17) = "-1" Then
		ShowMsg = -Abs(ShowMsg)
	ElseIf ShowMsg < -1 And Selected(17) = "1" Then
		ShowMsg = Abs(ShowMsg)
	End If
	'开始提取，如果成功更新备份字串类型数据表
	If ShowMsg = -1 Then ShowMsg = 0
	ExtractString = GetStrings(orgFile,ShowMsg)
	Select Case ExtractString
	Case Is > 0
		'显示提取结果
		If ShowMsg > 0 Then
			SetTextBoxString ShowMsg,Replace$(MsgList(59),"%s",CStr(UBound(AllStrDataList) + 1)),True
		ElseIf ShowMsg < 0 Then
			PSL.Output Replace$(MsgList(59),"%s",CStr(UBound(AllStrDataList) + 1))
		End If
	Case 0
		Select Case orgFile.Magic
		Case "NotPE32","NotPE64",""
			MsgBox MsgList(62),vbOkOnly+vbInformation,MsgList(63)
		Case Else
			MsgBox IIf(ExtractSet(49) = "0",MsgList(60),MsgList(61)),vbOkOnly+vbInformation,MsgList(63)
		End Select
		ExtractString = ExtractString(orgFile,ShowMsg)
	End Select
End Function


'提取字串对话框函数
Private Function ExtractStringDlgFunc(DlgItem$, Action%, SuppValue&) As Boolean
	Dim i As Long,j As Long,n As Long,k As Long
	Dim MsgList() As String,TempArray() As String,TempList() As String
	Dim Stemp As Boolean,Temp As String,Dic As Object
	Select Case Action%
	Case 1 ' 对话框窗口初始化
		If getMsgList(UIDataList,MsgList,"ExtractStringDlgFunc",1) = False Then Exit Function
		DlgText "SuppValueBox",CStr$(SuppValue)
		DlgVisible "ModeCheckBox",False
		DlgVisible "SuppValueBox",False
		DlgVisible "IncludeStrCheckBox",False
		DlgVisible "IncludeStrTextBox",False
		DlgVisible "FilePathBoxBak",False
		DlgVisible "RangeTextBoxBak",False
		DlgEnable "FilePathBox",False
		DlgEnable "SectionListBox",False
		DlgEnable "SectionListWithSubBox",False
		DlgEnable "LangListBox",False
		DlgEnable "CPListBox",False
		DlgEnable "SaveButton",False

		If CheckRefTypeArray(RefTypeList) = True Then
			ReDim TempArray(UBound(RefTypeList) + 1) As String
			TempArray(0) = MsgList(2)
			For i = 0 To UBound(RefTypeList)
				TempArray(i + 1) = RefTypeList(i).sName
				If RefTypeList(i).Template = UseRefTypeList(0).Template Then j = i + 1
			Next i
			If j = 0 Then
				If CheckRefTypeArray(UseRefTypeList) = True Then
					j = UBound(TempArray) + 1
					ReDim Preserve TempArray(j) As String
					TempArray(j) = UseRefTypeList(0).sName
				End If
			End If
		Else
			ReDim TempArray(0) As String
			TempArray(0) = MsgList(2)
			DlgEnable "ReferenceTypeList",False
		End If
		DlgListBoxArray "ReferenceTypeList",TempArray()
		Select Case SourceFile.Magic
		Case ""
			DlgVisible "SectionListWithSubBox",False
			DlgEnable "ReferenceCheckBox",False
			DlgEnable "VAOption",False
			ExtractSet(0) = "1"
			DlgEnable "SectionListEditButton",False
			ExtractSet(11) = "0"
			DlgValue "ReferenceTypeList",0
		Case "NotPE32","NotPE64"
			'DlgEnable "VAOption",False
			'ExtractSet(0) = "1"
			DlgVisible "SectionListWithSubBox",False
			DlgValue "ReferenceTypeList",j
		Case "PE32","PE64","NET32","NET64"
			DlgVisible "SectionListWithSubBox",False
			DlgEnable "ReferenceTypeList",False
			DlgValue "ReferenceTypeList",0
		Case "MAC32","MAC64"
			DlgVisible "SectionListBox",False
			DlgEnable "ReferenceTypeList",False
			DlgValue "ReferenceTypeList",0
		End Select

		Select Case DlgValue("ModeCheckBox")
		Case 0
			DlgVisible "OKButton",False
		Case 1
			DlgVisible "GetStrButton",False
			DlgEnable "FilePathButton",False
		Case Else
			DlgVisible "GetStrButton",False
		End Select

		'更改提取字串的其他字符匹配方式
		'为正则表达式并提取有非英文字串时改为常规方式
		 If ExtractSet(42) = "2" Then
			If UBound(UseLangList) > 0 Then
				ExtractSet(42) = "0"
			ElseIf UseLangList(0).LangID <> 1033 Then
				ExtractSet(42) = "0"
			End If
		'为非正则表达式并只提取英文字串时改为正则表达式方式)
		ElseIf ExtractSet(46) <> "" Then
			If UBound(UseLangList) = 0 Then
				If UseLangList(0).LangID = 1033 Then ExtractSet(42) = "2"
			End If
		End If

		If ExtractSet(4) = "" Then ExtractSet(4) = "2100000"
		If ExtractSet(7) = "1" Or ExtractSet(8) = "1" Then
			If Mid$(ExtractSet(4),1,1) = "0" Then
				ExtractSet(4) = AddEncodeLevel(ExtractSet(4),1)
			End If
		End If
		If ExtractSet(5) = "1" Or ExtractSet(6) = "1" Or ExtractSet(9) = "1" Then
			If Mid$(ExtractSet(4),2,1) = "0" Then
				ExtractSet(4) = AddEncodeLevel(ExtractSet(4),2)
			End If
		End If
		If ExtractSet(10) = "1" Then
			If CheckStrTypeArray(UseStrTypeList) = False Then
				ExtractSet(10) = "0"
			End If
		End If

		Temp = SourceFile.FilePath
		If Len(Temp) > 70 Then
			Temp = Left$(Temp,InStr(Temp,"\")) & "..." & Right(Temp,70 - Len(Left$(Temp,InStr(Temp,"\"))))
		End If
		DlgText "FilePathBox",Temp
		DlgText "FilePathBoxBak",SourceFile.FilePath
		DlgText "SectionListBox",StrListJoin(UseSectionList,ItemJoinStr)
		DlgText "SectionListWithSubBox",StrListJoin(UseSubSecList,ItemJoinStr)
		DlgText "LangListBox",StrListJoin(GetLangStrList(UseLangList,0),ItemJoinStr)
		DlgValue "ExtractModeOption",StrToLong(ExtractSet(0))

		DlgValue "ANSICheckBox",IIf(StrToLong(Mid$(ExtractSet(4),1,1)) = 0,0,1)
		DlgValue "UnicodeCheckBox",IIf(StrToLong(Mid$(ExtractSet(4),2,1)) = 0,0,1)
		DlgValue "UTF8CheckBox",IIf(StrToLong(Mid$(ExtractSet(4),3,1)) = 0,0,1)
		DlgText "CPListBox",ConvertEncodeLevel(ExtractSet(4),MsgList(24),ItemJoinStr)

		DlgValue "PascalCheckBox",StrToLong(ExtractSet(5))
		DlgValue "PascalDWordCheckBox",StrToLong(ExtractSet(6))
		DlgValue "PascalAnsiCheckBox",StrToLong(ExtractSet(7))
		DlgValue "PascalShortCheckBox",StrToLong(ExtractSet(8))
		DlgValue "NetStrCheckBox",StrToLong(ExtractSet(9))
		DlgValue "AndroidStrCheckBox",StrToLong(ExtractSet(41))
		DlgValue "CustomTypeCheckBox",StrToLong(ExtractSet(10))

		DlgValue "ReferenceCheckBox",StrToLong(ExtractSet(11))
		DlgValue "NullStrCheckBox",StrToLong(ExtractSet(12))
		DlgValue "ControlStrCheckBox",StrToLong(ExtractSet(13))
		DlgValue "AllSymbolCheckBox",StrToLong(ExtractSet(14))
		DlgValue "AllUCaseCheckBox",StrToLong(ExtractSet(15))
		DlgValue "AllLCaseCheckBox",StrToLong(ExtractSet(16))
		DlgValue "AllULCaseCheckBox",StrToLong(ExtractSet(17))
		DlgValue "ContinuousCheckBox",StrToLong(ExtractSet(18))
		DlgValue "OtherStrCheckBox",StrToLong(ExtractSet(19))
		DlgValue "IncludeStrCheckBox",StrToLong(ExtractSet(20))
		DlgValue "FilterStrCheckBox",StrToLong(ExtractSet(21))
		DlgValue "IgnoreFilterAccKeyCheckBox",StrToLong(ExtractSet(22))
		DlgValue "KeepStrCheckBox",StrToLong(ExtractSet(23))
		DlgValue "IgnoreKeepAccKeyCheckBox",StrToLong(ExtractSet(24))
		DlgValue "OutputMsgCheckBox",StrToLong(ExtractSet(25))
		DlgValue "LogingMsgCheckBox",StrToLong(ExtractSet(26))
		DlgValue "LogingFilteredStrOnlyCheckBox",StrToLong(ExtractSet(51))
		DlgText "MinStrLengthTextBox",ExtractSet(27)
		DlgText "ContinuousTextBox",ExtractSet(28)
		'DlgText "OtherStrTextBox",ExtractSet(29)
		DlgText "IncludeStrTextBox",ExtractSet(30)
		DlgValue "MaxStrLengthCheckBox",StrToLong(ExtractSet(52))
		DlgText "MaxStrLengthTextBox",ExtractSet(53)

		ExtractSet(31) = MergeStrEndCharSet(ExtractSet(31),MsgList(25))
		ExtractSetBak(31) = MergeStrEndCharSet(ExtractSetBak(31),MsgList(25))
		TempArray = ReSplit(ReSplit(ExtractSet(31),ItemJoinStr,2)(1),JoinStr)
		DlgListBoxArray "EndCharList",TempArray()
		DlgValue "EndCharList",StrToLong(ReSplit(ExtractSet(31),ItemJoinStr,2)(0))

		DlgValue "OtherMatchModeList",StrToLong(ExtractSet(42))
		DlgValue "OtherMatchCaseCheckBox",StrToLong(ExtractSet(43))
		DlgValue "IgnoreOtherAccKeyCheckBox",StrToLong(ExtractSet(44))
		'DlgText "OtherStrForWildcardTextBox",ExtractSet(45)
		'DlgText "OtherStrForRegExpTextBox",ExtractSet(46)
		DlgValue "CStringCheckBox",StrToLong(ExtractSet(48))
		DlgValue "RangeCheckBox",StrToLong(ExtractSet(49))

		'根据地址格式的设置转换提取区域
		If Trim$(ExtractSet(50)) = "" Then
			DlgText "RangeTextBox",MsgList(41)
		ElseIf StrToLong(Selected(16)) = 1 Then
			TempArray = ReSplit(ExtractSet(50),",")
			n = 0
			For i = 0 To UBound(TempArray)
				If InStr(TempArray(i),"-") Then
					TempList = ReSplit(Trim$(TempArray(i)),"-")
					For j = 0 To 1
						TempList(j) = ValToStr(StrToLong(Trim(TempList(j))),SourceFile.FileSize,True)
					Next j
					TempArray(i) = StrListJoin(TempList,"-")
				Else
					TempArray(i) = ValToStr(StrToLong(Trim$(TempArray(i))),SourceFile.FileSize,True)
				End If
			Next i
			DlgText "RangeTextBox",StrListJoin(TempArray,",")
		Else
			DlgText "RangeTextBox",ExtractSet(50)
		End If
		DlgText "RangeTextBoxBak",MsgList(41)

		GetHistory(TempList,"Filters","GetStrDlgGeneral")
		If ExtractSet(29) = "" Then
			ExtractSet(29) = TempList(0)
			ExtractSet(32) = Str2RegExpPattern(Convert(ExtractSet(29)))
		End If
		DlgListBoxArray "OtherStrTextBox",TempList()
		DlgText "OtherStrTextBox",ExtractSet(29)

		GetHistory(TempList,"Filters","GetStrDlgWildcard")
		If ExtractSet(45) = "" Then
			ExtractSet(45) = TempList(0)
			ExtractSet(47) = Convert(ExtractSet(45))
		End If
		DlgListBoxArray "OtherStrForWildcardTextBox",TempList()
		DlgText "OtherStrForWildcardTextBox",ExtractSet(45)

		GetHistory(TempList,"Filters","GetStrDlgRegExp")
		If ExtractSet(46) = "" Then ExtractSet(46) = TempList(0)
		DlgListBoxArray "OtherStrForRegExpTextBox",TempList()
		DlgText "OtherStrForRegExpTextBox",ExtractSet(46)

		Select Case DlgValue("OtherMatchModeList")
		Case 0
			DlgVisible "OtherStrForWildcardTextBox",False
			DlgVisible "OtherStrForRegExpTextBox",False
			DlgVisible "RegExpTipButton",False
		Case 1
			DlgVisible "OtherStrTextBox",False
			DlgVisible "OtherStrForRegExpTextBox",False
			DlgVisible "RegExpTipButton",False
		Case 2
			DlgVisible "OtherStrTextBox",False
			DlgVisible "OtherStrForWildcardTextBox",False
		End Select

		If DlgValue("RangeCheckBox") = 0 Then
			DlgVisible "RangeGroup",False
			DlgVisible "RangeTextBox",False
			DlgVisible "RangeTipButton",False
		Else
			DlgVisible "SectionListGroup",False
			DlgVisible "SectionListBox",False
			DlgVisible "SectionListEditButton",False
		End If

		If DlgText("FilePathBox") = "" Or DlgText("LangListBox") = "" Or DlgText("CPListBox") = "" Then
			DlgEnable "OKButton",False
			DlgEnable "GetStrButton",False
		ElseIf DlgValue("RangeCheckBox") = 0 And DlgText("SectionListBox") = "" Then
			DlgEnable "OKButton",False
			DlgEnable "GetStrButton",False
		ElseIf DlgValue("RangeCheckBox") = 1 And DlgText("RangeTextBox") = MsgList(41) Then
			DlgEnable "OKButton",False
			DlgEnable "GetStrButton",False
		ElseIf DlgValue("CStringCheckBox") + DlgValue("PascalCheckBox") + DlgValue("PascalDWordCheckBox") + _
			DlgValue("PascalAnsiCheckBox") + DlgValue("PascalShortCheckBox") + DlgValue("NetStrCheckBox") + _
			DlgValue("AndroidStrCheckBox") + DlgValue("CustomTypeCheckBox") = 0 Then
			DlgEnable "OKButton",False
			DlgEnable "GetStrButton",False
		End If
		If DlgText("FilePathBox") = "" Then
			DlgEnable "RangeTipButton",False
			DlgEnable "RangeTextBox",False
		End If
		If DlgText("LangListBox") = "" Then DlgEnable "LangLevelButton",False
		If DlgText("CPListBox") = "" Then DlgEnable "CPLevelButton",False
		DlgEnable "SaveButton",ArrayComp(ExtractSet,ExtractSetBak,"0-4,11-31,42-46,49-53")

		'设置当前对话框字体
		If CheckFont(LFList(0)) = True Then
			j = CreateFont(0,LFList(0))
			If j = 0 Then Exit Function
			For i = 0 To DlgCount() - 1
				SendMessageLNG(GetDlgItem(SuppValue,DlgControlId(DlgName(i))),WM_SETFONT,j,0)
			Next i
		End If
	Case 2 ' 数值更改或者按下按钮时
		If DlgItem$ = "CancelButton" Then
			ExtractSet = ExtractSetBak
			Select Case SourceFile.Magic
			Case "NotPE32","NotPE64",""
				UseRefTypeList(0) = UseRefTypeList(1)
				SourceFile.Magic = UseRefTypeList(1).FileMagic
				TargetFile.Magic = SourceFile.Magic
			End Select
			Exit Function
		End If
		ExtractStringDlgFunc = True ' 防止按下按钮关闭对话框窗口
		If getMsgList(UIDataList,MsgList,"ExtractStringDlgFunc",1) = False Then Exit Function
		Select Case DlgItem$
		Case "OKButton","GetStrButton"
			If DlgItem$ = "GetStrButton" Then
				If DlgText("FilePathBox") = "" Then
					MsgBox MsgList(11),vbOkOnly+vbInformation,MsgList(10)
					Exit Function
				ElseIf Dir$(DlgText("FilePathBoxBak")) = "" Then
					MsgBox MsgList(12),vbOkOnly+vbInformation,MsgList(10)
					Exit Function
				End If
				For i = 0 To UBound(UseLangList)
					If UseLangList(i).CodePage = CP_UNKNOWN Then
						MsgBox MsgList(37),vbOkOnly+vbInformation,MsgList(10)
						Exit Function
					ElseIf UseLangList(i).UniCodeRange = "" Then
						MsgBox MsgList(38),vbOkOnly+vbInformation,MsgList(10)
						Exit Function
					ElseIf UseLangList(i).LangID = 1033 Then
						Stemp = True
					End If
				Next i
				If i > 1 Then
					If Stemp = True Then
						If MsgBox(MsgList(48),vbYesNo+vbInformation,MsgList(4)) = vbNo Then Exit Function
					End If
				End If
			End If
			If DlgValue("RangeCheckBox") = 1 Then
				If DlgText("RangeTextBox") = "" Then
					MsgBox MsgList(42),vbOkOnly+vbInformation,MsgList(10)
					Exit Function
				End If
				If StrToLong(Selected(16)) = 1 Then
					If CheckStrRegExp(DlgText("RangeTextBox"),"[-,0-9a-f]",0,1,True) = False Then
						MsgBox MsgList(43),vbOkOnly+vbInformation,MsgList(10)
						Exit Function
					ElseIf CheckStrRegExp(DlgText("RangeTextBox"),"[0-9a-f]+-[0-9a-f]+(,[0-9a-f]+-[0-9a-f]+)*",0,5,True) = False Then
						MsgBox MsgList(44),vbOkOnly+vbInformation,MsgList(10)
						Exit Function
					End If
				Else
					If CheckStrRegExp(DlgText("RangeTextBox"),"[-,0-9]",0,1) = False Then
						MsgBox MsgList(43),vbOkOnly+vbInformation,MsgList(10)
						Exit Function
					ElseIf CheckStrRegExp(DlgText("RangeTextBox"),"[0-9]+-[0-9]+(,[0-9]+-[0-9]+)*",0,5) = False Then
						MsgBox MsgList(44),vbOkOnly+vbInformation,MsgList(10)
						Exit Function
					End If
				End If
				'检查允许的最小地址和最大地址
				j = SourceFile.SecList(SourceFile.MinSecID).lPointerToRawData
				n = SourceFile.SecList(SourceFile.MaxSecIndex).lPointerToRawData + SourceFile.SecList(SourceFile.MaxSecIndex).lSizeOfRawData - 1
				TempList = ReSplit(Replace$(DlgText("RangeTextBox"),",","-"),"-")
				For i = 0 To UBound(TempList) - 1 Step 2
					If StrToVal(TempList(i),StrToLong(Selected(16))) >= StrToVal(TempList(i + 1),StrToLong(Selected(16))) Then
						MsgBox Replace$(MsgList(45),"%s",TempList(i) & "-" & TempList(i + 1)),vbOkOnly+vbInformation,MsgList(10)
						Exit Function
					ElseIf StrToVal(TempList(i),StrToLong(Selected(16))) < j Then
						MsgBox Replace$(Replace$(MsgList(6),"%s",TempList(i)),"%d",CStr$(j)),vbOkOnly+vbInformation,MsgList(10)
						Exit Function
					ElseIf StrToVal(TempList(i + 1),StrToLong(Selected(16))) > n Then
						MsgBox Replace$(Replace$(MsgList(7),"%s",TempList(i + 1)),"%d",CStr$(n)),vbOkOnly+vbInformation,MsgList(10)
						Exit Function
					End If
				Next i
			End If
			If DlgValue("OtherStrCheckBox") = 1 Then
				Select Case DlgValue("OtherMatchModeList")
				Case 0
					If DlgText("OtherStrTextBox") = "" Then
						MsgBox MsgList(36),vbOkOnly+vbInformation,MsgList(10)
						Exit Function
					End If
				Case 1
					If DlgText("OtherStrForWildcardTextBox") = "" Then
						MsgBox MsgList(36),vbOkOnly+vbInformation,MsgList(10)
						Exit Function
					ElseIf FilterStr("CheckRegExp",DlgText("OtherStrForWildcardTextBox"),1) = -2 Then
						MsgBox MsgList(49),vbOkOnly+vbInformation,MsgList(10)
						Exit Function
					End If
				Case 2
					If DlgText("OtherStrForRegExpTextBox") = "" Then
						MsgBox MsgList(36),vbOkOnly+vbInformation,MsgList(10)
						Exit Function
					ElseIf CheckRegExp(RegExp,DlgText("OtherStrForRegExpTextBox")) = False Then
						MsgBox MsgList(31),vbOkOnly+vbInformation,MsgList(10)
						Exit Function
					End If
				End Select
			End If
			'保存自定义过滤字符
			If DlgText("OtherStrTextBox") <> "" Then
				GetHistory(TempList,"Filters","GetStrDlgGeneral")
				If InsertArray(TempList,DlgText("OtherStrTextBox"),0,True) = True Then
					WriteHistory(TempList,"Filters","GetStrDlgGeneral")
				End If
			End If
			If DlgText("OtherStrForWildcardTextBox") <> "" Then
				GetHistory(TempList,"Filters","GetStrDlgWildcard")
				If InsertArray(TempList,DlgText("OtherStrForWildcardTextBox"),0,True) = True Then
					WriteHistory(TempList,"Filters","GetStrDlgWildcard")
				End If
			End If
			If DlgText("OtherStrForRegExpTextBox") <> "" Then
				GetHistory(TempList,"Filters","GetStrDlgRegExp")
				If InsertArray(TempList,DlgText("OtherStrForRegExpTextBox"),0,True) = True Then
					WriteHistory(TempList,"Filters","GetStrDlgRegExp")
				End If
			End If
			ExtractSetBak = ExtractSet
			ExtractStringDlgFunc = False
			Exit Function
		Case "FilterStrButton"
			If EditFilter(ExtractSet,0) = True Then
				ExtractSetBak(34) = ExtractSet(34)
				ExtractSetBak(35) = ExtractSet(35)
				ExtractSetBak(39) = ExtractSet(39)
				WriteSettings("FilterStrDic")
			End If
			TempList = ReSplit(ReadBinaryFile(ExtractSet(35),CP_UNICODELITTLE,True),vbNullChar)
			StrList2StrDic(FilterStrDic,TempList,StrToLong(ReSplit(FilterStrSet(17),ItemJoinStr)(1)),1)
			Exit Function
		Case "KeepStrButton"
			If EditFilter(ExtractSet,1) = True Then
				ExtractSetBak(36) = ExtractSet(36)
				ExtractSetBak(37) = ExtractSet(37)
				ExtractSetBak(40) = ExtractSet(40)
				WriteSettings("ReserveStrDic")
			End If
			Exit Function
		Case "RangeCheckBox"
			If DlgValue("RangeCheckBox") = 0 Then
				DlgVisible "SectionListGroup",True
				DlgVisible "SectionListBox",True
				DlgVisible "SectionListEditButton",True
				DlgVisible "RangeGroup",False
				DlgVisible "RangeTextBox",False
				DlgVisible "RangeTipButton",False
			Else
				DlgVisible "SectionListGroup",False
				DlgVisible "SectionListBox",False
				DlgVisible "SectionListEditButton",False
				DlgVisible "RangeGroup",True
				DlgVisible "RangeTextBox",True
				DlgVisible "RangeTipButton",True
			End If
		Case "RangeTipButton"
			TempList = getSectionList(SourceFile.SecList,6,SourceFile.FileSize,StrToLong(Selected(16)))
			n = UBound(TempList)
			ReDim TempArray(n * 2 + 1) As String
			For i = 0 To n
				TempArray(i) = Replace$(MsgList(39),"%s",TempList(i))
			Next i
			TempList = getSectionList(SourceFile.SecList,8,SourceFile.FileSize,StrToLong(Selected(16)))
			For i = 0 To UBound(TempList)
				TempArray(n + 1 + i) = Replace$(MsgList(40),"%s",TempList(i))
			Next i
			'i = ShowPopupMenu(TempArray,vbPopupUseRightButton)
			TempArray(0) = PopupMenuShow(TempArray)
			If TempArray(0) = "" Then Exit Function
			TempArray(0) = Split(Split(TempArray(0),"(",2)(1),")")(0)
			Temp = DlgText("RangeTextBox")
			If Temp = "" Or Temp = DlgText("RangeTextBoxBak") Then
				DlgText "RangeTextBox",TempArray(0)
			ElseIf InStr(1,"-,",Mid$(Temp,Len(Temp),1)) Then
				DlgText "RangeTextBox",Temp & TempArray(0)
			ElseIf (UBound(ReSplit(Replace$(Temp,",","-"),"-")) And 1) Then
				DlgText "RangeTextBox",Temp & "," & TempArray(0)
			Else
				DlgText "RangeTextBox",Temp & "-" & TempArray(0)
			End If
			'按照地址显示方式设置转换为十进制值
			If StrToLong(Selected(16)) = 1 Then
				TempArray = ReSplit(DlgText("RangeTextBox"),",")
				n = 0
				For i = 0 To UBound(TempArray)
					If InStr(TempArray(i),"-") Then
						TempList = ReSplit(Trim$(TempArray(i)),"-")
						For j = 0 To 1
							TempList(j) = CStr$(StrToVal(Trim$(TempList(j)),True))
						Next j
						TempArray(i) = StrListJoin(TempList,"-")
					Else
						TempArray(i) = CStr$(StrToVal(Trim$(TempArray(i)),True))
					End If
				Next i
				ExtractSet(50) = StrListJoin(TempArray,",")
			Else
				ExtractSet(50) = DlgText("RangeTextBox")
			End If
			Exit Function
		Case "SaveButton"
			If WriteSettings("GetString") = False Then
				MsgBox Replace(MsgList(16),"%s",RegKey),vbOkOnly+vbInformation,MsgList(10)
				Exit Function
			End If
			'保存自定义过滤字符
			If DlgText("OtherStrTextBox") <> "" Then
				GetHistory(TempList,"Filters","GetStrDlgGeneral")
				If InsertArray(TempList,DlgText("OtherStrTextBox"),0,True) = True Then
					WriteHistory(TempList,"Filters","GetStrDlgGeneral")
				End If
			End If
			If DlgText("OtherStrForWildcardTextBox") <> "" Then
				GetHistory(TempList,"Filters","GetStrDlgWildcard")
				If InsertArray(TempList,DlgText("OtherStrForWildcardTextBox"),0,True) = True Then
					WriteHistory(TempList,"Filters","GetStrDlgWildcard")
				End If
			End If
			If DlgText("OtherStrForRegExpTextBox") <> "" Then
				GetHistory(TempList,"Filters","GetStrDlgRegExp")
				If InsertArray(TempList,DlgText("OtherStrForRegExpTextBox"),0,True) = True Then
					WriteHistory(TempList,"Filters","GetStrDlgRegExp")
				End If
			End If
			ExtractSetBak = ExtractSet
			DlgEnable "SaveButton",False
			Exit Function
		Case "HelpButton"
			ReDim TempArray(2) As String
			If DlgValue("ModeCheckBox") = 0 Then
				TempArray(0) = MsgList(0)
			Else
				TempArray(0) = MsgList(1)
			End If
			TempArray(1) = MsgList(23)
			TempArray(2) = MsgList(34)
			Select Case ShowPopupMenu(TempArray,vbPopupUseRightButton)
			Case 0
				If DlgValue("ModeCheckBox") = 0 Then
					If StrToLong(Selected(30)) = 1 Then
						If OpenCHM(CLng(DlgText("SuppValueBox")),1024,Selected(0),OSLanguage,UIFileList) = True Then Exit Function
					End If
					Call Help("GetStringHelp")
				Else
					If StrToLong(Selected(30)) = 1 Then
						If OpenCHM(CLng(DlgText("SuppValueBox")),1006,Selected(0),OSLanguage,UIFileList) = True Then Exit Function
					End If
					Call Help("GetStrSetHelp")
				End If
			Case 1
				If Dir$(MacroLoc & "\Module\modEncodeQuery.bas") <> "" Then
					MacroRun MacroLoc & "\Module\modEncodeQuery.bas"
				ElseIf Dir$(MacroLoc & "\modEncodeQuery.bas") <> "" Then
					MacroRun MacroLoc & "\modEncodeQuery.bas"
				End If
			Case 2
				If Dir$(MacroLoc & "\Module\modReferenceSearch.bas") <> "" Then
					MacroRun MacroLoc & "\Module\modReferenceSearch.bas", SourceFile.FilePath
				ElseIf Dir$(MacroLoc & "\modReferenceSearch.bas") <> "" Then
					MacroRun MacroLoc & "\modReferenceSearch.bas", SourceFile.FilePath
				End If
			End Select
			Exit Function
		Case "ResetButton"
			ReDim TempArray(1) As String
			TempArray(0) = MsgList(17)
			TempArray(1) = MsgList(18)
			Select Case ShowPopupMenu(TempArray,vbPopupUseRightButton)
			Case Is < 0
				Exit Function
			Case 0
				ExtractSet(4) = "2100000"
				DlgValue "ExtractModeOption",1
				DlgValue "ANSICheckBox",1
				DlgValue "UnicodeCheckBox",1
				DlgValue "UTF8CheckBox",0
				DlgText "CPListBox",ConvertEncodeLevel(ExtractSetBak(4),MsgList(24),ItemJoinStr)
				DlgValue "ReferenceCheckBox",0
				DlgValue "NullStrCheckBox",1
				DlgValue "ControlStrCheckBox",1
				DlgValue "AllSymbolCheckBox",1
				DlgValue "AllUCaseCheckBox",1
				DlgValue "AllLCaseCheckBox",1
				DlgValue "AllULCaseCheckBox",1
				DlgValue "ContinuousCheckBox",1
				DlgValue "OtherStrCheckBox",1
				DlgValue "IncludeStrCheckBox",1
				DlgValue "FilterStrCheckBox",1
				DlgValue "IgnoreFilterAccKeyCheckBox",1
				DlgValue "KeepStrCheckBox",1
				DlgValue "IgnoreKeepAccKeyCheckBox",1
				DlgValue "OutputMsgCheckBox",0
				DlgValue "LogingMsgCheckBox",0
				DlgText "MinStrLengthTextBox","2"
				DlgText "ContinuousTextBox","3"
				DlgText "OtherStrTextBox",SkipStr
				'DlgText "OtherStrForWildcardTextBox",""
				DlgText "OtherStrForRegExpTextBox",NoVowelsRegExp
				DlgText "IncludeStrTextBox",SkipHexStr
				DlgValue "MaxStrLengthCheckBox",0
				DlgText "MaxStrLengthTextBox","10000"
				DlgValue "EndCharList",IIf(SourceFile.Magic <> "",0,2)
				DlgValue "OtherMatchModeList",IIf(UBound(UseLangList) = 0 And UseLangList(0).LangID = 1033,2,0)
				DlgValue "OtherMatchCaseCheckBox",1
				DlgValue "IgnoreOtherAccKeyCheckBox",0
				DlgValue "CStringCheckBox",1
				DlgValue "RangeCheckBox",0
				'DlgValue "RangeTextBox",MsgList(41)
				'DlgValue "RangeTextBoxBak",MsgList(41)
				DlgValue "LogingFilteredStrOnlyCheckBox",0
				ExtractSet(27) = "2"
				ExtractSet(28) = "3"
				ExtractSet(29) = SkipStr
				ExtractSet(30) = SkipHexStr
				ExtractSet(31) = CStr$(DlgValue("EndCharList")) & ItemJoinStr & ReSplit(ExtractSet(31),ItemJoinStr,2)(1)
				ExtractSet(32) = Str2RegExpPattern(Convert(SkipStr))
				ExtractSet(33) = Str2RegExpPattern(Convert(SkipHexStr))
				'ExtractSet(45) = ""
				ExtractSet(46) = NoVowelsRegExp
				'ExtractSet(47) = ""
				'ExtractSet(50) = ""
				ExtractSet(51) = "1"
			Case Else
				If ExtractSetBak(4) = "" Then ExtractSetBak(4) = "2100000"
				ExtractSet(4) = ExtractSetBak(4)

				DlgValue "ExtractModeOption",StrToLong(ExtractSetBak(0))
				'DlgValue "ANSICheckBox",StrToLong(ExtractSetBak(1))
				'DlgValue "UnicodeCheckBox",StrToLong(ExtractSetBak(2))
				'DlgValue "UTF8CheckBox",StrToLong(ExtractSetBak(3))
				DlgValue "ANSICheckBox",IIf(StrToLong(Mid$(ExtractSetBak(4),1,1)) = 0,0,1)
				DlgValue "UnicodeCheckBox",IIf(StrToLong(Mid$(ExtractSetBak(4),2,1)) = 0,0,1)
				DlgValue "UTF8CheckBox",IIf(StrToLong(Mid$(ExtractSetBak(4),3,1)) = 0,0,1)
				DlgText "CPListBox",ConvertEncodeLevel(ExtractSetBak(4),MsgList(24),ItemJoinStr)
				DlgValue "PascalCheckBox",StrToLong(ExtractSetBak(5))
				DlgValue "PascalDWordCheckBox",StrToLong(ExtractSetBak(6))
				DlgValue "PascalAnsiCheckBox",StrToLong(ExtractSetBak(7))
				DlgValue "PascalShortCheckBox",StrToLong(ExtractSetBak(8))
				DlgValue "NetStrCheckBox",StrToLong(ExtractSetBak(9))
				DlgValue "CustomTypeCheckBox",StrToLong(ExtractSetBak(10))
				DlgValue "ReferenceCheckBox",StrToLong(ExtractSetBak(11))
				DlgValue "NullStrCheckBox",StrToLong(ExtractSetBak(12))
				DlgValue "ControlStrCheckBox",StrToLong(ExtractSetBak(13))
				DlgValue "AllSymbolCheckBox",StrToLong(ExtractSetBak(14))
				DlgValue "AllUCaseCheckBox",StrToLong(ExtractSetBak(15))
				DlgValue "AllLCaseCheckBox",StrToLong(ExtractSetBak(16))
				DlgValue "AllULCaseCheckBox",StrToLong(ExtractSetBak(17))
				DlgValue "ContinuousCheckBox",StrToLong(ExtractSetBak(18))
				DlgValue "OtherStrCheckBox",StrToLong(ExtractSetBak(19))
				DlgValue "IncludeStrCheckBox",StrToLong(ExtractSetBak(20))
				DlgValue "FilterStrCheckBox",StrToLong(ExtractSet(21))
				DlgValue "IgnoreFilterAccKeyCheckBox",StrToLong(ExtractSet(22))
				DlgValue "KeepStrCheckBox",StrToLong(ExtractSet(23))
				DlgValue "IgnoreKeepAccKeyCheckBox",StrToLong(ExtractSet(24))
				DlgValue "OutputMsgCheckBox",StrToLong(ExtractSetBak(25))
				DlgValue "LogingMsgCheckBox",StrToLong(ExtractSetBak(26))
				DlgText "MinStrLengthTextBox",ExtractSetBak(27)
				DlgText "ContinuousTextBox",ExtractSetBak(28)
				DlgText "OtherStrTextBox",ExtractSetBak(29)
				DlgText "IncludeStrTextBox",ExtractSetBak(30)
				DlgValue "MaxStrLengthCheckBox",StrToLong(ExtractSetBak(52))
				DlgText "MaxStrLengthTextBox",ExtractSetBak(53)

				TempArray = ReSplit(ReSplit(ExtractSetBak(31),ItemJoinStr,2)(1),JoinStr)
				DlgListBoxArray "EndCharList",TempArray()
				DlgValue "EndCharList",StrToLong(ReSplit(ExtractSetBak(31),ItemJoinStr,2)(0))

				DlgValue "AndroidStrCheckBox",StrToLong(ExtractSetBak(41))
				DlgValue "OtherMatchModeList",StrToLong(ExtractSetBak(42))
				DlgValue "OtherMatchCaseCheckBox",StrToLong(ExtractSetBak(43))
				DlgValue "IgnoreOtherAccKeyCheckBox",StrToLong(ExtractSetBak(44))
				DlgText "OtherStrForWildcardTextBox",ExtractSetBak(45)
				DlgText "OtherStrForRegExpTextBox",ExtractSetBak(46)
				DlgValue "CStringCheckBox",StrToLong(ExtractSetBak(48))
				DlgValue "RangeCheckBox",StrToLong(ExtractSetBak(49))
				DlgValue "LogingFilteredStrOnlyCheckBox",ExtractSetBak(51)

				'根据地址格式的设置转换提取区域
				If DlgText("RangeTextBox") <> DlgText("RangeTextBoxBak") Then
					If Trim$(ExtractSet(50)) = "" Then
						DlgText "RangeTextBox",MsgList(41)
					ElseIf StrToLong(Selected(16)) = 1 Then
						TempArray = ReSplit(ExtractSet(50),",")
						n = 0
						For i = 0 To UBound(TempArray)
							If InStr(TempArray(i),"-") Then
								TempList = ReSplit(Trim$(TempArray(i)),"-")
								For j = 0 To 1
									TempList(j) = ValToStr(StrToLong(Trim(TempList(j))),SourceFile.FileSize,True)
								Next j
								TempArray(i) = StrListJoin(TempList,"-")
							Else
								TempArray(i) = ValToStr(StrToLong(Trim$(TempArray(i))),SourceFile.FileSize,True)
							End If
						Next i
						DlgText "RangeTextBox",StrListJoin(TempArray,",")
					Else
						DlgText "RangeTextBox",ExtractSet(50)
					End If
					'DlgText "RangeTextBoxBak",MsgList(41)
				End If

				ExtractSet(27) = ExtractSetBak(27)
				ExtractSet(28) = ExtractSetBak(28)
				ExtractSet(29) = ExtractSetBak(29)
				ExtractSet(30) = ExtractSetBak(30)
				ExtractSet(31) = ExtractSetBak(31)
				ExtractSet(32) = Str2RegExpPattern(Convert(ExtractSetBak(29)))
				ExtractSet(33) = Str2RegExpPattern(Convert(ExtractSetBak(30)))
				ExtractSet(45) = ExtractSetBak(45)
				ExtractSet(46) = ExtractSetBak(46)
				ExtractSet(47) = Convert(ExtractSetBak(45))
				If SourceFile.Magic = "" Then
					If DlgValue("ExtractModeOption") = 0 Then
						DlgValue "ExtractModeOption",1
						ExtractSet(0) = "1"
					End If
				End If
			End Select
			If DlgValue("RangeCheckBox") = 0 Then
				DlgVisible "SectionListGroup",True
				DlgVisible "SectionListBox",True
				DlgVisible "SectionListEditButton",True
				DlgVisible "RangeGroup",False
				DlgVisible "RangeTextBox",False
				DlgVisible "RangeTipButton",False
			Else
				DlgVisible "SectionListGroup",False
				DlgVisible "SectionListBox",False
				DlgVisible "SectionListEditButton",False
				DlgVisible "RangeGroup",True
				DlgVisible "RangeTextBox",True
				DlgVisible "RangeTipButton",True
			End If
			Select Case DlgValue("OtherMatchModeList")
			Case 0
				DlgVisible "OtherStrTextBox",True
				DlgVisible "OtherStrForWildcardTextBox",False
				DlgVisible "OtherStrForRegExpTextBox",False
				DlgVisible "RegExpTipButton",False
			Case 1
				DlgVisible "OtherStrTextBox",False
				DlgVisible "OtherStrForWildcardTextBox",True
				DlgVisible "OtherStrForRegExpTextBox",False
				DlgVisible "RegExpTipButton",False
			Case 2
				DlgVisible "OtherStrTextBox",False
				DlgVisible "OtherStrForWildcardTextBox",False
				DlgVisible "OtherStrForRegExpTextBox",True
				DlgVisible "RegExpTipButton",True
			End Select
		Case "FilePathButton", "StringSearchButton"
			If DlgItem$ = "FilePathButton" Then
				If PSL.SelectFile(Temp,True,MsgList(9),MsgList(8)) = False Then Exit Function
			Else
				If SearchSet(3) = "" Then SearchSet(3) = ExtractSet(31)
				Temp = StringSearch(IIf(DlgValue("ModeCheckBox") > 1,0,DlgValue("ModeCheckBox")))
				If SearchSet(3) <> ExtractSet(31) Then
					ExtractSet(31) = SearchSet(3)
					n = DlgValue("EndCharList")
					TempList = ReSplit(ReSplit(ExtractSet(31),ItemJoinStr,2)(1),JoinStr)
					DlgListBoxArray "EndCharList",TempList()
					DlgValue "EndCharList",n
					If DlgValue("EndCharList") < 0 Then DlgValue "EndCharList",0
					ExtractSet(31) = CStr$(DlgValue("EndCharList")) & ItemJoinStr & StrListJoin(TempList,JoinStr)
				End If
				If Temp = "" Then Exit Function
			End If
			If Temp = SourceFile.FilePath Then Exit Function
			If IsOpen(Temp,2,0) = True Then Exit Function

			'检测所选文件是否已经是 PSL 来源列表文件
			If Not src Is Nothing Then
				For i = 1 To src.Project.SourceLists.Count
					If Temp = src.Project.SourceLists(i).SourceFile Then
						Set src = src.Project.SourceLists(i)
						Stemp = True
						Exit For
					End If
				Next i
			ElseIf Not trn Is Nothing Then
				For i = 1 To trn.Project.SourceLists.Count
					If Temp = trn.Project.SourceLists(i).SourceFile Then
						Set src = trn.Project.SourceLists(i)
						Stemp = True
						Exit For
					End If
				Next i
			End If

			'获取来源文件属性信息并设置目标文件和 HCS 文件路径
			ReDim AllLangList(0) As LANG_PROPERTIE,UseLangList(0) As LANG_PROPERTIE
			If Stemp = True Then
				SourceFile.FilePath = src.SourceFile
				If GetFileInfo(SourceFile.FilePath,SourceFile) = False Then Exit Function
				j = src.LangID
			Else
				SourceFile.FilePath = Temp
				If GetFileInfo(SourceFile.FilePath,SourceFile) = False Then Exit Function
				j = Val("&H" & SourceFile.LanguageID)
			End If
			SourceFile.CopePage = PSL.GetDefaultCodePage(j)
			SourceFile.hcsFile.FilePath = SourceFile.FilePath & ".hcs"

			'获取要提取语言中的代码页
			Set Dic = CreateObject("Scripting.Dictionary")
			n = 0
			If SourceFile.CopePage <> 0 Then
				Dic.Add(j,0)
				AllLangList(0) = UniLangList(GetDicVal(LangIDIndexDic,j,LangIDIndexDic.Item(1033)))
				n = n + 1
			End If
			If Stemp = True Then
				ReDim Preserve AllLangList(n + src.ExtLangCount) As LANG_PROPERTIE
				For i = 1 To src.ExtLangCount
					If src.ExtLang(i) > 0 Then
						If Not Dic.Exists(src.ExtLang(i)) Then
							Dic.Add(src.ExtLang(i),n)
							If LangIDIndexDic.Exists(src.ExtLang(i)) Then
								AllLangList(n) = UniLangList(LangIDIndexDic.Item(src.ExtLang(i)))
								n = n + 1
							End If
						End If
					End If
				Next i
			ElseIf SourceFile.CopePage = 0 And (Not src Is Nothing) Then
				ReDim Preserve AllLangList(n + src.Project.SourceLists.Count) As LANG_PROPERTIE
				For i = 1 To src.Project.SourceLists.Count
					j = src.Project.SourceLists(i).LangID
					If j <> 0 Then
						If Not Dic.Exists(j) Then
							Dic.Add(j,n)
							If LangIDIndexDic.Exists(j) Then
								AllLangList(n) = UniLangList(LangIDIndexDic.Item(j))
								If j = 1033 Then UseLangList(0) = AllLangList(n)
								n = n + 1
							End If
						End If
					End If
				Next i
			ElseIf SourceFile.CopePage = 0 Then
				ReDim Preserve AllLangList(UBound(UniLangList) + 1) As LANG_PROPERTIE
				For i = 0 To UBound(UniLangList)
					With UniLangList(i)
						If Not Dic.Exists(.LangID) Then
							If .CodePage <> CP_UNKNOWN And .CodePage <> CP_UTF7 And .CodePage <> CP_UTF8 And _
								.CodePage <> CP_UNICODELITTLE And .CodePage <> CP_UNICODEBIG And _
								.CodePage <> CP_UTF32LE And .CodePage <> CP_UTF32BE Then
								AllLangList(n) = UniLangList(i)
								If .LangID = 1033 Then UseLangList(0) = AllLangList(n)
								n = n + 1
							End If
						End If
					End With
				Next i
			End If
			If n > 0 Then n = n - 1
			ReDim Preserve AllLangList(n) As LANG_PROPERTIE
			If UseLangList(0).CodePage = 0 Then UseLangList(0) = AllLangList(0)
			Dic.RemoveAll

			'检查文件类型并读取来源文件的属性
			Select Case GetFileFormat(SourceFile.FilePath,StrToLong(Selected(1)),SourceFile.FileType)
			Case "PE","NET",""
				If GetPEHeaders(SourceFile.FilePath,SourceFile,StrToLong(Selected(1))) = True Then
					'更改重复区段名称
					ChangSectionNames SourceFile,MsgList(35),MsgList(13)
					'判断是否是 Delphi 程序
					If SourceFile.LangType = 0 Then
						If Stemp = True Then
							If InStr(LCase$(src.Parser),"delphi/c++") Then
								SourceFile.LangType = DELPHI_FILE_SIGNATURE
							End If
						End If
					End If
					'根据段名预定要提取的文件区段
					ReDim UseSectionList(0) As String
					For i = 0 To SourceFile.MaxSecIndex - 1
						If Not Dic.Exists(LCase$(SourceFile.SecList(i).sName)) Then
							Dic.Add(LCase$(SourceFile.SecList(i).sName),i)
						End If
					Next i
					Select Case SourceFile.LangType
					Case DELPHI_FILE_SIGNATURE, NET_FILE_SIGNATURE
						If Dic.Exists("code") Then
							UseSectionList(0) = SourceFile.SecList(Dic.Item("code")).sName
						ElseIf Dic.Exists(".text") Then
							UseSectionList(0) = SourceFile.SecList(Dic.Item(".text")).sName
						ElseIf Dic.Exists(".code") Then
							UseSectionList(0) = SourceFile.SecList(Dic.Item(".code")).sName
						ElseIf Dic.Exists(".rdata") Then
							UseSectionList(0) = SourceFile.SecList(Dic.Item(".rdata")).sName
						Else
							UseSectionList(0) = SourceFile.SecList(0).sName
						End If
					Case Else
						If Dic.Exists(".rdata") Then
							UseSectionList(0) = SourceFile.SecList(Dic.Item(".rdata")).sName
						ElseIf Dic.Exists(".code") Then
							UseSectionList(0) = SourceFile.SecList(Dic.Item(".code")).sName
						ElseIf Dic.Exists(".text") Then
							UseSectionList(0) = SourceFile.SecList(Dic.Item(".text")).sName
						Else
							UseSectionList(0) = SourceFile.SecList(0).sName
						End If
					End Select
					'其他显示设置
					DlgEnable "SectionListEditButton",True
					DlgEnable "VAOption",True
					DlgValue "EndCharList",0
				Else
					'更改区段名称
					ChangSectionNames SourceFile,MsgList(35),MsgList(13)
					ReDim UseSectionList(0) As String
					UseSectionList(0) = SourceFile.SecList(0).sName
					DlgEnable "SectionListEditButton",False
					DlgEnable "VAOption",False
					If DlgValue("ExtractModeOption") = 0 Then DlgValue "ExtractModeOption",1
					'DlgValue "EndCharList",2
				End If
				DlgText "SectionListBox",StrListJoin(UseSectionList,ItemJoinStr)
				DlgText "SectionListWithSubBox",""
			Case "MAC"
				If GetMacHeaders(SourceFile.FilePath,SourceFile,StrToLong(Selected(1))) = True Then
					'更改重复区段名称
					ChangSectionNames SourceFile,MsgList(35),MsgList(13)
					'根据段名预定要提取的文件区段
					ReDim UseSectionList(0) As String
					For i = 0 To SourceFile.MaxSecIndex
						If Not Dic.Exists(LCase$(SourceFile.SecList(i).sName)) Then
							Dic.Add(LCase$(SourceFile.SecList(i).sName),i)
						End If
					Next i
					If Dic.Exists("__text") Then
						UseSectionList(0) = SourceFile.SecList(Dic.Item("__text")).sName
					ElseIf Dic.Exists("__data") Then
						UseSectionList(0) = SourceFile.SecList(Dic.Item("__data")).sName
					ElseIf Dic.Exists("__linkedit") Then
						UseSectionList(0) = SourceFile.SecList(Dic.Item("__linkedit")).sName
					Else
						UseSectionList(0) = SourceFile.SecList(0).sName
					End If
					'根据要提取的文件区段，获取子节默认设置
					With SourceFile
						i = Dic.Item(UseSectionList(0))
						If .SecList(i).SubSecs > 0 Then
							ReDim UseSubSecList(.SecList(i).SubSecs - 1) As String
							k = 0
							For j = 0 To .SecList(i).SubSecs - 1
								Select Case LCase$(.SecList(i).SubSecList(j).sName)
								Case "__cstring","__text"
									UseSubSecList(k) = .SecList(i).sName & "-" & .SecList(i).SubSecList(j).sName
									k = k + 1
								End Select
							Next j
							If k > 0 Then
								ReDim Preserve UseSubSecList(k - 1) As String
							Else
								ReDim UseSubSecList(0) As String
								UseSubSecList(0) = .SecList(i).sName
							End If
						Else
							ReDim UseSubSecList(0) As String
							UseSubSecList(0) = .SecList(i).sName
						End If
					End With
					Set Dic = Nothing
					'其他显示设置
					DlgEnable "SectionListEditButton",True
					DlgEnable "VAOption",True
					DlgValue "EndCharList",0
					DlgText "SectionListWithSubBox",StrListJoin(UseSubSecList,ItemJoinStr)
				Else
					'更改区段名称
					ChangSectionNames SourceFile,MsgList(35),MsgList(13)
					ReDim UseSectionList(0) As String
					UseSectionList(0) = SourceFile.SecList(0).sName
					DlgEnable "SectionListEditButton",False
					DlgEnable "VAOption",False
					If DlgValue("ExtractModeOption") = 0 Then DlgValue "ExtractModeOption",1
					DlgValue "EndCharList",2
					DlgText "SectionListWithSubBox",""
				End If
				DlgText "SectionListBox",StrListJoin(UseSectionList,ItemJoinStr)
			End Select
			Set Dic = Nothing
			TargetFile = SourceFile

			'根据文件类型确定可用项
			Select Case SourceFile.Magic
			Case ""
				DlgVisible "SectionListWithSubBox",False
				DlgVisible "SectionListBox",True
				DlgEnable "ReferenceCheckBox",False
				DlgEnable "ReferenceTypeList",True
				DlgValue "ReferenceCheckBox",0
				DlgValue "ReferenceTypeList",0
				DlgEnable "VAOption",False
				DlgValue "ExtractModeOption",1
				ExtractSet(0) = "1"
				ExtractSet(11) = "0"
			Case "PE32","PE64","NET32","NET64"
				DlgVisible "SectionListWithSubBox",False
				DlgVisible "SectionListBox",True
				DlgEnable "ReferenceCheckBox",True
				DlgEnable "ReferenceTypeList",False
				DlgValue "ReferenceTypeList",0
				DlgEnable "VAOption",True
			Case "MAC32","MAC64"
				DlgVisible "SectionListWithSubBox",True
				DlgVisible "SectionListBox",False
				DlgEnable "ReferenceCheckBox",True
				DlgEnable "ReferenceTypeList",False
				DlgValue "ReferenceTypeList",0
				DlgEnable "VAOption",True
			End Select
			ReDim UseRefTypeList(1) As REF_TYPE

			'重置过滤显示项目内容
			For i = 1 To UBound(FilterStrSet) - 1
				FilterStrSet(i) = Left$(FilterStrSet(i),2)
			Next i
			'自动选择时重新获取字串过滤列表的设置
			If ExtractSet(34) = "1" Or ExtractSet(39) = "1" Then GetSettings("FilterStrDic")
			'自动选择时重新获取字串保留列表的设置
			If ExtractSet(36) = "1" Or ExtractSet(40) = "1" Then GetSettings("ReserveStrDic")
			'显示数据
			Temp = SourceFile.FilePath
			If Len(Temp) > 70 Then
				Temp = Left$(Temp,InStr(Temp,"\")) & "..." & Right(Temp,70 - Len(Left$(Temp,InStr(Temp,"\"))))
			End If
			DlgText "FilePathBox",Temp
			DlgText "FilePathBoxBak",SourceFile.FilePath
			DlgText "LangListBox",StrListJoin(GetLangStrList(UseLangList,0),ItemJoinStr)
			DlgText "RangeTextBox",MsgList(41)
			'DlgText "RangeTextBoxBak",MsgList(41)
			If SourceFile.Magic = "" Then
				DlgEnable "ReferenceCheckBox",False
				DlgValue "ReferenceCheckBox",0
			Else
				DlgEnable "ReferenceCheckBox",True
				DlgValue "ReferenceCheckBox",StrToLong(ExtractSet(11))
			End If
			If SourceFile.LangType = DELPHI_FILE_SIGNATURE Then
				DlgValue "PascalCheckBox",1
				DlgValue "PascalDWordCheckBox",1
				DlgValue "PascalAnsiCheckBox",1
				DlgValue "PascalShortCheckBox",1
			Else
				DlgValue "PascalCheckBox",0
				DlgValue "PascalDWordCheckBox",0
				DlgValue "PascalAnsiCheckBox",0
				DlgValue "PascalShortCheckBox",0
			End If
			If SourceFile.LangType = NET_FILE_SIGNATURE Then
				DlgValue "NetStrCheckBox",1
				DlgValue "ANSICheckBox",0
				DlgValue "UnicodeCheckBox",1
				DlgValue "UTF8CheckBox",0
				DlgValue "CStringCheckBox",0
				ExtractSet(4) = "0100000"
				DlgText "CPListBox",ConvertEncodeLevel(ExtractSet(4),MsgList(24),ItemJoinStr)
			Else
				DlgValue "NetStrCheckBox",0
			End If
			'仅一种英语的话使用正则表达式
			If DlgValue("OtherMatchModeList") <> 2 Then
				If DlgText("OtherStrForRegExpTextBox") <> "" Then
					If UBound(UseLangList) = 0 Then
						If UseLangList(0).LangID = 1033 Then
							DlgValue "OtherMatchModeList",2
							DlgVisible "OtherStrTextBox",False
							DlgVisible "OtherStrForWildcardTextBox",False
							DlgVisible "OtherStrForRegExpTextBox",True
							DlgVisible "RegExpTipButton",True
						End If
					End If
				End If
			End If
		Case "CustomTypeCheckBox"
			If CheckStrTypeArray(StrTypeList) = False Then
				DlgItem$ = "SetButton"
				Stemp = True
			ElseIf DlgValue("CustomTypeCheckBox") = 1 Then
				TempList = GetStrTypeNameList(StrTypeList)
				TempArray = GetStrTypeNameList(UseStrTypeList)
				If EditList(TempList,TempArray) = True Then
					If CheckArray(TempArray) = True Then
						Set Dic = CreateObject("Scripting.Dictionary")
						For i = 0 To UBound(StrTypeList)
							If Not Dic.Exists(StrTypeList(i).sName) Then
								Dic.Add(StrTypeList(i).sName,i)
							End If
						Next i
						ReDim UseStrTypeList(UBound(TempArray)) As STRING_TYPE
						For i = 0 To UBound(TempArray)
							If Dic.Exists(TempArray(i)) Then
								UseStrTypeList(i) = StrTypeList(Dic.Item(TempArray(i)))
							End If
						Next i
						Set Dic = Nothing
					Else
						ReDim UseStrTypeList(0) As STRING_TYPE
						DlgValue "CustomTypeCheckBox",0
						Exit Function
					End If
				ElseIf CheckArray(TempArray) = False Then
					DlgValue "CustomTypeCheckBox",0
					Exit Function
				End If
			End If
		Case "SectionListEditButton"
			If InStr(SourceFile.Magic,"MAC") Then
				TempArray = getSectionList(SourceFile.SecList,2)
				If EditList(TempArray,UseSubSecList) = False Then Exit Function
				DlgText "SectionListWithSubBox",StrListJoin(UseSubSecList,ItemJoinStr)
				Set Dic = CreateObject("Scripting.Dictionary")
				ReDim UseSectionList(UBound(UseSubSecList)) As String
				n = 0
				For i = 0 To UBound(UseSubSecList)
					If Not Dic.Exists(ReSplit(UseSubSecList(i),"-")(0)) Then
						Dic.Add(ReSplit(UseSubSecList(i),"-")(0),"")
						UseSectionList(n) = ReSplit(UseSubSecList(i),"-")(0)
						n = n + 1
					End If
				Next i
				If n > 0 Then n = n - 1
				ReDim Preserve UseSectionList(n) As String
				Set Dic = Nothing
			ElseIf EditList(getSectionList(SourceFile.SecList,0),UseSectionList) = False Then
				Exit Function
			End If
			DlgText "SectionListBox",StrListJoin(UseSectionList,ItemJoinStr)
			Exit Function
		Case "LangLevelButton"
			TempArray = GetLangStrList(UseLangList,0)
			If SetLevel(TempArray,0,MsgList(21)) = True Then
				DlgText "LangListBox",StrListJoin(TempArray,ItemJoinStr)
				'仅生成选定代码页列表
				Set Dic = CreateObject("Scripting.Dictionary")
				ReDim UseLangList(UBound(TempArray)) As LANG_PROPERTIE
				For i = 0 To UBound(AllLangList)
					If Not Dic.Exists(AllLangList(i).LangName) Then
						Dic.Add(AllLangList(i).LangName,i)
					End If
				Next i
				For i = 0 To UBound(TempArray)
					If Dic.Exists(TempArray(i)) Then
						UseLangList(n) = AllLangList(Dic.Item(TempArray(i)))
						n = n + 1
					End If
				Next i
				If n > 0 Then n = n - 1
				ReDim Preserve UseLangList(n) As LANG_PROPERTIE
				Set Dic = Nothing
			End If
		Case "LangListEditButton"
			'仅生成选定代码页列表
			Set Dic = CreateObject("Scripting.Dictionary")
			For i = LBound(AllLangList) To UBound(AllLangList)
				If Not Dic.Exists(AllLangList(i).LangName) Then
					Dic.Add(AllLangList(i).LangName,i)
				End If
			Next i
			TempList = GetLangStrList(AllLangList,0)
			TempArray = GetLangStrList(UseLangList,0)
			Do
				If EditList(TempList,TempArray) = False Then Exit Function
				n = 0
				For i = LBound(TempArray) To UBound(TempArray)
					If Dic.Exists(TempArray(i)) Then
						If AllLangList(Dic.Item(TempArray(i))).LangID = 1033 Then
							Stemp = True
						End If
						n = n + 1
					End If
				Next i
				If n < 2 Or Stemp = False Then Exit Do
				If MsgBox(MsgList(5),vbYesNo+vbInformation,MsgList(4)) = vbYes Then Exit Do
			Loop
			DlgText "LangListBox",StrListJoin(TempArray,ItemJoinStr)
			If DlgText("LangListBox") <> "" Then
				ReDim UseLangList(UBound(TempArray)) As LANG_PROPERTIE
				n = 0
				For i = LBound(TempArray) To UBound(TempArray)
					If Dic.Exists(TempArray(i)) Then
						UseLangList(n) = AllLangList(Dic.Item(TempArray(i)))
						n = n + 1
					End If
				Next i
				If n > 0 Then n = n - 1
				ReDim Preserve UseLangList(n) As LANG_PROPERTIE
			Else
				ReDim UseLangList(0) As LANG_PROPERTIE
			End If
			Set Dic = Nothing
			DlgValue "OtherMatchModeList",IIf(UBound(UseLangList) = 0 And UseLangList(0).LangID = 1033,2,0)
			Select Case DlgValue("OtherMatchModeList")
			Case 0
				DlgVisible "OtherStrTextBox",True
				DlgVisible "OtherStrForWildcardTextBox",False
				DlgVisible "OtherStrForRegExpTextBox",False
				DlgVisible "RegExpTipButton",False
			Case 1
				DlgVisible "OtherStrTextBox",False
				DlgVisible "OtherStrForWildcardTextBox",True
				DlgVisible "OtherStrForRegExpTextBox",False
				DlgVisible "RegExpTipButton",False
			Case 2
				DlgVisible "OtherStrTextBox",False
				DlgVisible "OtherStrForWildcardTextBox",False
				DlgVisible "OtherStrForRegExpTextBox",True
				DlgVisible "RegExpTipButton",True
			End Select
		Case "ANSICheckBox","UnicodeCheckBox","UTF8CheckBox"
			Select Case DlgItem$
			Case "ANSICheckBox"
				i = 1
			Case "UnicodeCheckBox"
				i = 2
			Case "UTF8CheckBox"
				i = 3
			End Select
			If DlgValue(DlgItem$) = 1 Then
				If Mid$(ExtractSet(4),i,1) = "0" Then
					ExtractSet(4) = AddEncodeLevel(ExtractSet(4),i)
				End If
			Else
				If Mid$(ExtractSet(4),i,1) <> "0" Then
					ExtractSet(4) = DelEncodeLevel(ExtractSet(4),i)
				End If
			End If
			DlgText "CPListBox",ConvertEncodeLevel(ExtractSet(4),MsgList(24),ItemJoinStr)
		Case "CPLevelButton"
			TempArray = ReSplit(DlgText("CPListBox"),ItemJoinStr)
			If SetLevel(TempArray,0,MsgList(50)) = True Then
				DlgText "CPListBox",StrListJoin(TempArray,ItemJoinStr)
				Set Dic = CreateObject("Scripting.Dictionary")
				For i = 0 To UBound(TempArray)
					If Not Dic.Exists(TempArray(i)) Then
						Dic.Add(TempArray(i),i + 1)
					End If
				Next i
				TempArray = ReSplit(MsgList(24),";")
				For i = 0 To UBound(TempArray)
					If Dic.Exists(TempArray(i)) Then
						Mid$(ExtractSet(4),i + 1,1) = CStr$(Dic.Item(TempArray(i)))
					Else
						Mid$(ExtractSet(4),i + 1,1) = "0"
					End If
				Next i
				Set Dic = Nothing
			End If
			Exit Function
		Case "CPListEditButton"
			TempList = ReSplit(MsgList(24),";")
			TempArray = ReSplit(DlgText("CPListBox"),ItemJoinStr)
			If EditList(TempList,TempArray) = False Then Exit Function
			If CheckArray(TempArray) = True Then
				Set Dic = CreateObject("Scripting.Dictionary")
				For i = 0 To UBound(TempArray)
					If Not Dic.Exists(TempArray(i)) Then
						Dic.Add(TempArray(i),i)
					End If
				Next i
				TempArray = ReSplit(MsgList(24),";")
				For i = 0 To UBound(TempArray)
					If Dic.Exists(TempArray(i)) Then
						Mid$(ExtractSet(4),i + 1,1) = "1"
					Else
						Mid$(ExtractSet(4),i + 1,1) = "0"
					End If
				Next i
				Set Dic = Nothing
				ExtractSet(4) = GetEncodeLevel(ExtractSet(4),"7453621","2100000")
			Else
				ExtractSet(4) = "0000000"
			End If
			DlgText "CPListBox",ConvertEncodeLevel(ExtractSet(4),MsgList(24),ItemJoinStr)
			DlgValue "ANSICheckBox",IIf(StrToLong(Mid$(ExtractSet(4),1,1)) = 0,0,1)
			DlgValue "UnicodeCheckBox",IIf(StrToLong(Mid$(ExtractSet(4),2,1)) = 0,0,1)
			DlgValue "UTF8CheckBox",IIf(StrToLong(Mid$(ExtractSet(4),3,1)) = 0,0,1)
		Case "PascalCheckBox","PascalDWordCheckBox","PascalAnsiCheckBox","PascalShortCheckBox","NetStrCheckBox","AndroidStrCheckBox"
			Select Case DlgItem$
			Case "PascalCheckBox","PascalDWordCheckBox","NetStrCheckBox"
				If DlgValue(DlgItem$) = 1 Then
					If Mid$(ExtractSet(4),2,1) = "0" Then
						ExtractSet(4) = AddEncodeLevel(ExtractSet(4),2)
					End If
					If DlgValue("EndCharList") > 0 Then DlgValue "EndCharList",0
				End If
			Case "PascalAnsiCheckBox","PascalShortCheckBox"
				If DlgValue(DlgItem$) = 1 Then
					If Mid$(ExtractSet(4),1,1) = "0" Then
						ExtractSet(4) = AddEncodeLevel(ExtractSet(4),1)
					End If
					If DlgValue("EndCharList") > 0 Then DlgValue "EndCharList",0
				End If
			Case "AndroidStrCheckBox"
				If DlgValue(DlgItem$) = 1 Then
					If Mid$(ExtractSet(4),3,1) = "0" Then
						ExtractSet(4) = AddEncodeLevel(ExtractSet(4),3)
					ElseIf Mid$(ExtractSet(4),2,1) = "0" Then
						ExtractSet(4) = AddEncodeLevel(ExtractSet(4),2)
					End If
					If DlgValue("EndCharList") > 0 Then DlgValue "EndCharList",0
				End If
			End Select
			DlgText "CPListBox",ConvertEncodeLevel(ExtractSet(4),MsgList(24),ItemJoinStr)
			DlgValue "ANSICheckBox",IIf(StrToLong(Mid$(ExtractSet(4),1,1)) = 0,0,1)
			DlgValue "UnicodeCheckBox",IIf(StrToLong(Mid$(ExtractSet(4),2,1)) = 0,0,1)
			DlgValue "UTF8CheckBox",IIf(StrToLong(Mid$(ExtractSet(4),3,1)) = 0,0,1)
		Case "ReferenceTypeList"
			'确定非 PE 文件是否获取引用
			i = DlgValue("ReferenceTypeList")
			If i < 0 Then Exit Function
			If i = 0 Then
				Select Case SourceFile.Magic
				Case "NotPE32","NotPE64",""
					SourceFile.Magic = ""
					TargetFile.Magic = ""
				Case Else
					Exit Function
				End Select
				UseRefTypeList(0).sName = ""
				UseRefTypeList(0).Algorithm = ""
				UseRefTypeList(0).ByteLength = 0
				UseRefTypeList(0).ByteOrder= 0
				UseRefTypeList(0).FileMagic = ""
				UseRefTypeList(0).PrefixByte = ""
				UseRefTypeList(0).PrefixLength = 0
				UseRefTypeList(0).StrAddAlgorithm = ""
				UseRefTypeList(0).Template = ""
			Else
				Select Case SourceFile.Magic
				Case "NotPE32","NotPE64",""
					SourceFile.Magic = RefTypeList(i - 1).FileMagic
					TargetFile.Magic = SourceFile.Magic
					UseRefTypeList(0) = RefTypeList(i - 1)
					UseRefTypeList(0).Algorithm = LCase(UseRefTypeList(0).Algorithm)
					UseRefTypeList(0).StrAddAlgorithm = LCase(UseRefTypeList(0).StrAddAlgorithm)
				Case Else
					Exit Function
				End Select
			End If
			'根据文件类型确定可用项
			Select Case SourceFile.Magic
			Case ""
				DlgEnable "ReferenceCheckBox",False
				DlgValue "ReferenceCheckBox",0
				ExtractSet(11) = "0"
				DlgEnable "VAOption",False
				DlgValue "ExtractModeOption",1
				ExtractSet(0) = "1"
			Case "NotPE32","NotPE64"
				DlgEnable "ReferenceCheckBox",True
				DlgEnable "VAOption",True
			End Select
			Exit Function
		Case "EndCharButton"
			TempArray = ReSplit(MsgList(26),ItemJoinStr)
			i = ShowPopupMenu(TempArray,vbPopupUseRightButton)
			If i < 0 Then Exit Function
			TempList = ReSplit(ReSplit(ExtractSet(31),ItemJoinStr,2)(1),JoinStr)
			If i = 0 Then
				Do
					Temp = InputBox(MsgList(28),MsgList(27),Temp)
					If Temp = "" Then Exit Function
					If InStr(Temp,"(") = 0 Or InStr(Temp,")") = 0 Then
						MsgBox MsgList(29),vbOkOnly+vbInformation,MsgList(3)
					ElseIf StrEndChar2Pattern(Temp,1)(0) = "" Then
						MsgBox MsgList(29),vbOkOnly+vbInformation,MsgList(3)
					Else
						TempArray(0) = Mid$(Temp,InStr(Temp,"("))
						TempArray(0) = Left$(TempArray(0),InStrRev(TempArray(0),")"))
						If InStr(ExtractSet(31),TempArray(0)) Then
							MsgBox MsgList(30),vbOkOnly+vbInformation,MsgList(3)
						ElseIf CheckRegExp(RegExp,TempArray(0)) = False Then
							MsgBox MsgList(31),vbOkOnly+vbInformation,MsgList(10)
						Else
							Exit Do
						End If
					End If
				Loop
				n = UBound(TempList) + 1
				ReDim Preserve TempList(n) As String
				TempList(n) = Temp
			ElseIf i = 1 Then
				n = DlgValue("EndCharList")
				If n < 0 Then Exit Function
				If n <= UBound(ReSplit(EndCharOfString,ValJoinStr)) Then
					MsgBox MsgList(32),vbOkOnly+vbInformation,MsgList(3)
					Exit Function
				End If
				Do
					Temp = EditSet(TempList,n)
					If Temp = "" Then Exit Function
					If InStr(Temp,"(") = 0 Or InStr(Temp,")") = 0 Then
						MsgBox MsgList(29),vbOkOnly+vbInformation,MsgList(3)
					ElseIf StrEndChar2Pattern(Temp,1)(0) = "" Then
						MsgBox MsgList(29),vbOkOnly+vbInformation,MsgList(3)
					Else
						TempArray(0) = Mid$(Temp,InStr(Temp,"("))
						TempArray(0) = Left$(TempArray(0),InStrRev(TempArray(0),")"))
						If InStr(Replace$(ExtractSet(31),TempList(n),""),TempArray(0)) Then
							MsgBox MsgList(30),vbOkOnly+vbInformation,MsgList(3)
						ElseIf CheckRegExp(RegExp,TempArray(0)) = False Then
							MsgBox MsgList(31),vbOkOnly+vbInformation,MsgList(10)
						Else
							Exit Do
						End If
					End If
				Loop
				TempList(n) = Temp
			ElseIf i = 2 Then
				n = DlgValue("EndCharList")
				If n < 0 Then Exit Function
				If n <= UBound(ReSplit(EndCharOfString,ValJoinStr)) Then
					MsgBox MsgList(32),vbOkOnly+vbInformation,MsgList(3)
					Exit Function
				ElseIf MsgBox(MsgList(33),vbYesNo+vbInformation,MsgList(4)) = vbNo Then
					Exit Function
				End If
				Call DelArray(TempList,n)
				n = n - 1
			End If
			ExtractSet(31) = CStr$(n) & ItemJoinStr & StrListJoin(TempList,JoinStr)
			SaveSetting(AppName,"GetString","EndCharOfString",ConvertStrEndCharSet(MergeStrEndCharSet(ExtractSet(31)),True))
			DlgListBoxArray "EndCharList",TempList()
			DlgValue "EndCharList",n
		Case "OutputMsgCheckBox", "LogingMsgCheckBox","LogingFilteredStrOnlyCheckBox"
			If DlgItem$ = "OutputMsgCheckBox" Then
				If DlgValue("OutputMsgCheckBox") = 1 Then
					DlgValue "LogingMsgCheckBox",0
					DlgValue "LogingFilteredStrOnlyCheckBox",0
				End If
			ElseIf DlgItem$ = "LogingMsgCheckBox" Then
				If DlgValue("LogingMsgCheckBox") = 1 Then
					DlgValue "OutputMsgCheckBox",0
					DlgValue "LogingFilteredStrOnlyCheckBox",0
				End If
			ElseIf DlgValue("LogingFilteredStrOnlyCheckBox") = 1 Then
				DlgValue "LogingMsgCheckBox",0
				DlgValue "OutputMsgCheckBox",0
			End If
		Case "OtherMatchModeList"
			Select Case DlgValue("OtherMatchModeList")
			Case 0
				DlgVisible "OtherStrTextBox",True
				DlgVisible "OtherStrForWildcardTextBox",False
				DlgVisible "OtherStrForRegExpTextBox",False
				DlgVisible "RegExpTipButton",False
			Case 1
				DlgVisible "OtherStrTextBox",False
				DlgVisible "OtherStrForWildcardTextBox",True
				DlgVisible "OtherStrForRegExpTextBox",False
				DlgVisible "RegExpTipButton",False
			Case 2
				DlgVisible "OtherStrTextBox",False
				DlgVisible "OtherStrForWildcardTextBox",False
				DlgVisible "OtherStrForRegExpTextBox",True
				DlgVisible "RegExpTipButton",True
			End Select
		Case "RegExpTipButton"
			If DlgValue("OtherMatchModeList") < 2 Then Exit Function
			If getMsgList(UIDataList,MsgList,"RegExpRuleTip",1) = False Then Exit Function
			i = ShowPopupMenu(MsgList,vbPopupUseRightButton)
			If i < 0 Then Exit Function
			If i = UBound(MsgList) Then
				If StrToLong(Selected(30)) = 1 Then
					If OpenCHM(CLng(DlgText("SuppValueBox")),1022,Selected(0),OSLanguage,UIFileList) = True Then Exit Function
				End If
				Call Help("RegExpRuleHelp")
				Exit Function
			End If
			If DlgText("OtherStrForRegExpTextBox") = "" Then
				DlgText "OtherStrForRegExpTextBox",Mid$(MsgList(i),InStrRev(MsgList(i),vbTab) + 1)
			Else
				DlgFocus("OtherStrForRegExpTextBox")  '设置焦点到文本框
				DlgText "OtherStrForRegExpTextBox",InsertStr(GetFocus(),DlgText("OtherStrForRegExpTextBox"), _
						Mid$(MsgList(i),InStrRev(MsgList(i),vbTab) + 1))
			End If
			ExtractSet(46) = DlgText("OtherStrForRegExpTextBox")
			DlgEnable "SaveButton",ArrayComp(ExtractSet,ExtractSetBak,"0-4,11-31,42-46,49-53")
			Exit Function
		Case "FavoriteButton"
			If getMsgList(UIDataList,MsgList,"EditFavority",1) = False Then Exit Function
			TempList = ReSplit(MsgList(25),ItemJoinStr)
			If UBound(TempList) < 7 Then Exit Function
			Select Case DlgValue("OtherMatchModeList")
			Case 0
				ReDim Preserve TempList(3) As String
				TempList(3) = ""
				Temp = "GetStrDlgGeneral"
				DlgItem$ = "OtherStrTextBox"
			Case 1
				ReDim Preserve TempList(3) As String
				TempList(2) = ""
				TempList(3) = ""
				Temp = "GetStrDlgWildcard"
				DlgItem$ = "OtherStrForWildcardTextBox"
			Case 2
				Temp = "GetStrDlgRegExp"
				DlgItem$ = "OtherStrForRegExpTextBox"
				TempList(4) = TempList(4) & " - " & NoVowelsRegExp
				TempList(5) = TempList(5) & " - " & FilePathRegExp
				TempList(6) = TempList(6) & " - " & RegKeyRegExp
				TempList(7) = TempList(7) & " - " & WebSiteRegExp
			End Select
			GetHistory(TempList,"Favorites",Temp," - ")
			n = 4
			For i = 4 To UBound(TempList)
				If CheckStrRegExp(TempList(i),"^\(\(.+?\)\)\|\(\(.+?\)\)$",0,5) = False Then
					TempList(n) = TempList(i)
					n = n + 1
				End If
			Next i
			If n > 0 Then n = n - 1
			ReDim Preserve TempList(n) As String
			i = ShowPopupMenu(TempList,vbPopupUseRightButton)
			Select Case i
			Case Is < 0
				Exit Function
			Case 0
				If DlgText(DlgItem$) = "" Then
					MsgBox MsgList(26),vbOkOnly+vbInformation,MsgList(19)
					Exit Function
				End If
				Select Case DlgItem$
				Case "OtherStrTextBox"
					If DlgText(DlgItem$) = SkipStr Then
						MsgBox MsgList(30),vbOkOnly+vbInformation,MsgList(19)
						Exit Function
					ElseIf FilterStr("CheckRegExp",DlgText(DlgItem$),1) = -2 Then
						MsgBox MsgList(32),vbOkOnly+vbInformation,MsgList(10)
						Exit Function
					End If
				Case "OtherStrForRegExpTextBox"
					If CheckRegExp(RegExp,DlgText(DlgItem$)) = False Then
						MsgBox MsgList(27),vbOkOnly+vbInformation,MsgList(19)
						Exit Function
					End If
					If CheckStrRegExp(DlgText(DlgItem$),"^\(\(.+?\)\)\|\(\(.+?\)\)$",0,5) Then
						MsgBox MsgList(29),vbOkOnly+vbInformation,MsgList(19)
						Exit Function
					End If
					For i = 4 To UBound(TempList)
						If InStr(TempList(i)," - ") Then
							If ReSplit(TempList(i)," - ",2)(1) = DlgText(DlgItem$) Then
								If i = 4 Then
									MsgBox MsgList(30),vbOkOnly+vbInformation,MsgList(19)
								Else
									MsgBox MsgList(28),vbOkOnly+vbInformation,MsgList(19)
								End If
								Exit Function
							End If
						End If
					Next i
				End Select
				GetHistory(TempList,"Favorites",Temp)
				For i = 0 To UBound(TempList)
					If InStr(TempList(i)," - ") Then
						If ReSplit(TempList(i)," - ",2)(1) = DlgText(DlgItem$) Then
							MsgBox MsgList(28),vbOkOnly+vbInformation,MsgList(19)
							Exit Function
						End If
					End If
				Next i
				ReDim TempArray(0) As String
				Do
					TempArray(0) = Trim$(InputBox(MsgList(15),MsgList(14),TempArray(0)))
					If TempArray(0) = "" Then Exit Function
					If InStr(TempArray(0)," - ") = 0 Then Exit Do
					MsgBox MsgList(20),vbOkOnly+vbInformation,MsgList(19)
				Loop
				i = IIf(CheckArray(TempList) = False,0,UBound(TempList) + 1)
				If InsertArray(TempList,TempArray(0) & " - " & DlgText(DlgItem$),i,True) = True Then
					WriteHistory(TempList,"Favorites",Temp,True)
				End If
			Case 1
				GetHistory(TempList,"Favorites",Temp)
				If EditFavority(TempList,DlgValue("OtherMatchModeList")) = True Then
					WriteHistory(TempList,"Favorites",Temp,True)
				End If
			Case 2
				Select Case DlgItem$
				Case "OtherStrTextBox"
					DlgText DlgItem$,SkipStr
					ExtractSet(29) = SkipStr
					ExtractSet(32) = Str2RegExpPattern(Convert(ExtractSet(29)))
				Case "OtherStrForWildcardTextBox"
					DlgText DlgItem$,""
					ExtractSet(45) = ""
					ExtractSet(47) = ""
				Case "OtherStrForRegExpTextBox"
					DlgText DlgItem$,NoVowelsRegExp
					ExtractSet(46) = NoVowelsRegExp
				End Select
				DlgEnable "SaveButton",ArrayComp(ExtractSet,ExtractSetBak,"0-4,11-31,42-46,49-53")
			Case 3
				If UBound(TempList) < 4 Then Exit Function
				Set Dic = CreateObject("Scripting.Dictionary")
				If CheckStrRegExp(ExtractSet(46),"^\(\(.+?\)\)\|\(\(.+?\)\)$",0,5) Then
					TempArray = ReSplit(ExtractSet(46),"))|((",-1)
					i = UBound(TempArray)
					TempArray(0) = Mid$(TempArray(0),3)
					TempArray(i) = Left$(TempArray(i),Len(TempArray(i)) - 2)
				Else
					ReDim TempArray(0) As String
					TempArray(0) = ExtractSet(46)
				End If
				For i = 0 To UBound(TempArray)
					If Not Dic.Exists(TempArray(i)) Then Dic.Add(TempArray(i),i)
				Next i
				ReDim TempArray(UBound(TempList)) As String
				n = 0
				For i = 4 To UBound(TempList)
					MsgList = ReSplit(TempList(i)," - ",2)
					If Dic.Exists(MsgList(1)) Then
						TempArray(n) = MsgList(0)
						n = n + 1
					End If
					If Not Dic.Exists(MsgList(0)) Then Dic.Add(MsgList(0),MsgList(1))
					TempList(i - 4) = MsgList(0)
				Next i
				If n > 0 Then n = n - 1
				ReDim Preserve TempArray(n) As String,TempList(i - 5) As String
				If EditList(TempList,TempArray) = False Then Exit Function
				For i = 0 To UBound(TempArray)
					If Dic.Exists(TempArray(i)) Then TempArray(i) = Dic.Item(TempArray(i))
				Next i
				Set Dic = Nothing
				If i = 1 Then
					DlgText DlgItem$,TempArray(0)
				Else
					DlgText DlgItem$,"((" & StrListJoin(TempArray,"))|((") & "))"
				End If
				ExtractSet(46) = DlgText(DlgItem$)
				DlgEnable "SaveButton",ArrayComp(ExtractSet,ExtractSetBak,"0-4,11-31,42-46,49-53")
			Case Else
				TempList = ReSplit(TempList(i)," - ",2)
				If UBound(TempList) < 1 Then Exit Function
				If DlgText(DlgItem$) = TempList(1) Then Exit Function
				DlgText DlgItem$,TempList(1)
				Select Case DlgItem$
				Case "OtherStrTextBox"
					ExtractSet(29) = TempList(1)
					ExtractSet(32) = Str2RegExpPattern(Convert(ExtractSet(29)))
				Case "OtherStrForWildcardTextBox"
					ExtractSet(45) = TempList(1)
					ExtractSet(47) = Convert(ExtractSet(45))
				Case "OtherStrForRegExpTextBox"
					ExtractSet(46) = TempList(1)
				End Select
				DlgEnable "SaveButton",ArrayComp(ExtractSet,ExtractSetBak,"0-4,11-31,42-46,49-53")
			End Select
			Exit Function
		End Select

		If DlgItem$ = "SetButton" Then
			If DlgItem$ = "SetButton" Then
				TempList = Selected
				ReDim tmpLFList(0) As LOG_FONT
				tmpLFList(0) = LFList(0)
				Call Settings(0)
			End If
			If Selected(0) <> TempList(0) Then
				'重置提取对话框字串
				If getMsgList(UIDataList,MsgList,"ExtractString",1) = True Then
   					DlgText -1,IIf(DlgValue("ModeCheckBox") = 0,MsgList(0),MsgList(1))
					DlgText "FileText",MsgList(2)
					DlgText "FilePathButton",MsgList(3)
					DlgText "StringSearchButton",MsgList(4)

					DlgText "ExtractModeGroup",MsgList(5)
					DlgText "VAOption",MsgList(6)
					DlgText "NotVAOption",MsgList(7)

					DlgText "SectionListGroup",MsgList(9)
					DlgText "RangeGroup",MsgList(10)
					DlgText "SectionListEditButton",MsgList(11)
					DlgText "RangeTipButton",MsgList(12)
					DlgText "RangeCheckBox",IIf(StrToLong(Selected(16)) = 0,MsgList(13),MsgList(14))

					DlgText "LangListEditButton",MsgList(16)

					DlgText "CPListGroup",MsgList(17)
					DlgText "ANSICheckBox",ReSplit(MsgList(18),ItemJoinStr)(0)
					DlgText "UnicodeCheckBox",ReSplit(MsgList(18),ItemJoinStr)(1)
					DlgText "UTF8CheckBox",ReSplit(MsgList(18),ItemJoinStr)(2)
					DlgText "CPListEditButton",MsgList(19)

					DlgText "CStringCheckBox",MsgList(20)
					DlgText "PascalCheckBox",MsgList(21)
					DlgText "PascalDWordCheckBox",MsgList(22)
					DlgText "PascalAnsiCheckBox",MsgList(23)
					DlgText "PascalShortCheckBox",MsgList(24)
					DlgText "NetStrCheckBox",MsgList(25)
					DlgText "AndroidStrCheckBox",MsgList(26)
					DlgText "CustomTypeCheckBox",IIf(CheckStrTypeArray(StrTypeList) = False,MsgList(27),MsgList(28))

					DlgText "RefAndLengthGroup",MsgList(29)
					DlgText "ReferenceTypeText",MsgList(8)
					DlgText "ReferenceCheckBox",MsgList(30)
					DlgText "MinStrLengthText",MsgList(31)
					DlgText "EndCharText",MsgList(32)
					DlgText "EndCharButton",MsgList(12)

					DlgText "FilterGroup",MsgList(33)
					DlgText "NullStrCheckBox",MsgList(34)
					DlgText "ControlStrCheckBox",MsgList(35)
					DlgText "AllSymbolCheckBox",MsgList(36)
					DlgText "AllUCaseCheckBox",MsgList(37)
					DlgText "AllLCaseCheckBox",MsgList(38)
					DlgText "AllULCaseCheckBox",MsgList(39)
					DlgText "ContinuousCheckBox",MsgList(40)
					DlgText "MaxStrLengthCheckBox",MsgList(15)

					DlgText "OtherStrCheckBox",MsgList(41)
					TempArray = ReSplit(MsgList(42),ItemJoinStr)
					i = DlgValue("OtherMatchModeList")
					DlgListBoxArray "OtherMatchModeList",TempArray()
					DlgValue "OtherMatchModeList",i
					DlgText "RegExpTipButton",MsgList(12)
					DlgText "FavoriteButton",MsgList(3)
					DlgText "OtherMatchCaseCheckBox",MsgList(43)
					DlgText "IgnoreOtherAccKeyCheckBox",MsgList(44)
					DlgText "IncludeStrCheckBox",MsgList(45)

					DlgText "FilterStrCheckBox",MsgList(46)
					DlgText "IgnoreFilterAccKeyCheckBox",MsgList(44)
					DlgText "FilterStrButton",MsgList(47)
					DlgText "KeepStrCheckBox",MsgList(48)
					DlgText "IgnoreKeepAccKeyCheckBox",MsgList(44)
					DlgText "KeepStrButton",MsgList(49)

					DlgText "MassageGroup",MsgList(50)
					DlgText "OutputMsgCheckBox",MsgList(51)
					DlgText "LogingMsgCheckBox",MsgList(52)
					DlgText "LogingFilteredStrOnlyCheckBox",MsgList(53)

					DlgText "HelpButton",MsgList(54)
					DlgText "SetButton",MsgList(55)
					DlgText "ResetButton",MsgList(56)
					DlgText "SaveButton",MsgList(57)
					DlgText "GetStrButton",MsgList(58)
				End If
				'重置当前对话框字串
				If getMsgList(UIDataList,MsgList,"ExtractStringDlgFunc",1) = True Then
					Select Case SourceFile.Magic
					Case "NotPE32","NotPE64",""
						UseSectionList(0) = MsgList(13)
						SourceFile.SecList(0).sName = MsgList(13)
						TargetFile.SecList(0).sName = MsgList(13)
						DlgText "SectionListBox",MsgList(13)
					Case Else
						If SourceFile.SecList(SourceFile.MaxSecIndex).lSizeOfRawData > 0 Then
							DlgText "SectionListBox",Replace$(DlgText("SectionListBox"),SourceFile.SecList(SourceFile.MaxSecIndex).sName,MsgList(35))
							SourceFile.SecList(SourceFile.MaxSecIndex).sName = MsgList(35)
							TargetFile.SecList(SourceFile.MaxSecIndex).sName = MsgList(35)
							UseSectionList = ReSplit(DlgText("SectionListBox"),ItemJoinStr)
						End If
					End Select
					If DlgText("RangeTextBox") = DlgText("RangeTextBoxBak") Then
						DlgText "RangeTextBox",MsgList(41)
					End If
					DlgText "RangeTextBoxBak",MsgList(41)
					ExtractSet(31) = MergeStrEndCharSet(ExtractSet(31),MsgList(25))
					ExtractSetBak(31) = MergeStrEndCharSet(ExtractSetBak(31),MsgList(25))
					TempArray = ReSplit(ReSplit(ExtractSet(31),ItemJoinStr,2)(1),JoinStr)
					DlgListBoxArray "EndCharList",TempArray()
					DlgValue "EndCharList",StrToLong(ReSplit(ExtractSet(31),ItemJoinStr,2)(0))
				End If
			End If

			'重置自定义引用算法
			j = 0
			If CheckRefTypeArray(RefTypeList) = True Then
				ReDim TempArray(UBound(RefTypeList) + 1) As String
				TempArray(0) = MsgList(2)
				For i = 0 To UBound(RefTypeList)
					TempArray(i + 1) = RefTypeList(i).sName
					If RefTypeList(i).Template = UseRefTypeList(0).Template Then j = i + 1
				Next i
				If j = 0 Then
					If CheckRefTypeArray(UseRefTypeList) = True Then
						j = UBound(TempArray) + 1
						ReDim Preserve TempArray(j) As String
						TempArray(j) = UseRefTypeList(0).sName
					End If
				End If
				Select Case SourceFile.Magic
				Case "NotPE32","NotPE64",""
					DlgEnable "ReferenceTypeList",True
				End Select
			Else
				ReDim TempArray(0) As String
				TempArray(0) = MsgList(2)
				DlgEnable "ReferenceTypeList",False
			End If
			DlgListBoxArray "ReferenceTypeList",TempArray()
			DlgValue "ReferenceTypeList",j
			If DlgValue("ReferenceTypeList") < 0 Then DlgValue "ReferenceTypeList",0

			'根据地址格式的设置转换提取区域
			If Selected(16) <> TempList(16) Then
				If Selected(0) = TempList(0) Then
					DlgText "RangeCheckBox",IIf(StrToLong(Selected(16)) = 0,MsgList(46),MsgList(47))
				End If
				If DlgText("RangeTextBox") <> DlgText("RangeTextBoxBak") Then
					If Trim$(ExtractSet(50)) = "" Then
						DlgText "RangeTextBox",MsgList(41)
					ElseIf StrToLong(Selected(16)) = 1 Then
						TempArray = ReSplit(Trim$(ExtractSet(50)),",")
						n = 0
						For i = 0 To UBound(TempArray)
							If InStr(TempArray(i),"-") Then
								TempList = ReSplit(Trim$(TempArray(i)),"-")
								For j = 0 To 1
									TempList(j) = ValToStr(StrToLong(TempList(j)),SourceFile.FileSize,True)
								Next j
								TempArray(i) = StrListJoin(TempList,"-")
							Else
								TempArray(i) = ValToStr(StrToLong(Trim$(TempArray(i))),SourceFile.FileSize,True)
							End If
						Next i
						DlgText "RangeTextBox",StrListJoin(TempArray,",")
					Else
						DlgText "RangeTextBox",ExtractSet(50)
					End If
					'DlgText "RangeTextBoxBak",MsgList(41)
				End If
			End If

			'检查自定义字串类型的设置
			DlgValue "CustomTypeCheckBox",IIf(CheckStrTypeArray(UseStrTypeList) = False,0,1)
			If CheckStrTypeArray(StrTypeList) = False Then
				DlgText "CustomTypeCheckBox",MsgList(14)
			Else
				DlgText "CustomTypeCheckBox",MsgList(15)
			End If
			'对自定义字串类型数据进行检查
			If Stemp = True Then
				If DlgValue("CustomTypeCheckBox") = 1 Then
					TempList = GetStrTypeNameList(StrTypeList)
					TempArray = GetStrTypeNameList(UseStrTypeList)
					If EditList(TempList,TempArray) = True Then
						Set Dic = CreateObject("Scripting.Dictionary")
						For i = 0 To UBound(StrTypeList)
							If Not Dic.Exists(StrTypeList(i).sName) Then Dic.Add(StrTypeList(i).sName,i)
						Next i
						ReDim UseStrTypeList(UBound(TempArray)) As STRING_TYPE
						For i = 0 To UBound(TempArray)
							If Dic.Exists(TempArray(i)) Then
								UseStrTypeList(i) = StrTypeList(Dic.Item(TempArray(i)))
							End If
						Next i
						Set Dic = Nothing
					End If
					If CheckArray(TempArray) = False Then
						DlgValue "CustomTypeCheckBox",0
					End If
				End If
				ExtractSet(10) = CStr(DlgValue("CustomTypeCheckBox"))
			End If
			'判断对话框字体是否已被改变
			If FontComp(LFList(0),tmpLFList(0)) = True Then
				n = CLng(DlgText("SuppValueBox"))
				j = CreateFont(n,LFList(0))
				If j = 0 Then Exit Function
				For i = 0 To DlgCount() - 1
					SendMessageLNG(GetDlgItem(n,DlgControlId(DlgName(i))),WM_SETFONT,j,0)
				Next i
				DrawWindow(n,j)
			End If
		Else
			ExtractSet(0) = CStr$(DlgValue("ExtractModeOption"))
			ExtractSet(1) = CStr$(DlgValue("ANSICheckBox"))
			ExtractSet(2) = CStr$(DlgValue("UnicodeCheckBox"))
			ExtractSet(3) = CStr$(DlgValue("UTF8CheckBox"))
			'ExtractSet(4) = DlgText("CPListBox")
			ExtractSet(5) = CStr$(DlgValue("PascalCheckBox"))
			ExtractSet(6) = CStr$(DlgValue("PascalDWordCheckBox"))
			ExtractSet(7) = CStr$(DlgValue("PascalAnsiCheckBox"))
			ExtractSet(8) = CStr$(DlgValue("PascalShortCheckBox"))
			ExtractSet(9) = CStr$(DlgValue("NetStrCheckBox"))
			ExtractSet(10) = CStr$(DlgValue("CustomTypeCheckBox"))
			ExtractSet(11) = CStr$(DlgValue("ReferenceCheckBox"))
			ExtractSet(12) = CStr$(DlgValue("NullStrCheckBox"))
			ExtractSet(13) = CStr$(DlgValue("ControlStrCheckBox"))
			ExtractSet(14) = CStr$(DlgValue("AllSymbolCheckBox"))
			ExtractSet(15) = CStr$(DlgValue("AllUCaseCheckBox"))
			ExtractSet(16) = CStr$(DlgValue("AllLCaseCheckBox"))
			ExtractSet(17) = CStr$(DlgValue("AllULCaseCheckBox"))
			ExtractSet(18) = CStr$(DlgValue("ContinuousCheckBox"))
			ExtractSet(19) = CStr$(DlgValue("OtherStrCheckBox"))
			ExtractSet(20) = CStr$(DlgValue("IncludeStrCheckBox"))
			ExtractSet(21) = CStr$(DlgValue("FilterStrCheckBox"))
			ExtractSet(22) = CStr$(DlgValue("IgnoreFilterAccKeyCheckBox"))
			ExtractSet(23) = CStr$(DlgValue("KeepStrCheckBox"))
			ExtractSet(24) = CStr$(DlgValue("IgnoreKeepAccKeyCheckBox"))
			ExtractSet(25) = CStr$(DlgValue("OutputMsgCheckBox"))
			ExtractSet(26) = CStr$(DlgValue("LogingMsgCheckBox"))
			ExtractSet(31) = DlgValue("EndCharList") & ItemJoinStr & ReSplit(ExtractSet(31),ItemJoinStr,2)(1)
			ExtractSet(41) = CStr$(DlgValue("AndroidStrCheckBox"))
			ExtractSet(42) = CStr$(DlgValue("OtherMatchModeList"))
			ExtractSet(43) = CStr$(DlgValue("OtherMatchCaseCheckBox"))
			ExtractSet(44) = CStr$(DlgValue("IgnoreOtherAccKeyCheckBox"))
			ExtractSet(48) = CStr$(DlgValue("CStringCheckBox"))
			ExtractSet(49) = CStr$(DlgValue("RangeCheckBox"))
			'ExtractSet(50) = CStr$(DlgValue("RangeTextBox"))
			ExtractSet(51) = CStr$(DlgValue("LogingFilteredStrOnlyCheckBox"))
			ExtractSet(52) = CStr$(DlgValue("MaxStrLengthCheckBox"))

			If DlgText("FilePathBox") = "" Or DlgText("LangListBox") = "" Or DlgText("CPListBox") = "" Then
				DlgEnable "OKButton",False
				DlgEnable "GetStrButton",False
			ElseIf DlgValue("RangeCheckBox") = 0 And DlgText("SectionListBox") = "" Then
				DlgEnable "OKButton",False
				DlgEnable "GetStrButton",False
			ElseIf DlgValue("RangeCheckBox") = 1 And DlgText("RangeTextBox") = "" Then
				DlgEnable "OKButton",False
				DlgEnable "GetStrButton",False
			ElseIf DlgValue("RangeCheckBox") = 1 And DlgText("RangeTextBox") = DlgText("RangeTextBoxBak") Then
				DlgEnable "OKButton",False
				DlgEnable "GetStrButton",False
			ElseIf DlgValue("CStringCheckBox") + DlgValue("PascalCheckBox") + DlgValue("PascalDWordCheckBox") + _
				DlgValue("PascalAnsiCheckBox") + DlgValue("PascalShortCheckBox") + DlgValue("NetStrCheckBox") + _
				DlgValue("AndroidStrCheckBox") + DlgValue("CustomTypeCheckBox") = 0 Then
				DlgEnable "OKButton",False
				DlgEnable "GetStrButton",False
			Else
				DlgEnable "OKButton",True
				DlgEnable "GetStrButton",True
			End If
			DlgEnable "RangeTipButton",IIf(DlgText("FilePathBox") = "",False,True)
			DlgEnable "RangeTextBox",IIf(DlgText("FilePathBox") = "",False,True)
			DlgEnable "LangLevelButton",IIf(DlgText("LangListBox") = "",False,True)
			DlgEnable "CPLevelButton",IIf(DlgText("CPListBox") = "",False,True)
			DlgEnable "SaveButton",ArrayComp(ExtractSet,ExtractSetBak,"0-4,11-31,42-46,49-53")
		End If
	Case 3 ' 文本框或者组合框文本被更改
		Select Case DlgItem$
		Case "RangeTextBox"
			DlgText "RangeTextBox",UCase$(Trim$(DlgText("RangeTextBox")))
			If DlgValue("RangeCheckBox") = 0 Then Exit Function
			If DlgText("RangeTextBox") = DlgText("RangeTextBoxBak") Then Exit Function
			If getMsgList(UIDataList,MsgList,"ExtractStringDlgFunc",1) = False Then Exit Function
			If DlgText("RangeTextBox") = "" Then
				MsgBox MsgList(42),vbOkOnly+vbInformation,MsgList(10)
				Exit Function
			End If
			If StrToLong(Selected(16)) = 0 Then
				If CheckStrRegExp(DlgText("RangeTextBox"),"[-,0-9]",0,1) = False Then
					MsgBox MsgList(43),vbOkOnly+vbInformation,MsgList(10)
					Exit Function
				'ElseIf CheckStrRegExp(DlgText("RangeTextBox"),"[0-9]+-[0-9]+(,[0-9]+-[0-9]+)*",0,5) = False Then
				'	MsgBox MsgList(44),vbOkOnly+vbInformation,MsgList(10)
				'	Exit Function
				End If
			Else
				If CheckStrRegExp(DlgText("RangeTextBox"),"[-,0-9a-f]",0,1,True) = False Then
					MsgBox MsgList(43),vbOkOnly+vbInformation,MsgList(10)
					Exit Function
				'ElseIf CheckStrRegExp(DlgText("RangeTextBox"),"[0-9a-f]+-[0-9a-f]+(,[0-9a-f]+-[0-9a-f]+)*",0,5,True) = False Then
				'	MsgBox MsgList(44),vbOkOnly+vbInformation,MsgList(10)
				'	Exit Function
				End If
			End If
			'检查允许的最小地址和最大地址
			j = SourceFile.SecList(SourceFile.MinSecID).lPointerToRawData
			n = SourceFile.SecList(SourceFile.MaxSecIndex).lPointerToRawData + SourceFile.SecList(SourceFile.MaxSecIndex).lSizeOfRawData - 1
			TempList = ReSplit(Replace$(DlgText("RangeTextBox"),",","-"),"-")
			For i = 0 To UBound(TempList) - 1 Step 2
				If StrToVal(TempList(i),StrToLong(Selected(16))) >= StrToVal(TempList(i + 1),StrToLong(Selected(16))) Then
					MsgBox Replace$(MsgList(45),"%s",TempList(i) & "-" & TempList(i + 1)),vbOkOnly+vbInformation,MsgList(10)
					Exit Function
				ElseIf StrToVal(TempList(i),StrToLong(Selected(16))) < j Then
					MsgBox Replace$(Replace$(MsgList(6),"%s",TempList(i)),"%d",CStr$(j)),vbOkOnly+vbInformation,MsgList(10)
					Exit Function
				ElseIf StrToVal(TempList(i + 1),StrToLong(Selected(16))) > n Then
					MsgBox Replace$(Replace$(MsgList(7),"%s",TempList(i + 1)),"%d",CStr$(n)),vbOkOnly+vbInformation,MsgList(10)
					Exit Function
				End If
			Next i
			'按照地址显示方式设置转换为十进制值
			If StrToLong(Selected(16)) = 1 Then
				TempArray = ReSplit(DlgText("RangeTextBox"),",")
				n = 0
				For i = 0 To UBound(TempArray)
					If InStr(TempArray(i),"-") Then
						TempList = ReSplit(Trim$(TempArray(i)),"-")
						For j = 0 To 1
							TempList(j) = CStr$(StrToVal(Trim$(TempList(j)),True))
						Next j
						TempArray(i) = StrListJoin(TempList,"-")
					Else
						TempArray(i) = CStr$(StrToVal(Trim$(TempArray(i)),True))
					End If
				Next i
				ExtractSet(50) = StrListJoin(TempArray,",")
			Else
				ExtractSet(50) = DlgText("RangeTextBox")
			End If
			If DlgText("LangListBox") = "" Or DlgText("CPListBox") = "" Or DlgText("SectionListBox") = "" Then
				DlgEnable "OKButton",False
				DlgEnable "GetStrButton",False
			ElseIf DlgValue("CStringCheckBox") + DlgValue("PascalCheckBox") + DlgValue("PascalDWordCheckBox") + _
				DlgValue("PascalAnsiCheckBox") + DlgValue("PascalShortCheckBox") + DlgValue("NetStrCheckBox") + _
				DlgValue("AndroidStrCheckBox") + DlgValue("CustomTypeCheckBox") = 0 Then
				DlgEnable "OKButton",False
				DlgEnable "GetStrButton",False
			Else
				DlgEnable "OKButton",True
				DlgEnable "GetStrButton",True
			End If
		Case "MinStrLengthTextBox"
			DlgText "MinStrLengthTextBox",Trim$(DlgText("MinStrLengthTextBox"))
			If ExtractSet(27) = DlgText("MinStrLengthTextBox") Then Exit Function
			If StrToLong(DlgText("MinStrLengthTextBox")) < 1 Then
				If getMsgList(UIDataList,MsgList,"ExtractStringDlgFunc",1) = False Then Exit Function
				MsgBox MsgList(19),vbOkOnly+vbInformation,MsgList(3)
				DlgText "MinStrLengthTextBox","2"
				Exit Function
			End If
			ExtractSet(27) = DlgText("MinStrLengthTextBox")
			DlgEnable "SaveButton",ArrayComp(ExtractSet,ExtractSetBak,"0-4,11-31,42-46,49-53")
		Case "MaxStrLengthTextBox"
			DlgText "MaxStrLengthTextBox",Trim$(DlgText("MaxStrLengthTextBox"))
			If ExtractSet(53) = DlgText("MaxStrLengthTextBox") Then Exit Function
			If StrToLong(DlgText("MaxStrLengthTextBox")) < 10000 Then
				If getMsgList(UIDataList,MsgList,"ExtractStringDlgFunc",1) = False Then Exit Function
				If MsgBox(MsgList(51),vbYesNo+vbInformation,MsgList(4)) = vbNo Then Exit Function
			End If
			ExtractSet(53) = DlgText("MaxStrLengthTextBox")
			DlgEnable "SaveButton",ArrayComp(ExtractSet,ExtractSetBak,"0-4,11-31,42-46,49-53")
		Case "ContinuousTextBox"
			DlgText "ContinuousTextBox",Trim$(DlgText("ContinuousTextBox"))
			If ExtractSet(28) = DlgText("ContinuousTextBox") Then Exit Function
			If StrToLong(DlgText("ContinuousTextBox")) < 3 Then
				If getMsgList(UIDataList,MsgList,"ExtractStringDlgFunc",1) = False Then Exit Function
				MsgBox MsgList(20),vbOkOnly+vbInformation,MsgList(3)
				DlgText "ContinuousTextBox","3"
				Exit Function
			End If
			ExtractSet(28) = DlgText("ContinuousTextBox")
			DlgEnable "SaveButton",ArrayComp(ExtractSet,ExtractSetBak,"0-4,11-31,42-46,49-53")
		Case "OtherStrTextBox"
			If ExtractSet(29) = DlgText("OtherStrTextBox") Then Exit Function
			ExtractSet(29) = DlgText("OtherStrTextBox")
			ExtractSet(32) = Str2RegExpPattern(Convert(ExtractSet(29)))
			DlgEnable "SaveButton",ArrayComp(ExtractSet,ExtractSetBak,"0-4,11-31,42-46,49-53")
		Case "OtherStrForWildcardTextBox"
			If ExtractSet(45) = DlgText("OtherStrForWildcardTextBox") Then Exit Function
			If DlgText("OtherStrForWildcardTextBox") <> "" Then
				If FilterStr("CheckRegExp",DlgText("OtherStrForWildcardTextBox"),1) = -2 Then
					If getMsgList(UIDataList,MsgList,"ExtractStringDlgFunc",1) = False Then Exit Function
					MsgBox MsgList(49),vbOkOnly+vbInformation,MsgList(10)
					Exit Function
				End If
			End If
			ExtractSet(45) = DlgText("OtherStrForWildcardTextBox")
			ExtractSet(47) = Convert(ExtractSet(45))
			DlgEnable "SaveButton",ArrayComp(ExtractSet,ExtractSetBak,"0-4,11-31,42-46,49-53")
		Case "OtherStrForRegExpTextBox"
			If ExtractSet(46) = DlgText("OtherStrForRegExpTextBox") Then Exit Function
			If DlgText("OtherStrForRegExpTextBox") <> "" Then
				If CheckRegExp(RegExp,DlgText("OtherStrForRegExpTextBox")) = False Then
					If getMsgList(UIDataList,MsgList,"ExtractStringDlgFunc",1) = False Then Exit Function
					MsgBox MsgList(31),vbOkOnly+vbInformation,MsgList(10)
					Exit Function
				End If
			End If
			ExtractSet(46) = DlgText("OtherStrForRegExpTextBox")
			DlgEnable "SaveButton",ArrayComp(ExtractSet,ExtractSetBak,"0-4,11-31,42-46,49-53")
		Case "IncludeStrTextBox"
			If ExtractSet(30) = DlgText("IncludeStrTextBox") Then Exit Function
			If DlgText("IncludeStrTextBox") = "" Then
				If getMsgList(UIDataList,MsgList,"ExtractStringDlgFunc",1) = False Then Exit Function
				MsgBox MsgList(36),vbOkOnly+vbInformation,MsgList(10)
				Exit Function
			End If
			ExtractSet(30) = DlgText("IncludeStrTextBox")
			ExtractSet(33) = Str2RegExpPattern(Convert(ExtractSet(30)))
			DlgEnable "SaveButton",ArrayComp(ExtractSet,ExtractSetBak,"0-4,11-31,42-46,49-53")
		End Select
	Case 6 ' 函数快捷键
		Select Case SuppValue
		Case 1	'帮助
			If getMsgList(UIDataList,MsgList,"ExtractStringDlgFunc",1) = False Then Exit Function
			ReDim TempArray(2) As String
			If DlgValue("ModeCheckBox") = 0 Then
				TempArray(0) = MsgList(0)
			Else
				TempArray(0) = MsgList(1)
			End If
			TempArray(1) = MsgList(23)
			TempArray(2) = MsgList(34)
			Select Case ShowPopupMenu(TempArray,vbPopupUseRightButton)
			Case 0
				If DlgValue("ModeCheckBox") = 0 Then
					If StrToLong(Selected(30)) = 1 Then
						If OpenCHM(CLng(DlgText("SuppValueBox")),1024,Selected(0),OSLanguage,UIFileList) = True Then Exit Function
					End If
					Call Help("GetStringHelp")
				Else
					If StrToLong(Selected(30)) = 1 Then
						If OpenCHM(CLng(DlgText("SuppValueBox")),1006,Selected(0),OSLanguage,UIFileList) = True Then Exit Function
					End If
					Call Help("GetStrSetHelp")
				End If
			Case 1
				If Dir$(MacroLoc & "\Module\modEncodeQuery.bas") <> "" Then
					MacroRun MacroLoc & "\Module\modEncodeQuery.bas"
				ElseIf Dir$(MacroLoc & "\modEncodeQuery.bas") <> "" Then
					MacroRun MacroLoc & "\modEncodeQuery.bas"
				End If
			Case 2
				If Dir$(MacroLoc & "\Module\modReferenceSearch.bas") <> "" Then
					MacroRun MacroLoc & "\Module\modReferenceSearch.bas", SourceFile.FilePath
				ElseIf Dir$(MacroLoc & "\modReferenceSearch.bas") <> "" Then
					MacroRun MacroLoc & "\modReferenceSearch.bas", SourceFile.FilePath
				End If
			End Select
		Case 2	'弹出正则表达式专用字符选择菜单
			If DlgValue("OtherMatchModeList") < 2 Then Exit Function
			If getMsgList(UIDataList,MsgList,"RegExpRuleTip",1) = False Then Exit Function
			i = ShowPopupMenu(MsgList,vbPopupUseRightButton)
			If i < 0 Then Exit Function
			If i = UBound(MsgList) Then
				If StrToLong(Selected(30)) = 1 Then
					If OpenCHM(CLng(DlgText("SuppValueBox")),1022,Selected(0),OSLanguage,UIFileList) = True Then Exit Function
				End If
				Call Help("RegExpRuleHelp")
				Exit Function
			End If
			If DlgText("OtherStrForRegExpTextBox") = "" Then
				DlgText "OtherStrForRegExpTextBox",Mid$(MsgList(i),InStrRev(MsgList(i),vbTab) + 1)
			Else
				DlgFocus("OtherStrForRegExpTextBox")  '设置焦点到文本框
				DlgText "OtherStrForRegExpTextBox",InsertStr(GetFocus(),DlgText("OtherStrForRegExpTextBox"), _
						Mid$(MsgList(i),InStrRev(MsgList(i),vbTab) + 1))
			End If
			ExtractSet(46) = DlgText("OtherStrForRegExpTextBox")
			DlgEnable "SaveButton",ArrayComp(ExtractSet,ExtractSetBak,"0-4,11-31,42-46,49-53")
		Case 9	'打开原始文件
			TempList = GetToolNameList(Tools,3)
			i = ShowPopupMenu(TempList,vbPopupUseRightButton)
			If i < 0 Then Exit Function
			ReDim TempList(0) As String
			TempList(0) = SourceFile.FilePath & JoinStr
			If OpenFile(SourceFile.FilePath,TempList,i + 3,False) = True Then
				If i = 0 Then WriteSettings("Tools")
			End If
		Case 11	'查看文件信息
			If SourceFile.FilePath = "" Then Exit Function
			If Dir$(SourceFile.FilePath) = "" Then Exit Function
			TempList = GetToolNameList(Tools,0)
			i = ShowPopupMenu(TempList,vbPopupUseRightButton)
			If i < 0 Then Exit Function
			Call FileInfoView(SourceFile,FreeByteList,i,0,StrToLong(Selected(16)))
		End Select
	End Select
End Function


'获取指定范围内的字串列表
Private Function SubStringList(DataList() As STRING_PROPERTIE,Optional ByVal ShowMsg As Long) As String()
	Dim i As Long,MaxNum As Long,Msg As String
	MaxNum = UBound(DataList) + 1
	Select Case ShowMsg
	Case 0
		ReDim TempList(MaxNum - 1) As String
		For i = 0 To MaxNum - 1
			TempList(i) = DataList(i).Trans.sString
		Next i
	Case Is > 0
		Msg = GetTextBoxString(ShowMsg) & " "
		ReDim TempList(MaxNum - 1) As String
		For i = 0 To MaxNum - 1
			TempList(i) = DataList(i).Trans.sString
			If i Mod 100 = 1 Then
				SetTextBoxString ShowMsg,Msg & Format$(i / MaxNum,"#%")
			End If
		Next i
		SetTextBoxString ShowMsg,Msg & "100%"
	Case Is < 0
		ReDim TempList(PSL.OutputWnd(0).LineCount - 1) As String
		For i = 1 To PSL.OutputWnd(0).LineCount
			TempList(i - 1) = PSL.OutputWnd(0).Text(i)
		Next i
		Msg = StrListJoin(TempList,vbCrLf) & " "
		ReDim TempList(MaxNum - 1) As String
		For i = 0 To MaxNum - 1
			TempList(i) = DataList(i).Trans.sString
			If i Mod 100 = 1 Then
				PSL.OutputWnd(0).Clear
				PSL.Output Msg & Format$(i / MaxNum,"#%")
			End If
		Next i
		PSL.OutputWnd(0).Clear
		PSL.Output Msg & "100%"
	End Select
	SubStringList = TempList
End Function


'备份原文件的所有信息
'提取时返回值 > 0 提取字串成功数量，否则，提取中止、取消提取
Private Function ReExtractString(orgFile As FILE_PROPERTIE,trnFile As FILE_PROPERTIE,ByVal ShowMsg As Long) As Long
	Dim i As Long,MsgList() As String,TempList() As String
	'备份原文件的所有信息
	Dim srcBak As PslSourceList,trnBak As PslTransList
	Dim orgFileBak As FILE_PROPERTIE,trnFileBak As FILE_PROPERTIE
	Dim UseSectionListBak() As String,UseSubSecListBak() As String
	Dim AllLangListBak() As LANG_PROPERTIE,UseRefTypeListBak() As REF_TYPE
	Set srcBak = src: Set trnBak = trn
	orgFileBak = orgFile: trnFileBak = trnFile
	UseSectionListBak = UseSectionList: UseSubSecListBak = UseSubSecList
	AllLangListBak = AllLangList: UseRefTypeListBak = UseRefTypeList
	ExtractSetBak = ExtractSet: TempList = Selected
	'转到提取对话框
	ReExtractString = ExtractString(orgFile,ShowMsg)
	If ReExtractString > 0 Then
		trnFile = orgFile
		HideSecMoveVal = 0
		Erase TempList,UseSectionListBak,AllLangListBak,UseRefTypeListBak
		ReDim GetFreeByteSecList(0) As String,FreeByteList(0) As FREE_BTYE_SPACE
		ReDim WriteLog(0) As String,FindLog(0) As String
		Set WriteLogDic = Nothing: Set FindLogDic = Nothing
		Exit Function
	End If
	Set src = srcBak: Set trn = trnBak
	orgFile = orgFileBak: trnFile = trnFileBak
	'ExtractSet = ExtractSetBak
	UseSectionList = UseSectionListBak: UseRefTypeList = UseRefTypeListBak
	AllLangList = AllLangListBak: UseSubSecList = UseSubSecListBak
	Erase UseSectionListBak,AllLangListBak,UseRefTypeListBak
	'自动选择时重新获取字串过滤列表的设置
	If ExtractSet(34) = "1" Or ExtractSet(39) = "1" Then GetSettings("FilterStrDic")
	'自动选择时重新获取字串保留列表的设置
	If ExtractSet(36) = "1" Or ExtractSet(40) = "1" Then GetSettings("ReserveStrDic")
	'获取过滤字串列表字典为字串过滤显示用
	MsgList = ReSplit(ReadBinaryFile(ExtractSet(35),CP_UNICODELITTLE,True),vbNullChar)
	StrList2StrDic(FilterStrDic,MsgList,StrToLong(ReSplit(FilterStrSet(17),ItemJoinStr)(1)),1)
	'重置未选定移位空间的移位字串
	If orgFile.Magic = "" Then Exit Function
	If trnFile.hcsFile.FilePath = orgFile.hcsFile.FilePath Then Exit Function
	If getMsgList(UIDataList,MsgList,"ReExtractString",1) = False Then Exit Function
	i = 0
	If Selected(10) <> TempList(10) Then
		MsgBox MsgList(1),vbOkOnly+vbInformation,MsgList(0)
		If ShowMsg > 0 Then
			SetTextBoxString ShowMsg,MsgList(5)
		ElseIf ShowMsg < 0 Then
			PSL.OutputWnd(0).Clear
			PSL.Output MsgList(5)
		End If
		If SetOverWriteAndGetRef(trnFile,AllStrDataList,StrToLong(Selected(10)),ShowMsg) > 0 Then
			MsgList(7) = MsgList(5) & " 100%" & TextJoinStr & MsgList(7)
		End If
		i = 2
	ElseIf ArrayComp(Selected,TempList,"2-7") = True Then
		If Selected(8) = "1" Then
			MsgBox MsgList(2),vbOkOnly+vbInformation,MsgList(0)
			i = 1
		Else
			MsgBox MsgList(3),vbOkOnly+vbInformation,MsgList(0)
			i = 2
		End If
	ElseIf Selected(11) <> TempList(11) Then
		If StrToLong(Selected(6) & Selected(7)) = 0 Then
			MsgBox MsgList(4),vbOkOnly+vbInformation,MsgList(0)
			i = 2
		End If
	End If
	If i > 0 Then
		Call ResetAndMoveStrings(trnFile,AllStrDataList,i,MsgList(6),MsgList(7),ShowMsg)
	End If
End Function


'编辑字串对话框
Private Function EditString(orgFile As FILE_PROPERTIE,trnFile As FILE_PROPERTIE) As Boolean
	Dim i As Long,MsgList() As String,TempList() As String
	If getMsgList(UIDataList,MsgList,"EditString",1) = False Then Exit Function
	If trnFile.hcsFile.FilePath = "" Then
		MsgList(0) = Replace$(Replace$(MsgList(0),"%s",Version),"%d",MsgList(40))
	Else
		MsgList(0) = Replace$(Replace$(MsgList(0),"%s",Version),"%d",trnFile.hcsFile.FilePath)
		If Len(MsgList(0)) > 110 Then
			MsgList(0) = Left$(MsgList(0),InStr(MsgList(0),"\")) & "..." & Right(MsgList(0),110 - Len(Left$(MsgList(0),InStr(MsgList(0),"\"))))
		End If
	End If
	i = IIf(trnFile.hcsFile.FilePath = orgFile.hcsFile.FilePath,1,0)
	'对话框
	Begin Dialog UserDialog 1150,595,MsgList(0),.EditStringDlgFunc ' %GRID:10,7,1,1
		CheckBox 0,0,0,21,"",.LoadDataCheckBox
		CheckBox 0,0,0,21,"",.ModeCheckBox,1
		TextBox 0,0,0,21,.SuppValueBox
		TextBox 0,0,0,21,.ScrollPosBox
		TextBox 0,0,200,21,.SelectLogBox
		TextBox 0,0,200,21,.StrIndexBox

		Text 930,7,210,14,MsgList(1),.inSectionText
		TextBox 930,21,100,21,.OrgInSectionBox
		TextBox 1040,21,100,21,.TrnInSectionBox

		Text 930,46,210,14,MsgList(2),.StartPosText
		Text 930,85,210,14,MsgList(3),.MaxPosText
		Text 930,124,210,14,MsgList(4),.VOffsetText
		Text 930,163,210,14,MsgList(5),.RefNumText
		TextBox 930,60,100,21,.OrgStartPosBox
		TextBox 930,99,100,21,.OrgMaxPosBox
		TextBox 1040,60,100,21,.TrnStartPosBox
		TextBox 1040,99,100,21,.TrnMaxPosBox
		DropListBox 930,138,100,21,TempList(),.OrgVOffsetList
		DropListBox 1040,138,100,21,TempList(),.TrnVOffsetList
		TextBox 930,177,100,21,.OrgRefNumBox
		TextBox 1040,177,100,21,.TrnRefNumBox

		Text 930,202,210,14,MsgList(6),.StrLengthText
		TextBox 930,216,60,21,.OrgStrLengthBox
		TextBox 1004,216,60,21,.TrnStrLengthBox
		TextBox 1080,216,60,21,.MaxStrLengthBox

		Text 930,241,210,14,MsgList(7),.StrTypeNameText
		DropListBox 930,255,210,21,TempList(),.StrTypeNameList

		Text 930,280,210,14,MsgList(8),.OrgStrCodeText
		DropListBox 930,294,210,21,TempList(),.OrgCodePageNameList
		ListBox 930,294,210,21,TempList(),.OrgCodePageValList

		Text 930,280,210,14,MsgList(9),.TrnStrCodeText
		DropListBox 930,294,210,21,TempList(),.TrnCodePageNameList
		ListBox 930,294,210,21,TempList(),.TrnCodePageValList

		PushButton 930,329,210,21,MsgList(10),.RefListButton
		PushButton 930,434,100,21,MsgList(42),.UpButton
		PushButton 1040,434,100,21,MsgList(43),.DownButton
		PushButton 1040,350,100,21,MsgList(11),.DelButton

		PushButton 930,371,100,21,MsgList(14),.SelectAllButton
		PushButton 1040,371,100,21,MsgList(15),.ResetButton
		PushButton 1040,350,100,21,MsgList(16),.WriteButton
		PushButton 930,392,100,21,MsgList(19),.FindButton
		PushButton 1040,392,100,21,MsgList(41),.RefreshButton
		PushButton 930,413,210,21,MsgList(17),.AddFilterStrButton
		PushButton 930,413,210,21,MsgList(18),.DelFilterStrButton
		PushButton 930,350,100,21,MsgList(12),.LockButton
		PushButton 930,350,100,21,MsgList(13),.UnLockButton
		PushButton 930,462,70,21,MsgList(45),.FilterButton1
		PushButton 1000,462,70,21,MsgList(46),.FilterButton2
		PushButton 1070,462,70,21,MsgList(47),.FilterButton3
		PushButton 930,483,210,21,MsgList(20),.FilterShowButton
		PushButton 930,504,210,21,MsgList(21),.AllShowButton
		Text 930,539,210,14,"",.StringNums,2
		PushButton 930,532,210,21,MsgList(39),.StopButton

		MultiListBox 10,7,910,378,TempList(),.UseStrList,1
		Text 10,392,690,14,MsgList(22),.OrgStringText
		Text 10,476,690,14,MsgList(23),.TrnStringText
		TextBox 10,413,910,56,.OrgStringBox,1
		TextBox 10,497,910,56,.TrnStringBox,1
		CheckBox 710,388,210,21,MsgList(24),.OrgCheckBox
		CheckBox 710,472,210,21,MsgList(25),.TrnCheckBox
		Text 10,392,200,14,MsgList(26),.MsgOutputText
		OptionGroup .MsgOutputGroup
			OptionButton IIf(i = 0,220,290),392,220,14,MsgList(27),.ActionProgressCheckBox
			OptionButton IIf(i = 0,450,550),392,220,14,MsgList(44),.FindResultsCheckBox
			OptionButton 680,392,220,14,MsgList(28),.WriteResultsCheckBox
		TextBox 10,413,910,140,.ActionProgressBox,1
		MultiListBox 10,413,910,140,TempList(),.FindResultsBox,1
		MultiListBox 10,413,910,140,TempList(),.WriteResultsBox,1

		PushButton 10,567,110,21,MsgList(29),.HelpButton
		PushButton 130,567,110,21,MsgList(30),.SetButton
		PushButton 250,567,110,21,MsgList(31),.AllResetButton
		PushButton 370,567,110,21,MsgList(32),.EditButton
		PushButton 490,567,110,21,MsgList(33),.ReExtractButton
		PushButton 610,567,110,21,MsgList(34),.GetStrSetButton
		PushButton 610,567,110,21,MsgList(35),.AllWriteButton
		PushButton 610,567,110,21,MsgList(36),.UndoWriteButton
		PushButton 730,567,110,21,"",.MsgOutputButton
		PushButton 910,567,110,21,MsgList(37),.SaveButton
		PushButton 1030,567,110,21,MsgList(38),.ExitButton
		CancelButton 1030,567,110,21,.CancelButton
	End Dialog
	Dim dlg As UserDialog
	If Dialog(dlg) = 0 Then Exit Function
End Function


'编辑字串对话框函数
Private Function EditStringDlgFunc(DlgItem$, Action%, SuppValue&) As Boolean
	Dim i As Long,j As Long,n As Long,k As Long,m As Long,x As Long,y As Long,t As Long
	Dim MsgList() As String,TempArray() As String,TempList() As String,TmpList() As String
	Dim intArray() As Long,intList() As Long,intArry() As Long,intArr() As Long,DataList() As STRING_PROPERTIE
	Dim Stemp As Boolean,Stemp2 As Boolean,Stemp3 As Boolean,Stemp4 As Boolean,Dic As Object
	Dim Temp As String,File As FILE_PROPERTIE,FN As FILE_IMAGE,Mode As Long,pt As POINTAPI

	'字串列表框中的鼠标右键菜单
	If Action% = 5 Then
		Wait 0.2
		EditStringDlgFunc = True '防止按下按钮关闭对话框窗口
		If DlgValue("LoadDataCheckBox") = 0 Then
			DlgValue "LoadDataCheckBox",1
			If Dir$(TargetFile.hcsFile.FilePath) = "" Then Exit Function
			Action% = 2: DlgItem$ = "LoadHCSFile"
		Else
			If GetAsyncKeyState(VK_RBUTTON) > -1 Then Exit Function
			Call GetCursorPos(pt)
			j = GetDlgItem(CLng(DlgText("SuppValueBox")),DlgControlId("UseStrList"))
			If DlgVisible("WriteResultsBox") = True Then
				k = GetDlgItem(CLng(DlgText("SuppValueBox")),DlgControlId("WriteResultsBox"))
			End If
			If DlgVisible("FindResultsBox") = True Then
				x = GetDlgItem(CLng(DlgText("SuppValueBox")),DlgControlId("FindResultsBox"))
			End If
			Select Case WindowFromPoint(pt.x,pt.y)
			'Select Case ChildWindowFromPoint(CLng(DlgText("SuppValueBox")),pt.x,pt.y)
			Case j
				intArray = GetListBoxIndexs(j)
				If CheckArrEmpty(intArray) = False Then Exit Function
				Stemp = IIf(TargetFile.hcsFile.FilePath = SourceFile.hcsFile.FilePath,False,True)
				If Stemp = False Then
					If getMsgList(UIDataList,MsgList,"SourceStringMenu",1) = False Then Exit Function
				Else
					If getMsgList(UIDataList,MsgList,"TranStringMenu",1) = False Then Exit Function
					If TargetFile.Magic = "" Or Selected(10) = "1" Then
						MsgList(16) = "": MsgList(17) = ""
						If TargetFile.Magic = "" Then MsgList(18) = "": MsgList(19) = ""
					End If
				End If
				Select Case ShowPopupMenu(MsgList,vbPopupUseRightButton)
				Case Is < 0
					Exit Function
				Case 0
					Action% = 2: DlgItem$ = "SelectAllButton"
				Case 1
					Action% = 2: DlgItem$ = "SelectButton"
				Case 2
					ReDim TempList(UBound(intArray)) As String
					For i = 0 To UBound(intArray)
						TempList(i) = UseStrDataList(intArray(i)).Source.sString
					Next i
					Clipboard StrListJoin(TempList,TextJoinStr)
					Exit Function
				Case 3
					If Stemp = False Then
						Action% = 2: DlgItem$ = "DelButton"
					Else
						ReDim TempList(UBound(intArray)) As String
						For i = 0 To UBound(intArray)
							TempList(i) = UseStrDataList(intArray(i)).Trans.sString
						Next i
						Clipboard StrListJoin(TempList,TextJoinStr)
						Exit Function
					End If
				Case 4
					If Stemp = False Then
						Action% = 2: DlgItem$ = "AddButton"
					Else
						Action% = 6: SuppValue& = 2
					End If
				Case 5
					Action% = 2: DlgItem$ = IIf(Stemp = False,"AppButton","AddFilterStrButton")
				Case 6
					If Stemp = False Then
						Action% = 6: SuppValue& = 2
					Else
						Action% = 2: DlgItem$ = "DelFilterStrButton"
					End If
				Case 7
					If Stemp = False Then
						Action% = 2: DlgItem$ = "AddFilterStrButton"
					Else
						Action% = 6: SuppValue& = 5
					End If
				Case 8
					If Stemp = False Then
						Action% = 2: DlgItem$ = "DelFilterStrButton"
					Else
						Action% = 6: SuppValue& = 9
					End If
				Case 9
					Action% = 6: SuppValue& = IIf(Stemp = False,5,10)
				Case 10
					If Stemp = False Then
						Action% = 2: DlgItem$ = "AddKeepStrButton"
					Else
						Action% = 6: SuppValue& = 11
					End If
				Case 11
					If Stemp = False Then
						Action% = 2: DlgItem$ = "DelKeepStrButton"
					Else
						Action% = 6: SuppValue& = 12
					End If
				Case 12
					If Stemp = False Then
						If EditFilter(ExtractSet,1) = True Then
							ExtractSetBak(36) = ExtractSet(36)
							ExtractSetBak(37) = ExtractSet(37)
							ExtractSetBak(40) = ExtractSet(40)
							WriteSettings("ReserveStrDic")
						End If
						Exit Function
					Else
						Action% = 6: SuppValue& = SuppValue& Or &H200
					End If
				Case 13
					If Stemp = False Then
						Action% = 6: SuppValue& = 9
					Else
						Action% = 2: DlgItem$ = "PreFillSpaceMenu"
					End If
				Case 14
					If Stemp = False Then
						Action% = 6: SuppValue& = 11
					Else
						Action% = 2: DlgItem$ = "AppFillSpaceMenu"
					End If
				Case 15
					Action% = 2: DlgItem$ = IIf(Stemp = False,"IgnoreButton","UnFillSpaceMenu")
				Case 16
					Action% = 2: DlgItem$ = IIf(Stemp = False,"UnIgnoreButton","OverLengthWriteMenu")
				Case 17
					If Stemp = False Then
						Clipboard Str2Hex(Convert(UseStrDataList(intArray(0)).Source.sString),UseStrDataList(intArray(0)).Source.CodePage,0)
						Exit Function
					Else
						Action% = 2: DlgItem$ = "UnOverLengthWriteMenu"
					End If
				Case 18
					Action% = 2: DlgItem$ = IIf(Stemp = False,"FileByteView","StrAddExpandButton")
				Case 19
					Action% = 2: DlgItem$ = "UnStrAddExpandButton"
				Case 20
					Action% = 2: DlgItem$ = "EditCommentMenu"
				Case 21
					Clipboard Str2Hex(Convert(UseStrDataList(intArray(0)).Source.sString),UseStrDataList(intArray(0)).Source.CodePage,0)
					Exit Function
				Case 22
					Clipboard Str2Hex(Convert(UseStrDataList(intArray(0)).Trans.sString),UseStrDataList(intArray(0)).Trans.CodePage,0)
					Exit Function
				Case 23
					Action% = 2: DlgItem$ = "FileByteView"
				End Select
			Case x
				intArray = GetListBoxIndexs(x)
				If CheckArrEmpty(intArray) = False Then Exit Function
				If getMsgList(UIDataList,MsgList,"FindAndWriteStringMenu",1) = False Then Exit Function
				Select Case ShowPopupMenu(MsgList,vbPopupUseRightButton)
				Case Is < 0
					Exit Function
				Case 0
					SetListBoxItems(GetDlgItem(CLng(DlgText("SuppValueBox")),DlgControlId("FindResultsBox")),-1)
					Action% = 2: DlgItem$ = "FindResultsBox"
				Case 1
					ReDim TempList(UBound(intArray)) As String
					For i = 0 To UBound(intArray)
						TempList(i) = FindLog(intArray(i))
					Next i
					Clipboard StrListJoin(TempList,TextJoinStr)
					Exit Function
				Case Else
					ReDim FindLog(0) As String
					Set FindLogDic = Nothing
					DlgListBoxArray "FindResultsBox",FindLog()
					Exit Function
				End Select
			Case k
				intArray = GetListBoxIndexs(k)
				If CheckArrEmpty(intArray) = False Then Exit Function
				If getMsgList(UIDataList,MsgList,"FindAndWriteStringMenu",1) = False Then Exit Function
				Select Case ShowPopupMenu(MsgList,vbPopupUseRightButton)
				Case Is < 0
					Exit Function
				Case 0
					SetListBoxItems(GetDlgItem(CLng(DlgText("SuppValueBox")),DlgControlId("WriteResultsBox")),-1)
					Action% = 2: DlgItem$ = "WriteResultsBox"
				Case 1
					ReDim TempList(UBound(intArray)) As String
					For i = 0 To UBound(intArray)
						TempList(i) = WriteLog(intArray(i))
					Next i
					Clipboard StrListJoin(TempList,TextJoinStr)
					Exit Function
				Case Else
					ReDim WriteLog(0) As String
					Set WriteLogDic = Nothing
					DlgListBoxArray "WriteResultsBox",WriteLog()
					Exit Function
				End Select
			End Select
			i = 0: j = 0: k = 0: x = 0: Stemp = False
			ReDim intArray(0) As Long,TempList(0) As String
		End If
	End If

	Select Case Action%
	Case 1 ' 对话框窗口初始化
		DlgText "SuppValueBox",CStr$(SuppValue)
		DlgVisible "LoadDataCheckBox",False
		DlgVisible "ModeCheckBox",False
		DlgVisible "SuppValueBox",False
		DlgVisible "ScrollPosBox",False
		DlgVisible "OrgCodePageValList",False
		DlgVisible "TrnCodePageValList",False
		DlgVisible "UnLockButton",False
		DlgVisible "MsgOutputText",False
		DlgVisible "MsgOutputGroup",False
		DlgVisible "ActionProgressBox",False
		DlgVisible "FindResultsBox",False
		DlgVisible "WriteResultsBox",False
		DlgVisible "CancelButton",False
		DlgVisible "StopButton",False
		DlgVisible "SelectLogBox",False
		DlgVisible "StrIndexBox",False

		DlgEnable "OrgRefNumBox",False
		DlgEnable "TrnRefNumBox",False
		DlgEnable "OrgStrLengthBox",False
		DlgEnable "TrnStrLengthBox",False
		DlgEnable "MaxStrLengthBox",False
		DlgEnable "OrgInSectionBox",False
		DlgEnable "TrnInSectionBox",False
		'DlgEnable "OrgVOffsetList",False
		'DlgEnable "TrnVOffsetList",False
		DlgEnable "TrnMaxPosBox",False
		DlgEnable "AllResetButton",False
		DlgEnable "ResetButton",False
		EscHwnd = GetDlgItem(SuppValue,DlgControlId("CancelButton"))
		StopHwnd = GetDlgItem(SuppValue,DlgControlId("StopButton"))

		If getMsgList(UIDataList,MsgList,"EditStringDlgFunc",1) = False Then Exit Function
		m = IIf(TargetFile.hcsFile.FilePath = SourceFile.hcsFile.FilePath,1,0)
		If m = 1 Then
			DlgVisible "TrnStrCodeText",False
			DlgVisible "TrnCodePageNameList",False
			DlgEnable "TrnStringBox",False
			DlgEnable "TrnCheckBox",False
			DlgValue "TrnCheckBox",1
			DlgVisible "WriteButton",False
			DlgVisible "AllWriteButton",False
			DlgVisible "UndoWriteButton",False
		Else
			DlgVisible "OrgStrCodeText",False
			DlgVisible "OrgCodePageNameList",False
			DlgEnable "OrgStringBox",False
			'DlgEnable "OrgCheckBox",False
			DlgValue "OrgCheckBox",1
			DlgEnable "StrTypeNameList",False
			DlgVisible "DelButton",False
			DlgVisible "GetStrSetButton",False
			i = InStrRev(LCase$(TargetFile.FilePath),".bak")
			If i > 0 Then
				If Mid$(LCase$(TargetFile.FilePath),i) = ".bak" Then
					If Dir$(TargetFile.FilePath) = "" Then i = 0
				Else
					i = 0
				End If
			End If
			If i < 1 Then
				DlgVisible "UndoWriteButton",False
			Else
				DlgEnable "WriteButton",False
				DlgVisible "AllWriteButton",False
			End If
		End If
		DlgText "MsgOutputButton",MsgList(22)

		DlgEnable "OrgStartPosBox",False
		DlgEnable "OrgMaxPosBox",False
		DlgEnable "StrTypeNameList",False
		DlgEnable "OrgCodePageNameList",False
		DlgEnable "TrnStartPosBox",False
		DlgEnable "TrnCodePageNameList",False
		DlgEnable "RefListButton",False
		DlgEnable "OrgVOffsetList",False
		DlgEnable "TrnVOffsetList",False
		DlgEnable "DelButton",False
		DlgEnable "LockButton",False
		DlgEnable "UnLockButton",False
		DlgEnable "FindButton",False
		DlgEnable "RefreshButton",False
		DlgEnable "FilterButton1",False
		DlgEnable "FilterButton2",False
		DlgEnable "FilterButton3",False
		DlgEnable "FilterShowButton",False
		DlgEnable "AllShowButton",False
		DlgEnable "SelectAllButton",False
		DlgEnable "UpButton",False
		DlgEnable "DownButton",False
		DlgEnable "WriteButton",False
		DlgEnable "AllWriteButton",False
		DlgVisible "DelFilterStrButton",False
		DlgEnable "AddFilterStrButton",False

		'设置当前对话框字体
		If CheckFont(LFList(0)) = True Then
			j = CreateFont(0,LFList(0))
			If j <> 0 Then
				For i = 0 To DlgCount() - 1
					If DlgType(i) <> "MultiListBox" And DlgName(i) <> "OrgStringBox" And DlgName(i) <> "TrnStringBox" Then
						DrawWindow(GetDlgItem(SuppValue,DlgControlId(DlgName(i))),j)
					End If
				Next i
			End If
		End If
		'设置字串列表框和字串编辑框字体
		If m = 1 Then
			If CheckFont(LFList(1)) = True Then
				j = CreateFont(0,LFList(1))
				If j <> 0 Then
					TempList = ReSplit("UseStrList;OrgStringBox;FindResultsBox",";")
					For i = 0 To UBound(TempList)
						DrawWindow(GetDlgItem(SuppValue,DlgControlId(TempList(i))),j)
					Next i
				End If
			End If
			If CheckFont(LFList(2)) = True Then
				j = CreateFont(0,LFList(2))
				If j <> 0 Then
					DrawWindow(GetDlgItem(SuppValue,DlgControlId("TrnStringBox")),j)
				End If
			End If
		Else
			If CheckFont(LFList(1)) = True Then
				j = CreateFont(0,LFList(1))
				If j <> 0 Then
					DrawWindow(GetDlgItem(SuppValue,DlgControlId("OrgStringBox")),j)
				End If
			End If
			If CheckFont(LFList(2)) = True Then
				j = CreateFont(0,LFList(2))
				If j <> 0 Then
					TempList = ReSplit("UseStrList;TrnStringBox;FindResultsBox;WriteResultsBox",";")
					For i = 0 To UBound(TempList)
						DrawWindow(GetDlgItem(SuppValue,DlgControlId(TempList(i))),j)
					Next i
				End If
			End If
		End If
	Case 2 ' 数值更改或者按下按钮时
		EditStringDlgFunc = True '防止按下按钮关闭对话框窗口
		If getMsgList(UIDataList,MsgList,"EditStringDlgFunc",1) = False Then Exit Function
		Select Case DlgItem$
		Case "StopButton"
			Exit Function
		Case "HelpButton"
			ReDim TempArray(10) As String
			TempArray(0) = MsgList(7)
			TempArray(1) = MsgList(8)
			TempArray(2) = MsgList(9)
			TempArray(3) = MsgList(10)
			TempArray(4) = MsgList(11)
			TempArray(5) = MsgList(12)
			TempArray(6) = MsgList(2)
			TempArray(7) = MsgList(3)
			TempArray(8) = MsgList(104)
			TempArray(9) = MsgList(105)
			TempArray(10) = MsgList(13)
			Select Case ShowPopupMenu(TempArray,vbPopupUseRightButton)
			Case 0
				If StrToLong(Selected(30)) = 1 Then
					If TargetFile.hcsFile.FilePath = SourceFile.hcsFile.FilePath Then
						If OpenCHM(CLng(DlgText("SuppValueBox")),1007,Selected(0),OSLanguage,UIFileList) = True Then Exit Function
					Else
						If OpenCHM(CLng(DlgText("SuppValueBox")),1008,Selected(0),OSLanguage,UIFileList) = True Then Exit Function
					End If
				End If
				Call Help("EditStringHelp")
			Case 1
				If StrToLong(Selected(30)) = 1 Then
					If OpenCHM(CLng(DlgText("SuppValueBox")),1017,Selected(0),OSLanguage,UIFileList) = True Then Exit Function
				End If
				Call Help("MainHelp")
			Case 2
				i = 0
				If StrToLong(Selected(17)) > 0 Then
					DlgVisible "OrgStringText",False
					DlgVisible "TrnStringText",False
					DlgVisible "OrgStringBox",False
					DlgVisible "TrnStringBox",False
					DlgVisible "OrgCheckBox",False
					DlgVisible "TrnCheckBox",False
					DlgVisible "MsgOutputText",True
					DlgVisible "MsgOutputGroup",True
					DlgVisible "WriteResultsCheckBox",IIf(TargetFile.hcsFile.FilePath = SourceFile.hcsFile.FilePath,False,True)
					DlgVisible "ActionProgressBox",True
					DlgVisible "FindResultsBox",False
					DlgVisible "WriteResultsBox",False
					DlgValue "MsgOutputGroup",0
					DlgText "MsgOutputButton",MsgList(30)
					i = GetDlgItem(CLng(DlgText("SuppValueBox")),DlgControlId("ActionProgressBox"))
				ElseIf StrToLong(Selected(17)) < 0 Then
					i = -2
				End If
				i = Download(UpdateSet,UpdateSet(1),3,i)
				If i = 0 Then Exit Function
	    		If UpdateSet(5) < Format(Date,"yyyy-MM-dd") Then
	    			Stemp = True
	    		ElseIf i = 3 And ArrayComp(UpdateSet,UpdateSetBak) = False Then
	    			Stemp = True
	    		End If
	    		If Stemp = True Then
					UpdateSet(5) = Format(Date,"yyyy-MM-dd")
					If WriteSettings("Update") = False Then Exit Function
					UpdateSetBak(5) = UpdateSet(5)
				End If
				If i = 3 Then Call ExitMacro(1)
			Case 3
				intArray = GetListBoxIndexs(GetDlgItem(CLng(DlgText("SuppValueBox")),DlgControlId("UseStrList")))
				If CheckArrEmpty(intArray) = True Then
					ReDim Preserve intArray(0) As Long
					Temp = UseStrDataList(intArray(0)).Source.sString & _
						   "<->" & UseStrDataList(intArray(0)).Trans.sString & _
						   " -scp:" & CStr$(UseStrDataList(intArray(0)).Source.CodePage) & _
						   " -tcp:" & CStr$(UseStrDataList(intArray(0)).Trans.CodePage) & " -se -ac -lng:" & Selected(0)
				End If
				If Dir$(MacroLoc & "\Module\modEncodeQuery.bas") <> "" Then
					MacroRun MacroLoc & "\Module\modEncodeQuery.bas",Temp
				ElseIf Dir$(MacroLoc & "\modEncodeQuery.bas") <> "" Then
					MacroRun MacroLoc & "\modEncodeQuery.bas",Temp
				End If
			Case 4
				intArray = GetListBoxIndexs(GetDlgItem(CLng(DlgText("SuppValueBox")),DlgControlId("UseStrList")))
				If CheckArrEmpty(intArray) = True Then
					ReDim Preserve intArray(0) As Long
					Temp = UseStrDataList(intArray(0)).Source.sString & _
						   "<->" & UseStrDataList(intArray(0)).Trans.sString & _
						   " -scp:" & CStr$(UseStrDataList(intArray(0)).Source.CodePage) & _
						   " -tcp:" & CStr$(UseStrDataList(intArray(0)).Trans.CodePage) & " -se -ac -td -lng:" & Selected(0)
				End If
				If Dir$(MacroLoc & "\Module\modEncodeQuery.bas") <> "" Then
					MacroRun MacroLoc & "\Module\modEncodeQuery.bas",Temp
				ElseIf Dir$(MacroLoc & "\modEncodeQuery.bas") <> "" Then
					MacroRun MacroLoc & "\modEncodeQuery.bas",Temp
				End If
			Case 5
				intArray = GetListBoxIndexs(GetDlgItem(CLng(DlgText("SuppValueBox")),DlgControlId("UseStrList")))
				If CheckArrEmpty(intArray) = True Then
					Temp = SourceFile.FilePath & " -add:" & CStr$(UseStrDataList(intArray(0)).Source.lStartAddress) & " -lng:" & Selected(0)
				Else
					Temp = SourceFile.FilePath & " -lng:" & Selected(0)
				End If
				If Dir$(MacroLoc & "\Module\modReferenceSearch.bas") <> "" Then
					MacroRun MacroLoc & "\Module\modReferenceSearch.bas", Temp
				ElseIf Dir$(MacroLoc & "\modReferenceSearch.bas") <> "" Then
					MacroRun MacroLoc & "\modReferenceSearch.bas", Temp
				End If
			Case 6
				Temp = TargetFile.FilePath
				i = InStrRev(LCase$(TargetFile.FilePath),".bak")
				If i > 1 Then
					If Mid$(LCase$(TargetFile.FilePath),i) = ".bak" Then
						Temp = Left$(TargetFile.FilePath,i - 1)
					End If
				End If
				If Dir$(MacroLoc & "\Module\modEncodeModifier.bas") <> "" Then
					MacroRun MacroLoc & "\Module\modEncodeModifier.bas",Temp
				ElseIf Dir$(MacroLoc & "\modEncodeModifier.bas") <> "" Then
					MacroRun MacroLoc & "\modEncodeModifier.bas",Temp
				End If
			Case 7
				Temp = TargetFile.FilePath
				i = InStrRev(LCase$(TargetFile.FilePath),".bak")
				If i > 1 Then
					If Mid$(LCase$(TargetFile.FilePath),i) = ".bak" Then
						Temp = Left$(TargetFile.FilePath,i - 1)
					End If
				End If
				If Dir$(MacroLoc & "\Module\modPESubFile.bas") <> "" Then
					MacroRun MacroLoc & "\Module\modPESubFile.bas",Temp
				ElseIf Dir$(MacroLoc & "\modPESubFile.bas") <> "" Then
					MacroRun MacroLoc & "\modPESubFile.bas",Temp
				End If
			Case 8
				If PSL.SelectFile(Temp,False,MsgList(107),MsgList(106)) = False Then Exit Function
				If (LCase$(Temp) Like "*.bat") = False Then
					If InStrRev(Temp,".") = 0 Then Temp = Temp & ".dat"
				End If
				If SaveKey(HKEY_CURRENT_USER,"Software\VB And VBA Program Settings\PSLHardCodedString\",Temp) = True Then
					MsgBox MsgList(108),vbOkOnly+vbInformation,MsgList(1)
				Else
					MsgBox Replace$(MsgList(109),"%s","HKCU\Software\VB And VBA Program Settings\PSLHardCodedString"),vbOkOnly+vbInformation,MsgList(1)
				End If
			Case 9
				If MsgBox(MsgList(110),vbYesNo+vbInformation,MsgList(0)) = vbNo Then Exit Function
				If PSL.SelectFile(Temp,True,MsgList(107),MsgList(111)) = False Then Exit Function
				If RestoreKey(HKEY_CURRENT_USER,"Software\VB And VBA Program Settings\PSLHardCodedString\",Temp) = False Then
					MsgBox MsgList(113),vbOkOnly+vbInformation,MsgList(1)
					Exit Function
				ElseIf MsgBox(Replace$(MsgList(112),"%s","HKCS\Software\VB And VBA Program Settings\PSLHardCodedString"),vbYesNo+vbInformation,MsgList(0)) = vbNo Then
					Exit Function
				End If
				'读取设置
				GetSettings("")
				'备份设置
				SelectedBak = Selected
				UpdateSetBak = UpdateSet
				ExtractSetBak = ExtractSet
				StrTypeListBak = StrTypeList
				LFListBak = LFList
				'重新获取字串过滤列表的设置
				GetSettings("FilterStrDic")
				'新获取字串保留列表的设置
				GetSettings("ReserveStrDic")
				'获取过滤字串列表字典为字串过滤显示用
				TempList = ReSplit(ReadBinaryFile(ExtractSet(35),CP_UNICODELITTLE,True),vbNullChar)
				StrList2StrDic(FilterStrDic,TempList,StrToLong(ReSplit(FilterStrSet(17),ItemJoinStr)(1)),1)
			Case 10
				If StrToLong(Selected(30)) = 1 Then
					If OpenCHM(CLng(DlgText("SuppValueBox")),1002,Selected(0),OSLanguage,UIFileList) = True Then Exit Function
				End If
				Call Help("About")
			End Select
			Exit Function
		Case "OrgCheckBox"
			DlgEnable "OrgStringBox",IIf(DlgValue("OrgCheckBox") = 0,True,False)
			Exit Function
		Case "TrnCheckBox"
			DlgEnable "TrnStringBox",IIf(DlgValue("TrnCheckBox") = 0,True,False)
			Exit Function
		Case "OrgVOffsetList"
			DlgValue "TrnVOffsetList",DlgValue("OrgVOffsetList")
			Exit Function
		Case "TrnVOffsetList"
			DlgValue "OrgVOffsetList",DlgValue("TrnVOffsetList")
			Exit Function
		Case "SelectAllButton"
			SetListBoxItems(GetDlgItem(CLng(DlgText("SuppValueBox")),DlgControlId("UseStrList")),-1)
			DlgItem$ = "UseStrList"
		Case "SelectButton"
			n = GetListBoxCount(GetDlgItem(CLng(DlgText("SuppValueBox")),DlgControlId("UseStrList")),0)
			MsgList(115) = Replace$(Replace$(Replace$(MsgList(115),"%1","0"),"%2",CStr$(n)),"%3",DlgText("SelectLogBox"))
			If DlgText("SelectLogBox") = "" Then
				Temp = MsgList(116)
			Else
				TempList = ReSplit(DlgText("SelectLogBox"),ItemJoinStr)
				Temp = TempList(UBound(TempList))
			End If
			Do
				Temp = Trim$(InputBox(MsgList(115),MsgList(114),Temp))
				If Temp = "" Or Temp = MsgList(116) Then
					If DlgText("SelectLogBox") <> "" Then
						If MsgBox(MsgList(117),vbYesNo+vbInformation,MsgList(0)) = vbYes Then
							DlgText "SelectLogBox",""
						End If
					End If
					Exit Function
				ElseIf CheckStrRegExp(Temp,"[-,0-9]",0,1) = False Then
					MsgBox MsgList(118),vbOkOnly+vbInformation,MsgList(1)
				Else
					TempList = ReSplit(Temp,",")
					Stemp = False
					For i = 0 To UBound(TempList)
						If InStr(TempList(i),"-") Then
							TempArray = ReSplit(Temp,"-")
							If TempArray(0) = "" Or TempArray(1) = "" Then
								MsgBox Replace$(MsgList(119),"%s",TempArray(0) & "-" & TempArray(1)),vbOkOnly+vbInformation,MsgList(1)
								Exit For
							ElseIf StrToLong(TempArray(0)) >= StrToLong(TempArray(1)) Then
								MsgBox Replace$(MsgList(120),"%s",TempArray(0) & "-" & TempArray(1)),vbOkOnly+vbInformation,MsgList(1)
								Stemp = True
								Exit For
							ElseIf StrToLong(TempArray(0)) > n Or StrToLong(TempArray(1)) > n Then
								MsgBox Replace$(MsgList(121),"%s",TempArray(0) & "-" & TempArray(1)),vbOkOnly+vbInformation,MsgList(1)
								Stemp = True
								Exit For
							End If
						ElseIf StrToLong(TempList(i)) > n Then
							MsgBox Replace$(MsgList(121),"%s",TempList(i)),vbOkOnly+vbInformation,MsgList(1)
							Stemp = True
							Exit For
						End If
					Next i
					If Stemp = False Then
						ReDim Preserve intList(n) As Long
						k = 0
						For i = 0 To UBound(TempList)
							If InStr(TempList(i),"-") Then
								TempArray = ReSplit(Temp,"-")
								For j = StrToLong(TempArray(0)) To StrToLong(TempArray(1))
									intList(k) = j
									k = k + 1
								Next j
							Else
								intList(k) = StrToLong(TempList(i))
								k = k + 1
							End If
						Next i
						If k = 0 Then Exit Function
						ReDim Preserve intList(k - 1) As Long
						If DlgText("SelectLogBox") = "" Then
							DlgText "SelectLogBox",Temp
							Stemp = True
						ElseIf InStr(ItemJoinStr & DlgText("SelectLogBox") & ItemJoinStr,ItemJoinStr & Temp & ItemJoinStr) = 0 Then
							DlgText "SelectLogBox",DlgText("SelectLogBox") & ItemJoinStr & Temp
							Stemp = True
						Else
							TempList = ReSplit(DlgText("SelectLogBox"),ItemJoinStr)
							If Temp <> TempList(UBound(TempList)) Then Stemp = True
						End If
						If Stemp = True Then
							SetListBoxItems(GetDlgItem(CLng(DlgText("SuppValueBox")),DlgControlId("UseStrList")),intList)
							DlgItem$ = "UseStrList"
							Exit Do
						Else
							Exit Function
						End If
					End If
				End If
			Loop
		Case "FindButton"
			If TargetFile.hcsFile.FilePath <> SourceFile.hcsFile.FilePath Then i = 1
			If FindSet(i) = False Then Exit Function
			intArray = GetListBoxIndexs(GetDlgItem(CLng(DlgText("SuppValueBox")),DlgControlId("UseStrList")))
			If CheckArrEmpty(intArray) = False Then Exit Function
			i = FindString(UseStrDataList,FindStrSet,intArray(0),StrToLong(FindStrSet(10)))
			Select Case i
			Case -2
				MsgBox Replace$(MsgList(19),"%s",FindStrSet(0)),vbOkOnly+vbInformation,MsgList(1)
				Exit Function
			Case -3
				MsgBox MsgList(101),vbOkOnly+vbInformation,MsgList(1)
				Exit Function
			Case -4
				MsgBox MsgList(15),vbOkOnly+vbInformation,MsgList(1)
				Exit Function
			Case Is < 0
				If FindStrSet(5) = "1" Then
					i = FindString(UseStrDataList,FindStrSet,-1)
				ElseIf MsgBox(Replace$(MsgList(16),"%s",FindStrSet(0)),vbYesNo+vbInformation,MsgList(0)) = vbYes Then
					FindStrSet(5) = "1"
					i = FindString(UseStrDataList,FindStrSet,-1)
				Else
					Stemp = True
				End If
			End Select
			If i < 0 And FindStrSet(9) = "0" Then
				If FindStrSet(7) & FindStrSet(8) = "01" Then
					If MsgBox(Replace$(MsgList(17),"%s",FindStrSet(0)),vbYesNo+vbInformation,MsgList(0)) = vbYes Then
						FindStrSet(7) = "1"
						i = FindString(UseStrDataList,FindStrSet,-1)
					Else
						Stemp = True
					End If
				ElseIf FindStrSet(7) & FindStrSet(8) = "10" Then
					If MsgBox(Replace$(MsgList(18),"%s",FindStrSet(0)),vbYesNo+vbInformation,MsgList(0)) = vbYes Then
						FindStrSet(8) = "1"
						i = FindString(UseStrDataList,FindStrSet,-1)
					Else
						Stemp = True
					End If
				End If
			End If
			If i < 0 Then
				If Stemp = False Then
					MsgBox Replace$(MsgList(19),"%s",FindStrSet(0)),vbOkOnly+vbInformation,MsgList(1)
				End If
				Exit Function
			ElseIf i = intArray(0) Then
				If StrToLong(FindStrSet(10)) = 0 Then
					MsgBox Replace$(MsgList(20),"%s",FindStrSet(0)),vbOkOnly+vbInformation,MsgList(1)
					Exit Function
				ElseIf UBound(FindLog) = 0 Then
					MsgBox Replace$(MsgList(20),"%s",FindStrSet(0)),vbOkOnly+vbInformation,MsgList(1)
				End If
			End If
			SetListBoxItems(GetDlgItem(CLng(DlgText("SuppValueBox")),DlgControlId("UseStrList")),i)
			If StrToLong(FindStrSet(10)) = 0 Then
				If CheckArray(FindLog) = True Then
					ReDim FindLog(0) As String
					Set FindLogDic = Nothing
					DlgListBoxArray "FindResultsBox",FindLog()
				End If
			ElseIf CheckArray(FindLog) = False Then
				Set FindLogDic = Nothing
				ReDim FindLog(0) As String
				DlgListBoxArray "FindResultsBox",FindLog()
				Exit Function
			Else
				If UBound(FindLog) = UBound(UseStrDataList) Then Exit Function
				If DlgVisible("FindResultsBox") = False Then
					DlgVisible "OrgStringText",False
					DlgVisible "TrnStringText",False
					DlgVisible "OrgStringBox",False
					DlgVisible "TrnStringBox",False
					DlgVisible "OrgCheckBox",False
					DlgVisible "TrnCheckBox",False
					DlgVisible "MsgOutputText",True
					DlgVisible "MsgOutputGroup",True
					DlgVisible "WriteResultsCheckBox",IIf(TargetFile.hcsFile.FilePath = SourceFile.hcsFile.FilePath,False,True)
					DlgVisible "ActionProgressBox",False
					DlgVisible "FindResultsBox",True
					DlgVisible "WriteResultsBox",False
					DlgValue "MsgOutputGroup",1
					DlgText "MsgOutputButton",MsgList(30)
				End If
				DlgListBoxArray "FindResultsBox",FindLog()
			End If
			DlgItem$ = "UseStrList"
		Case "EditButton"
			TempList = GetToolNameList(Tools,0)
			k = ShowPopupMenu(TempList,vbPopupUseRightButton)
			If k < 0 Then Exit Function
			Temp = TargetFile.FilePath & ".tmp"
			i = InStrRev(LCase$(TargetFile.FilePath),".bak")
			If i > 1 Then
				If Mid$(LCase$(TargetFile.FilePath),i) = ".bak" Then
					Temp = Left$(TargetFile.FilePath,i - 1) & ".tmp"
				End If
			End If
			TempArray = StrDataToString(SourceFile,AllStrDataList,OrgStrTypeList,False)
			If WriteBinaryFile(Temp,CP_UNICODELITTLE,TempArray(0)) = False Then
				On Error Resume Next
				Kill Temp
				On Error GoTo 0
				Exit Function
			End If
			ReDim FileDataList(0) As String
			FileDataList(0) = Temp & JoinStr & "unicodeFFFE"
			If OpenFile(Temp,FileDataList,k,False) = False Then
				If Dir$(Temp) <> "" Then
					On Error Resume Next
					Kill Temp
					On Error GoTo 0
				End If
			End If
			If k > 0 Then Exit Function
			If Dir$(Temp) <> "" Then
				On Error Resume Next
				Kill Temp
				On Error GoTo 0
			End If
			Exit Function
		Case "UndoWriteButton"
			For i = LBound(AllStrDataList) To UBound(AllStrDataList)
				AllStrDataList(i).WriteState = 0
				AllStrDataList(i).SourceStringClearState = 0
			Next i
			Temp = TargetFile.FilePath
			i = InStrRev(LCase$(TargetFile.FilePath),".bak")
			If i > 1 Then
				If Mid$(LCase$(TargetFile.FilePath),i) = ".bak" Then
					Temp = Left$(TargetFile.FilePath,i - 1)
				End If
			End If
			If Dir$(Temp & ".bak") <> "" Then
				On Error Resume Next
				If Dir$(Temp) <> "" Then
					i = GetAttr(Temp)
					If i <> vbNormal Then SetAttr Temp,vbNormal
					Kill Temp
				End If
				Name Temp & ".bak" As Temp
				If Err.Number <> 0 Then
					Err.Source = "NotUnWriteFile"
					Err.Description = Err.Description & JoinStr & Temp
					Call sysErrorMassage(Err,2)
					Exit Function
				End If
				On Error GoTo 0
				TargetFile.FilePath = Temp
			End If
			ReDim WriteLog(0) As String
			Set WriteLogDic = Nothing
			DlgListBoxArray "WriteResultsBox",WriteLog()
			DlgVisible "AllWriteButton",True
			DlgVisible "UndoWriteButton",False
			If CheckDataArray(UseStrDataList) = True Then
				DlgEnable "WriteButton",True
				DlgEnable "AllWriteButton",True
			End If
			DlgVisible "OrgStringText",True
			DlgVisible "TrnStringText",True
			DlgVisible "OrgStringBox",True
			DlgVisible "TrnStringBox",True
			DlgVisible "OrgCheckBox",True
			DlgVisible "TrnCheckBox",True
			DlgVisible "MsgOutputText",False
			DlgVisible "MsgOutputGroup",False
			DlgVisible "ActionProgressBox",False
			DlgVisible "FindResultsBox",False
			DlgVisible "WriteResultsBox",False
			DlgText "MsgOutputButton",MsgList(22)
			Exit Function
		Case "SaveButton", "CancelButton", "ExitButton"
			m = IIf(TargetFile.hcsFile.FilePath = SourceFile.hcsFile.FilePath,3,4)
			If DlgItem$ = "SaveButton" Then
				If CheckDataArray(AllStrDataList) = False Then
					MsgBox MsgList(52),vbOkOnly+vbInformation,MsgList(1)
					Exit Function
				End If
				If DlgValue("ModeCheckBox") = 1 Then
					If MsgBox(MsgList(23),vbYesNo+vbInformation,MsgList(0)) = vbNo Then
						Exit Function
					End If
				End If
			ElseIf CheckDataArray(AllStrDataList) = False Then
				EditStringDlgFunc = False
				Exit Function
			ElseIf DlgValue("ModeCheckBox") = 1 Then
				EditStringDlgFunc = False
				Exit Function
			Else
				Select Case MsgBox(MsgList(96),vbYesNoCancel+vbInformation,MsgList(0))
				Case vbCancel
					Exit Function
				Case vbNo
					EditStringDlgFunc = False
					Exit Function
				End Select
			End If
			TempArray = StrDataToString(SourceFile,AllStrDataList,OrgStrTypeList,IIf(m = 3,False,True))
			If WriteToFile(TargetFile.hcsFile.FilePath,TempArray(0),"unicodeFFFE") = False Then Exit Function
			If m = 4 Then
				Temp = TargetFile.FilePath & ".dat"
				i = InStrRev(LCase$(TargetFile.FilePath),".bak")
				If i > 1 Then
					If Mid$(LCase$(TargetFile.FilePath),i) = ".bak" Then
						Temp = Left$(TargetFile.FilePath,i - 1) & ".dat"
					End If
				End If
				WriteBinaryFile Temp,CP_UNICODELITTLE,TempArray(1),True
			End If
			MsgBox Replace$(MsgList(24),"%s",TargetFile.hcsFile.FilePath),vbOkOnly+vbInformation,MsgList(1)
			If m = 3 Then
				If (AddToPslProject(SourceFile) = -1) And (Not src Is Nothing) Then
					If MsgBox(MsgList(25),vbYesNo+vbInformation,MsgList(0)) = vbYes Then
						'更新时允许自动删除20个以上字串
						Stemp = PSL.Option(pslOptionBatchDelete)
						If Stemp = False Then PSL.Option(pslOptionBatchDelete) = True
						For i = 1 To src.Project.SourceLists.Count
							If src.Project.SourceLists(i).SourceFile = SourceFile.hcsFile.FilePath Then
								If UpdatePSLList(SourceFile,src.Project.SourceLists(i),True) > 2 Then
									DlgEnable "AllResetButton",True
								End If
								Exit For
							End If
						Next i
						'还原更新时允许自动删除20个以上字串选项的设置
						If Stemp = False Then PSL.Option(pslOptionBatchDelete) = Stemp
					End If
				End If
			ElseIf DlgEnable("AllResetButton") = True Then
				If DataComps(AllStrDataList,AllStrDataListBak,StrIDIndexDic,8) = True Then
					If MsgBox(MsgList(26),vbYesNo+vbInformation,MsgList(0)) = vbYes Then
						Dim hcsTrn As PslTransList
						For i = 1 To trn.Project.SourceLists.Count
							If trn.Project.SourceLists(i).SourceFile = SourceFile.hcsFile.FilePath Then
								Set hcsTrn = trn.Project.TransLists(trn.Project.SourceLists(i),trn.Language.LangID)
								If hcsTrn.SourceList.LastChange > hcsTrn.LastUpdate Then hcsTrn.Update
								Exit For
							End If
						Next i
						If hcsTrn Is Nothing Then Exit Function
						Stemp = False
						If hcsTrn.IsOpen = False Then
							If hcsTrn.Open = False Then Exit Function
							Stemp = True
						End If
						'显示消息输出模式
						If StrToLong(Selected(17)) > 0 Then
							If DlgVisible("ActionProgressBox") = False Then
								DlgVisible "OrgStringText",False
								DlgVisible "TrnStringText",False
								DlgVisible "OrgStringBox",False
								DlgVisible "TrnStringBox",False
								DlgVisible "OrgCheckBox",False
								DlgVisible "TrnCheckBox",False
								DlgVisible "MsgOutputText",True
								DlgVisible "MsgOutputGroup",True
								DlgVisible "ActionProgressBox",True
								DlgVisible "FindResultsBox",False
								DlgVisible "WriteResultsBox",False
								DlgValue "MsgOutputGroup",0
								DlgText "MsgOutputButton",MsgList(30)
							End If
							i = GetDlgItem(CLng(DlgText("SuppValueBox")),DlgControlId("ActionProgressBox"))
							SetTextBoxString i,Replace$(MsgList(27),"%s",hcsTrn.Title & ":" & PSL.GetLangCode(hcsTrn.Language.LangID,pslCodeText))
						ElseIf StrToLong(Selected(17)) < 0 Then
							PSL.Output Replace$(MsgList(27),"%s",hcsTrn.Title & ":" & PSL.GetLangCode(hcsTrn.Language.LangID,pslCodeText))
						End If
						With hcsTrn
							If ParentStrNum = .StringCount Then
								n = UpdatePSLTrans(hcsTrn,AllStrDataList,False)
							ElseIf MsgBox(MsgList(91),vbYesNo+vbInformation,MsgList(1)) = vbYes Then
								n = UpdatePSLTrans(hcsTrn,AllStrDataList,True)
							End If
						End With
						If Stemp = True Then hcsTrn.Close
						If StrToLong(Selected(17)) > 0 Then
							i = GetDlgItem(CLng(DlgText("SuppValueBox")),DlgControlId("ActionProgressBox"))
							SetTextBoxString i,Replace$(MsgList(28),"%s",CStr$(n)),True
						ElseIf StrToLong(Selected(17)) < 0 Then
							PSL.Output Replace$(MsgList(28),"%s",CStr$(n))
						End If
					End If
				End If
			End If
			If DlgItem$ = "SaveButton" Then
				DlgValue "ModeCheckBox",1
			Else
				EditStringDlgFunc = False
			End If
			Exit Function
		Case "AllResetButton"
			m = IIf(TargetFile.hcsFile.FilePath = SourceFile.hcsFile.FilePath,1,2)
			If DataComps(AllStrDataList,AllStrDataListBak,StrIDIndexDic,m) = True Then
				'提取来源或翻译字串列表，用于显示
				StrIDIndexDic.RemoveAll
				StrIDIndexDicBak.RemoveAll
				n = UBound(AllStrDataListBak)
				ReDim TempList(n) As String
				For i = 0 To n
					With AllStrDataListBak(i)
						TempList(i) = .Trans.sString
						If Not StrIDIndexDic.Exists(.ID) Then
							StrIDIndexDic.Add(.ID,i)
							StrIDIndexDicBak.Add(.ID,i)
						End If
					End With
				Next i
				DlgListBoxArray "UseStrList",TempList()
				DlgValue "UseStrList",Array(0)
			ElseIf DlgEnable("AllShowButton") = True Then
				TempList = SubStringList(AllStrDataListBak)
				DlgListBoxArray "UseStrList",TempList()
				DlgValue "UseStrList",Array(0)
			End If
			AllStrDataList = AllStrDataListBak
			UseStrDataList = AllStrDataList
			GetFreeByteSecList = GetFreeByteSecListBak
			FreeByteList = FreeByteListBak
			OrgStrTypeList = OrgStrTypeListBak
			'DlgEnable "RefreshButton",True
			'DlgEnable "FilterShowButton",True
			DlgEnable "AllShowButton",False
			DlgEnable "ResetButton",False
			DlgEnable "AllResetButton",False
			If DlgValue("ModeCheckBox") = 2 Then DlgValue "ModeCheckBox",1
			If m = 2 And SourceFile.Magic <> "" Then
				'显示消息输出模式
				j = StrToLong(Selected(17))
				If j > 0 Then
					If DlgVisible("ActionProgressBox") = False Then
						DlgVisible "OrgStringText",False
						DlgVisible "TrnStringText",False
						DlgVisible "OrgStringBox",False
						DlgVisible "TrnStringBox",False
						DlgVisible "OrgCheckBox",False
						DlgVisible "TrnCheckBox",False
						DlgVisible "MsgOutputText",True
						DlgVisible "MsgOutputGroup",True
						DlgVisible "ActionProgressBox",True
						DlgVisible "FindResultsBox",False
						DlgVisible "WriteResultsBox",False
						DlgValue "MsgOutputGroup",0
						DlgText "MsgOutputButton",MsgList(30)
					End If
					j = GetDlgItem(CLng(DlgText("SuppValueBox")),DlgControlId("ActionProgressBox"))
				ElseIf j < 0 Then
					j = -2
				End If
				Call ResetAndMoveStrings(TargetFile,AllStrDataList,1,MsgList(29),MsgList(21),j)
			End If
			'在字串类型列表中显示被还原的字串类型
			TempList = MergeStrType2StrList(StrTypeList,OrgStrTypeList,OrgStrTypeList,ReSplit(MsgList(4),ItemJoinStr))
			DlgListBoxArray "StrTypeNameList",TempList()
			DlgItem$ = "UseStrList"
		Case "MsgOutputButton"
			Select Case DlgText("MsgOutputButton")
			Case MsgList(22)
				DlgText "MsgOutputButton",MsgList(30)
				DlgVisible "OrgStringText",False
				DlgVisible "TrnStringText",False
				DlgVisible "OrgStringBox",False
				DlgVisible "TrnStringBox",False
				DlgVisible "OrgCheckBox",False
				DlgVisible "TrnCheckBox",False
				DlgVisible "MsgOutputText",True
				DlgVisible "MsgOutputGroup",True
				If TargetFile.hcsFile.FilePath = SourceFile.hcsFile.FilePath Then
					Select Case DlgValue("MsgOutputGroup")
					Case 0
						DlgVisible "ActionProgressBox",True
						DlgVisible "FindResultsBox",False
						DlgVisible "WriteResultsBox",False
					Case 1
						DlgVisible "ActionProgressBox",False
						DlgVisible "FindResultsBox",True
						DlgVisible "WriteResultsBox",False
					Case Else
						DlgVisible "ActionProgressBox",False
						DlgVisible "FindResultsBox",False
						DlgVisible "WriteResultsBox",False
					End Select
					DlgVisible "WriteResultsCheckBox",False
				Else
					Select Case DlgValue("MsgOutputGroup")
					Case 0
						DlgVisible "ActionProgressBox",True
						DlgVisible "FindResultsBox",False
						DlgVisible "WriteResultsBox",False
					Case 1
						DlgVisible "ActionProgressBox",False
						DlgVisible "FindResultsBox",True
						DlgVisible "WriteResultsBox",False
					Case Else
						DlgVisible "ActionProgressBox",False
						DlgVisible "FindResultsBox",False
						DlgVisible "WriteResultsBox",True
					End Select
					DlgVisible "WriteResultsCheckBox",True
				End If
			Case MsgList(30)
				DlgText "MsgOutputButton",MsgList(22)
				DlgVisible "OrgStringText",True
				DlgVisible "TrnStringText",True
				DlgVisible "OrgStringBox",True
				DlgVisible "TrnStringBox",True
				DlgVisible "OrgCheckBox",True
				DlgVisible "TrnCheckBox",True
				DlgVisible "MsgOutputText",False
				DlgVisible "MsgOutputGroup",False
				DlgVisible "ActionProgressBox",False
				DlgVisible "FindResultsBox",False
				DlgVisible "WriteResultsBox",False
			End Select
			Exit Function
		Case "MsgOutputGroup"
			If TargetFile.hcsFile.FilePath = SourceFile.hcsFile.FilePath Then
				Select Case DlgValue("MsgOutputGroup")
				Case 0
					DlgVisible "ActionProgressBox",True
					DlgVisible "FindResultsBox",False
					DlgVisible "WriteResultsBox",False
				Case 1
					DlgVisible "ActionProgressBox",False
					DlgVisible "FindResultsBox",True
					DlgVisible "WriteResultsBox",False
				Case Else
					DlgVisible "ActionProgressBox",False
					DlgVisible "FindResultsBox",False
					DlgVisible "WriteResultsBox",False
				End Select
				DlgVisible "WriteResultsCheckBox",False
			Else
				Select Case DlgValue("MsgOutputGroup")
				Case 0
					DlgVisible "ActionProgressBox",True
					DlgVisible "FindResultsBox",False
					DlgVisible "WriteResultsBox",False
				Case 1
					DlgVisible "ActionProgressBox",False
					DlgVisible "FindResultsBox",True
					DlgVisible "WriteResultsBox",False
				Case Else
					DlgVisible "ActionProgressBox",False
					DlgVisible "FindResultsBox",False
					DlgVisible "WriteResultsBox",True
				End Select
				DlgVisible "WriteResultsCheckBox",True
			End If
			Exit Function
		Case Is <> "UseStrList", Is <> "WriteResultsBox", Is <> "FindResultsBox"
			intArray = GetListBoxIndexs(GetDlgItem(CLng(DlgText("SuppValueBox")),DlgControlId("UseStrList")))
			If CheckArrEmpty(intArray) = False Then ReDim intArray(0) As Long
			intList = intArray
			If DlgEnable("AllShowButton") = True Then
				GetIndexList(StrIDIndexDic,UseStrDataList,intList,False)
			End If
		End Select

		Select Case DlgItem$
		Case "UpButton"
			ReDim Preserve intArray(0) As Long
			intArray(0) = intArray(0) - 1
			DlgValue "UseStrList",intArray()
			DlgItem$ = "UseStrList"
		Case "DownButton"
			ReDim Preserve intArray(0) As Long
			intArray(0) = intArray(0) + 1
			DlgValue "UseStrList",intArray()
			DlgItem$ = "UseStrList"
		Case "ReExtractButton","AddButton","AppButton","ImportSrcButton","ImportTranButton","LoadHCSFile"
			Select Case DlgItem$
			Case "ReExtractButton"
				TempList = ReSplit(MsgList(49),";")
				m = IIf(TargetFile.hcsFile.FilePath = SourceFile.hcsFile.FilePath,1,0)
				If m = 1 Then
					TempList(5) = ""
				Else
					TempList(2) = "": TempList(3) = "": TempList(4) = ""
				End If
				If Dir$(TargetFile.hcsFile.FilePath) = "" Then TempList(1) = ""
				If CheckDataArray(AllStrDataList) = False Then
					If TargetFile.FilePath = "" Then
						TempList(3) = "": TempList(4) = ""
					End If
					TempList(5) = ""
				End If
				t = ShowPopupMenu(TempList,vbPopupUseRightButton)
			Case "LoadHCSFile"
				m = IIf(TargetFile.hcsFile.FilePath = SourceFile.hcsFile.FilePath,1,0)
				t = 1
			Case "ImportSrcButton"
				t = 2
			Case "AddButton"
				t = 3
			Case "AppButton"
				t = 4
			Case "ImportTranButton"
				t = 5
			End Select
			Select Case t
			Case Is < 0
				Exit Function
			Case 0	'提取字串
				If CheckDataArray(AllStrDataList) = True Then
					If DlgValue("ModeCheckBox") <> 1 Then
						If MsgBox(MsgList(14),vbYesNo+vbInformation,MsgList(0)) = vbNo Then Exit Function
					End If
				End If
				TempList = Selected
				ReDim tmpLFList(2) As LOG_FONT
				tmpLFList = LFList
				Stemp2 = DlgVisible("UseStrList")
				j = GetDlgItem(CLng(DlgText("SuppValueBox")),DlgControlId("ActionProgressBox"))
				If StrToLong(Selected(17)) < 0 Then j = -j
				'显示消息输出模式
				If DlgVisible("ActionProgressBox") = False Then
					DlgVisible "OrgStringText",False
					DlgVisible "TrnStringText",False
					DlgVisible "OrgStringBox",False
					DlgVisible "TrnStringBox",False
					DlgVisible "OrgCheckBox",False
					DlgVisible "TrnCheckBox",False
					DlgVisible "MsgOutputText",True
					DlgVisible "MsgOutputGroup",True
					DlgVisible "WriteResultsCheckBox",IIf(m = 1,False,True)
					DlgVisible "ActionProgressBox",True
					DlgVisible "FindResultsBox",False
					DlgVisible "WriteResultsBox",False
					DlgValue "MsgOutputGroup",0
					DlgText "MsgOutputButton",MsgList(30)
				End If
				n = ReExtractString(SourceFile,TargetFile,j)
				Stemp3 = IIf(Selected(0) = TempList(0),False,True)
				If Stemp3 = True Then
					If getMsgList(UIDataList,MsgList,"EditStringDlgFunc",1) = False Then Exit Function
				End If
				Stemp4 = FontComps(LFList,tmpLFList)
				MsgList(50) = Replace$(Replace$(MsgList(50),"%s",Version),"%d",TargetFile.hcsFile.FilePath)
				If Len(MsgList(50)) > 110 Then
					MsgList(50) = Left$(MsgList(50),InStr(MsgList(50),"\")) & "..." & Right(MsgList(50),110 - Len(Left$(MsgList(50),InStr(MsgList(50),"\"))))
				End If
				DlgText -1,MsgList(50)
				'显示消息输出模式
				If n > 0 Then DlgValue "ModeCheckBox",0
				m = IIf(TargetFile.hcsFile.FilePath = SourceFile.hcsFile.FilePath,1,0)
				DlgVisible "WriteResultsCheckBox",IIf(m = 1,False,True)
				If CheckArray(FindLog) = False Then DlgListBoxArray "FindResultsBox",FindLog()
				If CheckArray(WriteLog) = False Then DlgListBoxArray "WriteResultsBox",WriteLog()
				DlgItem$ = "UseStrList"
			Case 1	'打开现有字串
				If CheckDataArray(AllStrDataList) = True Then
					If DlgValue("ModeCheckBox") <> 1 Then
						If MsgBox(MsgList(48),vbYesNo+vbInformation,MsgList(0)) = vbNo Then Exit Function
					End If
				End If
				If getMsgList(UIDataList,MsgList,"CheckData",1) = False Then Exit Function
				If DlgValue("LoadDataCheckBox") = 1 Then
					SourceFile.hcsFile.DateLastModified = FileDateTime(SourceFile.hcsFile.FilePath)
					TargetFile.hcsFile.DateLastModified = FileDateTime(TargetFile.hcsFile.FilePath)
					If SourceFile.hcsFile.DateLastModified > TargetFile.hcsFile.DateLastModified Then
						MsgBox Replace(MsgList(2),"%s",TargetFile.hcsFile.FilePath),vbOkOnly+vbInformation,MsgList(1)
						Exit Function
					End If
				End If
				Temp = ReadTextFile(TargetFile.hcsFile.FilePath,"unicodeFFFE")
				If Temp = "" Then
					MsgBox Replace(MsgList(3),"%s",TargetFile.hcsFile.FilePath),vbOkOnly+vbInformation,MsgList(1)
					Exit Function
				End If
				Call CheckData(SourceFile.FileName,TargetFile,Temp,False,UseStrTypeList,0)
				MsgList(2) = ""
				If TargetFile.hcsFile.SourceFileName <> SourceFile.OrigionalFileName Then
					MsgList(2) = MsgList(4)
				ElseIf TargetFile.hcsFile.SourceFileVersion <> SourceFile.FileVersion Then
					MsgList(2) = MsgList(5)
				ElseIf TargetFile.hcsFile.SourceFileLangID <> SourceFile.LanguageID Then
					MsgList(2) = MsgList(6)
				ElseIf TargetFile.hcsFile.FileFormat = False Then
					MsgList(2) = MsgList(7)
				End If
				If MsgList(2) <> "" Then
					MsgBox Replace(MsgList(2),"%s",TargetFile.hcsFile.FilePath),vbOkOnly+vbInformation,MsgList(1)
					Exit Function
				End If
				x = 0
				If TargetFile.hcsFile.SourceFileSize <> SourceFile.FileSize Then
					If MsgBox(Replace$(MsgList(8) & MsgList(10),"%s",TargetFile.hcsFile.FilePath),vbYesNo+vbInformation,MsgList(0)) = vbNo Then
						Exit Function
					End If
					x = 1
				End If
				If CStr(TargetFile.hcsFile.SourceFileDateTime) <> CStr(SourceFile.DateLastModified) Then
					If MsgBox(Replace$(MsgList(9) & MsgList(10),"%s",TargetFile.hcsFile.FilePath),vbYesNo+vbInformation,MsgList(0)) = vbNo Then
						Exit Function
					End If
					x = x + 10
				End If
				If x > 0 Then
					If ModifyDataFile(SourceFile,ReadTextFile(SourceFile.hcsFile.FilePath,"unicodeFFFE"),False,x) = False Then
						MsgBox(MsgList(12),vbOkOnly+vbInformation,MsgList(0))
						Exit Function
					End If
				End If
				OrgStrTypeList = UseStrTypeList: OrgStrTypeListBak = UseStrTypeList
				StrTypeListBak = StrTypeList: RefTypeListBak = RefTypeList
				If StringTerminator = "" Then
					ExtractSet(31) = "0" & ItemJoinStr & ReSplit(ExtractSet(31),ItemJoinStr,2)(1)
					StringTerminator = "(\x00+)"
				End If
				ExtractSet(31) = AddStrEndCharSet(ExtractSet(31),ReSplit(SourceFile.FileName,"(")(0) & JoinStr & StringTerminator)
				ExtractSetBak(31) = ExtractSet(31)
				If CheckStrTypeArray(UseStrTypeList) = True Then
					ExtractSet(10) = "1"
					ExtractSetBak = ExtractSet
				End If
				If getMsgList(UIDataList,MsgList,"EditStringDlgFunc",1) = False Then Exit Function
				'确定非 PE 文件是否获取引用
				Select Case SourceFile.Magic
				Case "NotPE32","NotPE64",""
					SourceFile.Magic = UseRefTypeList(0).FileMagic
					TargetFile.Magic = SourceFile.Magic
				End Select
				'显示消息输出模式
				j = StrToLong(Selected(17))
				If j > 0 Then
					If DlgVisible("ActionProgressBox") = False Then
						DlgVisible "OrgStringText",False
						DlgVisible "TrnStringText",False
						DlgVisible "OrgStringBox",False
						DlgVisible "TrnStringBox",False
						DlgVisible "OrgCheckBox",False
						DlgVisible "TrnCheckBox",False
						DlgVisible "MsgOutputText",True
						DlgVisible "MsgOutputGroup",True
						DlgVisible "WriteResultsCheckBox",IIf(m = 1,False,True)
						DlgVisible "ActionProgressBox",True
						DlgVisible "FindResultsBox",False
						DlgVisible "WriteResultsBox",False
						DlgValue "MsgOutputGroup",0
						DlgText "MsgOutputButton",MsgList(30)
					End If
					j = GetDlgItem(CLng(DlgText("SuppValueBox")),DlgControlId("ActionProgressBox"))
				ElseIf j < 0 Then
					j = -2
				End If
				n = ParseHCSFile(SourceFile,TargetFile,Temp,StrToLong(Selected(1)),IIf(x = 0,False,True),j) + 1
				If n < 1 Then Exit Function
				If n > 1 Then
					If j > 0 Then
						SetTextBoxString j,MsgList(51),True
					ElseIf j < 0 Then
						PSL.Output MsgList(51)
					End If
					Call ShowMoveMsg(MoveString(TargetFile,AllStrDataList,0,StrToLong(Selected(1)),j),0,4)
				End If
				DlgValue "ModeCheckBox",1
				DlgItem$ = "UseStrList"
			Case 2	'导入原始字串
				TempList = Selected
				ReDim tmpLFList(2) As LOG_FONT
				tmpLFList = LFList
				Do
					Stemp = ImportSet(1)
					Stemp3 = IIf(Selected(0) = TempList(0),False,True)
					If Stemp3 = True Then
						If getMsgList(UIDataList,MsgList,"EditStringDlgFunc",1) = False Then Exit Function
					End If
					If Stemp = False Then Exit Do
					ReDim intArray(0) As Long
					intArray(0) = intList(0)
					'显示消息输出模式
					j = StrToLong(Selected(17))
					If j > 0 Then
						If DlgVisible("ActionProgressBox") = False Then
							DlgVisible "OrgStringText",False
							DlgVisible "TrnStringText",False
							DlgVisible "OrgStringBox",False
							DlgVisible "TrnStringBox",False
							DlgVisible "OrgCheckBox",False
							DlgVisible "TrnCheckBox",False
							DlgVisible "MsgOutputText",True
							DlgVisible "MsgOutputGroup",True
							DlgVisible "WriteResultsCheckBox",False
							DlgVisible "ActionProgressBox",True
							DlgVisible "FindResultsBox",False
							DlgVisible "WriteResultsBox",False
							DlgValue "MsgOutputGroup",0
							DlgText "MsgOutputButton",MsgList(30)
						End If
						j = GetDlgItem(CLng(DlgText("SuppValueBox")),DlgControlId("ActionProgressBox"))
					ElseIf j < 0 Then
						j = -2
					End If
					n = ImportSrcString(SourceFile,ImportSrcSet,intArray,j)
					If n > 0 Then Exit Do
				Loop
				Stemp4 = FontComps(LFList,tmpLFList)
				'DlgText -1,Replace$(Replace$(MsgList(50),"%s",Version),"%d",TargetFile.hcsFile.FilePath)
				If n > 0 Then
					If ImportSrcSet(3) = "0" Or DlgEnable("AllShowButton") = True Then
						If ImportSrcSet(3) = "0" Then
							ReDim intArray(0) As Long
						Else
							'ID 列表转索引列表
							For i = 0 To n - 1
								intArray(i) = StrIDIndexDic.Item(intArray(i))
							Next i
						End If
						If j <> 0 Then
							If UBound(UseStrDataList) > 10000 Then
								If j > 0 Then
									SetTextBoxString j,MsgList(99),True
								ElseIf j < 0 Then
									PSL.Output MsgList(99)
								End If
							Else
								j = 0
							End If
						End If
						TmpList = SubStringList(UseStrDataList,j)
						DlgListBoxArray "UseStrList",TmpList()
						SetListBoxItems(GetDlgItem(CLng(DlgText("SuppValueBox")),DlgControlId("UseStrList")),intArray)
					Else
						'ID 列表转索引列表并显示
						j = GetDlgItem(CLng(DlgText("SuppValueBox")),DlgControlId("UseStrList"))
						For i = 0 To n - 1
							intArray(i) = StrIDIndexDic.Item(intArray(i))
							AddListBoxItems(j,UseStrDataList(intArray(i)).Source.sString,intArray(i))
							If UseStrDataList(intArray(i)).Source.lCharLength > x Then
								x = UseStrDataList(intArray(i)).Source.lCharLength
								y = intArray(i)
							End If
						Next i
						'设置水平滚动条的长度以查看最长列表项的全部字符串
						i = GetStrPixels(j,UseStrDataList(y).Source.sString)
						If i > SendMessageLNG(j, LB_GETHORIZONTALEXTENT, 0&, 0&) Then
							SendMessageLNG(j, LB_SETHORIZONTALEXTENT, i, 0&)
						End If
						If ImportSrcSet(3) = "0" Then ReDim intArray(0) As Long
						SetListBoxItems(j,intArray)
					End If
					DlgEnable "AllShowButton",False
					DlgEnable "AllResetButton",True
					If DlgValue("ModeCheckBox") = 1 Then DlgValue "ModeCheckBox",2
				End If
				DlgItem$ = "UseStrList"
			Case 3,4	'3 = 插入字串，4 = 附加字串
				i = intList(0) + IIf(t = 3,0,1)
				If i > 0 And AllStrDataList(intList(0)).Source.CodePage > 0 Then
					AddStrSet(4) = CStr$(AllStrDataList(i - 1).Source.lMaxAddress + 1)
				Else
					AddStrSet(4) = CStr$(SourceFile.SecList(SourceFile.MinSecID).lPointerToRawData)
				End If
				If StrToLong(AddStrSet(4)) > StrToLong(AddStrSet(5)) Then AddStrSet(5) = ""
				AddStrSet(8) = CStr$(intList(0))
				'备份显示语言设置，以便添加字串时更改语言设置
				TempList = Selected
				ReDim tmpLFList(2) As LOG_FONT
				tmpLFList = LFList
				Do
					Stemp = AddStringSet(AddStrSet)
					Stemp3 = IIf(Selected(0) = TempList(0),False,True)
					If Stemp3 = True Then
						If getMsgList(UIDataList,MsgList,"EditStringDlgFunc",1) = False Then Exit Function
					End If
					If Stemp = False Then Exit Do
					ReDim intArray(0) As Long
					intArray(0) = intList(0)
					'显示消息输出模式
					j = StrToLong(Selected(17))
					If j > 0 Then
						If DlgVisible("ActionProgressBox") = False Then
							DlgVisible "OrgStringText",False
							DlgVisible "TrnStringText",False
							DlgVisible "OrgStringBox",False
							DlgVisible "TrnStringBox",False
							DlgVisible "OrgCheckBox",False
							DlgVisible "TrnCheckBox",False
							DlgVisible "MsgOutputText",True
							DlgVisible "MsgOutputGroup",True
							DlgVisible "WriteResultsCheckBox",False
							DlgVisible "ActionProgressBox",True
							DlgVisible "FindResultsBox",False
							DlgVisible "WriteResultsBox",False
							DlgValue "MsgOutputGroup",0
							DlgText "MsgOutputButton",MsgList(30)
						End If
						j = GetDlgItem(CLng(DlgText("SuppValueBox")),DlgControlId("ActionProgressBox"))
					ElseIf j < 0 Then
						j = -2
					End If
					n = AddString(SourceFile,AddStrSet,intArray,j)
					If n > 0 Then Exit Do
				Loop
				Stemp4 = FontComps(LFList,tmpLFList)
				'DlgText -1,Replace$(Replace$(MsgList(50),"%s",Version),"%d",TargetFile.hcsFile.FilePath)
				If n > 0 Then
					If DlgEnable("AllShowButton") = True Then
						'ID 列表转索引列表
						For i = 0 To n - 1
							intArray(i) = StrIDIndexDic.Item(intArray(i))
						Next i
						If j <> 0 Then
							If UBound(UseStrDataList) > 10000 Then
								If j > 0 Then
									SetTextBoxString j,MsgList(99),True
								ElseIf j < 0 Then
									PSL.Output MsgList(99)
								End If
							Else
								j = 0
							End If
						End If
						TmpList = SubStringList(UseStrDataList,j)
						DlgListBoxArray "UseStrList",TmpList()
						SetListBoxItems(GetDlgItem(CLng(DlgText("SuppValueBox")),DlgControlId("UseStrList")),intArray)
					Else
						'ID 列表转索引列表并显示
						j = GetDlgItem(CLng(DlgText("SuppValueBox")),DlgControlId("UseStrList"))
						For i = 0 To n - 1
							intArray(i) = StrIDIndexDic.Item(intArray(i))
							AddListBoxItems(j,UseStrDataList(intArray(i)).Source.sString,intArray(i))
							If UseStrDataList(intArray(i)).Source.lCharLength > x Then
								x = UseStrDataList(intArray(i)).Source.lCharLength
								y = intArray(i)
							End If
						Next i
						'设置水平滚动条的长度以查看最长列表项的全部字符串
						i = GetStrPixels(j,UseStrDataList(y).Source.sString)
						If i > SendMessageLNG(j, LB_GETHORIZONTALEXTENT, 0&, 0&) Then
							SendMessageLNG(j, LB_SETHORIZONTALEXTENT, i, 0&)
						End If
						SetListBoxItems(j,intArray)
					End If
					DlgEnable "AllResetButton",True
					DlgEnable "AllShowButton",False
					If DlgValue("ModeCheckBox") = 1 Then DlgValue "ModeCheckBox",2
				End If
				DlgItem$ = "UseStrList"
			Case 5	'导入翻译
				'显示消息输出模式
				j = StrToLong(Selected(17))
				If j > 0 Then
					If DlgVisible("ActionProgressBox") = False Then
						DlgVisible "OrgStringText",False
						DlgVisible "TrnStringText",False
						DlgVisible "OrgStringBox",False
						DlgVisible "TrnStringBox",False
						DlgVisible "OrgCheckBox",False
						DlgVisible "TrnCheckBox",False
						DlgVisible "MsgOutputText",True
						DlgVisible "MsgOutputGroup",True
						DlgVisible "ActionProgressBox",True
						DlgVisible "FindResultsBox",False
						DlgVisible "WriteResultsBox",False
						DlgValue "MsgOutputGroup",0
						DlgText "MsgOutputButton",MsgList(30)
					End If
					j = GetDlgItem(CLng(DlgText("SuppValueBox")),DlgControlId("ActionProgressBox"))
				ElseIf j < 0 Then
					j = -2
				End If
				Do
					If ImportSet(0) = False Then Exit Function
					intArry = intList
					If ImportTranSet(2) & ImportTranSet(3) = "01" Then
						If GetIndexList(StrIDIndexDic,AllStrDataList,intArry,True) = False Then
							Exit Function
						End If
					End If
					n = ImportTranString(TargetFile,ImportTranSet,intArry,j)
					If n > 0 Then Exit Do
				Loop
				If n < 1 Then Exit Function
				'重置字串数据并重新移位
				Call ResetAndMoveString(TargetFile,AllStrDataList,intArry,True,True,MsgList,j)
				'更新翻译字串列表，用于显示
				If DlgEnable("AllShowButton") = True Then
					If ImportTranSet(2) & ImportTranSet(3) = "10" Then
						For i = LBound(intArry) To UBound(intArry)
							k = UseStrIDIndexDic(AllStrDataList(intArry(i)).ID)
							UseStrDataList(k) = AllStrDataList(intArry(i))
							intArry(i) = k
						Next i
					Else
						UseStrDataList = AllStrDataList
						DlgEnable "AllShowButton",False
					End If
				Else
					UseStrDataList = AllStrDataList
				End If
				If j <> 0 Then
					If UBound(UseStrDataList) > 10000 Then
						If j > 0 Then
							SetTextBoxString j,MsgList(99),True
						ElseIf j < 0 Then
							PSL.Output MsgList(99)
						End If
					Else
						j = 0
					End If
				End If
				TempList = SubStringList(UseStrDataList,j)
				DlgListBoxArray "UseStrList",TempList()
				SetListBoxItems(GetDlgItem(CLng(DlgText("SuppValueBox")),DlgControlId("UseStrList")),intArry)
				DlgEnable "AllResetButton",True
				If DlgValue("ModeCheckBox") = 1 Then DlgValue "ModeCheckBox",2
				DlgItem$ = "UseStrList"
			End Select
			If t < 2 Then
				'提取时转为简洁模式
				If m = 1 Then
					DlgVisible "OrgStrCodeText",True
					DlgVisible "OrgCodePageNameList",True
					DlgVisible "TrnStrCodeText",False
					DlgVisible "TrnCodePageNameList",False

					DlgVisible "DelButton",True
					DlgVisible "LockButton",True
					DlgVisible "UnLockButton",False
					DlgVisible "GetStrSetButton",True
					DlgVisible "WriteButton",False
					DlgVisible "AllWriteButton",False
					DlgVisible "UndoWriteButton",False

					DlgEnable "TrnStartPosBox",False
					DlgEnable "TrnStringBox",False
					DlgEnable "TrnCheckBox",False
					DlgValue "TrnCheckBox",1
				End If
				If n > 0 Then
					If m = 0 And StrToLong(Selected(20)) = 1 Then
						For i = 0 To UBound(FilterStrSet)
							Select Case i
							Case 0
								FilterStrSet(i) = "1"
							Case 2
								FilterStrSet(i) = IIf(TargetFile.Magic = "","1;4567","1;45678")
							Case 4
								FilterStrSet(i) = "1;12"
							Case 17
								FilterStrSet(i) = "0;1"
							Case 18 To 22
								FilterStrSet(i) = "0"
							Case 23
								FilterStrSet(i) = "0;0;"
							Case Else
								FilterStrSet(i) = "0;"
							End Select
						Next i
						i = FilterString(DataList,FilterStrSet,intArry,m)
						If i > 0 Then
							UseStrDataList = DataList
							DlgEnable "RefreshButton",True
							DlgEnable "AllShowButton",IIf(i = UBound(AllStrDataList) + 1,False,True)
							DlgText "SelectLogBox",""
						Else
							UseStrDataList = AllStrDataList
							'DlgEnable "RefreshButton",False
							DlgEnable "AllShowButton",False
						End If
					Else
						UseStrDataList = AllStrDataList
						'DlgEnable "RefreshButton",False
						DlgEnable "AllShowButton",False
					End If
					DlgEnable "FilterButton1",True
					DlgEnable "FilterButton2",True
					DlgEnable "FilterButton3",True
					DlgEnable "FilterShowButton",True
					'备份文件
					AllStrDataListBak = AllStrDataList
					GetFreeByteSecListBak = GetFreeByteSecList: FreeByteListBak = FreeByteList
					If j <> 0 Then
						If UBound(UseStrDataList) > 10000 Then
							If j > 0 Then
								SetTextBoxString j,MsgList(100),True
							ElseIf j < 0 Then
								PSL.Output MsgList(100)
							End If
						Else
							j = 0
						End If
					End If
					'备份字串ID索引字典
					CopyDic StrIDIndexDic,StrIDIndexDicBak,j
					'显示字串数据
					If j > 0 Then
						SetTextBoxString j,MsgList(99),True
					ElseIf j < 0 Then
						PSL.Output MsgList(99)
					End If
					TempList = SubStringList(UseStrDataList,j)
					DlgListBoxArray "UseStrList",TempList()
					DlgValue "UseStrList",Array(0)
					DlgEnable "AllResetButton",False
				End If
			End If
			If t <> 5 Then
				If Stemp3 = False And Stemp4 = False Then
					'分割字串类型数组的名称，用于显示
					TempList = MergeStrType2StrList(StrTypeList,OrgStrTypeList,OrgStrTypeList,ReSplit(MsgList(4),ItemJoinStr))
					DlgListBoxArray "StrTypeNameList",TempList()
					'分割代码页数组的名称和值，用于显示
					TempList = GetLangStrList(UniLangList,3,True)
					DlgListBoxArray "OrgCodePageNameList",TempList()
					DlgListBoxArray "TrnCodePageNameList",TempList()
					TempList = GetLangStrList(UniLangList,4,True)
					DlgListBoxArray "OrgCodePageValList",TempList()
					DlgListBoxArray "TrnCodePageValList",TempList()
				End If
			End If
		Case "GetStrSetButton"
			'备份显示语言设置，以便添加字串时更改语言设置
			TempList = Selected
			'备份其他设置
			TempArray = UseSectionList
			ReDim tmpLFList(2) As LOG_FONT
			tmpLFList = LFList
			Select Case SourceFile.Magic
			Case "NotPE32","NotPE64",""
				UseRefTypeList(1) = UseRefTypeList(0)
			End Select
			'转到提取对话框
			If ExtractString(SourceFile,0) = 0 Then UseSectionList = TempArray
			If UseRefTypeList(0).Template <> UseRefTypeList(1).Template Then
				Select Case SourceFile.Magic
				Case ""
					DlgEnable "RefListButton",False
					For i = 0 To UBound(AllStrDataList)
						AllStrDataList(i).Moveable = Moveable(SourceFile,AllStrDataList(i))
						AllStrDataList(i).Source.lReferenceNum = 0
						AllStrDataList(i).Source.GetRefState = 0
						AllStrDataList(i).Trans.lReferenceNum = 0
						AllStrDataList(i).Trans.GetRefState = 0
					Next i
				Case "NotPE32","NotPE64"
					DlgEnable "RefListButton",True
					For i = 0 To UBound(AllStrDataList)
						AllStrDataList(i).Moveable = Moveable(SourceFile,AllStrDataList(i))
						AllStrDataList(i).Source.lReferenceNum = 0
						AllStrDataList(i).Source.GetRefState = 0
						AllStrDataList(i).Trans.lReferenceNum = 0
						AllStrDataList(i).Trans.GetRefState = 0
					Next i
				End Select
			End If
			Stemp3 = IIf(Selected(0) = TempList(0),False,True)
			Stemp4 = FontComps(LFList,tmpLFList)
			If Stemp3 = False And Stemp4 = False Then
				'选中提取对话框上的自定义字串选项
				If CheckStrTypeArray(OrgStrTypeList) = True Then ExtractSet(10) = "1"
				'更新已改名或新增加的类型用于字串类型显示
				TmpList = MergeStrType2StrList(StrTypeList,OrgStrTypeList,OrgStrTypeList,ReSplit(MsgList(4),ItemJoinStr))
				DlgListBoxArray "StrTypeNameList",TmpList()
				DlgValue "StrTypeNameList",StrTypeValue(AllStrDataList(intList(0)).StrType)
				'分割代码页数组的名称和值，用于显示
				TempArray = GetLangStrList(UniLangList,3,True)
				DlgListBoxArray "OrgCodePageNameList",TempArray()
				DlgListBoxArray "TrnCodePageNameList",TempArray()
				TempArray = GetLangStrList(UniLangList,4,True)
				DlgListBoxArray "OrgCodePageValList",TempArray()
				DlgListBoxArray "TrnCodePageValList",TempArray()
				DlgText "OrgCodePageValList",CStr$(AllStrDataList(intList(0)).Source.CodePage)
				DlgText "TrnCodePageValList",CStr$(AllStrDataList(intList(0)).Trans.CodePage)
				DlgValue "OrgCodePageNameList",DlgValue("OrgCodePageValList")
				DlgValue "TrnCodePageNameList",DlgValue("TrnCodePageValList")
				If Selected(16) = TempList(16) Then Exit Function
			End If
			DlgItem$ = "UseStrList"
		Case "AddFilterStrButton"
			x = StrToLong(ReSplit(FilterStrSet(17),ItemJoinStr)(1))
			j = FilterStrDic.Count
			ReDim TempList(UBound(intList)) As String
			For i = 0 To UBound(intList)
				With AllStrDataList(intList(i))
					If .WriteType > -2 And .WriteType < 1 Then
						Temp = Trim$(.Source.sString)
						If x = 0 Then
							If Not FilterStrDic.Exists(Temp) Then
								FilterStrDic.Add(Temp,j + n)
								TempList(n) = Temp
								n = n + 1
							End If
						Else
							Temp = Trim$(DelAccKey(Temp))
							If Temp <> "" Then
								If Not FilterStrDic.Exists(Temp) Then
									FilterStrDic.Add(Temp,j + n)
									TempList(n) = Temp
									n = n + 1
								End If
							End If
						End If
						k = k + 1
					End If
				End With
			Next i
			If n + k = 0 Then
				MsgBox MsgList(102),vbOkOnly+vbInformation,MsgList(0)
				Exit Function
			End If
			Temp = Mid$(ExtractSet(35),InStrRev(ExtractSet(35),"\") + 1)
			'显示消息输出模式
			If StrToLong(Selected(17)) > 0 Then
				If DlgVisible("ActionProgressBox") = False Then
					DlgVisible "OrgStringText",False
					DlgVisible "TrnStringText",False
					DlgVisible "OrgStringBox",False
					DlgVisible "TrnStringBox",False
					DlgVisible "OrgCheckBox",False
					DlgVisible "TrnCheckBox",False
					DlgVisible "MsgOutputText",True
					DlgVisible "MsgOutputGroup",True
					DlgVisible "WriteResultsCheckBox",IIf(TargetFile.hcsFile.FilePath = SourceFile.hcsFile.FilePath,False,True)
					DlgVisible "ActionProgressBox",True
					DlgVisible "FindResultsBox",False
					DlgVisible "WriteResultsBox",False
					DlgValue "MsgOutputGroup",0
					DlgText "MsgOutputButton",MsgList(30)
				End If
				x = GetDlgItem(CLng(DlgText("SuppValueBox")),DlgControlId("ActionProgressBox"))
				SetTextBoxString x,Replace$(Replace$(Replace$(MsgList(31),"%s",CStr(n)),"%d",Temp),"%n",CStr(j + n)),True
			ElseIf StrToLong(Selected(17)) < 0 Then
				PSL.Output Replace$(Replace$(Replace$(MsgList(31),"%s",CStr(n)),"%d",Temp),"%n",CStr(j + n))
			End If
			If StrToLong(Selected(27)) = 1 Then Beep
			ReDim Preserve TempList(n - 1) As String
			WriteBinaryFile ExtractSet(35),CP_UNICODELITTLE,StrListJoin(TempList,vbNullChar) & vbNullChar,True,j
			DlgVisible "AddFilterStrButton",False
			DlgVisible "DelFilterStrButton",True
			DlgEnable "AddFilterStrButton",False
			DlgEnable "DelFilterStrButton",True
			Exit Function
		Case "DelFilterStrButton"
			x = StrToLong(ReSplit(FilterStrSet(17),ItemJoinStr)(1))
			j = FilterStrDic.Count
			For i = 0 To UBound(intList)
				With AllStrDataList(intList(i))
					If .WriteType > -2 And .WriteType < 1 Then
						If x = 0 Then
							Temp = Trim$(.Source.sString)
						Else
							Temp = Trim$(DelAccKey(.Source.sString))
						End If
						If Temp <> "" Then
							If FilterStrDic.Exists(Temp) Then
								intList(n) = FilterStrDic.Item(Temp)
								n = n + 1
								FilterStrDic.Remove(Temp)
							End If
						End If
					End If
				End With
			Next i
			If n = 0 Then
				MsgBox MsgList(103),vbOkOnly+vbInformation,MsgList(0)
				Exit Function
			End If
			Temp = Mid$(ExtractSet(35),InStrRev(ExtractSet(35),"\") + 1)
			'显示消息输出模式
			If StrToLong(Selected(17)) > 0 Then
				If DlgVisible("ActionProgressBox") = False Then
					DlgVisible "OrgStringText",False
					DlgVisible "TrnStringText",False
					DlgVisible "OrgStringBox",False
					DlgVisible "TrnStringBox",False
					DlgVisible "OrgCheckBox",False
					DlgVisible "TrnCheckBox",False
					DlgVisible "MsgOutputText",True
					DlgVisible "MsgOutputGroup",True
					DlgVisible "WriteResultsCheckBox",IIf(TargetFile.hcsFile.FilePath = SourceFile.hcsFile.FilePath,False,True)
					DlgVisible "ActionProgressBox",True
					DlgVisible "FindResultsBox",False
					DlgVisible "WriteResultsBox",False
					DlgValue "MsgOutputGroup",0
					DlgText "MsgOutputButton",MsgList(30)
				End If
				x = GetDlgItem(CLng(DlgText("SuppValueBox")),DlgControlId("ActionProgressBox"))
				SetTextBoxString x,Replace$(Replace$(Replace$(MsgList(54),"%s",CStr(n)),"%d",Temp),"%n",CStr(j - n)),True
			ElseIf StrToLong(Selected(17)) < 0 Then
				PSL.Output Replace$(Replace$(Replace$(MsgList(54),"%s",CStr(n)),"%d",Temp),"%n",CStr(j - n))
			End If
			If StrToLong(Selected(27)) = 1 Then Beep
			ReDim Preserve intList(n - 1) As Long
			Call SortNumArray(intList,0,n - 1,False)
			TempList = ReSplit(ReadBinaryFile(ExtractSet(35),CP_UNICODELITTLE,True),vbNullChar)
			Call DelArrays(FilterStrDic,TempList,intList,False)
			Temp = StrListJoin(TempList,vbNullChar)
			WriteBinaryFile ExtractSet(35),CP_UNICODELITTLE,IIf(Temp = "","",Temp & vbNullChar),True
			DlgVisible "AddFilterStrButton",True
			DlgVisible "DelFilterStrButton",False
			DlgEnable "AddFilterStrButton",True
			DlgEnable "DelFilterStrButton",False
			Exit Function
		Case "AddKeepStrButton"
			x = StrToLong(ExtractSet(24))
			j = ReserveStrDic.Count
			ReDim TempList(UBound(intList)) As String
			For i = 0 To UBound(intList)
				With AllStrDataList(intList(i))
					Temp = Trim$(.Source.sString)
					If x = 0 Then
						If Not ReserveStrDic.Exists(Temp) Then
							ReserveStrDic.Add(Temp,j + n)
							TempList(n) = Temp
							n = n + 1
						End If
					Else
						Temp = Trim$(DelAccKey(Temp))
						If Temp <> "" Then
							If Not ReserveStrDic.Exists(Temp) Then
								ReserveStrDic.Add(Temp,j + n)
								TempList(n) = Temp
								n = n + 1
							End If
						End If
					End If
				End With
			Next i
			If n = 0 Then
				MsgBox MsgList(128),vbOkOnly+vbInformation,MsgList(0)
				Exit Function
			End If
			Temp = Mid$(ExtractSet(37),InStrRev(ExtractSet(37),"\") + 1)
			'显示消息输出模式
			If StrToLong(Selected(17)) > 0 Then
				If DlgVisible("ActionProgressBox") = False Then
					DlgVisible "OrgStringText",False
					DlgVisible "TrnStringText",False
					DlgVisible "OrgStringBox",False
					DlgVisible "TrnStringBox",False
					DlgVisible "OrgCheckBox",False
					DlgVisible "TrnCheckBox",False
					DlgVisible "MsgOutputText",True
					DlgVisible "MsgOutputGroup",True
					DlgVisible "WriteResultsCheckBox",IIf(TargetFile.hcsFile.FilePath = SourceFile.hcsFile.FilePath,False,True)
					DlgVisible "ActionProgressBox",True
					DlgVisible "FindResultsBox",False
					DlgVisible "WriteResultsBox",False
					DlgValue "MsgOutputGroup",0
					DlgText "MsgOutputButton",MsgList(30)
				End If
				x = GetDlgItem(CLng(DlgText("SuppValueBox")),DlgControlId("ActionProgressBox"))
				SetTextBoxString x,Replace$(Replace$(Replace$(MsgList(126),"%s",CStr(n)),"%d",Temp),"%n",CStr(j + n)),True
			ElseIf StrToLong(Selected(17)) < 0 Then
				PSL.Output Replace$(Replace$(Replace$(MsgList(126),"%s",CStr(n)),"%d",Temp),"%n",CStr(j + n))
			End If
			If StrToLong(Selected(28)) = 1 Then Beep
			ReDim Preserve TempList(n - 1) As String
			WriteBinaryFile ExtractSet(37),CP_UNICODELITTLE,StrListJoin(TempList,vbNullChar) & vbNullChar,True,j
			Exit Function
		Case "DelKeepStrButton"
			x = StrToLong(ExtractSet(24))
			j = ReserveStrDic.Count
			For i = 0 To UBound(intList)
				With AllStrDataList(intList(i))
					If x = 0 Then
						Temp = Trim$(.Source.sString)
					Else
						Temp = Trim$(DelAccKey(.Source.sString))
					End If
					If Temp <> "" Then
						If ReserveStrDic.Exists(Temp) Then
							intList(n) = ReserveStrDic.Item(Temp)
							n = n + 1
							ReserveStrDic.Remove(Temp)
						End If
					End If
				End With
			Next i
			If n = 0 Then
				MsgBox MsgList(129),vbOkOnly+vbInformation,MsgList(0)
				Exit Function
			End If
			Temp = Mid$(ExtractSet(37),InStrRev(ExtractSet(37),"\") + 1)
			'显示消息输出模式
			If StrToLong(Selected(17)) > 0 Then
				If DlgVisible("ActionProgressBox") = False Then
					DlgVisible "OrgStringText",False
					DlgVisible "TrnStringText",False
					DlgVisible "OrgStringBox",False
					DlgVisible "TrnStringBox",False
					DlgVisible "OrgCheckBox",False
					DlgVisible "TrnCheckBox",False
					DlgVisible "MsgOutputText",True
					DlgVisible "MsgOutputGroup",True
					DlgVisible "WriteResultsCheckBox",IIf(TargetFile.hcsFile.FilePath = SourceFile.hcsFile.FilePath,False,True)
					DlgVisible "ActionProgressBox",True
					DlgVisible "FindResultsBox",False
					DlgVisible "WriteResultsBox",False
					DlgValue "MsgOutputGroup",0
					DlgText "MsgOutputButton",MsgList(30)
				End If
				x = GetDlgItem(CLng(DlgText("SuppValueBox")),DlgControlId("ActionProgressBox"))
				SetTextBoxString x,Replace$(Replace$(Replace$(MsgList(127),"%s",CStr(n)),"%d",Temp),"%n",CStr(j - n)),True
			ElseIf StrToLong(Selected(17)) < 0 Then
				PSL.Output Replace$(Replace$(Replace$(MsgList(127),"%s",CStr(n)),"%d",Temp),"%n",CStr(j - n))
			End If
			If StrToLong(Selected(28)) = 1 Then Beep
			ReDim Preserve intList(n - 1) As Long
			Call SortNumArray(intList,0,n - 1,False)
			TempList = ReSplit(ReadBinaryFile(ExtractSet(37),CP_UNICODELITTLE,True),vbNullChar)
			Call DelArrays(ReserveStrDic,TempList,intList,False)
			Temp = StrListJoin(TempList,vbNullChar)
			WriteBinaryFile ExtractSet(37),CP_UNICODELITTLE,IIf(Temp = "","",Temp & vbNullChar),True
			Exit Function
		Case "AllShowButton"
			UseStrDataList = AllStrDataList
			TempList = SubStringList(UseStrDataList)
			DlgListBoxArray "UseStrList",TempList()
			SetListBoxItems(GetDlgItem(CLng(DlgText("SuppValueBox")),DlgControlId("UseStrList")),intList)
			DlgEnable "RefreshButton",CheckFilterStrSet(FilterStrSet)
			'DlgEnable "FilterShowButton",True
			DlgEnable "AllShowButton",False
			DlgItem$ = "UseStrList"
		Case "FilterShowButton", "RefreshButton","FilterButton1", "FilterButton2", "FilterButton3"
			m = IIf(TargetFile.hcsFile.FilePath = SourceFile.hcsFile.FilePath,1,0)
			intArray = intList
			Select Case DlgItem$
			Case "FilterShowButton"
				If FilterSet(IIf(TargetFile.Magic = "",0,1),m) = False Then Exit Function
				i = FilterString(DataList,FilterStrSet,intArray,m)
			Case "FilterButton1", "FilterButton2", "FilterButton3"
				TempList = FilterStrSet
				For i = 0 To UBound(TempList)
					Select Case i
					Case 0
						TempList(i) = "0"
					Case 2
						Select Case DlgItem$
						Case "FilterButton1"
							TempList(i) = "1;012"
						Case "FilterButton2"
							TempList(i) = "1;3"
						Case "FilterButton3"
							TempList(i) = IIf(TargetFile.Magic = "","1;7","1;5")
						End Select
					Case 18 To 22
						TempList(i) = "0"
					Case 23
						TempList(i) = "0;0;"
					Case Else
						TempList(i) = "0;"
					End Select
				Next i
				i = FilterString(DataList,TempList,intArray,m)
			Case "RefreshButton"
				i = FilterString(DataList,FilterStrSet,intArray,m)
			End Select
			If i > -1 Then
				If DataComps(DataList,UseStrDataList,UseStrIDIndexDic,m) = False Then Exit Function
				UseStrDataList = DataList
				TempList = SubStringList(UseStrDataList)
				DlgListBoxArray "UseStrList",TempList()
				SetListBoxItems(GetDlgItem(CLng(DlgText("SuppValueBox")),DlgControlId("UseStrList")),intArray)
				DlgEnable "RefreshButton",True
				'DlgEnable "FilterShowButton",False
				DlgEnable "AllShowButton",IIf(i = UBound(AllStrDataList) + 1,False,True)
				DlgText "SelectLogBox",""
				DlgItem$ = "UseStrList"
			ElseIf DlgEnable("AllShowButton") = True Then
				UseStrDataList = AllStrDataList
				TempList = SubStringList(UseStrDataList)
				DlgListBoxArray "UseStrList",TempList()
				SetListBoxItems(GetDlgItem(CLng(DlgText("SuppValueBox")),DlgControlId("UseStrList")),intList)
				DlgEnable "RefreshButton",CheckFilterStrSet(FilterStrSet)
				'DlgEnable "FilterShowButton",True
				DlgEnable "AllShowButton",False
				DlgText "SelectLogBox",""
				DlgItem$ = "UseStrList"
			Else
				DlgEnable "RefreshButton",CheckFilterStrSet(FilterStrSet)
				Exit Function
			End If
		Case "DelButton"
			If MsgBox(MsgList(32),vbYesNo+vbInformation,MsgList(0)) = vbNo Then Exit Function
			n = UBound(UseStrDataList)
			If DlgEnable("AllShowButton") = True Then
				Call DelDataArray(StrIDIndexDic,AllStrDataList,intList)
				Call DelDataArray(UseStrIDIndexDic,UseStrDataList,intArray)
			Else
				Call DelDataArray(StrIDIndexDic,AllStrDataList,intList)
				UseStrDataList = AllStrDataList
			End If
			If UBound(intArray) = n Then
				j = GetDlgItem(CLng(DlgText("SuppValueBox")),DlgControlId("UseStrList"))
				DelListBoxItems(j,-2)
			Else
				n = n - UBound(intArray) - 1
				i = IIf(intArray(0) < 0,0,IIf(intArray(0) > n,n,intArray(0)))
				If UBound(intArray) > 500 Then
					TempList = SubStringList(UseStrDataList)
					DlgListBoxArray "UseStrList",TempList()
					DlgValue "UseStrList",Array(i)
				Else
					j = GetDlgItem(CLng(DlgText("SuppValueBox")),DlgControlId("UseStrList"))
					DelListBoxItems(j,intArray)
					SetListBoxItems(j,i)
				End If
			End If
			DlgEnable "AllResetButton",True
			If DlgValue("ModeCheckBox") = 1 Then DlgValue "ModeCheckBox",2
			DlgItem$ = "UseStrList"
		Case "ResetButton"
			m = IIf(TargetFile.hcsFile.FilePath = SourceFile.hcsFile.FilePath,1,0)
			'为不同的字串类型还原做准备
			If m = 1 Then
				Set Dic = CreateObject("Scripting.Dictionary")
				If CheckStrTypeArray(OrgStrTypeList) = True Then
					t = UBound(OrgStrTypeList) + 1
					For i = 0 To t - 1
						Temp = StrTypeToString(OrgStrTypeList,i)
						If Not Dic.Exists(Temp) Then Dic.Add(Temp,i)
					Next i
				End If
				If CheckStrTypeArray(OrgStrTypeListBak) = True Then
					For i = 0 To UBound(OrgStrTypeListBak)
						Temp = StrTypeToString(OrgStrTypeListBak,i)
						If Not Dic.Exists(Temp) Then Dic.Add(Temp,-(i + 1))
					Next i
				End If
			End If
			'开始还原
			j = UBound(intList)
			ReDim Preserve TempList(j) As String,intArray(j) As Long
			DataList = AllStrDataList
			For i = LBound(intList) To UBound(intList)
				j = intList(i)
				With AllStrDataList(j)
					If StrIDIndexDicBak.Exists(.ID) Then
						k = StrIDIndexDicBak.Item(.ID)
						If DataComp(AllStrDataList(j),AllStrDataListBak(k),m) = True Then
							If m = 0 Then
								x = 0
								If .ScapeIDForMove <> AllStrDataListBak(k).ScapeIDForMove Then
									x = 1
								ElseIf .ScapeIDBeMoved <> AllStrDataListBak(k).ScapeIDBeMoved Then
									x = 1
								End If
								If x = 1 Then
									If ResetStrVal(TargetFile,AllStrDataList,FreeByteList,j,1) = True Then Stemp2 = True
								End If
							End If
							AllStrDataList(j) = AllStrDataListBak(k)
							'匹配并更新新旧字串类型
							If m = 1 Then
								If .StrType > 4 Then
									ReDim intArry(.Source.lReferenceNum) As Long
									For k = 0 To .Source.lReferenceNum
										If k = 0 Then
											intArry(k) = .StrType
										Else
											intArry(k) = .Source.Reference(k - 1).StrType
										End If
										If y <> intArry(k) Then
											y = intArry(k)
											Temp = StrTypeToString(OrgStrTypeListBak,intArry(k) - 5)
										End If
										If Dic.Exists(Temp) Then
											If Dic.Item(Temp) < 0 Then
												ReDim Preserve OrgStrTypeList(t) As STRING_TYPE
												OrgStrTypeList(t) = OrgStrTypeListBak(-Dic.Item(Temp) - 1)
												Dic.Item(Temp) = t
												If k = 0 Then
													.StrType = t + 5
												Else
													.Source.Reference(k - 1).StrType = t + 5
												End If
												'获取字串类型长度
												Call StrTypeLength(AllStrDataList(j),OrgStrTypeList,FN,Mode,.WriteType)
												t = t + 1
											ElseIf Dic.Item(Temp) <> intArry(k) Then
												If k = 0 Then
													.StrType = Dic.Item(Temp) + 5
												Else
													.Source.Reference(k - 1).StrType = Dic.Item(Temp) + 5
												End If
												'获取字串类型长度
												Call StrTypeLength(AllStrDataList(j),OrgStrTypeList,FN,Mode,.WriteType)
											End If
										Else
											If k = 0 Then
												.StrType = 0
											Else
												.Source.Reference(k - 1).StrType = 0
											End If
											'获取字串类型长度
											Call StrTypeLength(AllStrDataList(j),OrgStrTypeList,FN,Mode,.WriteType)
										End If
									Next k
								End If
								'还原已被更改的字串字典中的 ID，因修改代码页、地址等重新提取时地址更改后，ID 也会更改
								.ID = .Source.lStartAddress
								If .ID <> DataList(j).ID Then
									If StrIDIndexDic.Exists(DataList(j).ID) Then
										If Not StrIDIndexDic.Exists(.ID) Then
											StrIDIndexDic.Key(DataList(j).ID) = .ID
										End If
									End If
									If StrIDIndexDicBak.Exists(DataList(j).ID) Then
										If Not StrIDIndexDicBak.Exists(.ID) Then
											StrIDIndexDicBak.Key(DataList(j).ID) = .ID
											AllStrDataListBak(StrIDIndexDicBak.Item(.ID)).ID = .ID
										End If
									End If
									If UseStrIDIndexDic.Exists(DataList(j).ID) Then
										If Not UseStrIDIndexDic.Exists(.ID) Then
											UseStrIDIndexDic.Key(DataList(j).ID) = .ID
											UseStrDataList(UseStrIDIndexDic.Item(.ID)).ID = .ID
										End If
									End If
								End If
							Else
								'保留写入状态，以便过滤显示
								.WriteState = DataList(j).WriteState
								'保留已拆分的父字串和子字串的拆分数据
								.SplitState = DataList(j).SplitState
								If .SplitState <> 0 Then
									.ID = DataList(j).ID
									.MoveMode = DataList(j).MoveMode
									.Source.Reference = DataList(j).Source.Reference
									.Source.lReferenceNum = DataList(j).Source.lReferenceNum
									.Source.GetRefState = DataList(j).Source.GetRefState
									.Trans.Reference = DataList(j).Trans.Reference
									.Trans.lReferenceNum = DataList(j).Trans.lReferenceNum
									.Trans.GetRefState = DataList(j).Trans.GetRefState
									Stemp = True
									If ResetStrVal(TargetFile,AllStrDataList,FreeByteList,j,1) = True Then Stemp2 = True
								ElseIf x = 1 Then
									Stemp = True
									If ResetStrVal(TargetFile,AllStrDataList,FreeByteList,j,1) = True Then Stemp2 = True
								End If
							End If
							UseStrDataList(intArray(i)) = AllStrDataList(j)
							TempList(n) = AllStrDataList(j).Trans.sString
							intArray(n) = intArray(i)
							n = n + 1
						End If
					End If
				End With
			Next i
			Set Dic = Nothing
			If n = 0 Then Exit Function
			ReDim Preserve TempList(n - 1) As String,intArray(n - 1) As Long
			j = GetDlgItem(CLng(DlgText("SuppValueBox")),DlgControlId("UseStrList"))
			ChangeListBoxItems(j,TempList,intArray,intArray)
			SetListBoxItems(j,intArray)
			If Stemp = True And Selected(8) = "1" Then
				'重新分配空余地址
				Call ShowMoveMsg(MoveString(TargetFile,AllStrDataList,0,StrToLong(Selected(1)),j),Stemp2,0)
			End If
			DlgEnable "ResetButton",False
			DlgEnable "AllResetButton",DataComps(AllStrDataList,AllStrDataListBak,StrIDIndexDic,m)
			If DlgEnable("AllResetButton") = True Then
				If DlgValue("ModeCheckBox") = 1 Then DlgValue "ModeCheckBox",2
			Else
				If DlgValue("ModeCheckBox") = 2 Then DlgValue "ModeCheckBox",1
			End If
			'在字串类型列表中显示被添加的字串类型
			If t > 0 Then
				TempList = MergeStrType2StrList(StrTypeList,OrgStrTypeList,OrgStrTypeList,ReSplit(MsgList(4),ItemJoinStr))
				DlgListBoxArray "StrTypeNameList",TempList()
			End If
			DlgItem$ = "UseStrList"
		Case "StrTypeNameList"
			'添加或删除自定义字串类型
			TempList = ReSplit(MsgList(4),ItemJoinStr)
			i = UBound(TempList)
			Select Case DlgText("StrTypeNameList")
			Case TempList(i - 1), TempList(i - 2)
				If DlgText("StrTypeNameList") = TempList(i - 1) Then
					TempList = GetStrTypeNameList(OrgStrTypeList)
					If SetLevel(TempList,0,MsgList(122)) = False Then Exit Function
					Set Dic = CreateObject("Scripting.Dictionary")
					For i = 0 To UBound(OrgStrTypeList)
						If Not Dic.Exists(OrgStrTypeList(i).sName) Then
							Dic.Add(OrgStrTypeList(i).sName,i)
						End If
					Next i
					ReDim TempData(0) As STRING_TYPE
					TempData = OrgStrTypeList
					n = 0
					For i = 0 To UBound(TempList)
						If Dic.Exists(TempList(i)) Then
							TempData(n) = OrgStrTypeList(Dic.Item(TempList(i)))
							n = n + 1
						End If
					Next i
					Set Dic = Nothing
					TempArray = GetStrTypeNameList(TempData)
					Stemp = False
				Else
					TempList = MergeStrType2StrList(StrTypeList,OrgStrTypeList,UseStrTypeList,TempArray)
					TempArray = GetStrTypeNameList(OrgStrTypeList)
					If EditList(TempList,TempArray) = False Then Exit Function
					Stemp = True
				End If
				'显示消息输出模式
				m = 0
				If CheckArray(TempArray) = True Then
					m = StrToLong(Selected(17))
					If m > 0 Then
						If DlgVisible("ActionProgressBox") = False Then
							DlgVisible "OrgStringText",False
							DlgVisible "TrnStringText",False
							DlgVisible "OrgStringBox",False
							DlgVisible "TrnStringBox",False
							DlgVisible "OrgCheckBox",False
							DlgVisible "TrnCheckBox",False
							DlgVisible "MsgOutputText",True
							DlgVisible "MsgOutputGroup",True
							DlgVisible "WriteResultsCheckBox",IIf(TargetFile.hcsFile.FilePath = SourceFile.hcsFile.FilePath,False,True)
							DlgVisible "ActionProgressBox",True
							DlgVisible "FindResultsBox",False
							DlgVisible "WriteResultsBox",False
							DlgValue "MsgOutputGroup",0
							DlgText "MsgOutputButton",MsgList(30)
						End If
						m = GetDlgItem(CLng(DlgText("SuppValueBox")),DlgControlId("ActionProgressBox"))
					End If
				End If
				If ManageStrType(SourceFile,intArray,TempArray,Stemp,m) = 0 Then Exit Function
				'分割字串类型数组的名称，用于显示
				TempList = MergeStrType2StrList(StrTypeList,OrgStrTypeList,OrgStrTypeList,ReSplit(MsgList(4),ItemJoinStr))
				DlgListBoxArray "StrTypeNameList",TempList()
				If Stemp = False Then
					DlgValue "StrTypeNameList",StrTypeValue(AllStrDataList(intList(0)).StrType)
				Else
					DlgValue "StrTypeNameList",UBound(TempList) - 1
				End If
				'字串有变化时全部显示，并刷新和定位
				If CheckArray(TempArray) = True Then
					If DlgEnable("AllShowButton") = True Then
						UseStrDataList = AllStrDataList
						TempList = SubStringList(UseStrDataList)
						DlgListBoxArray "UseStrList",TempList()
						SetListBoxItems(GetDlgItem(CLng(DlgText("SuppValueBox")),DlgControlId("UseStrList")),intList)
						DlgEnable "RefreshButton",CheckFilterStrSet(FilterStrSet)
						'DlgEnable "FilterShowButton",True
						DlgEnable "AllShowButton",False
						ReDim TempArray(0) As String
					End If
				End If
			Case Else
				'指定或检测字串类型
				j = 7: k = DlgValue("StrTypeNameList")
				n = k: m = 0
				'显示消息输出模式
				If UBound(intList) > 0 Then
					m = StrToLong(Selected(17))
					If m > 0 Then
						If DlgVisible("ActionProgressBox") = False Then
							DlgVisible "OrgStringText",False
							DlgVisible "TrnStringText",False
							DlgVisible "OrgStringBox",False
							DlgVisible "TrnStringBox",False
							DlgVisible "OrgCheckBox",False
							DlgVisible "TrnCheckBox",False
							DlgVisible "MsgOutputText",True
							DlgVisible "MsgOutputGroup",True
							DlgVisible "WriteResultsCheckBox",IIf(TargetFile.hcsFile.FilePath = SourceFile.hcsFile.FilePath,False,True)
							DlgVisible "ActionProgressBox",True
							DlgVisible "FindResultsBox",False
							DlgVisible "WriteResultsBox",False
							DlgValue "MsgOutputGroup",0
							DlgText "MsgOutputButton",MsgList(30)
						End If
						m = GetDlgItem(CLng(DlgText("SuppValueBox")),DlgControlId("ActionProgressBox"))
					End If
				End If
				TempArray = CheckStrType(SourceFile,intList,intArray,OrgStrTypeList,j,k,m)
				DlgValue "StrTypeNameList",StrTypeValue(AllStrDataList(intList(0)).StrType)
				If k < 0 Then
					MsgBox Replace$(MsgList(33),"%s",CStr(-k)),vbOkOnly+vbInformation,MsgList(1)
				End If
				If j > -1 Then Exit Function
				If n = 1 Then
					If UBound(intList) = UBound(AllStrDataList) And k = 0 Then
						ReDim OrgStrTypeList(0) As STRING_TYPE
						'分割字串类型数组的名称，用于显示
						TempList = MergeStrType2StrList(StrTypeList,OrgStrTypeList,OrgStrTypeList,ReSplit(MsgList(4),ItemJoinStr))
						DlgListBoxArray "StrTypeNameList",TempList()
					End If
				End If
			End Select
			'选中提取对话框上的自定义字串选项
			ExtractSet(10) = IIf(CheckStrTypeArray(OrgStrTypeList) = True,"1","0")
			'字串有变化时刷新和定位
			If CheckArray(TempArray) = True Then
				j = GetDlgItem(CLng(DlgText("SuppValueBox")),DlgControlId("UseStrList"))
				ChangeListBoxItems(j,TempArray,intArray,intArray)
				SetListBoxItems(j,intArray)
			End If
			DlgEnable "AllResetButton",True
			If DlgValue("ModeCheckBox") = 1 Then DlgValue "ModeCheckBox",2
			DlgItem$ = "UseStrList"
		Case "OrgCodePageNameList"
			k = DlgValue("OrgCodePageValList")
			DlgValue "OrgCodePageValList",DlgValue("OrgCodePageNameList")
			If k = DlgValue("OrgCodePageValList") Then
				If UBound(intList) = 0 Then Exit Function
			End If
			Mode = LoadFile(SourceFile.FilePath,FN,0,0,0,StrToLong(Selected(1)))
			If Mode < -1 Then Exit Function
			TempList = ExtractSet
			TempList(10) = IIf(CheckStrTypeArray(OrgStrTypeList) = True,"1","0")
			TempList(31) = AddStrEndCharSet(ExtractSet(31),JoinStr & StringTerminator)
			x = StrToLong(DlgText("OrgCodePageValList"))
			ReDim LangList(UBound(UseLangList)) As LANG_PROPERTIE
			LangList = GetSubLangListByCP(UseLangList,x)
			ReDim DataList(1) As STRING_PROPERTIE,TempArray(UBound(intList)) As String
			intArry = intList
			For i = 0 To UBound(intList)
				With AllStrDataList(intList(i))
					If .Source.CodePage <> x Then
						If .LockState = 0 Then
							DataList(0) = AllStrDataList(intList(i))
							'DataList(0).Source.inSectionID = -1
							DataList(0).Source.CodePage = x
							DataList(1) = GetString(SourceFile,FN,DataList(0),LangList,OrgStrTypeList,TempList,0,Mode,True)
							If DataList(1).Source.sString <> "" Then
								If DataComp(DataList(1),AllStrDataList(intList(i)),1) = True Then
									If DataList(1).Moveable = 0 Or DataList(1).Moveable = 2 Then
										intArry(m) = intList(i)
										m = m + 1
									End If
									AllStrDataList(intList(i)) = DataList(1)
									UseStrDataList(intArray(i)) = DataList(1)
									TempArray(j) = DataList(1).Source.sString
									intArray(j) = intArray(i)
									j = j + 1
								End If
							End If
						Else
							t = t + 1
						End If
					End If
				End With
			Next i
			'获取字串的引用列表和引用地址前的自定义类型
			If m > 0 Then
				ReDim Preserve intArry(m - 1) As Long
				i = IIf(IIf(TempList(10) = "0",0,CheckRefCustomStrType(OrgStrTypeList,IIf(SourceFile.Magic = "",0,1))) = 0,1,5)
				i = getVAListAndStrTypeByVA(SourceFile,FN,AllStrDataList,OrgStrTypeList,intArry,m,i,Mode,MsgList(34),0,True)
			End If
			If UnLoadFile(FN,0,Mode) = False Then Exit Function
			If i < -2 Then Exit Function
			If t > 0 Then
				MsgBox Replace$(MsgList(35),"%s",CStr(t)),vbOkOnly+vbInformation,MsgList(1)
			End If
			If j = 0 Then
				DlgValue "OrgCodePageValList",k
				DlgValue "OrgCodePageNameList",k
				Exit Function
			End If
			ReDim Preserve TempArray(j - 1) As String,intArray(j - 1) As Long
			j = GetDlgItem(CLng(DlgText("SuppValueBox")),DlgControlId("UseStrList"))
			ChangeListBoxItems(j,TempArray,intArray,intArray)
			SetListBoxItems(j,intArray)
			DlgEnable "AllResetButton",True
			If DlgValue("ModeCheckBox") = 1 Then DlgValue "ModeCheckBox",2
			DlgItem$ = "UseStrList"
		Case "TrnCodePageNameList"
			k = DlgValue("TrnCodePageValList")
			DlgValue "TrnCodePageValList",DlgValue("TrnCodePageNameList")
			If k = DlgValue("TrnCodePageValList") Then
				If UBound(intList) = 0 Then Exit Function
			End If
			'打开文件
			Mode = LoadFile(TargetFile.FilePath,FN,0,0,0,StrToLong(Selected(1)))
			If Mode < -1 Then Exit Function
			'更改字串代码页
			x = StrToLong(DlgText("TrnCodePageValList"))
			intArry = intList: intArr = intList
			For i = 0 To UBound(intList)
				With AllStrDataList(intList(i))
				If x = CP_UNKNOWN Then
					'y = CheckCodePage(.Trans.sString,UniLangList)
					If .WriteType > -2 And .WriteType < 1 Then
						y = .Source.CodePage
					ElseIf .Source.CodePage = CP_UNICODELITTLE Or .Source.CodePage = CP_UNICODEBIG Or _
						.Source.CodePage = CP_UTF7 Or .Source.CodePage = CP_UTF8 Or _
						.Source.CodePage = CP_UTF32LE Or .Source.CodePage = CP_UTF32BE Then
						y = .Source.CodePage
					Else
						y = TargetFile.CopePage
						If y = 0 Then y = .Source.CodePage
					End If
				Else
					y = x
				End If
				If .Trans.CodePage <> y Then
					If .LockState = 0 Then
						If StringToByte(.Trans.sString,y) <> StringToByte(.Trans.sString,.Trans.CodePage) Then
							If .WriteType > -2 And .WriteType < 1 Then
								.Trans.lMaxAddress = GetMaxAddress(AllStrDataList(intList(i)),True)
							End If
							.Trans.CodePage = y
							.Trans.lHexLength = StrHexLength(.Trans.sString,.Trans.CodePage,1)
							'获取字串类型长度及其翻译更改和截断写入引起的差额，用于还原开始地址为完整翻译的地址
							'.Trans.MoveLength 为截断写入后与完整翻译之间的长度差额
							.Trans.MoveLength = StrTypeLength(AllStrDataList(intList(i)),OrgStrTypeList,FN,Mode,1) - .Trans.MoveLength
							'更改翻译地址及需要获取引用的字串索引
							Call ChangeStrAddAndGetRefIndex(AllStrDataList,intArry,intArr,m,n,intList(i),1)
							UseStrDataList(intArray(i)) = AllStrDataList(intList(i))
							intList(j) = intList(i)
							j = j + 1
						End If
					Else
						t = t + 1
					End If
				End If
				End With
			Next i
			'获取字串的引用代码和引用地址
			If m + n > 0 Then
				If m > 0 Then
					ReDim Preserve intArry(m - 1) As Long
					i = GetVARefListBatch(TargetFile,FN,AllStrDataList,OrgStrTypeList,intArry,TempList,0,Mode,0,True)
				End If
				If n > 0 Then
					ReDim Preserve intArr(n - 1) As Long
					ReDim TempList(n - 1) As String
					Call GetVARefListBatch(TargetFile,"",AllStrDataList,OrgStrTypeList,intArr,TempList,1,0,0)
				End If
			End If
			If UnLoadFile(FN,0,Mode) = False Then Exit Function
			If i < -1 Then Exit Function
			If t > 0 Then
				MsgBox Replace$(MsgList(35),"%s",CStr(t)),vbOkOnly+vbInformation,MsgList(1)
			End If
			If j = 0 Then
				DlgValue "TrnCodePageValList",k
				DlgValue "TrnCodePageNameList",k
				Exit Function
			End If
			ReDim Preserve intList(j - 1) As Long
			'重置字串数据并移位
			Call ResetAndMoveString(TargetFile,AllStrDataList,intList,IIf(m = 0,False,True),True,MsgList,0)
			DlgEnable "AllResetButton",True
			If DlgValue("ModeCheckBox") = 1 Then DlgValue "ModeCheckBox",2
			DlgItem$ = "UseStrList"
		Case "PreFillSpaceMenu","AppFillSpaceMenu","UnFillSpaceMenu"
			'打开文件
			Mode = LoadFile(TargetFile.FilePath,FN,0,0,0,StrToLong(Selected(1)))
			If Mode < -1 Then Exit Function
			intArry = intList: intArr = intList
			ReDim TempArray(UBound(intList)) As String
			For i = 0 To UBound(intList)
				With AllStrDataList(intList(i))
				If .WriteType < -1 Or .WriteType > 0 Then
					If DlgItem$ = "UnFillSpaceMenu" Then
						x = .FillLength
						Stemp2 = IIf(.FillLength > 0,False,True)
					Else
						x = .Source.lHexLength + .Source.iNullByteLength - .Trans.lHexLength - .Trans.iNullByteLength
						Stemp2 = IIf(DlgItem$ = "AppFillSpaceMenu",False,True)
					End If
					If x > 0 Or .FillLength <> 0 Then
						If .LockState = 0 Then
							'转义字串，因为 FillStrWithSpape 函数不转义，需要实际字串
							Temp = Convert(.Trans.sString)
							If .FillLength = 0 Or x = .FillLength Then
								k = FillStrWithSpape(Temp,.Trans.CodePage,.Source.lHexLength - Abs(.FillLength),True,Stemp2)
							Else
								FillStrWithSpape(Temp,.Trans.CodePage,.Source.lHexLength - Abs(.FillLength),True,IIf(.FillLength > 0,False,True))
								k = FillStrWithSpape(Temp,.Trans.CodePage,.Source.lHexLength,True,Stemp2)
							End If
							If k <> .FillLength Then
								.FillLength = k
								.Trans.lHexLength = StrHexLength(Temp,.Trans.CodePage,0)
								.Trans.lCharLength = Len(Temp)
								'反转义字串，因为前面已转义
								.Trans.sString = ReConvert(Temp)
								'获取字串类型长度及其翻译更改和截断写入引起的差额，用于还原开始地址为完整翻译的地址
								'.Trans.MoveLength 为截断写入后与完整翻译之间的长度差额
								.Trans.MoveLength = StrTypeLength(AllStrDataList(intList(i)),OrgStrTypeList,FN,Mode,1) - .Trans.MoveLength
								'更改翻译地址及需要获取引用的字串索引
								Call ChangeStrAddAndGetRefIndex(AllStrDataList,intArry,intArr,m,n,intList(i),0)
								UseStrDataList(intArray(i)) = AllStrDataList(intList(i))
								TempArray(j) = .Trans.sString
								intList(j) = intList(i)
								intArray(j) = intArray(i)
								j = j + 1
							End If
						Else
							t = t + 1
						End If
					End If
				End If
				End With
			Next i
			'获取字串的引用代码和引用地址
			If m + n > 0 Then
				If m > 0 Then
					ReDim Preserve intArry(m - 1) As Long
					i = GetVARefListBatch(TargetFile,FN,AllStrDataList,OrgStrTypeList,intArry,TempList,0,Mode,0,True)
				End If
				If n > 0 Then
					ReDim Preserve intArr(n - 1) As Long
					ReDim TempList(n - 1) As String
					Call GetVARefListBatch(TargetFile,"",AllStrDataList,OrgStrTypeList,intArr,TempList,1,0,0)
				End If
			End If
			If UnLoadFile(FN,0,Mode) = False Then Exit Function
			If i < -1 Then Exit Function
			If t > 0 Then
				If DlgItem$ = "UnFillSpaceMenu" Then
					MsgBox Replace$(MsgList(90),"%s",CStr(t)),vbOkOnly+vbInformation,MsgList(1)
				Else
					MsgBox Replace$(MsgList(89),"%s",CStr(t)),vbOkOnly+vbInformation,MsgList(1)
				End If
			End If
			If j = 0 Then Exit Function
			ReDim Preserve TempArray(j - 1) As String,intList(j - 1) As Long
			'重置字串数据并移位
			Call ResetAndMoveString(TargetFile,AllStrDataList,intList,IIf(m = 0,False,True),True,MsgList,0)
			j = GetDlgItem(CLng(DlgText("SuppValueBox")),DlgControlId("UseStrList"))
			ChangeListBoxItems(j,TempArray,intArray,intArray)
			SetListBoxItems(j,intArray)
			DlgEnable "AllResetButton",True
			If DlgValue("ModeCheckBox") = 1 Then DlgValue "ModeCheckBox",2
			DlgItem$ = "UseStrList"
		Case "OverLengthWriteMenu","UnOverLengthWriteMenu"
			x = IIf(DlgItem$ = "OverLengthWriteMenu",0,2)
			intArry = intList: intArr = intList
			For i = 0 To UBound(intList)
				With AllStrDataList(intList(i))
				If .OverLengthWrite <> x Then
					If .LockState = 0 Then
						.OverLengthWrite = x
						If .ScapeIDForMove = -1 Then	'未移位的字串
							If  .ScapeIDBeMoved = -1 Then	'未被占用的字串
								.Trans.lMaxAddress = GetMaxAddress(AllStrDataList(intList(i)),False)
								'最大地址被减少而引起超长时
								If .Trans.lEndAddress + .EndByteLength + .Trans.iNullByteLength > .Trans.lMaxAddress Then
									'更改翻译地址及需要获取引用的字串索引
									ChangeStrAddAndGetRefIndex(AllStrDataList,intArry,intArr,m,n,intList(i),2)
									intList(j) = intList(i)
									j = j + 1
								Else
									.Trans.lMaxHexLength = .Trans.lMaxAddress - .Trans.lStartAddress + 1 - .EndByteLength - .Trans.iNullByteLength
								End If
							ElseIf .ScapeIDBeMoved > -1  Then	'已被占用的字串
								If x = 0 Then
									'获取被占用的字串ID
									y = StrIDIndexDic.Item(.ScapeIDBeMoved)
									With AllStrDataList(y)
										.Trans.lMaxAddress = GetMaxAddress(AllStrDataList(intList(i)),False)
										.Trans.lMaxHexLength = .Trans.lMaxAddress - .Trans.lStartAddress + 1 - .EndByteLength - .Trans.iNullByteLength
									End With
									'更改翻译地址及需要获取引用的字串索引
									intList(j) = y
									j = j + 1
								ElseIf .Trans.lMaxAddress > GetMaxAddress(AllStrDataList(intList(i)),False) Then
									'获取被占用的字串ID
									intList(j) = StrIDIndexDic.Item(.ScapeIDBeMoved)
									j = j + 1
									'重置被占用的字串
									ResetStrVal(TargetFile,AllStrDataList,FreeByteList,intList(i),2)
									'获取翻译的最大地址
									.Trans.lMaxAddress = GetMaxAddress(AllStrDataList(intList(i)),False)
									'更改翻译地址及需要获取引用的字串索引
									ChangeStrAddAndGetRefIndex(AllStrDataList,intArry,intArr,m,n,intList(i),2)
									intList(j) = intList(i)
									j = j + 1
								Else
									'获取被占用的字串ID
									y = StrIDIndexDic.Item(.ScapeIDBeMoved)
									With AllStrDataList(y)
										.Trans.lMaxAddress = GetMaxAddress(AllStrDataList(intList(i)),False)
										.Trans.lMaxHexLength = .Trans.lMaxAddress - .Trans.lStartAddress + 1 - .EndByteLength - .Trans.iNullByteLength
									End With
									'更改翻译地址及需要获取引用的字串索引
									intList(j) = y
									j = j + 1
								End If
							End If
						Else	'已移位的字串
							If .ScapeIDBeMoved = -1 Then	'未被占用的字串
								'还原最大结束地址为原始最大地址
								If x = 0 Then
									If .Trans.lMaxHexLength <= .Source.lMaxHexLength Then
										ResetStrVal(TargetFile,AllStrDataList,FreeByteList,intList(i),1)
									End If
								End If
							ElseIf .ScapeIDBeMoved > -1  Then	'已被占用的字串
								'获取被占用的字串ID
								y = StrIDIndexDic.Item(.ScapeIDBeMoved)
								With AllStrDataList(y)
									.Trans.lMaxAddress = GetMaxAddress(AllStrDataList(intList(i)),False)
									.Trans.lMaxHexLength = .Trans.lMaxAddress - .Trans.lStartAddress + 1 - .EndByteLength - .Trans.iNullByteLength
								End With
								'更改翻译地址及需要获取引用的字串索引
								intList(j) = y
								j = j + 1
							End If
						End If
						Stemp = True
					Else
						t = t + 1
					End If
				End If
				End With
			Next i
			'获取字串的引用代码和引用地址
			If m + n > 0 Then
				If m > 0 Then
					'打开文件
					Mode = LoadFile(TargetFile.FilePath,FN,0,0,0,StrToLong(Selected(1)))
					If Mode < -1 Then Exit Function
					ReDim Preserve intArry(m - 1) As Long
					i = GetVARefListBatch(TargetFile,FN,AllStrDataList,OrgStrTypeList,intArry,TempList,0,Mode,0,True)
					If UnLoadFile(FN,0,Mode) = False Then Exit Function
				End If
				If n > 0 Then
					ReDim Preserve intArr(n - 1) As Long
					ReDim TempList(n - 1) As String
					Call GetVARefListBatch(TargetFile,"",AllStrDataList,OrgStrTypeList,intArr,TempList,1,0,0)
				End If
			End If
			If i < -1 Then Exit Function
			If t > 0 Then
				If DlgItem$ = "OverLengthWriteMenu" Then
					MsgBox Replace$(MsgList(92),"%s",CStr(t)),vbOkOnly+vbInformation,MsgList(1)
				Else
					MsgBox Replace$(MsgList(93),"%s",CStr(t)),vbOkOnly+vbInformation,MsgList(1)
				End If
			End If
			If Stemp = False Then Exit Function
			If j > 0 Then
				ReDim Preserve intList(j - 1) As Long
				'重置字串数据并移位
				Call ResetAndMoveString(TargetFile,AllStrDataList,intList,IIf(m = 0,False,True),True,MsgList,0)
			End If
			DlgEnable "AllResetButton",True
			If DlgValue("ModeCheckBox") = 1 Then DlgValue "ModeCheckBox",2
			DlgItem$ = "UseStrList"
		Case "StrAddExpandButton","UnStrAddExpandButton"
			If Selected(8) = "0" Then
				MsgBox MsgList(36),vbOkOnly+vbInformation,MsgList(1)
				Exit Function
			End If
			Stemp = IIf(DlgItem$ = "StrAddExpandButton",False,True)
			If ExpandStrOrgAdd(TargetFile,AllStrDataList,intList(0),Stemp) = False Then Exit Function
			DlgEnable "AllResetButton",True
			If DlgValue("ModeCheckBox") = 1 Then DlgValue "ModeCheckBox",2
			DlgItem$ = "UseStrList"
		Case "IgnoreButton","UnIgnoreButton"
			x = IIf(DlgItem$ = "IgnoreButton",1,0)
			For i = LBound(intList) To UBound(intList)
				With AllStrDataList(intList(i))
					If .iError <> x Then
						If .LockState = 0 Then
							.iError = x
							n = n + 1
						Else
							t = t + 1
						End If
					End If
				End With
			Next i
			If t > 0 Then
				If DlgItem$ = "IgnoreButton" Then
					MsgBox Replace$(MsgList(97),"%s",CStr(t)),vbOkOnly+vbInformation,MsgList(1)
				Else
					MsgBox Replace$(MsgList(98),"%s",CStr(t)),vbOkOnly+vbInformation,MsgList(1)
				End If
			End If
			If n = 0 Then Exit Function
			DlgEnable "AllResetButton",True
			If DlgValue("ModeCheckBox") = 1 Then DlgValue "ModeCheckBox",2
			DlgItem$ = "UseStrList"
		Case "EditCommentMenu"
			EditComment(AllStrDataList(intList(0)).Source.sString,intList(0),UBound(AllStrDataList) + 1)
			Exit Function
		Case "FileByteView"
			TempList = GetToolNameList(Tools,0)
			k = ShowPopupMenu(TempList,vbPopupUseRightButton)
			If k < 0 Then Exit Function
			'查找未获取过引用的字串索引号
			intArry = intList
			For i = 0 To UBound(intList)
				With AllStrDataList(intList(i))
					If .Moveable = 0 Or .Moveable = 2 Then
						If .Source.GetRefState = 0 Then
							intArry(m) = intList(i)
							m = m + 1
						End If
					End If
				End With
			Next i
			If m > 0 Then
				'打开文件
				Mode = LoadFile(SourceFile.FilePath,FN,0,0,0,StrToLong(Selected(1)))
				If Mode < -1 Then Exit Function
				'显示消息输出模式
				j = StrToLong(Selected(17))
				If j > 0 Then
					If DlgVisible("ActionProgressBox") = False Then
						DlgVisible "OrgStringText",False
						DlgVisible "TrnStringText",False
						DlgVisible "OrgStringBox",False
						DlgVisible "TrnStringBox",False
						DlgVisible "OrgCheckBox",False
						DlgVisible "TrnCheckBox",False
						DlgVisible "MsgOutputText",True
						DlgVisible "MsgOutputGroup",True
						DlgVisible "WriteResultsCheckBox",IIf(y = 1,False,True)
						DlgVisible "ActionProgressBox",True
						DlgVisible "FindResultsBox",False
						DlgVisible "WriteResultsBox",False
						DlgValue "MsgOutputGroup",0
						DlgText "MsgOutputButton",MsgList(30)
					End If
					j = GetDlgItem(CLng(DlgText("SuppValueBox")),DlgControlId("ActionProgressBox"))
					SetTextBoxString j,MsgList(34)
				ElseIf j < 0 Then
					PSL.OutputWnd(0).Clear
					PSL.Output MsgList(34)
					j = -2
				End If
				ReDim Preserve intArry(m - 1) As Long
				m = GetVARefListBatch(SourceFile,FN,AllStrDataList,OrgStrTypeList,intArry,TempArray,0,Mode,j,True)
				If UnLoadFile(FN,0,Mode) = False Then Exit Function
			End If
			Call FileByteView(TargetFile,AllStrDataList,intList,k,StrToLong(Selected(16)))
			Exit Function
		Case "RefListButton"
			If SourceFile.Magic = "" Then Exit Function
			If Selected(8) = "0" Then
				MsgBox MsgList(36),vbOkOnly+vbInformation,MsgList(1)
				Exit Function
			End If
			'查找未获取过引用的字串索引号
			i = intList(0)
			intArry = intList
			y = IIf(TargetFile.hcsFile.FilePath = SourceFile.hcsFile.FilePath,1,0)
			For j = 0 To UBound(intList)
				With AllStrDataList(intList(j))
					If .Moveable = 0 Or .Moveable = 2 Then
						If .Source.GetRefState = 0 Then
							intArry(m) = intList(j)
							m = m + 1
							If y = 0 Then
								intList(n) = intList(j)
								n = n + 1
							End If
						ElseIf y = 0 Then
							If .Source.lReferenceNum > 0 Then
								If .Trans.GetRefState = 0 Then
									intList(n) = intList(j)
									n = n + 1
								End If
							End If
						End If
					End If
					If .WriteType > 0 Then Stemp2 = True
				End With
			Next j
			'获取字串的引用地址和引用代码
			If m + n > 0 Then
				If m > 0 Then
					'打开文件
					Mode = LoadFile(SourceFile.FilePath,FN,0,0,0,StrToLong(Selected(1)))
					If Mode < -1 Then Exit Function
					'显示消息输出模式
					j = StrToLong(Selected(17))
					If j > 0 Then
						If DlgVisible("ActionProgressBox") = False Then
							DlgVisible "OrgStringText",False
							DlgVisible "TrnStringText",False
							DlgVisible "OrgStringBox",False
							DlgVisible "TrnStringBox",False
							DlgVisible "OrgCheckBox",False
							DlgVisible "TrnCheckBox",False
							DlgVisible "MsgOutputText",True
							DlgVisible "MsgOutputGroup",True
							DlgVisible "WriteResultsCheckBox",IIf(y = 1,False,True)
							DlgVisible "ActionProgressBox",True
							DlgVisible "FindResultsBox",False
							DlgVisible "WriteResultsBox",False
							DlgValue "MsgOutputGroup",0
							DlgText "MsgOutputButton",MsgList(30)
						End If
						j = GetDlgItem(CLng(DlgText("SuppValueBox")),DlgControlId("ActionProgressBox"))
						SetTextBoxString j,MsgList(34)
					ElseIf j < 0 Then
						PSL.OutputWnd(0).Clear
						PSL.Output MsgList(34)
						j = -2
					End If
					ReDim Preserve intArry(m - 1) As Long
					'Dim StartTime As Date
					'StartTime = Timer
					m = GetVARefListBatch(SourceFile,FN,AllStrDataList,OrgStrTypeList,intArry,TempList,0,Mode,j,True)
					'PSL.Output Format$(DateAdd("s",Timer - StartTime,0),"hh:mm:ss")
					If UnLoadFile(FN,0,Mode) = False Then Exit Function
					If m < -1 Then Exit Function
					Stemp = True
					m = 0
					If y = 0 And Stemp2 = True Then
						If DlgValue("ModeCheckBox") = 1 Then DlgValue "ModeCheckBox",2
					End If
				End If
				If n > 0 Then
					ReDim Preserve intList(n - 1) As Long
					ReDim TempList(n - 1) As String
					Call GetVARefListBatch(TargetFile,"",AllStrDataList,OrgStrTypeList,intList,TempList,1,0,0)
				End If
			End If
			If UBound(intArray) > 0 Then
				If StrToLong(Selected(17)) > 0 Then
					j = GetDlgItem(CLng(DlgText("SuppValueBox")),DlgControlId("ActionProgressBox"))
					SetTextBoxString j,MsgList(37),Stemp
				ElseIf StrToLong(Selected(17)) < 0 Then
					If Stemp = False Then PSL.OutputWnd(0).Clear
					PSL.Output MsgList(37)
				End If
			End If
			If AllStrDataList(i).Source.lReferenceNum = 0 Then
				MsgBox MsgList(38),vbOkOnly+vbInformation,MsgList(1)
				Exit Function
			End If
			With AllStrDataList(i)
				x = .SplitState
				If x = 0 Then
					TempList = RefList2StrList(.Source,0)
					TempArray = RefList2StrList(.Trans,0)
					If .WriteType = 0 Then x = -1
				ElseIf x < 0 Then
					n = StrIDIndexDic.Item(-x)
					TempList = RefList2StrList(AllStrDataList(n).Source,0)
					TempArray = RefList2StrList(AllStrDataList(n).Trans,0)
					Temp = StrListJoin(ChangeList(TempList,TempArray),RefJoinStr)
					If Temp <> "" Then
						TempArray = ReSplit(StrListJoin(RefList2StrList(.Source,0),RefJoinStr) & RefJoinStr & Temp,RefJoinStr)
						TempList = ChangeList(TempList,TempArray,1)
					Else
						TempList = RefList2StrList(.Source,0)
					End If
					TempArray = RefList2StrList(.Trans,0)
				Else
					TempList = RefList2StrList(.Source,0)
					TempArray = RefList2StrList(.Trans,0)
				End If
				n = .WriteType + .SplitState
				If n = 0 Then x = -1
				'按用户设置转换地址格式
				If StrToLong(Selected(16)) = 1 Then
					TempList = DecStrListToHexStrList(TempList,TargetFile.FileSize,True)
					TempArray = DecStrListToHexStrList(TempArray,TargetFile.FileSize,True)
				End If
			End With
			'编辑引用列表
			m = IIf(AllStrDataList(i).Source.Reference(0).Index = 0,0,1)
			If EditList(TempList,TempArray,x,IIf(y = 0,i,-1),m) = False Then
				If y = 0 Then
					'确定快速定位引用
					k = RefQuickPosition(TargetFile,i,m,DlgEnable("AllShowButton"))
					If k > 0 Then
						t = 0
						ReDim intArry(AllStrDataList(i).SplitState - 1) As Long
						If DlgEnable("AllShowButton") = False Then
							For j = 0 To AllStrDataList(i).SplitState - 1
								intArry(j) = i + j + 1
							Next j
							t = AllStrDataList(i).SplitState
						Else
							For j = 0 To AllStrDataList(i).SplitState - 1
								If UseStrIDIndexDic.Exists(AllStrDataList(i + j + 1).ID) Then
									intArry(t) = UseStrIDIndexDic.Item(AllStrDataList(i + j + 1).ID)
									t = t + 1
								End If
							Next j
							If t > 0 Then ReDim Preserve intArry(t - 1) As Long
						End If
						If t > 0 Then
							ReDim TmpList(t - 1) As String,intList(t - 1) As Long
							For j = 0 To t - 1
								TmpList(j) = UseStrDataList(intArry(j)).Trans.sString
								intList(j) = intArray(0) + j + 1
							Next j
							n = GetDlgItem(CLng(DlgText("SuppValueBox")),DlgControlId("UseStrList"))
							ChangeListBoxItems(n,TmpList,intArry,intList)
							SetListBoxItems(n,intArray)
						End If
					End If
				End If
				If Stemp = False And k = 0 Then Exit Function
			ElseIf n = 0 Then
				MsgBox MsgList(39),vbOkOnly+vbInformation,MsgList(1)
				If Stemp = False Then Exit Function
			Else
				'按用户设置还原地址格式
				If StrToLong(Selected(16)) = 1 Then
					TempList = HexStrListToDecStrList(TempList)
					TempArray = HexStrListToDecStrList(TempArray)
				End If
				'备份当前字串数据
				ReDim DataList(1) As STRING_PROPERTIE
				DataList(0) = AllStrDataList(i)
				With AllStrDataList(i)
					'判断是否是删除子字串
					If .SplitState < 0 Then
						If CheckArray(TempArray) = False Then x = 3
					End If
					'定义使用的文件
					File = TargetFile
					'根据编辑列表对话框返回值选择不同的空位扩展方式
					If .Moveable <> 2 And .Trans.lMaxAddress > File.SecList(.Source.inSectionID).lPointerToRawData + _
						File.SecList(.Source.inSectionID).lSizeOfRawData Then
						If x < 0 Then
							'移位到新增节后空位的字串，先获取新增节后空位的信息
							If Selected(5) = "1" Or Selected(6) = "1" Then
								ReDim FreeByte(0) As FREE_BTYE_SPACE
								If Selected(5) = "1" Then
									FreeByte(0).inSectionID = .Source.inSectionID
								Else
									FreeByte(0).inSectionID = TargetFile.MaxSecID
									FreeByte(0).Length = File.SecList(.Source.inSectionID).lSizeOfRawData \ 10
								End If
								If AddSectionSize(File,FreeByte,0,StrToLong(Selected(1))) < 1 Then
									MsgBox MsgList(40),vbOkOnly+vbInformation,MsgList(1)
									Exit Function
								End If
							'移位到新增节的字串，先获取新增节信息
							ElseIf Selected(7) = "1" Then
								ReDim FreeByte(0) As FREE_BTYE_SPACE
								FreeByte(0).Length = File.SecList(.Source.inSectionID).lSizeOfRawData \ 10
								If AddSection(File,FreeByte(0),0,StrToLong(Selected(1))) < 1 Then
									MsgBox MsgList(41),vbOkOnly+vbInformation,MsgList(1)
									Exit Function
								End If
							End If
						Else
							'移位到节后空位的字串，先获取节后空位的信息
							Select Case .MoveType
							Case 4
								ReDim FreeByte(0) As FREE_BTYE_SPACE
								FreeByte(0).inSectionID = .Source.inSectionID
								If AddSectionSize(File,FreeByte,0,StrToLong(Selected(1))) < 1 Then
									MsgBox MsgList(40),vbOkOnly+vbInformation,MsgList(1)
									Exit Function
								End If
							Case 5
								ReDim FreeByte(0) As FREE_BTYE_SPACE
								FreeByte(0).inSectionID = TargetFile.MaxSecID
								FreeByte(0).Length = (.Trans.lMaxAddress - File.SecList(File.MaxSecID).lPointerToRawData + _
													File.SecList(File.MaxSecID).lSizeOfRawData) * 2
								If AddSectionSize(File,FreeByte,0,StrToLong(Selected(1))) < 1 Then
									MsgBox MsgList(40),vbOkOnly+vbInformation,MsgList(1)
									Exit Function
								End If
							'移位到新增节的字串，先获取新增节信息
							Case 6
								ReDim FreeByte(0) As FREE_BTYE_SPACE
								FreeByte(0).Length = (.Trans.lMaxAddress - File.SecList(File.MaxSecID).lPointerToRawData + _
													File.SecList(File.MaxSecID).lSizeOfRawData) * 2
								If AddSection(File,FreeByte(0),0,StrToLong(Selected(1))) < 1 Then
									MsgBox MsgList(41),vbOkOnly+vbInformation,MsgList(1)
									Exit Function
								End If
							End Select
						End If
					End If
				End With
				'不拆分字串时按常规字串计算移位或复位
				If x = 0 Then
					'获取子字串的原始引用地址和引用代码
					If AllStrDataList(i).SplitState < 0 Then
						k = SubString(TargetFile,File,DataList(0),i,TempArray,DlgEnable("AllShowButton"))
						'字串位置有变化时刷新字串列表框
						If k > -1 And k <> intArray(0) Then
							n = GetDlgItem(CLng(DlgText("SuppValueBox")),DlgControlId("UseStrList"))
							ChangeListBoxItems(n,UseStrDataList(k).Trans.sString,intArray(0),k)
							SetListBoxItems(n,k)
						End If
						k = -1  '为标记更改
					'获取父字串的原始引用地址和引用代码
					Else
						k = ParentString(TargetFile,File,DataList(0),i,TempArray)
						If k = 0 And Stemp = False Then Exit Function
					End If
				'用父字串管理子字串(增加、减少及合并)
				ElseIf AllStrDataList(i).SplitState > -1 Then
					t = 0
					With AllStrDataList(i)
						'同步随引用地址的自定义字串类型
						.Trans.Reference = .Source.Reference
						.Trans.lReferenceNum = .Source.lReferenceNum
						'获取父字串引用地址的引用代码(获取类型必须为 2)
						Call GetVARefList(File,"",.Trans,OrgStrTypeList,.TagType,.Moveable,StrListJoin(TempArray,RefJoinStr),2,0,0)
						ReDim TempList(0) As String,TempArray(0) As String
						'仅拆分子字串
						If .SplitState = 0 Then
							TempArray = RefList2StrList(.Trans,0)
							'确定快速定位引用
							.Source.Reference(0).Index = m
						'合并子字串
						ElseIf x = 2 Then
							TempList = RefList2StrList(DataList(0).Trans,0)
							ReDim intArry(.SplitState - 1) As Long
							If DlgEnable("AllShowButton") = False Then
								For j = 0 To .SplitState - 1
									intArry(j) = i + j + 1
								Next j
								t = .SplitState
							Else
								For j = 0 To .SplitState - 1
									If UseStrIDIndexDic.Exists(AllStrDataList(i + j + 1).ID) Then
										intArry(t) = UseStrIDIndexDic.Item(AllStrDataList(i + j + 1).ID)
										t = t + 1
									End If
								Next j
								If t > 0 Then ReDim Preserve intArry(t - 1) As Long
							End If
						'计算要增加的子字串和要删除的地址
						ElseIf .Trans.lReferenceNum > 0 Then
							ReDim intArry(.SplitState - 1) As Long
							If DlgEnable("AllShowButton") = False Then
								For j = 0 To .SplitState - 1
									intArry(j) = i + j + 1
								Next j
								t = .SplitState
							Else
								For j = 0 To .SplitState - 1
									If UseStrIDIndexDic.Exists(AllStrDataList(i + j + 1).ID) Then
										intArry(t) = UseStrIDIndexDic.Item(AllStrDataList(i + j + 1).ID)
										t = t + 1
									End If
								Next j
								If t > 0 Then ReDim Preserve intArry(t - 1) As Long
							End If
							ReDim TmpList(t - 1) As String,intList(t - 1) As Long
							'确定快速定位引用
							Call RefQuickPosition(TargetFile,i,m,DlgEnable("AllShowButton"))
							n = ManageSubString(TargetFile,File,DataList(0),i,TempArray,TempList,DlgEnable("AllShowButton"))
							If n = 0 Then Exit Function
							If n < 0 And t > 0 Then
								ReDim TmpList(t - 1) As String,intList(t - 1) As Long
								For j = 0 To t - 1
									TmpList(j) = UseStrDataList(intArry(j)).Trans.sString
									intList(j) = intArray(0) + j + 1
								Next j
								n = GetDlgItem(CLng(DlgText("SuppValueBox")),DlgControlId("UseStrList"))
								ChangeListBoxItems(n,TmpList,intArry,intList)
								SetListBoxItems(n,intArray)
							End If
						'当引用数为零时删除全部子字串
						Else
							If MsgBox(MsgList(42),vbYesNo+vbInformation,MsgList(0)) = vbNo Then
								AllStrDataList(i) = DataList(0)
								Exit Function
							End If
							TempList = RefList2StrList(DataList(0).Trans,0)
							ReDim intArry(.SplitState - 1) As Long
							If DlgEnable("AllShowButton") = False Then
								For j = 0 To .SplitState - 1
									intArry(j) = i + j + 1
								Next j
								t = .SplitState
							Else
								For j = 0 To .SplitState - 1
									If UseStrIDIndexDic.Exists(AllStrDataList(i + j + 1).ID) Then
										intArry(t) = UseStrIDIndexDic.Item(AllStrDataList(i + j + 1).ID)
										t = t + 1
									End If
								Next j
								If t > 0 Then ReDim Preserve intArry(t - 1) As Long
							End If
						End If
					End With
					'添加一个或多个子字串
					n = AddSubString(TargetFile,DataList,i,TempArray,DlgEnable("AllShowButton"),m)
					'删除一个或多个子字串
					m = DelSubStrings(TargetFile,TempList,DlgEnable("AllShowButton"))
					'从小到大排序并刷新显示字串列表框
					k = SortSubString(TargetFile,i,n,m,DlgEnable("AllShowButton"))
					If k <> 0 Then
						n = GetDlgItem(CLng(DlgText("SuppValueBox")),DlgControlId("UseStrList"))
						If t > 0 Then DelListBoxItems(n,intArry)
						t = AllStrDataList(i).SplitState
						If t > 0 Then
							ReDim TmpList(t - 1) As String,intList(t - 1) As Long
							If DlgEnable("AllShowButton") = False Then
								For j = 0 To t - 1
									TmpList(j) = AllStrDataList(i + j + 1).Trans.sString
									intList(j) = intArray(0) + j + 1
								Next j
							Else
								t = 0
								For j = 0 To AllStrDataList(i).SplitState - 1
									If UseStrIDIndexDic.Exists(AllStrDataList(i + j + 1).ID) Then
										TmpList(t) = AllStrDataList(i + j + 1).Trans.sString
										intList(t) = intArray(0) + t + 1
										t = t + 1
									End If
								Next j
								If t > 0 Then
									ReDim Preserve TmpList(t - 1) As String,intList(t - 1) As Long
								End If
							End If
							If t > 0 Then
								For j = 0 To UBound(intList)
									AddListBoxItems(n,TmpList(j),intList(j))
								Next j
								SetListBoxItems(n,intArray)
							End If
						End If
					End If
					'父字串未翻译时，所有翻译引用全部清空
					If AllStrDataList(i).SplitState = 0 Then
						If AllStrDataList(i).WriteType = 0 Then
							AllStrDataList(i).Trans.lReferenceNum = 0
							ReDim AllStrDataList(i).Trans.Reference(0) 'As STRING_SUB_PROPERTIE
						End If
					End If
				'删除单个子字串
				Else
					k = DelSubString(TargetFile,DataList(0),i,DlgEnable("AllShowButton"))
					If k <> 0 Then
						intArray(0) = intArray(0) - 1
						n = GetDlgItem(CLng(DlgText("SuppValueBox")),DlgControlId("UseStrList"))
						DelListBoxItems(n,intArray(0) + 1)
						SetListBoxItems(n,intArray)
					End If
					i = i - 1
					'父字串未翻译时，所有翻译引用全部清空
					If AllStrDataList(i).SplitState = 0 Then
						If AllStrDataList(i).WriteType = 0 Then
							AllStrDataList(i).Trans.lReferenceNum = 0
							ReDim AllStrDataList(i).Trans.Reference(0) 'As STRING_SUB_PROPERTIE
						End If
					End If
				End If
				If y = 0 Then Call AutoComment(i,x,MsgList)
			End If
			If k > 0 Then
				If AllStrDataList(i).Moveable <> 2 Then
					'分配空余地址
					Call ShowMoveMsg(MoveString(TargetFile,AllStrDataList,0,StrToLong(Selected(1)),0),k,1)
					'超长移位模式字串移位不成功时清空翻译引用列表
					If AllStrDataList(i).MoveMode = 0 And AllStrDataList(i).WriteType = 2 Then
						ReDim AllStrDataList(i).Trans.Reference(0) 'As REFERENCE_PROPERTIE
						AllStrDataList(i).Trans.lReferenceNum = 0
						AllStrDataList(i).Trans.GetRefState = 0
					End If
				End If
			End If
			DlgEnable "AllResetButton",True
			If y = 0 And k <> 0 Then
				If DlgValue("ModeCheckBox") = 1 Then DlgValue "ModeCheckBox",2
			End If
			DlgItem$ = "UseStrList"
		Case "AllWriteButton", "WriteButton"
			WriteSet = 0
			Stemp = IIf(DlgItem$ = "AllWriteButton",False,True)
			If TargetFile.Magic = "" Then
				ReDim TempArray(4) As String
				TempArray(0) = MsgList(43)
				TempArray(1) = MsgList(44)
				TempArray(2) = MsgList(45)
				TempArray(3) = MsgList(46)
				k = ShowPopupMenu(TempArray,vbPopupUseRightButton)
				If k < 0 Then Exit Function
				WriteSet = k - 1
			ElseIf Stemp = True Then
				'添加移位到其他字串的字串索引号
				i = AddIndexList(AllStrDataList,intList,intArray)
				If i > 0 Then
					Select Case MsgBox(Replace$(MsgList(47),"%s",CStr(i)),vbYesNoCancel+vbInformation,MsgList(0))
					Case vbYes
						intList = intArray
					Case vbCancel
						Exit Function
					End Select
				End If
			End If
			'显示写入结果模式
			DlgText "MsgOutputButton",MsgList(30)
			DlgEnable "WriteButton",False
			DlgVisible "AllWriteButton",False
			DlgVisible "UndoWriteButton",True
			DlgVisible "OrgStringText",False
			DlgVisible "TrnStringText",False
			DlgVisible "OrgStringBox",False
			DlgVisible "TrnStringBox",False
			DlgVisible "OrgCheckBox",False
			DlgVisible "TrnCheckBox",False
			DlgVisible "MsgOutputText",True
			DlgVisible "MsgOutputGroup",True
			DlgVisible "ActionProgressBox",False
			DlgVisible "FindResultsBox",False
			DlgVisible "WriteResultsBox",True
			DlgValue "MsgOutputGroup",2
			'写入字串
			Call WriteStrings(TargetFile,GetDlgItem(CLng(DlgText("SuppValueBox")),DlgControlId("WriteResultsBox")),intList,Stemp)
			Exit Function
		Case "LockButton"
			For i = LBound(intList) To UBound(intList)
				AllStrDataList(intList(i)).LockState = 1
			Next i
			DlgVisible "LockButton",False
			DlgVisible "UnLockButton",True
			Exit Function
		Case "UnLockButton"
			For i = LBound(intList) To UBound(intList)
				AllStrDataList(intList(i)).LockState = 0
			Next i
			DlgVisible "LockButton",True
			DlgVisible "UnLockButton",False
			Exit Function
		Case "FindResultsBox"
			If CheckArray(FindLog) = False Then Exit Function
			m = FindLogDic.Count
			If m = 0 Then Exit Function
			intArray = GetListBoxIndexs(GetDlgItem(CLng(DlgText("SuppValueBox")),DlgControlId("FindResultsBox")))
			If CheckArrEmpty(intArray) = False Then Exit Function
			If DlgEnable("AllShowButton") = True Then
				For i = LBound(intArray) To UBound(intArray)
					j = intArray(i)
					If j > -1 And j < m Then
						If FindLogDic.Exists(j) Then
							If UseStrIDIndexDic.Exists(FindLogDic.Item(j)) Then
								intArray(n) = UseStrIDIndexDic.Item(FindLogDic.Item(j))
								n = n + 1
							End If
						End If
					End If
				Next i
			Else
				For i = LBound(intArray) To UBound(intArray)
					j = intArray(i)
					If j > -1 And j < m Then
						If FindLogDic.Exists(j) Then
							If StrIDIndexDic.Exists(FindLogDic.Item(j)) Then
								intArray(n) = StrIDIndexDic.Item(FindLogDic.Item(j))
								n = n + 1
							End If
						End If
					End If
				Next i
			End If
			If n = 0 Then Exit Function
			ReDim Preserve intArray(n - 1) As Long
			SetListBoxItems(GetDlgItem(CLng(DlgText("SuppValueBox")),DlgControlId("UseStrList")),intArray)
			DlgItem$ = "UseStrList"
		Case "WriteResultsBox"
			If CheckArray(WriteLog) = False Then Exit Function
			m = WriteLogDic.Count
			If m = 0 Then Exit Function
			intArray = GetListBoxIndexs(GetDlgItem(CLng(DlgText("SuppValueBox")),DlgControlId("WriteResultsBox")))
			If CheckArrEmpty(intArray) = False Then Exit Function
			If DlgEnable("AllShowButton") = True Then
				For i = LBound(intArray) To UBound(intArray)
					j = intArray(i) - 2
					If j > -1 And j < m Then
						If WriteLogDic.Exists(j) Then
							If UseStrIDIndexDic.Exists(WriteLogDic.Item(j)) Then
								intArray(n) = UseStrIDIndexDic.Item(WriteLogDic.Item(j))
								n = n + 1
							End If
						End If
					End If
				Next i
			Else
				For i = LBound(intArray) To UBound(intArray)
					j = intArray(i) - 2
					If j > -1 And j < m Then
						If WriteLogDic.Exists(j) Then
							If StrIDIndexDic.Exists(WriteLogDic.Item(j)) Then
								intArray(n) = StrIDIndexDic.Item(WriteLogDic.Item(j))
								n = n + 1
							End If
						End If
					End If
				Next i
			End If
			If n = 0 Then Exit Function
			ReDim Preserve intArray(n - 1) As Long
			SetListBoxItems(GetDlgItem(CLng(DlgText("SuppValueBox")),DlgControlId("UseStrList")),intArray)
			DlgItem$ = "UseStrList"
		End Select

		If DlgItem$ = "SetButton" Or Stemp3 = True Or Stemp4 = True Then
			If DlgItem$ = "SetButton" Then
				TempList = Selected
				ReDim tmpLFList(2) As LOG_FONT
				tmpLFList = LFList
				Call Settings(IIf(TargetFile.hcsFile.FilePath = SourceFile.hcsFile.FilePath,0,3))
				If Selected(0) <> TempList(0) Then Stemp3 = True
			End If
			'更改字串地址的显示格式
			If Selected(16) <> TempList(16) Then DlgItem$ = "UseStrList"
			If Stemp3 = True Then
				'更新非 PE 文件和隐藏区段名
				Select Case SourceFile.Magic
				Case "NotPE32","NotPE64",""
					If getMsgList(UIDataList,MsgList,"CheckFile",1) = True Then
						UseSectionList(0) = MsgList(10)
						SourceFile.SecList(0).sName = MsgList(10)
						TargetFile.SecList(0).sName = MsgList(10)
						DlgText "OrgInSectionBox",MsgList(10)
						DlgText "TrnInSectionBox",MsgList(10)
					End If
				Case Else
					If SourceFile.SecList(SourceFile.MaxSecIndex).lSizeOfRawData > 0 Then
						If getMsgList(UIDataList,MsgList,"CheckFile",1) = True Then
							Temp = SourceFile.SecList(SourceFile.MaxSecIndex).sName
							For i = 0 To UBound(UseSectionList)
								If UseSectionList(i) = SourceFile.SecList(SourceFile.MaxSecIndex).sName Then
									UseSectionList(i) = MsgList(9)
									Exit For
								End If
							Next i
							SourceFile.SecList(SourceFile.MaxSecIndex).sName = MsgList(9)
							TargetFile.SecList(SourceFile.MaxSecIndex).sName = MsgList(9)
							If DlgText("OrgInSectionBox") = Temp Then DlgText "OrgInSectionBox",MsgList(9)
							If DlgText("TrnInSectionBox") = Temp Then DlgText "TrnInSectionBox",MsgList(9)
						End If
					End If
				End Select
				'更新当前对话框字串
				If getMsgList(UIDataList,MsgList,"EditString",1) = True Then
	   				If TargetFile.hcsFile.FilePath = "" Then
	   					MsgList(0) = Replace$(Replace$(MsgList(0),"%s",Version),"%d",MsgList(40))
	   				Else
	   					MsgList(0) = Replace$(Replace$(MsgList(0),"%s",Version),"%d",TargetFile.hcsFile.FilePath)
	   					If Len(MsgList(0)) > 110 Then
	   						MsgList(0) = Left$(MsgList(0),InStr(MsgList(0),"\")) & "..." & Right(MsgList(0),110 - Len(Left$(MsgList(0),InStr(MsgList(0),"\"))))
	   					End If
	   				End If
	   				DlgText -1,MsgList(0)
   					DlgText "inSectionText",MsgList(1)
					DlgText "StartPosText",MsgList(2)
					DlgText "MaxPosText",MsgList(3)
					DlgText "VOffsetText",MsgList(4)
					DlgText "RefNumText",MsgList(5)

					DlgText "StrLengthText",MsgList(6)
					DlgText "StrTypeNameText",MsgList(7)
					DlgText "OrgStrCodeText",MsgList(8)
					DlgText "TrnStrCodeText",MsgList(9)

					DlgText "RefListButton",MsgList(10)
					DlgText "DelButton",MsgList(11)
					DlgText "LockButton",MsgList(12)
					DlgText "UnLockButton",MsgList(13)
					DlgText "SelectAllButton",MsgList(14)
					DlgText "ResetButton",MsgList(15)
					DlgText "WriteButton",MsgList(16)
					DlgText "AddFilterStrButton",MsgList(17)
					DlgText "DelFilterStrButton",MsgList(18)
					DlgText "FindButton",MsgList(19)
					DlgText "FilterButton1",MsgList(45)
					DlgText "FilterButton2",MsgList(46)
					DlgText "FilterButton3",MsgList(47)
					DlgText "FilterShowButton",MsgList(20)
					DlgText "AllShowButton",MsgList(21)
					DlgText "StopButton",MsgList(39)
					DlgText "RefreshButton",MsgList(41)
					DlgText "UpButton",MsgList(42)
					DlgText "DownButton",MsgList(43)

					DlgText "OrgStringText",MsgList(22)
					DlgText "TrnStringText",MsgList(23)
					DlgText "OrgCheckBox",MsgList(24)
					DlgText "TrnCheckBox",MsgList(25)

					DlgText "MsgOutputText",MsgList(26)
					DlgText "ActionProgressCheckBox",MsgList(27)
					DlgText "FindResultsCheckBox",MsgList(44)
					DlgText "WriteResultsCheckBox",MsgList(28)

					DlgText "HelpButton",MsgList(29)
					DlgText "SetButton",MsgList(30)
					DlgText "AllResetButton",MsgList(31)
					DlgText "EditButton",MsgList(32)
					DlgText "ReExtractButton",MsgList(33)
					DlgText "GetStrSetButton",MsgList(34)
					DlgText "AllWriteButton",MsgList(35)
					DlgText "UndoWriteButton",MsgList(36)
					'DlgText "MsgOutputButton",""
					DlgText "SaveButton",MsgList(37)
					DlgText "ExitButton",MsgList(38)
				End If
				If getMsgList(UIDataList,MsgList,"EditStringDlgFunc",1) = True Then
					Select Case DlgValue("MsgOutputGroup")
					Case 0
						DlgText "MsgOutputButton",IIf(DlgVisible("ActionProgressBox") = True,MsgList(30),MsgList(22))
					Case 1
						DlgText "MsgOutputButton",IIf(DlgVisible("FindResultsBox") = True,MsgList(30),MsgList(22))
					Case Else
						DlgText "MsgOutputButton",IIf(DlgVisible("WriteResultsBox") = True,MsgList(30),MsgList(22))
					End Select
					If CheckDataArray(UseStrDataList) = True Then
						DlgText "StringNums",Replace$(Replace$(Replace$(MsgList(6),"%n",CStr(intList(0))), _
								"%s",CStr(UBound(UseStrDataList) + 1)),"%d",CStr(UBound(intList) + 1))
					Else
						DlgText "StringNums",Replace$(Replace$(Replace$(MsgList(6),"%n","0"),"%s","0"),"%d","0")
					End If
				End If
			End If
			'更新字串类型数组的名称，用于显示
			TmpList = MergeStrType2StrList(StrTypeList,OrgStrTypeList,OrgStrTypeList,ReSplit(MsgList(4),ItemJoinStr))
			DlgListBoxArray "StrTypeNameList",TmpList()
			DlgValue "StrTypeNameList",StrTypeValue(AllStrDataList(intList(0)).StrType)
			'分割代码页数组的名称和值，用于显示
			TempArray = GetLangStrList(UniLangList,3,True)
			DlgListBoxArray "OrgCodePageNameList",TempArray()
			DlgListBoxArray "TrnCodePageNameList",TempArray()
			TempArray = GetLangStrList(UniLangList,4,True)
			DlgListBoxArray "OrgCodePageValList",TempArray()
			DlgListBoxArray "TrnCodePageValList",TempArray()
			DlgText "OrgCodePageValList",CStr$(AllStrDataList(intList(0)).Source.CodePage)
			DlgText "TrnCodePageValList",CStr$(AllStrDataList(intList(0)).Trans.CodePage)
			DlgValue "OrgCodePageNameList",DlgValue("OrgCodePageValList")
			DlgValue "TrnCodePageNameList",DlgValue("TrnCodePageValList")
			'判断是否需要重置并移位
			If SourceFile.Magic <> "" Then
				If TargetFile.hcsFile.FilePath <> SourceFile.hcsFile.FilePath Then
					k = 0
					If Selected(10) <> TempList(10) Then
						MsgBox MsgList(94),vbOkOnly+vbInformation,MsgList(1)
						'显示消息输出模式
						j = StrToLong(Selected(17))
						If j > 0 Then
							If DlgVisible("ActionProgressBox") = False Then
								DlgVisible "OrgStringText",False
								DlgVisible "TrnStringText",False
								DlgVisible "OrgStringBox",False
								DlgVisible "TrnStringBox",False
								DlgVisible "OrgCheckBox",False
								DlgVisible "TrnCheckBox",False
								DlgVisible "MsgOutputText",True
								DlgVisible "MsgOutputGroup",True
								DlgVisible "ActionProgressBox",True
								DlgVisible "FindResultsBox",False
								DlgVisible "WriteResultsBox",False
								DlgValue "MsgOutputGroup",0
								DlgText "MsgOutputButton",MsgList(30)
							End If
							j = GetDlgItem(CLng(DlgText("SuppValueBox")),DlgControlId("ActionProgressBox"))
							SetTextBoxString j,MsgList(34)
						ElseIf j < 0 Then
							j = -2
							PSL.OutputWnd(0).Clear
							PSL.Output MsgList(34)
						End If
						If SetOverWriteAndGetRef(TargetFile,AllStrDataList,StrToLong(Selected(10)),j) > 0 Then
							MsgList(29) = MsgList(34) & " 100%" & TextJoinStr & MsgList(29)
						End If
						k = 2
					ElseIf ArrayComp(Selected,TempList,"2-7") = True Then
						If Selected(8) = "1" Then
							MsgBox MsgList(55),vbOkOnly+vbInformation,MsgList(1)
							k = 1
						Else
							MsgBox MsgList(56),vbOkOnly+vbInformation,MsgList(1)
							k = 2
						End If
					ElseIf Selected(11) <> TempList(11) Then
						If StrToLong(Selected(6) & Selected(7)) = 0 Then
							MsgBox MsgList(57),vbOkOnly+vbInformation,MsgList(1)
							k = 2
						End If
					End If
					If k > 0 Then
						If k <> 2 Then
							'显示消息输出模式
							j = StrToLong(Selected(17))
							If j > 0 Then
								If DlgVisible("ActionProgressBox") = False Then
									DlgVisible "OrgStringText",False
									DlgVisible "TrnStringText",False
									DlgVisible "OrgStringBox",False
									DlgVisible "TrnStringBox",False
									DlgVisible "OrgCheckBox",False
									DlgVisible "TrnCheckBox",False
									DlgVisible "MsgOutputText",True
									DlgVisible "MsgOutputGroup",True
									DlgVisible "ActionProgressBox",True
									DlgVisible "FindResultsBox",False
									DlgVisible "WriteResultsBox",False
									DlgValue "MsgOutputGroup",0
									DlgText "MsgOutputButton",MsgList(30)
								End If
								j = GetDlgItem(CLng(DlgText("SuppValueBox")),DlgControlId("ActionProgressBox"))
							ElseIf j < 0 Then
								j = -2
							End If
						End If
						Call ResetAndMoveStrings(TargetFile,AllStrDataList,k,MsgList(29),MsgList(21),j)
						DlgItem$ = "UseStrList"
					End If
				End If
			End If
			'判断是否需要重置对话框主字体
			If FontComp(LFList(0),tmpLFList(0)) = True Then
				k = CLng(DlgText("SuppValueBox"))
				j = CreateFont(k,LFList(0))
				If j <> 0 Then
					For i = 0 To DlgCount() - 1
						If DlgType(i) <> "MultiListBox" And DlgName(i) <> "OrgStringBox" And DlgName(i) <> "TrnStringBox" Then
							DrawWindow(GetDlgItem(k,DlgControlId(DlgName(i))),j)
						End If
					Next i
				End If
			End If
			'设置字串列表框和字串编辑框字体
			If TargetFile.hcsFile.FilePath = SourceFile.hcsFile.FilePath Then
				If FontComp(LFList(1),tmpLFList(1)) = True Then
					k = CLng(DlgText("SuppValueBox"))
					j = CreateFont(k,LFList(1))
					If j <> 0 Then
						TempList = ReSplit("UseStrList;OrgStringBox;FindResultsBox",";")
						For i = 0 To UBound(TempList)
							DrawWindow(GetDlgItem(k,DlgControlId(TempList(i))),j)
						Next i
					End If
				End If
				If FontComp(LFList(2),tmpLFList(2)) = True Then
					k = CLng(DlgText("SuppValueBox"))
					j = CreateFont(k,LFList(2))
					If j <> 0 Then
						DrawWindow(GetDlgItem(k,DlgControlId("TrnStringBox")),j)
					End If
				End If
			Else
				If FontComp(LFList(1),tmpLFList(1)) = True Then
					k = CLng(DlgText("SuppValueBox"))
					j = CreateFont(k,LFList(1))
					If j <> 0 Then
						DrawWindow(GetDlgItem(k,DlgControlId("OrgStringBox")),j)
					End If
				End If
				If FontComp(LFList(2),tmpLFList(2)) = True Then
					k = CLng(DlgText("SuppValueBox"))
					j = CreateFont(k,LFList(2))
					If j <> 0 Then
						TempList = ReSplit("UseStrList;TrnStringBox;FindResultsBox;WriteResultsBox",";")
						For i = 0 To UBound(TempList)
							DrawWindow(GetDlgItem(k,DlgControlId(TempList(i))),j)
						Next i
					End If
				End If
			End If
			If DlgItem$ <> "UseStrList" Then Exit Function
		End If

		If CheckDataArray(UseStrDataList) = True Then
			m = IIf(TargetFile.hcsFile.FilePath = SourceFile.hcsFile.FilePath,1,0)
			If DlgItem$ = "UseStrList" Then
				i = GetDlgItem(CLng(DlgText("SuppValueBox")),DlgControlId("UseStrList"))
				intArray = GetListBoxIndexs(i)
				If CheckArrEmpty(intArray) = False Then Exit Function
				intList = intArray
				ReDim Preserve intList(0) As Long
				DlgText "StrIndexBox",CStr$(intList(0))
				If GetIndexList(StrIDIndexDic,UseStrDataList,intList,False) = False Then Exit Function
				i = intList(0): j = 0
				With AllStrDataList(i)
					DlgText "OrgInSectionBox",GetSectionName(SourceFile,.Source.inSectionID,.Source.inSubSecID)
					If .MoveType < 6 Then
						DlgText "TrnInSectionBox",GetSectionName(TargetFile,.Trans.inSectionID,.Trans.inSubSecID)
					ElseIf InStr(TargetFile.Magic,"PE") Then
						DlgText "TrnInSectionBox",NewPESecName
					Else
						DlgText "TrnInSectionBox",NewMacSecName
					End If

					DlgText "OrgStartPosBox",ValToStr(.Source.lStartAddress,TargetFile.FileSize,StrToLong(Selected(16)))
					DlgText "OrgMaxPosBox",ValToStr(.Source.lMaxAddress,TargetFile.FileSize,StrToLong(Selected(16)))
					DlgText "OrgRefNumBox",CStr$(.Source.lReferenceNum)
					DlgValue "StrTypeNameList",StrTypeValue(.StrType)
					DlgText "OrgCodePageValList",CStr$(.Source.CodePage)
					DlgValue "OrgCodePageNameList",DlgValue("OrgCodePageValList")
					DlgText "OrgStrLengthBox",CStr$(.Source.lHexLength)

					DlgText "TrnStartPosBox",ValToStr(.Trans.lStartAddress,TargetFile.FileSize,StrToLong(Selected(16)))
					DlgText "TrnMaxPosBox",ValToStr(.Trans.lMaxAddress,TargetFile.FileSize,StrToLong(Selected(16)))
					DlgText "TrnRefNumBox",CStr$(.Trans.lReferenceNum)
					DlgText "TrnCodePageValList",CStr$(.Trans.CodePage)
					DlgValue "TrnCodePageNameList",DlgValue("TrnCodePageValList")
					DlgText "TrnStrLengthBox",CStr$(.Trans.lHexLength)

					DlgText "MaxStrLengthBox",CStr$(.Trans.lMaxHexLength)
					DlgText "OrgStringBox",IIf(StrToLong(Selected(19)) = 0,.Source.sString,Replace$(.Source.sString," ",SpaceWithPointChar))
					DlgText "TrnStringBox",IIf(StrToLong(Selected(19)) = 0,.Trans.sString,Replace$(.Trans.sString," ",SpaceWithPointChar))

					TempList = GetRefCodeList(AllStrDataList(i),False)
					DlgListBoxArray "OrgVOffsetList",TempList()
					TempList = GetRefCodeList(GetVARefForMoveMode2(TargetFile,AllStrDataList(i)),True,j)
					DlgListBoxArray "TrnVOffsetList",TempList()
					DlgValue "OrgVOffsetList",j
					DlgValue "TrnVOffsetList",j

					'定位写入消息框中的消息
					If DlgItem$ = "UseStrList" Then
						If DlgVisible("FindResultsBox") = True Then
							If CheckArray(FindLog) = True Then
								n = 0: x = UBound(intArray)
								ReDim intArry(x) As Long
								If DlgEnable("AllShowButton") = True Then
									For k = 0 To x
										j = intArray(k)
										If FindLogDic.Exists(CStr(UseStrDataList(j).ID)) Then
											intArry(n) = FindLogDic.Item(CStr(UseStrDataList(j).ID))
											n = n + 1
										End If
									Next k
								Else
									For k = 0 To x
										j = intArray(k)
										If FindLogDic.Exists(CStr(AllStrDataList(j).ID)) Then
											intArry(n) = FindLogDic.Item(CStr(AllStrDataList(j).ID))
											n = n + 1
										End If
									Next k
								End If
								If n > 0 Then
									ReDim Preserve intArry(n - 1) As Long
									SetListBoxItems(GetDlgItem(CLng(DlgText("SuppValueBox")),DlgControlId("FindResultsBox")),intArry)
								End If
							End If
						ElseIf DlgVisible("WriteResultsBox") = True Then
							If CheckArray(WriteLog) = True Then
								n = 0: x = UBound(intArray)
								ReDim intArry(x) As Long
								If DlgEnable("AllShowButton") = True Then
									For k = 0 To x
										j = intArray(k)
										If WriteLogDic.Exists(CStr(UseStrDataList(j).ID)) Then
											intArry(n) = WriteLogDic.Item(CStr(UseStrDataList(j).ID)) + 2
											n = n + 1
										End If
									Next k
								Else
									For k = 0 To x
										j = intArray(k)
										If WriteLogDic.Exists(CStr(AllStrDataList(j).ID)) Then
											intArry(n) = WriteLogDic.Item(CStr(AllStrDataList(j).ID)) + 2
											n = n + 1
										End If
									Next k
								End If
								If n > 0 Then
									ReDim Preserve intArry(n - 1) As Long
									SetListBoxItems(GetDlgItem(CLng(DlgText("SuppValueBox")),DlgControlId("WriteResultsBox")),intArry)
								End If
							End If
						End If
					End If

					'确定重置按钮的显示状态
					If DlgEnable("AllResetButton") = True Then
						DlgEnable "ResetButton",DataCompByID(AllStrDataList(i),AllStrDataListBak,StrIDIndexDicBak,m)
					Else
						DlgEnable "ResetButton",False
					End If

					'确定开始地址输入框、引用代码和引用地址按钮的显示状态
					If .Moveable = 2 Then
						DlgEnable "OrgStartPosBox",False
						DlgEnable "OrgMaxPosBox",False
						DlgEnable "TrnStartPosBox",False
						If .Source.lReferenceNum = 0 Then
							DlgEnable "OrgVOffsetList",False
							DlgEnable "TrnVOffsetList",False
						Else
							DlgEnable "OrgVOffsetList",True
							DlgEnable "TrnVOffsetList",True
						End If
						DlgEnable "RefListButton",True
					ElseIf .Moveable > 0 Then
						If m = 1 Then
							DlgEnable "OrgStartPosBox",True
							DlgEnable "OrgMaxPosBox",True
						End If
						DlgEnable "OrgVOffsetList",False
						DlgEnable "TrnVOffsetList",False
						DlgEnable "TrnStartPosBox",False
						DlgEnable "RefListButton",False
					ElseIf .Source.lReferenceNum = 0 Then
						If m = 1 Then
							DlgEnable "OrgStartPosBox",True
							DlgEnable "OrgMaxPosBox",True
						End If
						DlgEnable "OrgVOffsetList",False
						DlgEnable "TrnVOffsetList",False
						If .Source.GetRefState = 1 Then
							DlgEnable "TrnStartPosBox",False
						Else
							DlgEnable "TrnStartPosBox",IIf((.WriteType < -1 Or .WriteType > 0) And .SplitState < 1,True,False)
						End If
						DlgEnable "RefListButton",IIf(Selected(8) = "1",True,False)
					Else
						If m = 1 Then
							DlgEnable "OrgStartPosBox",True
							DlgEnable "OrgMaxPosBox",True
						End If
						DlgEnable "OrgVOffsetList",True
						DlgEnable "TrnVOffsetList",True
						DlgEnable "TrnStartPosBox",IIf((.WriteType < -1 Or .WriteType > 0) And .SplitState < 1,True,False)
						DlgEnable "RefListButton",IIf(Selected(8) = "1",True,False)
					End If
					If .LockState = 0 Then
						DlgVisible "LockButton",True
						DlgVisible "UnLockButton",False
					Else
						DlgVisible "LockButton",False
						DlgVisible "UnLockButton",True
					End If
					If ReSplit(FilterStrSet(17),ItemJoinStr)(1) = "0" Then
						Temp = Trim$(.Source.sString)
					Else
						Temp = Trim$(DelAccKey(.Source.sString))
					End If
					If FilterStrDic.Exists(Temp) Then
						DlgVisible "AddFilterStrButton",False
						DlgVisible "DelFilterStrButton",True
					Else
						DlgVisible "AddFilterStrButton",True
						DlgVisible "DelFilterStrButton",False
					End If
				End With
				DlgText "StringNums",Replace$(Replace$(Replace$(MsgList(6),"%n",CStr(i)), _
						"%s",CStr(UBound(UseStrDataList) + 1)),"%d",CStr(UBound(intArray) + 1))
			End If
			DlgEnable "LockButton",True
			DlgEnable "UnLockButton",True
			DlgEnable "AddFilterStrButton",DlgVisible("AddFilterStrButton")
			DlgEnable "DelFilterStrButton",DlgVisible("DelFilterStrButton")
			DlgEnable "SelectAllButton",True
			DlgEnable "FindButton",True
			If DlgListBoxArray("UseStrList") < 2 Then
				DlgEnable "UpButton",False
				DlgEnable "DownButton",False
			Else
				Select Case intArray(0)
				Case Is < 1
					DlgEnable "UpButton",False
					DlgEnable "DownButton",True
				Case DlgListBoxArray("UseStrList") - 1
					DlgEnable "UpButton",True
					DlgEnable "DownButton",False
				Case Else
					DlgEnable "UpButton",True
					DlgEnable "DownButton",True
				End Select
			End If
			'DlgEnable "RefreshButton",True
			'DlgEnable "FilterShowButton",True
			If m = 1 Then
				DlgEnable "StrTypeNameList",True
				DlgEnable "OrgCodePageNameList",True
				DlgEnable "DelButton",True
			Else
				DlgEnable "TrnCodePageNameList",True
				If DlgVisible("UndoWriteButton") = False Then
					DlgEnable "AllWriteButton",True
					DlgEnable "WriteButton",True
				End If
			End If
		Else
			ReDim TempList(0) As String
			DlgText "OrgInSectionBox",""
			DlgText "OrgStartPosBox",""
			DlgText "OrgMaxPosBox",""
			DlgListBoxArray "OrgVOffsetList",TempList()
			DlgValue "OrgVOffsetList",0
			DlgText "OrgRefNumBox","0"
			DlgText "OrgCodePageValList","-1"
			DlgValue "OrgCodePageNameList",DlgValue("OrgCodePageValList")
			DlgText "OrgStrLengthBox","0"

			DlgText "TrnInSectionBox",""
			DlgText "TrnStartPosBox",""
			DlgText "TrnMaxPosBox",""
			DlgListBoxArray "TrnVOffsetList",TempList()
			DlgValue "TrnVOffsetList",0
			DlgText "TrnRefNumBox","0"
			DlgText "TrnCodePageValList","-1"
			DlgValue "TrnCodePageNameList",DlgValue("TrnCodePageValList")
			DlgText "TrnStrLengthBox","0"

			DlgText "MaxStrLengthBox","0"
			DlgText "OrgStringBox",""
			DlgText "TrnStringBox",""
			DlgText "StringNums",Replace$(Replace$(Replace$(MsgList(6),"%n","0"),"%s","0"),"%d","0")

			DlgEnable "OrgStartPosBox",False
			DlgEnable "OrgMaxPosBox",False
			DlgValue "StrTypeNameList",0
			DlgEnable "StrTypeNameList",False
			DlgEnable "OrgCodePageNameList",False
			DlgEnable "TrnStartPosBox",False
			DlgEnable "TrnCodePageNameList",False
			DlgEnable "RefListButton",False
			DlgEnable "OrgVOffsetList",False
			DlgEnable "TrnVOffsetList",False
			DlgEnable "DelButton",False
			'DlgVisible "LockButton",True
			'DlgVisible "UnLockButton",False
			DlgEnable "LockButton",False
			DlgEnable "UnLockButton",False
			DlgEnable "SelectAllButton",False
			DlgEnable "FindButton",False
			DlgEnable "UpButton",False
			DlgEnable "DownButton",False
			DlgEnable "ResetButton",False
			DlgVisible "AddFilterStrButton",True
			DlgVisible "DelFilterStrButton",False
			DlgEnable "AddFilterStrButton",False
			DlgEnable "DelFilterStrButton",False
			'DlgEnable "RefreshButton",True
			'DlgEnable "FilterShowButton",False
			DlgEnable "WriteButton",False
			DlgEnable "AllWriteButton",False
		End If
	Case 3 ' 文本框或者组合框文本被更改
		Select Case DlgItem$
		Case "OrgStartPosBox","OrgMaxPosBox","TrnStartPosBox","TrnMaxPosBox","OrgStringBox","TrnStringBox"
			'获取当前选定字串在所有字串数据中的索引列表
			If CheckDataArray(UseStrDataList) = False Then Exit Function
			intArray = GetListBoxIndexs(GetDlgItem(CLng(DlgText("SuppValueBox")),DlgControlId("UseStrList")))
			If CheckArrEmpty(intArray) = False Then Exit Function
			ReDim Preserve intArray(0) As Long
			If DlgText("StrIndexBox") = "" Then DlgText "StrIndexBox",CStr$(intArray(0))
			If intArray(0) <> StrToLong(DlgText("StrIndexBox")) Then
				intArray(0) = StrToLong(DlgText("StrIndexBox"))
				DlgText "StrIndexBox",CStr$(intArray(0))
			End If
			intList = intArray
			If DlgEnable("AllShowButton") = True Then
				If GetIndexList(StrIDIndexDic,UseStrDataList,intList,False) = False Then
					Exit Function
				End If
			End If
			i = intList(0)	'注意：后面不可用 i 变量
			If getMsgList(UIDataList,MsgList,"EditStringDlgFunc",1) = False Then Exit Function
			'拒绝对锁定字串进行编辑
			If AllStrDataList(i).LockState > 0 Then
				MsgBox MsgList(58),vbOkOnly+vbInformation,MsgList(1)
				Exit Function
			End If
			'获取字串所在节最小地址和最大地址(注意 y, t 变量后面要用到)
			If AllStrDataList(i).Source.inSectionID <= SourceFile.MaxSecIndex Then
				y = TargetFile.SecList(AllStrDataList(i).Source.inSectionID).lPointerToRawData
				t = y + TargetFile.SecList(AllStrDataList(i).Source.inSectionID).lSizeOfRawData - 1
			Else
				MsgBox MsgList(59),vbOkOnly+vbInformation,MsgList(1)
				Exit Function
			End If
			'处理文本框或者组合框文本的更改
			ReDim DataList(0) As STRING_PROPERTIE
			DataList(0) = AllStrDataList(i)
		Case Else
			Exit Function
		End Select
		Select Case DlgItem$
		Case "OrgStartPosBox"
			With AllStrDataList(i)
				DlgText "OrgStartPosBox",UCase$(Trim$(DlgText("OrgStartPosBox")))
				'检查输入的地址是否合法
				If StrToLong(Selected(16)) = 0 Then
					If CheckStrRegExp(DlgText("OrgStartPosBox"),"[0-9]",0,1) = False Then
						MsgBox MsgList(95),vbOkOnly+vbInformation,MsgList(1)
						DlgText "OrgStartPosBox",ValToStr(.Source.lStartAddress,TargetFile.FileSize,StrToLong(Selected(16)))
						Exit Function
					End If
				ElseIf CheckStrRegExp(DlgText("OrgStartPosBox"),CheckSkipStr(6),0,1,True) = False Then
					MsgBox MsgList(95),vbOkOnly+vbInformation,MsgList(1)
					DlgText "OrgStartPosBox",ValToStr(.Source.lStartAddress,TargetFile.FileSize,StrToLong(Selected(16)))
					Exit Function
				End If
				n = StrToVal(DlgText("OrgStartPosBox"),StrToLong(Selected(16)))
				If n = .Source.lStartAddress Then Exit Function
				If StrIDIndexDic.Exists(n) Then
					MsgBox MsgList(82),vbOkOnly+vbInformation,MsgList(1)
					DlgText "OrgStartPosBox",ValToStr(.Source.lStartAddress,TargetFile.FileSize,StrToLong(Selected(16)))
					Exit Function
				End If
				'检查输入的地址是否在合理范围内(排除当前字串所在节以外和各种文件头数据区段)
				If n > t Or n < y Then
					MsgBox Replace$(MsgList(59),"%s",ValToStr(y,TargetFile.FileSize,StrToLong(Selected(16))) & " - " & _
									ValToStr(t,TargetFile.FileSize,StrToLong(Selected(16)))),vbOkOnly+vbInformation,MsgList(1)
					DlgText "OrgStartPosBox",ValToStr(.Source.lStartAddress,TargetFile.FileSize,StrToLong(Selected(16)))
					Exit Function
				End If
				j = SkipHeader(SourceFile,n,0,0,1)
				If j > -1 And j < 16 Then
					If getMsgList(UIDataList,TempList,"FileInfoView",1) = False Then Exit Function
					If MsgBox(Replace$(MsgList(60),"%s",TempList(j + 30)),vbYesNo+vbInformation,MsgList(0)) = vbNo Then
						DlgText "OrgStartPosBox",ValToStr(.Source.lStartAddress,TargetFile.FileSize,StrToLong(Selected(16)))
						Exit Function
					End If
				ElseIf j > 15 Then
					If MsgBox(MsgList(61),vbYesNo+vbInformation,MsgList(0)) = vbNo Then
						DlgText "OrgStartPosBox",ValToStr(.Source.lStartAddress,TargetFile.FileSize,StrToLong(Selected(16)))
						Exit Function
					End If
				End If
				TempList = ExtractSet
				TempList(10) = IIf(CheckStrTypeArray(OrgStrTypeList) = True,"1","0")
				TempList(31) = AddStrEndCharSet(ExtractSet(31),JoinStr & StringTerminator)
				'打开原始文件
				Mode = LoadFile(SourceFile.FilePath,FN,0,0,0,StrToLong(Selected(1)))
				If Mode < -1 Then Exit Function
				.Source.lStartAddress = n
				.Source.lHexLength = .Source.lEndAddress - .Source.lStartAddress + 1
				AllStrDataList(i) = GetString(SourceFile,FN,AllStrDataList(i), _
									GetSubLangListByCP(UseLangList,.Source.CodePage),OrgStrTypeList,TempList,0,Mode)
				If UnLoadFile(FN,0,Mode) = False Then Exit Function
				If .Source.sString = "" Then
					MsgBox MsgList(66),vbOkOnly+vbInformation,MsgList(1)
					AllStrDataList(i) = DataList(0)
					DlgText "OrgStartPosBox",ValToStr(.Source.lStartAddress,TargetFile.FileSize,StrToLong(Selected(16)))
					Exit Function
				ElseIf DataComp(AllStrDataList(i),DataList(0),1) = False Then
					MsgBox MsgList(67),vbOkOnly+vbInformation,MsgList(1)
					AllStrDataList(i) = DataList(0)
					DlgText "OrgStartPosBox",ValToStr(.Source.lStartAddress,TargetFile.FileSize,StrToLong(Selected(16)))
					Exit Function
				End If
			End With
		Case "OrgMaxPosBox"
			With AllStrDataList(i)
				DlgText "OrgMaxPosBox",UCase$(Trim$(DlgText("OrgMaxPosBox")))
				'检查输入的地址是否合法
				If StrToLong(Selected(16)) = 0 Then
					If CheckStrRegExp(DlgText("OrgMaxPosBox"),"[0-9]",0,1) = False Then
						MsgBox MsgList(95),vbOkOnly+vbInformation,MsgList(1)
						DlgText "OrgMaxPosBox",ValToStr(.Source.lMaxAddress,TargetFile.FileSize,StrToLong(Selected(16)))
						Exit Function
					End If
				ElseIf CheckStrRegExp(DlgText("OrgMaxPosBox"),CheckSkipStr(6),0,1,True) = False Then
					MsgBox MsgList(95),vbOkOnly+vbInformation,MsgList(1)
					DlgText "OrgMaxPosBox",ValToStr(.Source.lMaxAddress,TargetFile.FileSize,StrToLong(Selected(16)))
					Exit Function
				End If
				n = StrToVal(DlgText("OrgMaxPosBox"),StrToLong(Selected(16)))
				If n = .Source.lMaxAddress Then Exit Function
				'检查输入的地址是否在合理范围内(排除当前字串所在节以外和各种文件头数据区段)
				If n > t Or n < y Then
					MsgBox Replace$(MsgList(59),"%s",ValToStr(y,TargetFile.FileSize,StrToLong(Selected(16))) & " - " & _
									ValToStr(t,TargetFile.FileSize,StrToLong(Selected(16)))),vbOkOnly+vbInformation,MsgList(1)
					DlgText "OrgMaxPosBox",ValToStr(.Source.lMaxAddress,TargetFile.FileSize,StrToLong(Selected(16)))
					Exit Function
				End If
				j = SkipHeader(SourceFile,n,0,0,1)
				If j > -1 And j < 16 Then
					If getMsgList(UIDataList,TempList,"FileInfoView",1) = False Then Exit Function
					If MsgBox(Replace$(MsgList(60),"%s",TempList(j + 30)),vbYesNo+vbInformation,MsgList(0)) = vbNo Then
						DlgText "OrgMaxPosBox",ValToStr(.Source.lMaxAddress,TargetFile.FileSize,StrToLong(Selected(16)))
						Exit Function
					End If
				ElseIf j > 15 Then
					If MsgBox(MsgList(61),vbYesNo+vbInformation,MsgList(0)) = vbNo Then
						DlgText "OrgMaxPosBox",ValToStr(.Source.lMaxAddress,TargetFile.FileSize,StrToLong(Selected(16)))
						Exit Function
					End If
				End If
				TempList = ExtractSet
				TempList(10) = IIf(CheckStrTypeArray(OrgStrTypeList) = True,"1","0")
				TempList(31) = AddStrEndCharSet(ExtractSet(31),JoinStr & StringTerminator)
				'打开原始文件
				Mode = LoadFile(SourceFile.FilePath,FN,0,0,0,StrToLong(Selected(1)))
				If Mode < -1 Then Exit Function
				.Source.lEndAddress = IIf(n < .Source.lMaxAddress,0,n)
				.Source.lHexLength = .Source.lEndAddress - .Source.lStartAddress + 1
				AllStrDataList(i) = GetString(SourceFile,FN,AllStrDataList(i), _
									GetSubLangListByCP(UseLangList,.Source.CodePage),OrgStrTypeList,TempList,0,Mode)
				If UnLoadFile(FN,0,Mode) = False Then Exit Function
				If .Source.sString = "" Then
					MsgBox MsgList(66),vbOkOnly+vbInformation,MsgList(1)
					AllStrDataList(i) = DataList(0)
					DlgText "OrgMaxPosBox",ValToStr(.Source.lMaxAddress,TargetFile.FileSize,StrToLong(Selected(16)))
					Exit Function
				ElseIf DataComp(AllStrDataList(i),DataList(0),1) = False Then
					MsgBox MsgList(67),vbOkOnly+vbInformation,MsgList(1)
					AllStrDataList(i) = DataList(0)
					DlgText "OrgMaxPosBox",ValToStr(.Source.lMaxAddress,TargetFile.FileSize,StrToLong(Selected(16)))
					Exit Function
				End If
			End With
		Case "TrnStartPosBox"
			With AllStrDataList(i)
				DlgText "TrnStartPosBox",UCase$(Trim$(DlgText("TrnStartPosBox")))
				'检查字串是否为丢失的地址
				If .WriteType < 0 Then Exit Function
				'检查输入的地址是否合法
				If StrToLong(Selected(16)) = 0 Then
					If CheckStrRegExp(DlgText("TrnStartPosBox"),"[0-9]",0,1) = False Then
						MsgBox MsgList(95),vbOkOnly+vbInformation,MsgList(1)
						DlgText "TrnStartPosBox",ValToStr(.Trans.lStartAddress,TargetFile.FileSize,StrToLong(Selected(16)))
						Exit Function
					End If
				ElseIf CheckStrRegExp(DlgText("TrnStartPosBox"),CheckSkipStr(6),0,1,True) = False Then
					MsgBox MsgList(95),vbOkOnly+vbInformation,MsgList(1)
					DlgText "TrnStartPosBox",ValToStr(.Trans.lStartAddress,TargetFile.FileSize,StrToLong(Selected(16)))
					Exit Function
				End If
				n = StrToVal(DlgText("TrnStartPosBox"),StrToLong(Selected(16)))
				If n = .Trans.lStartAddress Then Exit Function
				'检查输入的地址是否在合理范围内(排除当前字串所在节以外和各种文件头数据区段)
				If .WriteType = 0 Then
					MsgBox MsgList(39),vbOkOnly+vbInformation,MsgList(1)
					DlgText "TrnStartPosBox",ValToStr(.Trans.lStartAddress,TargetFile.FileSize,StrToLong(Selected(16)))
					Exit Function
				End If
				If n > t Or n < y Then
					If .MoveType < 4 Then
						MsgBox Replace$(MsgList(59),"%s",ValToStr(y,TargetFile.FileSize,StrToLong(Selected(16))) & " - " & _
									ValToStr(t,TargetFile.FileSize,StrToLong(Selected(16)))),vbOkOnly+vbInformation,MsgList(1)
					End If
					DlgText "TrnStartPosBox",ValToStr(.Trans.lStartAddress,TargetFile.FileSize,StrToLong(Selected(16)))
					Exit Function
				End If
				k = SkipHeader(TargetFile,.Source.lStartAddress,0,0)
				j = SkipHeader(TargetFile,n,0,0)
				If k = -1 And j > -1 And j < 16 Then
					If getMsgList(UIDataList,TempList,"FileInfoView",1) = False Then Exit Function
					If MsgBox(Replace$(MsgList(62),"%s",TempList(j + 30)),vbYesNo+vbInformation,MsgList(0)) = vbNo Then
						DlgText "TrnStartPosBox",ValToStr(.Trans.lStartAddress,TargetFile.FileSize,StrToLong(Selected(16)))
						Exit Function
					End If
				ElseIf k > -1 And k < 16 And j <> k Then
					If getMsgList(UIDataList,TempList,"FileInfoView",1) = False Then Exit Function
					If MsgBox(Replace$(MsgList(63),"%s",TempList(j + 30)),vbYesNo+vbInformation,MsgList(0)) = vbNo Then
						DlgText "TrnStartPosBox",ValToStr(.Trans.lStartAddress,TargetFile.FileSize,StrToLong(Selected(16)))
						Exit Function
					End If
				ElseIf k = -1 And j > 15 Then
					If MsgBox(MsgList(64),vbYesNo+vbInformation,MsgList(0)) = vbNo Then
						DlgText "TrnStartPosBox",ValToStr(.Trans.lStartAddress,TargetFile.FileSize,StrToLong(Selected(16)))
						Exit Function
					End If
				ElseIf k > 15 And j <> k Then
					If MsgBox(MsgList(65),vbYesNo+vbInformation,MsgList(0)) = vbNo Then
						DlgText "TrnStartPosBox",ValToStr(.Trans.lStartAddress,TargetFile.FileSize,StrToLong(Selected(16)))
						Exit Function
					End If
				End If
				For j = UBound(AllStrDataList) + 1 To UBound(FreeByteList)
					If FreeByteList(j).MoveType < -1 Then
						If n >= FreeByteList(j).Address And n <= FreeByteList(j).MaxAddress Then
							MsgBox MsgList(68),vbOkOnly+vbInformation,MsgList(1)
							DlgText "TrnStartPosBox",ValToStr(.Trans.lStartAddress,TargetFile.FileSize,StrToLong(Selected(16)))
							Exit Function
						End If
					End If
				Next j
				If .Source.GetRefState = 0 Then
					'打开目标文件
					Mode = LoadFile(TargetFile.FilePath,FN,0,0,0,StrToLong(Selected(1)))
					If Mode < -1 Then Exit Function
					'获取原始字串的引用代码和引用列表
					Call GetVARefList(TargetFile,FN,.Source,OrgStrTypeList,.TagType,.Moveable,"",0,Mode,0)
					j = 0
					TempList = GetRefCodeList(AllStrDataList(i),False,j)
					DlgListBoxArray "OrgVOffsetList",TempList()
					DlgValue "OrgVOffsetList",j
					If UnLoadFile(FN,0,Mode) = False Then Exit Function
				End If
				If .Source.lReferenceNum = 0 Then
					MsgBox MsgList(69),vbOkOnly+vbInformation,MsgList(1)
					DlgText "TrnStartPosBox",ValToStr(.Trans.lStartAddress,TargetFile.FileSize,StrToLong(Selected(16)))
					Exit Function
				ElseIf .Trans.GetRefState = 0 Then
					Call GetVARefList(TargetFile,"",.Trans,OrgStrTypeList,.TagType,.Moveable,"",1,0,0)
					j = 0
					TempList = GetRefCodeList(AllStrDataList(i),True,j)
					DlgListBoxArray "TrnVOffsetList",TempList()
					DlgValue "TrnVOffsetList",j
					DlgValue "OrgVOffsetList",j
				End If
				'检查所选地址是否在当前翻译地址中
				If n >= .Trans.lStartAddress And n <= .Trans.lMaxAddress Then
					MsgBox MsgList(70),vbOkOnly+vbInformation,MsgList(1)
					DlgText "TrnStartPosBox",ValToStr(.Trans.lStartAddress,TargetFile.FileSize,StrToLong(Selected(16)))
					Exit Function
				End If
				'计算移位需要的字节长度
				k = GetEvenPos(.Trans.lHexLength + .Trans.StrTypeLength + .EndByteLength + .Trans.iNullByteLength + 1)
			End With
			'检查所选地址
			For j = LBound(AllStrDataList) To UBound(AllStrDataList)
				With AllStrDataList(j)
					'检查所选地址是否被其他翻译占用
					If n >= .Trans.lStartAddress - .Trans.StrTypeLength And n <= .Trans.lEndAddress + .EndByteLength + .Trans.iNullByteLength Then
						MsgBox MsgList(71),vbOkOnly+vbInformation,MsgList(1)
						DlgText "TrnStartPosBox",ValToStr(AllStrDataList(i).Trans.lStartAddress,TargetFile.FileSize,StrToLong(Selected(16)))
						Exit Function
					End If
					'检查所选地址是否是其他字串的原始地址
					If n >= .Source.lStartAddress - .Source.StrTypeLength And n <= .Source.lMaxAddress Then
						If .ScapeIDBeMoved = -1 And .SplitState = 0 Then
							'人工复位
							If n = AllStrDataList(i).Source.lStartAddress Then
								'检查是否超长和可变长型字串类型
								If CheckStrVal(AllStrDataList(i),4,0) = False Then
									If MsgBox(MsgList(72),vbYesNo+vbInformation,MsgList(0)) = vbNo Then
										DlgText "TrnStartPosBox",ValToStr(AllStrDataList(i).Trans.lStartAddress,TargetFile.FileSize,StrToLong(Selected(16)))
										Exit Function
									End If
								End If
								'获取翻译的开始地址和最大地址
								n = .Source.lStartAddress - .Source.StrTypeLength + AllStrDataList(i).Trans.StrTypeLength
								m = GetMaxAddress(AllStrDataList(j),False)
								Stemp = True
							'检查空字节数是否适合字串字节长度
							ElseIf .WriteType = 3 Then
								If .OverLengthWrite = 0 Then
									x = .Source.lMaxHexLength + .Source.StrTypeLength + .EndByteLength + .Source.iNullByteLength
								Else
									x = .Source.lHexLength + .Source.StrTypeLength + .EndByteLength + .Source.iNullByteLength
								End If
								If k < x Then
									'获取翻译的开始地址和最大地址
									n = .Source.lStartAddress - .Source.StrTypeLength + AllStrDataList(i).Trans.StrTypeLength
									m = GetMaxAddress(AllStrDataList(j),False)
									Stemp = True
								End If
							ElseIf .WriteType = 1 Then
								x = GetEvenPos(.Trans.lStartAddress + .Trans.lHexLength + .EndByteLength + .Trans.iNullByteLength + 1)
								If k < GetMaxAddress(AllStrDataList(j),False) - x + 1 Then
									If n - x < 0 Then
										MsgBox MsgList(73),vbOkOnly+vbInformation,MsgList(1)
									ElseIf n - x > 0 Then
										MsgBox MsgList(74),vbOkOnly+vbInformation,MsgList(1)
									End If
									'获取翻译的开始地址和引用代码
									n = GetEvenPos(x + AllStrDataList(i).Trans.StrTypeLength)
									m = GetMaxAddress(AllStrDataList(j),False)
									'更改占用字串的最大地址和最大长度
									.Trans.lMaxAddress = n - AllStrDataList(i).Trans.StrTypeLength - 1
									.Trans.lMaxHexLength = .Trans.lMaxAddress - .Trans.lStartAddress + 1 - .EndByteLength - .Trans.iNullByteLength
									Stemp = True
								End If
							End If
							If Stemp = True Then
								'标记原占有空间为未占有，并更改原被占有空间为当前字串的开始地址和最大可写长度
								ChangeStrVal(TargetFile,AllStrDataList,FreeByteList,i,0)
								'标记现占有空间为占有
								.ScapeIDBeMoved = IIf(x = 0,-1,AllStrDataList(i).ID)
								FreeByteList(FreeByteDic.Item(.ID)).MoveType = AllStrDataList(i).ID
								With AllStrDataList(i)
									'记录更改数据
									.MoveType = IIf(x = 0,0,1)
									'MoveMode = 3 人工移位，除人工复位、取消翻译或翻译再超长、引用地址置空、修改占用的字串空位的字串翻译外不会改变
									.MoveMode = IIf(x = 0,IIf(.Source.MoveLength = 0,0,2),3)
									.Trans.MoveLength = 0
									.Trans.lStartAddress = n
									.Trans.lEndAddress = n + .Trans.lHexLength - 1
									.Trans.lMaxAddress = m
									.Trans.lMaxHexLength = m - n + 1 - .EndByteLength - .Trans.iNullByteLength
									.Trans.inSectionID = AllStrDataList(j).Source.inSectionID
									.ScapeIDForMove = IIf(x = 0,-1,AllStrDataList(j).ID)
									If x = 0 And .MoveMode = 0 Then
										.Trans.lReferenceNum = 0
									Else
										.Trans.Reference = .Source.Reference
										.Trans.lReferenceNum = .Source.lReferenceNum
									End If
									Call GetVARefList(TargetFile,"",.Trans,OrgStrTypeList,.TagType,.Moveable,"",1,0,0)
									If x = 0 Then
										'重置字串数据并重新移位
										Call ResetAndMoveString(TargetFile,AllStrDataList,intList,False,True,MsgList,0)
									Else
										'获取字串写入类型
										.WriteType = WriteType(TargetFile,AllStrDataList(i),WriteSet)
										MsgBox MsgList(75),vbOkOnly+vbInformation,MsgList(1)
									End If
								End With
							Else
								MsgBox MsgList(76),vbOkOnly+vbInformation,MsgList(1)
								DlgText "TrnStartPosBox",ValToStr(AllStrDataList(i).Trans.lStartAddress,TargetFile.FileSize,StrToLong(Selected(16)))
								Exit Function
							End If
						Else
							MsgBox MsgList(71),vbOkOnly+vbInformation,MsgList(1)
							DlgText "TrnStartPosBox",ValToStr(AllStrDataList(i).Trans.lStartAddress,TargetFile.FileSize,StrToLong(Selected(16)))
							Exit Function
						End If
						Stemp = True
						Exit For
					End If
				End With
			Next j
			If Stemp = False Then
				With AllStrDataList(i)
					'打开目标文件
					Mode = LoadFile(TargetFile.FilePath,FN,0,0,0,StrToLong(Selected(1)))
					If Mode < -1 Then Exit Function
					If GetByte(FN,n,Mode) <> 0 Then
						UnLoadFile(FN,0,Mode)
						MsgBox MsgList(77),vbOkOnly+vbInformation,MsgList(1)
						DlgText "TrnStartPosBox",ValToStr(.Trans.lStartAddress,TargetFile.FileSize,StrToLong(Selected(16)))
						Exit Function
					End If
					j = n
					Do
						j = j - 1
					Loop Until GetByte(FN,j,Mode) <> 0 Or j < y
					If n - j < 3 Then
						MsgBox MsgList(73),vbOkOnly+vbInformation,MsgList(1)
					ElseIf n - j > 3 Then
						MsgBox MsgList(74),vbOkOnly+vbInformation,MsgList(1)
					End If
					n = j + 3
					m = getNotNullByte(FN,n,t + 1,Mode) - 1
					'避开 Delphi 窗体代码
					If TargetFile.LangType = DELPHI_FILE_SIGNATURE And m + 6 < t Then
						If GetLong(FN,m + 1,Mode) = &HFFFFFFFF Then
							If m - 4 > n Then m = m - 4
						End If
					End If
					If UnLoadFile(FN,0,Mode) = False Then Exit Function
					'检查空字节数是否适合字串字节长度
					If m - n + 1 <= k Then
						MsgBox MsgList(78),vbOkOnly+vbInformation,MsgList(1)
						DlgText "TrnStartPosBox",ValToStr(.Trans.lStartAddress,TargetFile.FileSize,StrToLong(Selected(16)))
						Exit Function
					End If
					'检查该地址是否是已获取的空余地址以及是否已被占用
					If FreeByteDic.Exists(m - 1) Then
						j = Abs(FreeByteDic.Item(m - 1))
						If FreeByteList(j).MoveType = -1 Then
							'未被占用时
							n = FreeByteList(j).Address
							m = FreeByteList(j).MaxAddress
							Stemp = True
						Else
							'已被占用时
							MsgBox MsgList(71),vbOkOnly+vbInformation,MsgList(1)
							DlgText "TrnStartPosBox",ValToStr(.Trans.lStartAddress,TargetFile.FileSize,StrToLong(Selected(16)))
							Exit Function
						End If
					End If
					'标记原占有空间为未占有，并更改原被占有空间为当前字串的开始地址和最大可写长度
					ChangeStrVal(TargetFile,AllStrDataList,FreeByteList,i,0)
					'记录更改数据
					.MoveType = 2
					.MoveMode = 3	'人工移位，除了人工复位、取消翻译或翻译再超长、引用地址置空外不会改变
					.Trans.MoveLength = 0
					.Trans.lStartAddress = GetEvenPos(n + .Trans.StrTypeLength)
					.Trans.lEndAddress = .Trans.lStartAddress + .Trans.lHexLength - 1
					.Trans.lMaxAddress = m
					.Trans.lMaxHexLength = m - .Trans.lStartAddress + 1 - .EndByteLength - .Trans.iNullByteLength
					.Trans.inSectionID = SkipSection(TargetFile,.Trans.lStartAddress,0,0)
					.Trans.Reference = .Source.Reference
					.Trans.lReferenceNum = .Source.lReferenceNum
					Call GetVARefList(TargetFile,"",.Trans,OrgStrTypeList,.TagType,.Moveable,"",1,0,0)
					'获取空余空间的ID号并标记已占有
					If Stemp = True Then
						'已获取的空余地址
						FreeByteList(j).MoveType = .ID
						.ScapeIDForMove = FreeByteList(j).lNumber
					Else
						'添加到空余地址数据库
						j = UBound(FreeByteList) + 1
						ReDim Preserve FreeByteList(j) As FREE_BTYE_SPACE
						FreeByteList(j).lNumber = -j
						FreeByteList(j).Address = n
						FreeByteList(j).MaxAddress = m
						FreeByteList(j).Length = m - n + 1
						FreeByteList(j).MoveType = .ID
						FreeByteList(j).inSectionID = .Trans.inSectionID
						FreeByteDic.Add(m - 1,-j)
						.ScapeIDForMove = -j
					End If
					'获取字串写入类型
					.WriteType = WriteType(TargetFile,AllStrDataList(i),WriteSet)
				End With
				MsgBox MsgList(79),vbOkOnly+vbInformation,MsgList(1)
			End If
		Case "OrgStringBox"
			With AllStrDataList(i)
				If StrToLong(Selected(19)) = 0 Then
					Temp = ReConvert(Convert(DlgText("OrgStringBox")))
				Else
					Temp = ReConvert(Convert(Replace$(DlgText("OrgStringBox"),SpaceWithPointChar," ")))
				End If
				If Temp = .Source.sString Then Exit Function
				'检查字串是否为丢失的地址
				If TargetFile.hcsFile.FilePath <> SourceFile.hcsFile.FilePath Then
					MsgBox MsgList(80),vbOkOnly+vbInformation,MsgList(1)
					If StrToLong(Selected(19)) = 0 Then
						DlgText "OrgStringBox",.Source.sString
					Else
						DlgText "OrgStringBox",Replace$(.Source.sString," ",SpaceWithPointChar)
					End If
					Exit Function
				End If
				If DlgText("OrgStringBox") = "" Then
					MsgBox MsgList(81),vbOkOnly+vbInformation,MsgList(1)
					If StrToLong(Selected(19)) = 0 Then
						DlgText "OrgStringBox",.Source.sString
					Else
						DlgText "OrgStringBox",Replace$(.Source.sString," ",SpaceWithPointChar)
					End If
					Exit Function
				End If
				'打开原始文件
				Mode = LoadFile(SourceFile.FilePath,FN,0,0,SourceFile.FileSize,StrToLong(Selected(1)))
				If Mode < -1 Then Exit Function
				ReDim TempList(1) As String
				TempList(0) = Convert(.Source.sString)
				TempList(1) = Convert(Temp)
				Temp = MaxSubString(TempList)
				If Temp <> "" Then
					j = StrHexLength(Left$(TempList(0),InStr(TempList(0),Temp)),.Source.CodePage,0)
					k = StrHexLength(Left$(TempList(1),InStr(TempList(1),Temp)),.Source.CodePage,0)
					j = .Source.lStartAddress + j - k
				Else
					'查找指定字串
					If i = 0 Then
						k = y
					ElseIf i <= UBound(AllStrDataList) Then
						k = AllStrDataList(i - 1).Source.lMaxAddress + 1
					End If
					j = InByteRegExp(FN.ImageByte,StringToByte(TempList(1),.Source.CodePage),k,t) - 1
					If j < 0 Then
						Call UnLoadFile(FN,0,Mode)
						MsgBox MsgList(84),vbOkOnly+vbInformation,MsgList(1)
						If StrToLong(Selected(19)) = 0 Then
							DlgText "OrgStringBox",.Source.sString
						Else
							DlgText "OrgStringBox",Replace$(.Source.sString," ",SpaceWithPointChar)
						End If
						Exit Function
					End If
				End If
				If j <> .Source.lStartAddress Then
					If StrIDIndexDic.Exists(j) Then
						Call UnLoadFile(FN,0,Mode)
						MsgBox MsgList(82),vbOkOnly+vbInformation,MsgList(1)
						If StrToLong(Selected(19)) = 0 Then
							DlgText "OrgStringBox",.Source.sString
						Else
							DlgText "OrgStringBox",Replace$(.Source.sString," ",SpaceWithPointChar)
						End If
						Exit Function
					End If
				End If
				If SkipHeader(SourceFile,j,0,0,1) > -1 Then
					If MsgBox(MsgList(83),vbYesNo+vbInformation,MsgList(0)) = vbNo Then
						Call UnLoadFile(FN,0,Mode)
						If StrToLong(Selected(19)) = 0 Then
							DlgText "OrgStringBox",.Source.sString
						Else
							DlgText "OrgStringBox",Replace$(.Source.sString," ",SpaceWithPointChar)
						End If
						Exit Function
					End If
				End If
				.Source.lStartAddress = j
				.Source.lHexLength = StrHexLength(TempList(1),.Source.CodePage,0)
				.Source.lEndAddress = .Source.lStartAddress + .Source.lHexLength - 1
				TempList = ExtractSet
				TempList(10) = IIf(CheckStrTypeArray(OrgStrTypeList) = True,"1","0")
				TempList(31) = AddStrEndCharSet(ExtractSet(31),JoinStr & StringTerminator)
				AllStrDataList(i) = GetString(SourceFile,FN,AllStrDataList(i), _
									GetSubLangListByCP(UseLangList,.Source.CodePage),OrgStrTypeList,TempList,0,Mode)
				If UnLoadFile(FN,0,Mode) = False Then Exit Function
				If StrToLong(Selected(19)) = 0 Then
					Temp = ReConvert(Convert(DlgText("OrgStringBox")))
				Else
					Temp = ReConvert(Convert(Replace$(DlgText("OrgStringBox"),SpaceWithPointChar," ")))
				End If
				If .Source.sString <> Temp Then
					MsgBox MsgList(84),vbOkOnly+vbInformation,MsgList(1)
					If .ID <> DataList(0).ID Then
						If StrIDIndexDic.Exists(.ID) Then
							If Not StrIDIndexDic.Exists(DataList(0).ID) Then
								StrIDIndexDic.Key(.ID) = DataList(0).ID
							End If
						End If
						If StrIDIndexDicBak.Exists(.ID) Then
							If Not StrIDIndexDicBak.Exists(DataList(0).ID) Then
								StrIDIndexDicBak.Key(.ID) = DataList(0).ID
								AllStrDataListBak(StrIDIndexDicBak.Item(.ID)).ID = DataList(0).ID
							End If
						End If
						If UseStrIDIndexDic.Exists(.ID) Then
							If Not UseStrIDIndexDic.Exists(DataList(0).ID) Then
								UseStrIDIndexDic.Key(.ID) = DataList(0).ID
								UseStrDataList(UseStrIDIndexDic.Item(.ID)).ID = DataList(0).ID
							End If
						End If
					End If
					AllStrDataList(i) = DataList(0)
					If StrToLong(Selected(19)) = 0 Then
						DlgText "OrgStringBox",DataList(0).Source.sString
					Else
						DlgText "OrgStringBox",Replace$(DataList(0).Source.sString," ",SpaceWithPointChar)
					End If
					Exit Function
				End If
			End With
		Case "TrnStringBox"
			With AllStrDataList(i)
				If StrToLong(Selected(19)) = 0 Then
					Temp = ReConvert(Convert(DlgText("TrnStringBox")))
				Else
					Temp = ReConvert(Convert(Replace$(DlgText("TrnStringBox"),SpaceWithPointChar," ")))
				End If
				If Temp = .Trans.sString Then Exit Function
				If DlgText("TrnStringBox") = "" Then
					MsgBox MsgList(81),vbOkOnly+vbInformation,MsgList(1)
					If StrToLong(Selected(19)) = 0 Then
						DlgText "TrnStringBox",.Trans.sString
					Else
						DlgText "TrnStringBox",Replace$(.Trans.sString," ",SpaceWithPointChar)
					End If
					Exit Function
				End If
				.FillLength = 0
				.Trans.sString = Temp
				If .Trans.sString = .Source.sString Then
					If .SplitState = 0 Then .MoveMode = 0
					.Trans.CodePage = .Source.CodePage
					.Trans.lCharLength = .Source.lCharLength
					.Trans.lHexLength = .Source.lHexLength
					.Trans.iNullByteLength = .Source.iNullByteLength
				Else
					If .WriteType > -2 And .WriteType < 1 Then
						If .Source.CodePage <> CP_UNICODELITTLE And .Source.CodePage <> CP_UNICODEBIG And _
							.Source.CodePage <> CP_UTF7 And .Source.CodePage <> CP_UTF8 And _
							.Source.CodePage <> CP_UTF32LE And .Source.CodePage <> CP_UTF32BE Then
							.Trans.CodePage = TargetFile.CopePage
							If .Trans.CodePage = 0 Then .Trans.CodePage = .Source.CodePage
						End If
						.Trans.lMaxAddress = GetMaxAddress(AllStrDataList(i),True)
					End If
					Temp = Convert(.Trans.sString)
					.Trans.lHexLength = StrHexLength(Temp,.Trans.CodePage,0)
					.Trans.lCharLength = Len(Temp)
					.Trans.iNullByteLength = NullByteLength(AllStrDataList(i),True)
				End If
				'检查字串是否为丢失的地址
				'打开原始文件
				Mode = LoadFile(TargetFile.FilePath,FN,0,0,0,StrToLong(Selected(1)))
				If Mode < -1 Then Exit Function
				'获取字串类型长度及其翻译更改和截断写入引起的差额，用于还原开始地址为完整翻译的地址
				'.Trans.MoveLength 为截断写入后与完整翻译之间的长度差额
				.Trans.MoveLength = StrTypeLength(AllStrDataList(i),OrgStrTypeList,FN,Mode,1) - .Trans.MoveLength
				'更改翻译地址及需要获取引用的字串索引
				m = 0: n = 0: intArry = intArray
				Call ChangeStrAddAndGetRefIndex(AllStrDataList,intArry,intList,m,n,i,0)
				intList(0) = i
				'获取字串的引用代码和引用地址
				If m + n > 0 Then
					If m > 0 Then
						Call GetVARefList(TargetFile,FN,.Source,OrgStrTypeList,.TagType,.Moveable,"",0,Mode,0)
					End If
					If n > 0 Then
						'已移位到扩展区段和新增区段的字串用原地址和引用代码反算引用
						j = IIf(.MoveType < 4,1,-(.Trans.lStartAddress - .Trans.MoveLength))
						Call GetVARefList(TargetFile,"",.Trans,OrgStrTypeList,.TagType,.Moveable,"",j,0,0)
						.Trans.MoveLength = 0 '已重置翻译开始地址为完整翻译的地址，故置零
					End If
				End If
				'卸载文件
				If UnLoadFile(FN,0,Mode) = False Then Exit Function
				'重置字串数据并重新移位
				Call ResetAndMoveString(TargetFile,AllStrDataList,intList,True,False,MsgList,0)
			End With
		End Select

		'显示数据
		m = IIf(TargetFile.hcsFile.FilePath = SourceFile.hcsFile.FilePath,1,0)
		If DataComp(DataList(0),AllStrDataList(i),m) = True Then
			UseStrDataList(intArray(0)) = AllStrDataList(i)
			j = GetDlgItem(CLng(DlgText("SuppValueBox")),DlgControlId("UseStrList"))
			ChangeListBoxItems(j,AllStrDataList(i).Trans.sString,intArray(0),intArray(0))
			SetListBoxItems(j,intArray(0))
			With AllStrDataList(i)
				DlgText "OrgInSectionBox",GetSectionName(SourceFile,.Source.inSectionID,.Source.inSubSecID)
				If .MoveType < 6 Then
					DlgText "TrnInSectionBox",GetSectionName(TargetFile,.Trans.inSectionID,.Trans.inSubSecID)
				ElseIf InStr(TargetFile.Magic,"PE") Then
					DlgText "TrnInSectionBox",NewPESecName
				Else
					DlgText "TrnInSectionBox",NewMacSecName
				End If
				DlgText "OrgStartPosBox",ValToStr(.Source.lStartAddress,TargetFile.FileSize,StrToLong(Selected(16)))
				DlgText "OrgMaxPosBox",ValToStr(.Source.lMaxAddress,TargetFile.FileSize,StrToLong(Selected(16)))
				DlgText "OrgRefNumBox",CStr$(.Source.lReferenceNum)
				DlgValue "StrTypeNameList",StrTypeValue(.StrType)
				DlgText "OrgCodePageValList",CStr$(.Source.CodePage)
				DlgValue "OrgCodePageNameList",DlgValue("OrgCodePageValList")
				DlgText "OrgStrLengthBox",CStr$(.Source.lHexLength)

				DlgText "TrnStartPosBox",ValToStr(.Trans.lStartAddress,TargetFile.FileSize,StrToLong(Selected(16)))
				DlgText "TrnMaxPosBox",ValToStr(.Trans.lMaxAddress,TargetFile.FileSize,StrToLong(Selected(16)))
				DlgText "TrnRefNumBox",CStr$(.Trans.lReferenceNum)
				DlgText "TrnCodePageValList",CStr$(.Trans.CodePage)
				DlgValue "TrnCodePageNameList",DlgValue("TrnCodePageValList")
				DlgText "TrnStrLengthBox",CStr$(.Trans.lHexLength)

				DlgText "MaxStrLengthBox",CStr$(.Trans.lMaxHexLength)
				DlgText "OrgStringBox",IIf(StrToLong(Selected(19)) = 0,.Source.sString,Replace$(.Source.sString," ",SpaceWithPointChar))
				DlgText "TrnStringBox",IIf(StrToLong(Selected(19)) = 0,.Trans.sString,Replace$(.Trans.sString," ",SpaceWithPointChar))
				TempList = GetRefCodeList(AllStrDataList(i),False)
				DlgListBoxArray "OrgVOffsetList",TempList()
				j = 0
				TempList = GetRefCodeList(AllStrDataList(i),True,j)
				DlgListBoxArray "TrnVOffsetList",TempList()
				DlgValue "OrgVOffsetList",j
				DlgValue "TrnVOffsetList",j
			End With
			DlgEnable "ResetButton",True
			DlgEnable "AllResetButton",True
			If DlgValue("ModeCheckBox") = 1 Then DlgValue "ModeCheckBox",2
		End If
	'Case 4 ' 焦点更改
	'	DlgText "ScrollPosBox","0"
	Case 6 ' 函数快捷键
		If getMsgList(UIDataList,MsgList,"EditStringDlgFunc",1) = False Then Exit Function
		Select Case SuppValue
		Case 1	'帮助
			ReDim TempArray(10) As String
			TempArray(0) = MsgList(7)
			TempArray(1) = MsgList(8)
			TempArray(2) = MsgList(9)
			TempArray(3) = MsgList(10)
			TempArray(4) = MsgList(11)
			TempArray(5) = MsgList(12)
			TempArray(6) = MsgList(2)
			TempArray(7) = MsgList(3)
			TempArray(8) = MsgList(104)
			TempArray(9) = MsgList(105)
			TempArray(10) = MsgList(13)
			Select Case ShowPopupMenu(TempArray,vbPopupUseRightButton)
			Case 0
				If StrToLong(Selected(30)) = 1 Then
					If TargetFile.hcsFile.FilePath = SourceFile.hcsFile.FilePath Then
						If OpenCHM(CLng(DlgText("SuppValueBox")),1007,Selected(0),OSLanguage,UIFileList) = True Then Exit Function
					Else
						If OpenCHM(CLng(DlgText("SuppValueBox")),1008,Selected(0),OSLanguage,UIFileList) = True Then Exit Function
					End If
				End If
				Call Help("EditStringHelp")
			Case 1
				If StrToLong(Selected(30)) = 1 Then
					If OpenCHM(CLng(DlgText("SuppValueBox")),1017,Selected(0),OSLanguage,UIFileList) = True Then Exit Function
				End If
				Call Help("MainHelp")
			Case 2
				i = 0
				If StrToLong(Selected(17)) > 0 Then
					DlgVisible "OrgStringText",False
					DlgVisible "TrnStringText",False
					DlgVisible "OrgStringBox",False
					DlgVisible "TrnStringBox",False
					DlgVisible "OrgCheckBox",False
					DlgVisible "TrnCheckBox",False
					DlgVisible "MsgOutputText",True
					DlgVisible "MsgOutputGroup",True
					DlgVisible "WriteResultsCheckBox",IIf(TargetFile.hcsFile.FilePath = SourceFile.hcsFile.FilePath,False,True)
					DlgVisible "ActionProgressBox",True
					DlgVisible "FindResultsBox",False
					DlgVisible "WriteResultsBox",False
					DlgValue "MsgOutputGroup",0
					DlgText "MsgOutputButton",MsgList(30)
					i = GetDlgItem(CLng(DlgText("SuppValueBox")),DlgControlId("ActionProgressBox"))
				ElseIf StrToLong(Selected(17)) < 0 Then
					i = -2
				End If
				i = Download(UpdateSet,UpdateSet(1),3,i)
				If i = 0 Then Exit Function
	    		If UpdateSet(5) < Format(Date,"yyyy-MM-dd") Then
	    			Stemp = True
	    		ElseIf i = 3 And ArrayComp(UpdateSet,UpdateSetBak) = False Then
	    			Stemp = True
	    		End If
	    		If Stemp = True Then
					UpdateSet(5) = Format(Date,"yyyy-MM-dd")
					If WriteSettings("Update") = False Then Exit Function
					UpdateSetBak(5) = UpdateSet(5)
				End If
				If i = 3 Then Call ExitMacro(1)
			Case 3
				intArray = GetListBoxIndexs(GetDlgItem(CLng(DlgText("SuppValueBox")),DlgControlId("UseStrList")))
				If CheckArrEmpty(intArray) = True Then
					ReDim Preserve intArray(0) As Long
					Temp = UseStrDataList(intArray(0)).Source.sString & _
						   "<->" & UseStrDataList(intArray(0)).Trans.sString & _
						   " -scp:" & CStr$(UseStrDataList(intArray(0)).Source.CodePage) & _
						   " -tcp:" & CStr$(UseStrDataList(intArray(0)).Trans.CodePage) & " -se -ac -lng:" & Selected(0)
				End If
				If Dir$(MacroLoc & "\Module\modEncodeQuery.bas") <> "" Then
					MacroRun MacroLoc & "\Module\modEncodeQuery.bas",Temp
				ElseIf Dir$(MacroLoc & "\modEncodeQuery.bas") <> "" Then
					MacroRun MacroLoc & "\modEncodeQuery.bas",Temp
				End If
			Case 4
				intArray = GetListBoxIndexs(GetDlgItem(CLng(DlgText("SuppValueBox")),DlgControlId("UseStrList")))
				If CheckArrEmpty(intArray) = True Then
					ReDim Preserve intArray(0) As Long
					Temp = UseStrDataList(intArray(0)).Source.sString & _
						   "<->" & UseStrDataList(intArray(0)).Trans.sString & _
						   " -scp:" & CStr$(UseStrDataList(intArray(0)).Source.CodePage) & _
						   " -tcp:" & CStr$(UseStrDataList(intArray(0)).Trans.CodePage) & " -se -ac -td -lng:" & Selected(0)
				End If
				If Dir$(MacroLoc & "\Module\modEncodeQuery.bas") <> "" Then
					MacroRun MacroLoc & "\Module\modEncodeQuery.bas",Temp
				ElseIf Dir$(MacroLoc & "\modEncodeQuery.bas") <> "" Then
					MacroRun MacroLoc & "\modEncodeQuery.bas",Temp
				End If
			Case 5
				intArray = GetListBoxIndexs(GetDlgItem(CLng(DlgText("SuppValueBox")),DlgControlId("UseStrList")))
				If CheckArrEmpty(intArray) = True Then
					Temp = SourceFile.FilePath & " -add:" & CStr$(UseStrDataList(intArray(0)).Source.lStartAddress) & " -lng:" & Selected(0)
				Else
					Temp = SourceFile.FilePath & " -lng:" & Selected(0)
				End If
				If Dir$(MacroLoc & "\Module\modReferenceSearch.bas") <> "" Then
					MacroRun MacroLoc & "\Module\modReferenceSearch.bas", Temp
				ElseIf Dir$(MacroLoc & "\modReferenceSearch.bas") <> "" Then
					MacroRun MacroLoc & "\modReferenceSearch.bas", Temp
				End If
			Case 6
				Temp = TargetFile.FilePath
				i = InStrRev(LCase$(TargetFile.FilePath),".bak")
				If i > 1 Then
					If Mid$(LCase$(TargetFile.FilePath),i) = ".bak" Then
						Temp = Left$(TargetFile.FilePath,i - 1)
					End If
				End If
				If Dir$(MacroLoc & "\Module\modEncodeModifier.bas") <> "" Then
					MacroRun MacroLoc & "\Module\modEncodeModifier.bas",Temp
				ElseIf Dir$(MacroLoc & "\modEncodeModifier.bas") <> "" Then
					MacroRun MacroLoc & "\modEncodeModifier.bas",Temp
				End If
			Case 7
				Temp = TargetFile.FilePath
				i = InStrRev(LCase$(TargetFile.FilePath),".bak")
				If i > 1 Then
					If Mid$(LCase$(TargetFile.FilePath),i) = ".bak" Then
						Temp = Left$(TargetFile.FilePath,i - 1)
					End If
				End If
				If Dir$(MacroLoc & "\Module\modPESubFile.bas") <> "" Then
					MacroRun MacroLoc & "\Module\modPESubFile.bas",Temp
				ElseIf Dir$(MacroLoc & "\modPESubFile.bas") <> "" Then
					MacroRun MacroLoc & "\modPESubFile.bas",Temp
				End If
			Case 8
				If PSL.SelectFile(Temp,False,MsgList(107),MsgList(106)) = False Then Exit Function
				If (LCase$(Temp) Like "*.bat") = False Then
					If InStrRev(Temp,".") = 0 Then Temp = Temp & ".dat"
				End If
				If SaveKey(HKEY_CURRENT_USER,"Software\VB And VBA Program Settings\PSLHardCodedString\",Temp) = True Then
					MsgBox MsgList(108),vbOkOnly+vbInformation,MsgList(1)
				Else
					MsgBox Replace$(MsgList(109),"%s","HKCU\Software\VB And VBA Program Settings\PSLHardCodedString"),vbOkOnly+vbInformation,MsgList(1)
				End If
			Case 9
				If MsgBox(MsgList(110),vbYesNo+vbInformation,MsgList(0)) = vbNo Then Exit Function
				If PSL.SelectFile(Temp,True,MsgList(107),MsgList(111)) = False Then Exit Function
				If RestoreKey(HKEY_CURRENT_USER,"Software\VB And VBA Program Settings\PSLHardCodedString\",Temp) = False Then
					MsgBox MsgList(113),vbOkOnly+vbInformation,MsgList(1)
					Exit Function
				ElseIf MsgBox(Replace$(MsgList(112),"%s","HKCS\Software\VB And VBA Program Settings\PSLHardCodedString"),vbYesNo+vbInformation,MsgList(0)) = vbNo Then
					Exit Function
				End If
				'读取设置
				GetSettings("")
				'备份设置
				SelectedBak = Selected
				UpdateSetBak = UpdateSet
				ExtractSetBak = ExtractSet
				StrTypeListBak = StrTypeList
				LFListBak = LFList
				'重新获取字串过滤列表的设置
				GetSettings("FilterStrDic")
				'新获取字串保留列表的设置
				GetSettings("ReserveStrDic")
				'获取过滤字串列表字典为字串过滤显示用
				TempList = ReSplit(ReadBinaryFile(ExtractSet(35),CP_UNICODELITTLE,True),vbNullChar)
				StrList2StrDic(FilterStrDic,TempList,StrToLong(ReSplit(FilterStrSet(17),ItemJoinStr)(1)),1)
			Case 10
				If StrToLong(Selected(30)) = 1 Then
					If OpenCHM(CLng(DlgText("SuppValueBox")),1002,Selected(0),OSLanguage,UIFileList) = True Then Exit Function
				End If
				Call Help("About")
			End Select
			Exit Function
		Case 2, 4	'查看字串数据
			intArray = GetListBoxIndexs(GetDlgItem(CLng(DlgText("SuppValueBox")),DlgControlId("UseStrList")))
			If CheckArrEmpty(intArray) = False Then Exit Function
			If DlgEnable("AllShowButton") = True Then
				If GetIndexList(StrIDIndexDic,UseStrDataList,intArray,False) = False Then
					Exit Function
				End If
			End If
			TempList = GetToolNameList(Tools,0)
			k = ShowPopupMenu(TempList,vbPopupUseRightButton)
			If k < 0 Then Exit Function
			File = TargetFile
			i = InStrRev(LCase$(TargetFile.FilePath),".bak")
			If i > 1 Then
				If Mid$(LCase$(TargetFile.FilePath),i) = ".bak" Then
					File.FilePath = Left$(TargetFile.FilePath,i - 1)
				End If
			End If
			Call StrDataView(File,AllStrDataList,AllStrDataListBak,intArray,k,SuppValue,StrToLong(Selected(16)))
			Exit Function
		Case 3	'查找
			If FindStrSet(0) = "" Then
				If TargetFile.hcsFile.FilePath <> SourceFile.hcsFile.FilePath Then i = 1
				If FindSet(i) = False Then Exit Function
			End If
			If FindStrSet(0) = "" Then Exit Function
			intArray = GetListBoxIndexs(GetDlgItem(CLng(DlgText("SuppValueBox")),DlgControlId("UseStrList")))
			If CheckArrEmpty(intArray) = False Then Exit Function
			i = FindString(UseStrDataList,FindStrSet,intArray(0))
			If i < 0 Then
				If FindStrSet(5) = "1" Then
					i = FindString(UseStrDataList,FindStrSet,-1)
				ElseIf MsgBox(Replace$(MsgList(16),"%s",FindStrSet(0)),vbYesNo+vbInformation,MsgList(0)) = vbYes Then
					FindStrSet(5) = "1"
					i = FindString(UseStrDataList,FindStrSet,-1)
				Else
					Stemp = True
				End If
			End If
			If i < 0 And FindStrSet(9) = "0" Then
				If FindStrSet(7) & FindStrSet(8) = "01" Then
					If MsgBox(Replace$(MsgList(17),"%s",FindStrSet(0)),vbYesNo+vbInformation,MsgList(0)) = vbYes Then
						FindStrSet(7) = "1"
						i = FindString(UseStrDataList,FindStrSet,-1)
					Else
						Stemp = True
					End If
				ElseIf FindStrSet(7) & FindStrSet(8) = "10" Then
					If MsgBox(Replace$(MsgList(18),"%s",FindStrSet(0)),vbYesNo+vbInformation,MsgList(0)) = vbYes Then
						FindStrSet(8) = "1"
						i = FindString(UseStrDataList,FindStrSet,-1)
					Else
						Stemp = True
					End If
				End If
			End If
			If i < 0 Then
				If Stemp = False Then
					MsgBox Replace$(MsgList(19),"%s",FindStrSet(0)),vbOkOnly+vbInformation,MsgList(1)
				End If
				Exit Function
			ElseIf i = intArray(0) Then
				If StrToLong(FindStrSet(10)) = 0 Then
					MsgBox Replace$(MsgList(20),"%s",FindStrSet(0)),vbOkOnly+vbInformation,MsgList(1)
					Exit Function
				ElseIf UBound(FindLog) = 0 Then
					MsgBox Replace$(MsgList(20),"%s",FindStrSet(0)),vbOkOnly+vbInformation,MsgList(1)
				End If
			End If
			SetListBoxItems(GetDlgItem(CLng(DlgText("SuppValueBox")),DlgControlId("UseStrList")),i)
			ReDim intArray(0) As Long
			intArray(0) = i
			If DlgEnable("AllShowButton") = True Then
				If GetIndexList(StrIDIndexDic,UseStrDataList,intArray,False) = False Then
					Exit Function
				End If
			End If
			i = intArray(0)
			Stemp = True
		Case 5	'编辑过滤列表
			If EditFilter(ExtractSet,0) = True Then
				ExtractSetBak(34) = ExtractSet(34)
				ExtractSetBak(35) = ExtractSet(35)
				ExtractSetBak(39) = ExtractSet(39)
				WriteSettings("FilterStrDic")
			End If
			TempList = ReSplit(ReadBinaryFile(ExtractSet(35),CP_UNICODELITTLE,True),vbNullChar)
			StrList2StrDic(FilterStrDic,TempList,StrToLong(ReSplit(FilterStrSet(17),ItemJoinStr)(1)),1)
			Exit Function
		Case 6 To 8	'查看空余地址数据信息
			If TargetFile.FilePath = "" Then Exit Function
			If Dir$(TargetFile.FilePath) = "" Then Exit Function
			If SourceFile.Magic = "" Or TargetFile.hcsFile.FilePath = SourceFile.hcsFile.FilePath Then
				MsgBox MsgList(86),vbOkOnly+vbInformation,MsgList(1)
				Exit Function
			End If
			TempList = GetToolNameList(Tools,0)
			k = ShowPopupMenu(TempList,vbPopupUseRightButton)
			If k < 0 Then Exit Function
			If DlgEnable("AllResetButton") = True Then
				Stemp = True
			Else
				Set Dic = CreateObject("Scripting.Dictionary")
				For i = 0 To UBound(TargetFile.SecList)
					If Not Dic.Exists(TargetFile.SecList(i).sName) Then
						Dic.Add(TargetFile.SecList(i).sName,i)
					End If
				Next i
				For i = 0 To UBound(UseSectionList)
					If GetFreeByteSecList(Dic.Item(UseSectionList(i))) = "" Then
						Stemp = True
						Exit For
					End If
				Next i
				Set Dic = Nothing
			End If
			If Stemp = True Then
				'显示消息输出模式
				j = StrToLong(Selected(17))
				If j > 0 Then
					If DlgVisible("ActionProgressBox") = False Then
						DlgVisible "OrgStringText",False
						DlgVisible "TrnStringText",False
						DlgVisible "OrgStringBox",False
						DlgVisible "TrnStringBox",False
						DlgVisible "OrgCheckBox",False
						DlgVisible "TrnCheckBox",False
						DlgVisible "MsgOutputText",True
						DlgVisible "MsgOutputGroup",True
						DlgVisible "ActionProgressBox",True
						DlgVisible "FindResultsBox",False
						DlgVisible "WriteResultsBox",False
						DlgValue "MsgOutputGroup",0
						DlgText "MsgOutputButton",MsgList(30)
					End If
					j = GetDlgItem(CLng(DlgText("SuppValueBox")),DlgControlId("ActionProgressBox"))
					SetTextBoxString j,MsgList(87)
				ElseIf j < 0 Then
					PSL.OutputWnd(0).Clear
					PSL.Output MsgList(87)
					j = -2
				End If
				Call MoveString(TargetFile,AllStrDataList,1,StrToLong(Selected(1)),j)
			End If
			File = TargetFile
			i = InStrRev(LCase$(TargetFile.FilePath),".bak")
			If i > 1 Then
				If Mid$(LCase$(TargetFile.FilePath),i) = ".bak" Then
					File.FilePath = Left$(TargetFile.FilePath,i - 1)
				End If
			End If
			If j = 0 Then j = GetDlgItem(CLng(DlgText("SuppValueBox")),DlgControlId("ActionProgressBox"))
			Call FreeByteView(File,FreeByteList,k,SuppValue,StrToLong(Selected(16)),j)
			Exit Function
		Case 9 To 10	'打开文件
			TempList = GetToolNameList(Tools,3)
			k = ShowPopupMenu(TempList,vbPopupUseRightButton)
			If k < 0 Then Exit Function
			If SuppValue = 9 Then
				Temp = SourceFile.FilePath
			Else
				Temp = TargetFile.FilePath
				i = InStrRev(LCase$(TargetFile.FilePath),".bak")
				If i > 1 Then
					If Mid$(LCase$(TargetFile.FilePath),i) = ".bak" Then
						Temp = Left$(TargetFile.FilePath,i - 1)
					End If
				End If
			End If
			ReDim TempList(0) As String
			TempList(0) = Temp & JoinStr
			If OpenFile(Temp,TempList,k + 3,False) = True Then
				If k = 0 Then WriteSettings("Tools")
			End If
			Exit Function
		Case 11 To 12	'查看文件信息
			If TargetFile.FilePath = "" Then Exit Function
			If Dir$(TargetFile.FilePath) = "" Then Exit Function
			TempList = GetToolNameList(Tools,0)
			k = ShowPopupMenu(TempList,vbPopupUseRightButton)
			If k < 0 Then Exit Function
			If SuppValue = 11 Then
				Call FileInfoView(SourceFile,FreeByteList,k,0,StrToLong(Selected(16)))
			Else
				File.FilePath = TargetFile.FilePath
				i = InStrRev(LCase$(TargetFile.FilePath),".bak")
				If i > 1 Then
					If Mid$(LCase$(TargetFile.FilePath),i) = ".bak" Then
						File.FilePath = Left$(TargetFile.FilePath,i - 1)
					End If
				End If
				If GetFileInfo(File.FilePath,File) = False Then Exit Function
				Select Case TargetFile.Magic
				Case "PE32","PE64","NET32","NET64","NotPE32","NotPE64",""
					GetPEHeaders(File.FilePath,File,StrToLong(Selected(1)))
				Case "MAC32","MAC64"
					GetMacHeaders(File.FilePath,File,StrToLong(Selected(1)))
				End Select
				Call FileInfoView(File,FreeByteList,k,0,StrToLong(Selected(16)))
			End If
			Exit Function
		End Select
		If SuppValue And &H200 Then '取消翻译
			If TargetFile.hcsFile.FilePath = SourceFile.hcsFile.FilePath Then Exit Function
			intArray = GetListBoxIndexs(GetDlgItem(CLng(DlgText("SuppValueBox")),DlgControlId("UseStrList")))
			If CheckArrEmpty(intArray) = False Then Exit Function
			intList = intArray: intArry = intArray
			If DlgEnable("AllShowButton") = True Then
				If GetIndexList(StrIDIndexDic,UseStrDataList,intList,False) = False Then
					Exit Function
				End If
			End If
			ReDim TempList(UBound(intList)) As String
			For i = 0 To UBound(intList)
				j = intList(i)
				With AllStrDataList(j)
					If .WriteType < -1 Or .WriteType > 0 Then
						If .LockState = 0 Then
							If .SplitState = 0 Then .MoveMode = 0
							.Source.MoveLength = 0
							.Trans.MoveLength = 0
							.Trans.sString = .Source.sString
							.Trans.CodePage = .Source.CodePage
							.Trans.lCharLength = .Source.lCharLength
							.Trans.lHexLength = .Source.lHexLength
							.Trans.iNullByteLength = .Source.iNullByteLength
							.Trans.StrTypeLength = .Source.StrTypeLength
							If ResetStrVal(TargetFile,AllStrDataList,FreeByteList,j,1) = True Then
								Stemp = True
							End If
							.WriteType = WriteType(TargetFile,AllStrDataList(j),WriteSet)
							UseStrDataList(intArray(i)) = AllStrDataList(j)
							TempList(n) = AllStrDataList(j).Trans.sString
							intArry(n) = intArray(i)
							n = n + 1
						Else
							m = m + 1
						End If
					End If
				End With
			Next i
			If Stemp = True And Selected(8) = "1" Then
				Call ShowMoveMsg(MoveString(TargetFile,AllStrDataList,0,StrToLong(Selected(1)),0),0,3)
			End If
			If m > 0 Then
				MsgBox Replace$(MsgList(88),"%s",CStr(m)),vbOkOnly+vbInformation,MsgList(1)
			End If
			If n = 0 Then Exit Function
			ReDim Preserve TempList(n - 1) As String,intArry(n - 1) As Long
			j = GetDlgItem(CLng(DlgText("SuppValueBox")),DlgControlId("UseStrList"))
			ChangeListBoxItems(j,TempList,intArry,intArry)
			SetListBoxItems(j,intArray)
			DlgEnable "ResetButton",True
			DlgEnable "AllResetButton",True
			If DlgValue("ModeCheckBox") = 1 Then DlgValue "ModeCheckBox",2
			i = intList(0)
			Stemp = True
		End If
		'显示更改
		If Stemp = True Then
			With AllStrDataList(i)
				DlgText "OrgInSectionBox",GetSectionName(SourceFile,.Source.inSectionID,.Source.inSubSecID)
				If .MoveType < 6 Then
					DlgText "TrnInSectionBox",GetSectionName(TargetFile,.Trans.inSectionID,.Trans.inSubSecID)
				ElseIf InStr(TargetFile.Magic,"PE") Then
					DlgText "TrnInSectionBox",NewPESecName
				Else
					DlgText "TrnInSectionBox",NewMacSecName
				End If

				DlgText "OrgStartPosBox",ValToStr(.Source.lStartAddress,TargetFile.FileSize,StrToLong(Selected(16)))
				DlgText "OrgMaxPosBox",ValToStr(.Source.lMaxAddress,TargetFile.FileSize,StrToLong(Selected(16)))
				DlgText "OrgRefNumBox",CStr$(.Source.lReferenceNum)
				DlgText "OrgCodePageValList",CStr$(.Source.CodePage)
				DlgValue "OrgCodePageNameList",DlgValue("OrgCodePageValList")
				DlgText "OrgStrLengthBox",CStr$(.Source.lHexLength)

				DlgText "TrnStartPosBox",ValToStr(.Trans.lStartAddress,TargetFile.FileSize,StrToLong(Selected(16)))
				DlgText "TrnMaxPosBox",ValToStr(.Trans.lMaxAddress,TargetFile.FileSize,StrToLong(Selected(16)))
				DlgText "TrnRefNumBox",CStr$(.Trans.lReferenceNum)
				DlgText "TrnCodePageValList",CStr$(.Trans.CodePage)
				DlgValue "TrnCodePageNameList",DlgValue("TrnCodePageValList")
				DlgText "TrnStrLengthBox",CStr$(.Trans.lHexLength)

				DlgText "MaxStrLengthBox",CStr$(.Trans.lMaxHexLength)
				DlgText "OrgStringBox",IIf(StrToLong(Selected(19)) = 0,.Source.sString,Replace$(.Source.sString," ",SpaceWithPointChar))
				DlgText "TrnStringBox",IIf(StrToLong(Selected(19)) = 0,.Trans.sString,Replace$(.Trans.sString," ",SpaceWithPointChar))

				TempList = GetRefCodeList(AllStrDataList(i),False)
				DlgListBoxArray "OrgVOffsetList",TempList()
				j = 0
				TempList = GetRefCodeList(AllStrDataList(i),True,j)
				DlgListBoxArray "TrnVOffsetList",TempList()
				DlgValue "OrgVOffsetList",j
				DlgValue "TrnVOffsetList",j
			End With
		End If
	End Select
End Function


'原址扩展
Private Function ExpandStrOrgAdd(trnFile As FILE_PROPERTIE,DataList() As STRING_PROPERTIE,ByVal strID As Long,ByVal Stemp As Boolean) As Boolean
	Dim i As Long,j As Long,k As Long,Mode As Long,FN As FILE_IMAGE,MsgList() As String,TempList() As STRING_PROPERTIE
	If getMsgList(UIDataList,MsgList,"OriginalAddExpand",1) = False Then Exit Function
	If DataList(strID).SplitState < 0 Then
		MsgBox MsgList(1),vbOkOnly+vbInformation,MsgList(0)
		Exit Function
	End If
	j = strID + DataList(strID).SplitState + 1
	If j > UBound(DataList) Then Exit Function
	TempList = DataList
	With TempList(j)
		If Stemp = False Then
			If TempList(strID).WriteType = 5 Then
				MsgBox MsgList(2),vbOkOnly+vbInformation,MsgList(0)
				Exit Function
			ElseIf CheckStrVal(TempList(strID),4,0) = True Then
				MsgBox MsgList(3),vbOkOnly+vbInformation,MsgList(0)
				Exit Function
			ElseIf TempList(strID).SplitState = 0 And TempList(strID).Trans.lReferenceNum > 0 And _
				TempList(strID).Trans.lReferenceNum <> TempList(strID).Source.lReferenceNum Then
				MsgBox MsgList(4),vbOkOnly+vbInformation,MsgList(0)
				Exit Function
			ElseIf .Moveable > 0 Then
				MsgBox MsgList(5),vbOkOnly+vbInformation,MsgList(0)
				Exit Function
			ElseIf TempList(strID).Source.lMaxAddress + 1 <> .Source.lStartAddress - .Source.StrTypeLength Then
				MsgBox MsgList(6),vbOkOnly+vbInformation,MsgList(0)
				Exit Function
			ElseIf .Source.GetRefState = 0 Then
				'打开文件
				Mode = LoadFile(trnFile.FilePath,FN,0,0,0,StrToLong(Selected(1)))
				If Mode < -1 Then Exit Function
				'获取原始字串的引用代码和引用列表
				GetVARefList(trnFile,FN,.Source,OrgStrTypeList,.TagType,.Moveable,"",0,Mode,0)
				If UnLoadFile(FN,0,Mode) = False Then Exit Function
			End If
			If .Source.lReferenceNum = 0 Then
				MsgBox MsgList(7),vbOkOnly+vbInformation,MsgList(0)
				Exit Function
			ElseIf .SplitState <> 0 Or (.Trans.lReferenceNum > 0 And .Trans.lReferenceNum <> .Source.lReferenceNum) Then
				MsgBox MsgList(8),vbOkOnly+vbInformation,MsgList(0)
				Exit Function
			End If
			'非拆分字串的翻译引用置零
			If TempList(strID).SplitState = 0 Then TempList(strID).Trans.lReferenceNum = 0
			TempList(strID).MoveMode = 5
			.MoveMode = 1
			.Trans.Reference = .Source.Reference
			.Trans.lReferenceNum = .Source.lReferenceNum
			Mode = True
		Else
			If TempList(strID).WriteType <> 5 Then
				MsgBox MsgList(9),vbOkOnly+vbInformation,MsgList(0)
				Exit Function
			End If
			If TempList(strID).SplitState = 0 Then
				TempList(strID).MoveMode = IIf(TempList(strID).Source.MoveLength = 0,0,2)
			Else
				TempList(strID).MoveMode = IIf(TempList(strID).Source.MoveLength = 0,4,2)
			End If
			.MoveMode = 0
			Mode = CheckStrVal(TempList(j),4,0)
			If Mode = True Then .Trans.lReferenceNum = 0
		End If
	End With
	'重置字串的地址
	For i = 0 To 1
		If i = 0 Then k = j Else k = strID
		ResetStrVal(trnFile,TempList,FreeByteList,k,1)
	Next i
	'分配空余地址
	Call ShowMoveMsg(MoveString(trnFile,TempList,0,StrToLong(Selected(1)),0),1,1)
	For i = 0 To 1
		If i = 0 Then k = strID Else k = j
		With TempList(k)
			'获取字串的写入类型
			.WriteType = WriteType(trnFile,TempList(k),WriteSet)
			'获取字串的移位模式
			.MoveMode = MoveMode(trnFile,TempList(k))
			'超长移位模式字串移位不成功时清空翻译引用列表
			If k = j And .MoveMode < 2 And .WriteType = 2 Then
				ReDim TempList(k).Trans.Reference(0) 'As REFERENCE_PROPERTIE
				.Trans.lReferenceNum = 0
				.Trans.GetRefState = 0
			End If
		End With
	Next i
	If Stemp = False Then
		If TempList(strID).WriteType <> 5 Then
			MsgBox MsgList(10),vbOkOnly+vbInformation,MsgList(0)
			Exit Function
		End If
	Else
		If TempList(strID).WriteType = 5 Then
			MsgBox MsgList(11),vbOkOnly+vbInformation,MsgList(0)
			Exit Function
		End If
	End If
	DataList = TempList
	ExpandStrOrgAdd = True
End Function


'合并消息和多个字串类型数组的名称，用于字串列表显示
'MsgList 为空或未初始化时，仅合并多个字串类型数组的名称
Private Function MergeStrType2StrList(aStrTypeList() As STRING_TYPE,oStrTypeList() As STRING_TYPE, _
				uStrTypeList() As STRING_TYPE,MsgList() As String) As String()
	Dim i As Integer,j As Integer,n As Integer,Dic As Object,Temp As String,TempList() As String
	If CheckArray(MsgList) = True Then
		n = UBound(MsgList) - 2
		TempList = MsgList
		If CheckStrTypeArray(oStrTypeList) = True Then
			Set Dic = CreateObject("Scripting.Dictionary")
			j = UBound(oStrTypeList)
			ReDim Preserve TempList(n + j + 3) As String
			For i = 0 To j
				TempList(n) = Replace$(MsgList(10),"%s",oStrTypeList(i).sName)
				Temp = StrTypeToString(oStrTypeList,i)
				If Not Dic.Exists(Temp) Then Dic.Add(Temp,"")
				n = n + 1
			Next i
			If CheckStrTypeArray(uStrTypeList) = True Then
				j = UBound(uStrTypeList)
				ReDim Preserve TempList(n + j + 2) As String
				For i = 0 To j
					Temp = StrTypeToString(uStrTypeList,i)
					If Not Dic.Exists(Temp) Then
						TempList(n) = Replace$(MsgList(10),"%s",uStrTypeList(i).sName)
						Dic.Add(Temp,"")
						n = n + 1
					End If
				Next i
			End If
			TempList(n) = MsgList(8)
			TempList(n + 1) = MsgList(9)
			ReDim Preserve TempList(n + 1) As String
			Set Dic = Nothing
		ElseIf CheckStrTypeArray(uStrTypeList) = True Then
			j = UBound(uStrTypeList)
			ReDim Preserve TempList(n + j + 2) As String
			For i = 0 To j
				TempList(n) = Replace$(MsgList(10),"%s",uStrTypeList(i).sName)
				n = n + 1
			Next i
			TempList(n) = MsgList(8)
			TempList(n + 1) = MsgList(9)
			ReDim Preserve TempList(n + 1) As String
		ElseIf CheckStrTypeArray(aStrTypeList) = True Then
			ReDim Preserve TempList(n) As String
		Else
			ReDim Preserve TempList(n - 1) As String
		End If
	Else
		Set Dic = CreateObject("Scripting.Dictionary")
		If CheckStrTypeArray(oStrTypeList) = True Then
			j = UBound(oStrTypeList)
			ReDim TempList(j) As String
			For i = 0 To j
				TempList(i) = oStrTypeList(i).sName
				Temp = StrTypeToString(oStrTypeList,i)
				If Not Dic.Exists(Temp) Then Dic.Add(Temp,"")
			Next i
			n = j + 1
		End If
		If CheckStrTypeArray(uStrTypeList) = True Then
			j = UBound(uStrTypeList)
			ReDim Preserve TempList(n + j) As String
			For i = 0 To j
				Temp = StrTypeToString(uStrTypeList,i)
				If Not Dic.Exists(Temp) Then
					Dic.Add(Temp,"")
					TempList(n) = uStrTypeList(i).sName
					n = n + 1
				End If
			Next i
		End If
		If CheckStrTypeArray(aStrTypeList) = True Then
			j = UBound(aStrTypeList)
			ReDim Preserve TempList(n + j) As String
			For i = 0 To j
				Temp = StrTypeToString(aStrTypeList,i)
				If Not Dic.Exists(Temp) Then
					Dic.Add(Temp,"")
					TempList(n) = aStrTypeList(i).sName
					n = n + 1
				End If
			Next i
		End If
		Set Dic = Nothing
		If n > 0 Then n = n - 1
		ReDim Preserve TempList(n) As String
	End If
	MergeStrType2StrList = TempList
End Function


'优先级更改、增加和删除自定义字串类型，返回字串数据被更改的字串索引号
'返回值：ManageStrType = -1 全部删除类型，ManageStrType > 0 添加和删除类型
'UseIndexList 空字串数组，不输入，用于返回字串有修改的列表
'fType = True 增加和删除自定义字串类型，否则修改优先级
Private Function ManageStrType(File As FILE_PROPERTIE,UseIndexList() As Long,NewTypeList() As String,ByVal fType As Boolean,ByVal ShowMsg As Long) As Long
	Dim i As Long,m As Long,n As Long,y As Long,Mode As Long
	Dim AddTypeList() As String,DelTypeList() As String,MsgList() As String,Dic As Object
	Dim FN As FILE_IMAGE,strData As STRING_PROPERTIE
	If fType = True Then
		'获取使用的字串类型名称列表
		MsgList = GetStrTypeNameList(OrgStrTypeList)
		'计算要增加的自定义字串类型
		AddTypeList = ChangeList(NewTypeList,ChangeList(MsgList,NewTypeList,1))
		'计算要删除的自定义字串类型
		DelTypeList = ChangeList(MsgList,ChangeList(NewTypeList,MsgList,1))
		'组织提示消息
		n = IIf(CheckArray(AddTypeList) = True,UBound(AddTypeList) + 1,0)
		m = IIf(CheckArray(DelTypeList) = True,UBound(DelTypeList) + 1,0)
		If n + m = 0 Then Exit Function
		If getMsgList(UIDataList,MsgList,"ManageStrType",1) = False Then Exit Function
		If n > 0 And m > 0 Then '添加和删除
			If MsgBox(MsgList(1),vbYesNo+vbInformation,MsgList(0)) = vbNo Then Exit Function
		ElseIf n > 0 Then		'仅添加
			If MsgBox(MsgList(2),vbYesNo+vbInformation,MsgList(0)) = vbNo Then Exit Function
		Else					'仅删除
			If MsgBox(MsgList(3),vbYesNo+vbInformation,MsgList(0)) = vbNo Then Exit Function
			'当只有删除时，检查是否都是要删除所有自定义类型
			If ArrayComp(DelTypeList,GetStrTypeNameList(OrgStrTypeList)) = False Then
				y = UBound(AllStrDataList)
				For i = 0 To y
					With AllStrDataList(i)
						If .StrType > 4 Then
							.StrType = 0
							If .Source.lReferenceNum > 0 Then
								For n = 0 To .Source.lReferenceNum - 1
									.Source.Reference(n).StrType = 0
								Next n
							End If
							.LengthModeID = 0
							.TagType = TagType(.StrType,OrgStrTypeList)
							.Source.lMaxHexLength = .Source.lMaxAddress - .Source.lStartAddress + 1 - .EndByteLength - .Source.iNullByteLength
							.Trans = .Source
							ReDim AllStrDataList(i).Trans.Reference(0) 'As REFERENCE_PROPERTIE
							.Trans.GetRefState = 0
							.Trans.lReferenceNum = 0
							Call StrTypeLength(AllStrDataList(i),OrgStrTypeList,"",Mode,.WriteType)
						End If
					End With
				Next i
				ReDim OrgStrTypeList(0) As STRING_TYPE,NewTypeList(0) As String
				ManageStrType = -1
				If StrToLong(Selected(25)) = 1 Then Beep
				Exit Function
			End If
		End If
	ElseIf ShowMsg <> 0 Then
		If getMsgList(UIDataList,MsgList,"ManageStrType",1) = False Then Exit Function
	End If
	'重新构建要被使用的自定义字串类型
	Set Dic = CreateObject("Scripting.Dictionary")
	m = UBound(NewTypeList)
	ReDim TypeList(m) As STRING_TYPE
	For i = 0 To m
		If Not Dic.Exists(NewTypeList(i)) Then
			Dic.Add(NewTypeList(i),i)
		End If
	Next i
	If CheckStrTypeArray(OrgStrTypeList) = True Then
		For i = 0 To UBound(OrgStrTypeList)
			If Dic.Exists(OrgStrTypeList(i).sName) Then
				n = Dic.Item(OrgStrTypeList(i).sName)
				TypeList(n) = OrgStrTypeList(i)
				Dic.Remove(OrgStrTypeList(i).sName)
			End If
		Next i
	End If
	If Dic.Count > 0 Then
		If CheckStrTypeArray(StrTypeList) = True Then
			For i = 0 To UBound(StrTypeList)
				If Dic.Exists(StrTypeList(i).sName) Then
					n = Dic.Item(StrTypeList(i).sName)
					TypeList(n) = StrTypeList(i)
					Dic.Remove(StrTypeList(i).sName)
				End If
			Next i
		End If
	End If
	Set Dic = Nothing
	ReDim NewTypeList(0) As String
	'打开文件
	Mode = LoadFile(File.FilePath,FN,0,0,0,StrToLong(Selected(1)))
	If Mode < -1 Then GoTo ExitFunction
	'判断是否需要检查跟随引用地址的自定义字符类型
	y = CheckRefCustomStrType(TypeList,IIf(File.Magic = "",0,1))
	'获取字串的引用地址和引用代码
	m = 0: n = 0
	If File.Magic <> "" And y > 1 Then
		ReDim UseIndexList(UBound(AllStrDataList)) As Long
		For i = 0 To UBound(AllStrDataList)
			With AllStrDataList(i)
				If .Moveable = 0 Or .Moveable = 2 Then
					If .Source.GetRefState = 0 Then
						UseIndexList(m) = i
						m = m + 1
					End If
					n = n + 1
				End If
			End With
		Next i
		If n = 0 Then GoTo ExitFunction
		If m > 0 Then
			If ShowMsg > 0 Then
				SetTextBoxString ShowMsg,MsgList(4)
			ElseIf ShowMsg < 0 Then
				PSL.OutputWnd(0).Clear
				PSL.Output MsgList(4)
			End If
			ReDim Preserve UseIndexList(m - 1) As Long
			ReDim AddTypeList(m - 1) As String
			If GetVARefListBatch(File,FN,AllStrDataList,TypeList,UseIndexList,AddTypeList,4,Mode,ShowMsg,True) < -1 Then
				UnLoadFile(FN,0,Mode)
				Exit Function
			End If
		End If
	End If
	'准备检测进度消息
	If ShowMsg <> 0 Then
		If m <> 0 Then MsgList(5) = MsgList(4) & " 100%" & vbCrLf & MsgList(5)
	End If
	'获取字串类型
	m = 0: n = 0: y = UBound(AllStrDataList) + 1
	ReDim NewTypeList(y) As String,UseIndexList(y) As Long
	For i = 0 To y - 1
		strData = AllStrDataList(i)
		With strData
			If .StrType <> 0 And .StrType < 5 Then GoTo NextNo
			If .WriteType < 0 Then GoTo NextNo
			.StrType = 0
			.Source.sString = Convert(.Source.sString)
			.StrType = GetCustomStrTypeRegExp(FN,.Source,TypeList,Mode,2)
			'If .StrType < 5 Then
			'	If .StrType = AllStrDataList(i).StrType Then GoTo NextNo
			'ElseIf	TypeList(.StrType - 5).CodeLoc = 0 Then
			'	If .StrType = AllStrDataList(i).StrType Then GoTo NextNo
			'End If
			.LengthModeID = 0
			.TagType = TagType(.StrType,TypeList)
			If .ID <> .Source.lStartAddress Then
				If StrIDIndexDic.Exists(.ID) Then
					If Not StrIDIndexDic.Exists(.Source.lStartAddress) Then
						StrIDIndexDic.Key(.ID) = .Source.lStartAddress
					End If
				End If
				If StrIDIndexDicBak.Exists(.ID) Then
					If Not StrIDIndexDicBak.Exists(.Source.lStartAddress) Then
						StrIDIndexDicBak.Key(.ID) = .Source.lStartAddress
						AllStrDataListBak(StrIDIndexDicBak.Item(.ID)).ID = .Source.lStartAddress
					End If
				End If
				If UseStrIDIndexDic.Exists(.ID) Then
					If Not UseStrIDIndexDic.Exists(.Source.lStartAddress) Then
						UseStrIDIndexDic.Key(.ID) = .Source.lStartAddress
						UseStrDataList(UseStrIDIndexDic.Item(.ID)).ID = .Source.lStartAddress
					End If
				End If
				.ID = .Source.lStartAddress
			End If
			.Source.sString = ReConvert(.Source.sString)
			.Source.lMaxHexLength = .Source.lMaxAddress - .Source.lStartAddress + 1 - .EndByteLength - .Source.iNullByteLength
			.Trans = .Source
			ReDim strData.Trans.Reference(0) 'As REFERENCE_PROPERTIE
			.Trans.GetRefState = 0
			.Trans.lReferenceNum = 0
			Call StrTypeLength(strData,TypeList,FN,Mode,.WriteType)
			If .Source.sString <> AllStrDataList(i).Source.sString Then
				NewTypeList(n) = .Source.sString
				UseIndexList(n) = i
				n = n + 1
			End If
			'UseStrDataList(n) = strData
			AllStrDataList(i) = strData
			m = m + 1
			NextNo:
		End With
		If ShowMsg > 0 Then
			SetTextBoxString ShowMsg,MsgList(5) & Format$(i / y," #%")
		ElseIf ShowMsg < 0 Then
			PSL.OutputWnd(0).Clear
			PSL.Output MsgList(5) & Format$(i / y," #%")
		End If
	Next i
	If m > 0 Then
		OrgStrTypeList = TypeList: UseStrTypeList = TypeList
	End If
	If n > 0 Then
		ReDim Preserve NewTypeList(n - 1) As String,UseIndexList(n - 1) As Long
	End If
	ManageStrType = m
	If ShowMsg > 0 Then
		SetTextBoxString ShowMsg,MsgList(5) & " 100%"
	ElseIf ShowMsg < 0 Then
		PSL.OutputWnd(0).Clear
		PSL.Output MsgList(5) & " 100%"
	End If
	If StrToLong(Selected(25)) = 1 Then Beep
	ExitFunction:
	UnLoadFile(FN,0,Mode)
End Function


'指定或检测字串类型，返回字串数据被更改的字串索引号
'返回值：CheckStrType = 字串被更改的字串列表，MaxDefaultTypeID < 0 被更改的类型数，SelectTypeID < 0 被锁定的字串数
Private Function CheckStrType(File As FILE_PROPERTIE,AllIndexList() As Long,UseIndexList() As Long, _
			TypeList() As STRING_TYPE,MaxDefaultTypeID As Long,SelectTypeID As Long,ByVal ShowMsg As Long) As String()
	Dim i As Long,j As Long,m As Long,n As Long,x As Long,y As Long,k As Long,Mode As Long
	Dim intArray() As Long,TempList() As String,MsgList() As String
	Dim FN As FILE_IMAGE,strData As STRING_PROPERTIE
	If ShowMsg <> 0 Then
		If getMsgList(UIDataList,MsgList,"CheckStrType",1) = False Then Exit Function
	End If
	'打开文件
	Mode = LoadFile(File.FilePath,FN,0,0,0,StrToLong(Selected(1)))
	If Mode < -1 Then GoTo ExitFunction
	'设置和检测的字串类型相匹配的提取选项
	TempList = ExtractSet
	Select Case SelectTypeID
	Case 0
		If File.LangType = DELPHI_FILE_SIGNATURE Then
			For i = 2 To 5
				TempList(SelectTypeID + 3) = "1"
			Next i
		ElseIf File.LangType = NET_FILE_SIGNATURE And File.USStreamID > -1 Then
			TempList(2) = "1"
			TempList(9) = "1"
		Else
			TempList(41) = "1"
		End If
		TempList(10) = IIf(CheckStrTypeArray(TypeList) = True,"1","0")
	Case 2 To 5
		TempList(SelectTypeID + 3) = "1"
	Case 6
		TempList(2) = "1"
		TempList(9) = "1"
	Case 7
		TempList(41) = "1"
	Case Is > MaxDefaultTypeID
		TempList(10) = IIf(CheckStrTypeArray(TypeList) = True,"1","0")
	End Select
	If SelectTypeID <> 1 Then
		'判断是否需要检查跟随引用地址的自定义字符类型
		If TempList(10) = "1" Then y = CheckRefCustomStrType(TypeList,IIf(File.Magic = "",0,1))
		'获取字串的引用地址和引用代码
		If File.Magic <> "" And y > 1 Then
			intArray = AllIndexList
			For i = 0 To UBound(AllIndexList)
				With AllStrDataList(AllIndexList(i))
					If .LockState = 0 Then
						If .Moveable = 0 Or .Moveable = 2 Then
							If .Source.GetRefState = 0 Then
								intArray(m) = AllIndexList(i)
								m = m + 1
							End If
							j = j + 1
						End If
					Else
						x = x + 1
					End If
				End With
			Next i
			If j = 0 Then GoTo ExitFunction
			If m > 0 Then
				If ShowMsg > 0 Then
					SetTextBoxString ShowMsg,MsgList(0)
				ElseIf ShowMsg < 0 Then
					PSL.OutputWnd(0).Clear
					PSL.Output MsgList(0)
				End If
				ReDim Preserve intArray(m - 1) As Long
				ReDim TempArray(m - 1) As String
				If GetVARefListBatch(File,FN,AllStrDataList,TypeList,intArray,TempArray,4,Mode,ShowMsg,True) < -1 Then
					UnLoadFile(FN,0,Mode)
					Exit Function
				End If
			End If
		End If
		'准备检测进度消息
		If ShowMsg <> 0 Then
			If m <> 0 Then MsgList(1) = MsgList(0) & " 100%" & vbCrLf & MsgList(1)
		End If
	End If
	'获取字串类型
	m = 0: n = 0: x = 0: y = UBound(AllIndexList) + 1
	ReDim TempArray(y) As String
	For i = 0 To y - 1
		j = AllIndexList(i)
		strData = AllStrDataList(j)
		With strData
			If .LockState = 0 Then
				If .WriteType < 0 Then GoTo NextNo
				.StrType = 0
				If SelectTypeID <> 1 Then
					.Source.sString = Convert(.Source.sString)
					.StrType = GetStrType(File,FN,.Source,TypeList,TempList,Mode,SelectTypeID + 2)
				End If
				If .StrType < 5 Then
					If .StrType = AllStrDataList(j).StrType Then GoTo NextNo
				ElseIf	TypeList(.StrType - 5).CodeLoc = 0 Then
					If .StrType = AllStrDataList(j).StrType Then GoTo NextNo
				End If
				Select Case SelectTypeID
				Case 1
					If .Source.lReferenceNum > 0 Then
						For k = 0 To .Source.lReferenceNum - 1
							.Source.Reference(k).StrType = 0
						Next k
					End If
				Case 6
					If .StrType > -1 Or .StrType < -4 Then GoTo NextNo
				Case 7
					If .StrType > -5 Then GoTo NextNo
				Case Is > MaxDefaultTypeID
					If .StrType < SelectTypeID - 3 Then GoTo NextNo
				Case Is <> 0
					If .StrType <> SelectTypeID - 1 Then GoTo NextNo
				End Select
				.LengthModeID = 0
				.TagType = TagType(.StrType,TypeList)
				If SelectTypeID <> 1 Then
					If .ID <> .Source.lStartAddress Then
						If StrIDIndexDic.Exists(.ID) Then
							If Not StrIDIndexDic.Exists(.Source.lStartAddress) Then
								StrIDIndexDic.Key(.ID) = .Source.lStartAddress
							End If
						End If
						If StrIDIndexDicBak.Exists(.ID) Then
							If Not StrIDIndexDicBak.Exists(.Source.lStartAddress) Then
								StrIDIndexDicBak.Key(.ID) = .Source.lStartAddress
								AllStrDataListBak(StrIDIndexDicBak.Item(.ID)).ID = .Source.lStartAddress
							End If
						End If
						If UseStrIDIndexDic.Exists(.ID) Then
							If Not UseStrIDIndexDic.Exists(.Source.lStartAddress) Then
								UseStrIDIndexDic.Key(.ID) = .Source.lStartAddress
								UseStrDataList(UseStrIDIndexDic.Item(.ID)).ID = .Source.lStartAddress
							End If
						End If
						.ID = .Source.lStartAddress
					End If
					.Source.sString = ReConvert(.Source.sString)
					If .Source.sString <> AllStrDataList(j).Source.sString Then
						TempArray(n) = .Source.sString
						UseIndexList(n) = UseIndexList(i)
						n = n + 1
					End If
				End If
				.Source.lMaxHexLength = .Source.lMaxAddress - .Source.lStartAddress + 1 - .EndByteLength - .Source.iNullByteLength
				.Trans = .Source
				ReDim strData.Trans.Reference(0) 'As REFERENCE_PROPERTIE
				.Trans.GetRefState = 0
				.Trans.lReferenceNum = 0
				Call StrTypeLength(strData,TypeList,FN,Mode,.WriteType)
				UseStrDataList(UseIndexList(i)) = strData
				AllStrDataList(j) = strData
				m = m + 1
				NextNo:
			Else
				x = x + 1
			End If
		End With
		If ShowMsg > 0 Then
			SetTextBoxString ShowMsg,MsgList(1) & Format$(i / y," #%")
		ElseIf ShowMsg < 0 Then
			PSL.OutputWnd(0).Clear
			PSL.Output MsgList(1) & Format$(i / y," #%")
		End If
	Next i
	MaxDefaultTypeID = -m: SelectTypeID = -x
	If m > 0 Then ExtractSet = TempList
	If n > 0 Then n = n - 1
	ReDim Preserve TempArray(n) As String,UseIndexList(n) As Long
	CheckStrType = TempArray
	If ShowMsg > 0 Then
		SetTextBoxString ShowMsg,MsgList(1) & " 100%"
	ElseIf ShowMsg < 0 Then
		PSL.OutputWnd(0).Clear
		PSL.Output MsgList(1) & " 100%"
	End If
	If StrToLong(Selected(25)) = 1 Then Beep
	ExitFunction:
	UnLoadFile(FN,0,Mode)
End Function


'更新 PSL 翻译列表中的翻译
'Mode = False 一对一导入，否则非一对一导入
Private Function UpdatePSLTrans(hcsTrn As PslTransList,DataList() As STRING_PROPERTIE,Optional ByVal Mode As Boolean) As Long
	Dim i As Long,j As Long,k As Long,Dic As Object,TransDic As Object,MsgList() As String,TempList() As String
 	If Mode = False Then
 		With hcsTrn
 			For i = 0 To UBound(DataList)
				If DataList(i).SplitState > -1 And DataList(i).iError = 0 Then
					j = j + 1
					If .String(j).State(pslStateLocked) = False Then
						If .String(j).State(pslStateReadOnly) = False Then
							If .String(j).SourceText = DataList(i).Source.sString Then
								If .String(j).Text <> DataList(i).Trans.sString Then
									.String(j).Text = DataList(i).Trans.sString
									If .String(j).SourceText <> DataList(i).Trans.sString Then
										.String(j).State(pslStateReview) = True
									Else
										.String(j).State(pslStateTranslated) = False
									End If
									UpdatePSLTrans = UpdatePSLTrans + 1
								End If
							End If
						End If
					End If
				End If
			Next i
		End With
	Else
 		If getMsgList(UIDataList,MsgList,"ImportString",1) = False Then Exit Function
 		Set Dic = CreateObject("Scripting.Dictionary")
 		Set TransDic = CreateObject("Scripting.Dictionary")
		For i = 0 To UBound(DataList)
			With DataList(i)
				If .Source.sString <> .Trans.sString Then
					If Not Dic.Exists(.Source.sString) Then
						Dic.Add(.Source.sString,.Trans.sString)
						If Not TransDic.Exists(.Trans.sString) Then
							TransDic.Add(.Trans.sString,"")
						End If
					ElseIf Not TransDic.Exists(.Trans.sString) Then
						Dic.Item(.Source.sString) = Dic.Item(.Source.sString) & vbNullChar & .Trans.sString
						TransDic.Add(.Trans.sString,"")
					End If
				End If
			End With
		Next i
		Set TransDic = Nothing
		With hcsTrn
			For j = 1 To hcsTrn.StringCount
				If .String(j).State(pslStateLocked) = False Then
					If .String(j).State(pslStateReadOnly) = False Then
						If Dic.Exists(.String(j).SourceText) Then
							TempList = ReSplit(Dic.Item(.String(j).SourceText),vbNullChar)
							i = 0
							If k = 0 Then
								If UBound(TempList) > 0 Then
									i = SelectTrans(.String(j).SourceText,TempList,MsgList,k)
									If i = -2 Then Exit For
									If i = -1 Then GoTo NextNo
								End If
							End If
							If .String(j).Text <> TempList(i) Then
								.String(j).Text = TempList(i)
								If .String(j).SourceText <> TempList(i) Then
									.String(j).State(pslStateTranslated) = True
								Else
									.String(j).State(pslStateTranslated) = False
								End If
								UpdatePSLTrans = UpdatePSLTrans + 1
							End If
						End If
					End If
				End If
				NextNo:
			Next j
		End With
		Set Dic = Nothing
	End If
End Function


'设置允许/禁止超长写入属性，并获取超长字串的引用
Private Function SetOverWriteAndGetRef(trnFile As FILE_PROPERTIE,DataList() As STRING_PROPERTIE,ByVal OverWrite As Integer,ByVal ShowMsg As Long) As Long
	Dim i As Long
	If OverWrite = 0 Then
		For i = 0 To UBound(DataList)
			If DataList(i).OverLengthWrite = 1 Then DataList(i).OverLengthWrite = OverWrite
		Next i
	Else
		ReDim intList(UBound(DataList)) As Long
		For i = 0 To UBound(DataList)
			With DataList(i)
				If .OverLengthWrite = 0 Then
					.OverLengthWrite = OverWrite
					'未移位的字串
					If .ScapeIDForMove = -1 Then
						'最大地址被减少而引起超长时
						If .Trans.lEndAddress + .EndByteLength + .Trans.iNullByteLength > GetMaxAddress(DataList(i),False) Then
							intList(SetOverWriteAndGetRef) = i
							SetOverWriteAndGetRef = SetOverWriteAndGetRef + 1
						End If
					End If
				End If
			End With
		Next i
		If SetOverWriteAndGetRef = 0 Then Exit Function
		ReDim Preserve intList(SetOverWriteAndGetRef - 1) As Long
		Dim FN As FILE_IMAGE,TempList() As String
		'打开文件
		i = LoadFile(trnFile.FilePath,FN,0,0,0,StrToLong(Selected(1)))
		If i < -1 Then Exit Function
		Call GetVARefListBatch(trnFile,FN,DataList,OrgStrTypeList,intList,TempList,0,i,ShowMsg,True)
		UnLoadFile(FN,0,i)
	End If
End Function


'更改翻译或代码页更改后的地址、最大长度以及需要获取引用的字串索引
'Mode = 0 翻译长度改变而代码页不变时使用，会因可变字串类型写入时的字串类型长度改变而更改翻译的开始地址
'Mode = 1 翻译代码页改变时使用，获取字串后空字节长度，会因可变字串类型写入时的字串类型长度改变而更改翻译的开始地址
'Mode > 1 翻译长度改变而代码页不变时使用，不会因可变字串类型写入时的字串类型长度改变而更改翻译的开始地址
'ChangeStrAddAndGetRefIndex 返回：返回是否需要移位
Private Function ChangeStrAddAndGetRefIndex(DataList() As STRING_PROPERTIE,SrcRefIndexList() As Long,TrnRefIndexList() As Long, _
		SrcRefNum As Long,TrnRefNum As Long,ByVal Index As Long,ByVal Mode As Integer) As Boolean
	With DataList(Index)
		'更改翻译开始地址
		If .WriteType > -2 And .WriteType < 1 Then
			.Trans.lStartAddress = .Source.lStartAddress + .Source.MoveLength
		ElseIf Mode < 2 Then
			.Trans.lStartAddress = .Trans.lStartAddress + .Trans.MoveLength
		End If
		If Mode = 1 Then
			.Trans.iNullByteLength = NullByteLength(DataList(Index),True) '更改代码页时
		End If
		If .Moveable > 0 Then
			.Trans.lEndAddress = .Trans.lStartAddress + .Trans.lHexLength - 1
			.Trans.lMaxHexLength = .Trans.lMaxAddress - .Trans.lStartAddress + 1 - .EndByteLength - .Trans.iNullByteLength
		ElseIf .Source.inSectionID < SourceFile.MaxSecIndex Then
			.Trans.lEndAddress = .Trans.lStartAddress + .Trans.lHexLength - 1
			.Trans.lMaxHexLength = .Trans.lMaxAddress - .Trans.lStartAddress + 1 - .EndByteLength - .Trans.iNullByteLength
			'获取引用地址及代码
			If CheckStrVal(DataList(Index),5,0) = False Or .TagType > 1 Or .Trans.MoveLength <> 0 Then
				If .Source.GetRefState = 0 Then
					SrcRefIndexList(SrcRefNum) = Index
					SrcRefNum = SrcRefNum + 1
					If .MoveMode < 4 Or .Trans.MoveLength <> 0 Then
						TrnRefIndexList(TrnRefNum) = Index
						TrnRefNum = TrnRefNum + 1
					End If
					'PSL.OutputWnd(0).Clear	'编辑翻译时
					'PSL.Output MsgList(34)	'编辑翻译时
					'Call getVARefList(TargetFile,FN,.Source,OrgStrTypeList,.TagType,.Moveable,"",0,Mode,1)	'编辑翻译时
				ElseIf .Source.lReferenceNum > 0 Then
					If (.Trans.GetRefState = 0 And .MoveMode < 4) Or .Trans.MoveLength <> 0 Then
						TrnRefIndexList(TrnRefNum) = Index
						TrnRefNum = TrnRefNum + 1
						'PSL.OutputWnd(0).Clear	'编辑翻译时
						'PSL.Output MsgList(34)	'编辑翻译时
						'已移位到扩展区段和新增区段的字串用原地址和引用代码反算引用
						'j = IIf(.MoveType < 4,1,-(.Trans.lStartAddress - .Trans.MoveLength))	'编辑翻译时
						'Call getVARefList(TargetFile,"",.Trans,OrgStrTypeList,.TagType,.Moveable,"",j,0,1)	'编辑翻译时
					End If
				End If
			End If
			If CheckStrVal(DataList(Index),6,0) = False Then ChangeStrAddAndGetRefIndex = True
		Else
			.Trans.lEndAddress = .Trans.lStartAddress + .Trans.lHexLength - 1
			.Trans.lMaxAddress = GetMaxAddress(DataList(Index),False)
			.Trans.lMaxHexLength = .Trans.lMaxAddress - .Trans.lStartAddress + 1 - .EndByteLength - .Trans.iNullByteLength
		End If
		'.Trans.MoveLength 为翻译的完整写入和截断写入后的的长度差额
		'将用于获取采用反算法获取新地址的引用，故保留
		'.Trans.MoveLength = 0	'更改翻译时
	End With
End Function


'重置所有字串数据并重新移位
'Mode = 0 重置不符合移位空间的字串不重新移位，不显示进度
'Mode = 1 仅重置不符合移位空间的字串并重新移位，显示进度
'Mode = 2 重置所有字串并重新移位，显示进度
Private Sub ResetAndMoveStrings(trnFile As FILE_PROPERTIE,DataList() As STRING_PROPERTIE,ByVal Mode As Long, _
			ByVal ResetMsg As String,ByVal MoveMsg As String,ByVal ShowMsg As Long)
	Dim i As Long,n As Long
	n = UBound(DataList)
	For i = 0 To n
		If Mode > 0 Then
			If ShowMsg > 0 Then
				SetTextBoxString ShowMsg,ResetMsg & " " & Format$(i / n,"#%")
			ElseIf ShowMsg < 0 Then
				PSL.OutputWnd(0).Clear
				PSL.Output ResetMsg & " " & Format$(i / n,"#%")
			End If
		End If
		If Mode = 2 Then
			If DataList(i).WriteType < -1 Or DataList(i).WriteType > 0 Then
				ResetStrVal(trnFile,DataList,FreeByteList,i,1)
			End If
		Else
			Select Case DataList(i).MoveType
			Case 1
				If Selected(2) = "0" Then ResetStrVal(trnFile,DataList,FreeByteList,i,1)
			Case 2
				If Selected(3) = "0" Then ResetStrVal(trnFile,DataList,FreeByteList,i,1)
			Case 3
				If Selected(4) = "0" Then ResetStrVal(trnFile,DataList,FreeByteList,i,1)
			Case 4
				If Selected(5) = "0" Then ResetStrVal(trnFile,DataList,FreeByteList,i,1)
			Case 5
				If Selected(6) = "0" Then ResetStrVal(trnFile,DataList,FreeByteList,i,1)
			Case 6
				If Selected(7) = "0" Then ResetStrVal(trnFile,DataList,FreeByteList,i,1)
			End Select
		End If
	Next i
	If Mode = 0 Then Exit Sub
	If Selected(8) = "1" Then
		If ShowMsg > 0 Then
			SetTextBoxString ShowMsg,MoveMsg,True
		ElseIf ShowMsg < 0 Then
			PSL.Output MoveMsg
		End If
		Call ShowMoveMsg(MoveString(trnFile,DataList,0,StrToLong(Selected(1)),ShowMsg),0,2)
	End If
End Sub


'重置选定字串数据并重新移位
Private Sub ResetAndMoveString(trnFile As FILE_PROPERTIE,DataList() As STRING_PROPERTIE,intList() As Long, _
			ByVal OutputWndClear As Boolean,ByVal Mode As Boolean,MsgList() As String,ByVal ShowMsg As Long)
	Dim i As Long,j As Long,Stemp As Boolean,Stemp2 As Boolean
	For i = 0 To UBound(intList)
		j = intList(i)
		With DataList(j)
			'获取字串的写入类型
			.WriteType = WriteType(trnFile,DataList(j),WriteSet)
			'获取字串移位类型(仍将为按照原来的移位模式)
			'.MoveMode = GetMoveMode(trnFile,DataList(j))
			'再超长字串再移位
			If CheckStrVal(DataList(j),5,0) = False Then
				If .ScapeIDForMove <> -1 Or .ScapeIDBeMoved <> -1 Then
					If ResetStrVal(trnFile,DataList,FreeByteList,j,1) = True Then
						Stemp2 = True: Stemp = True
					End If
				End If
				'If .MoveMode <> 4 And .SplitState < 1 Then
				If .MoveMode <> 4 Then
					If .Source.lReferenceNum > 0 Then Stemp = True
				End If
			'不再超长字串复位
			ElseIf CheckStrVal(DataList(j),4,0) = True Then
				If .ScapeIDForMove <> -1 Then
					If .MoveMode <> 3 Then
						If ResetStrVal(trnFile,DataList,FreeByteList,j,1) = True Then
							Stemp2 = True: Stemp = True
						End If
						If .MoveMode = 1 Then
							If .Source.lReferenceNum > 0 Then Stemp = True
						End If
						If Stemp = False And Mode = False Then
							MsgBox MsgList(53),vbOkOnly+vbInformation,MsgList(1)
						End If
					End If
				ElseIf .WriteType > -2 And .WriteType < 1 Then
					ResetStrVal(trnFile,DataList,FreeByteList,j,0)
				ElseIf .MoveMode = 1 Then
					If .Source.lReferenceNum > 0 Then Stemp = True
				End If
			End If
			'获取字串移位类型(重置后引用地址为零时移位模式会更改)
			.MoveMode = MoveMode(trnFile,DataList(j))
		End With
	Next i
	If Stemp = True And Selected(8) = "1" Then
		If ShowMsg > 0 Then
			SetTextBoxString ShowMsg,MsgList(21),OutputWndClear
		ElseIf ShowMsg < 0 Then
			If OutputWndClear = False Then PSL.OutputWnd(0).Clear
			PSL.Output MsgList(21)
		End If
		Call ShowMoveMsg(MoveString(trnFile,DataList,0,StrToLong(Selected(1)),ShowMsg),Stemp2,0)
	End If
End Sub


'重置字串数据并重新移位
'MoveResult 返回值: 0 不需要移位，1 = 全部移位成功，> 1 = 移位失败数，-1 全部失败
'                   第一个项目为有引用字串的移位结果，第二个项目为无引用字串的移位结果
'重置字串数据并重新移位
Private Sub ShowMoveMsg(MoveResult As POINTAPI,ByVal BeMoved As Long,ByVal Mode As Integer)
	If MoveResult.x + MoveResult.y = 0 Then Exit Sub
	Dim MsgList() As String,Temp As String
	If getMsgList(UIDataList,MsgList,"ShowMoveMsg",1) = False Then Exit Sub
	Select Case Mode
	Case 0	'选定重置、修改翻译、导入翻译、填充空格、更改超长写入时
		If BeMoved = False Then
			If MoveResult.x = 1 Then
				Temp = MsgList(1)
			ElseIf MoveResult.x > 1 Then
				Temp = Replace$(MsgList(2),"%s",CStr$(MoveResult.x - 1))
			ElseIf MoveResult.x < 0 Then
				Temp = IIf(Selected(7) = "0",MsgList(7),MsgList(4))
			End If
		Else
			If MoveResult.x = 1 Then
				Temp = MsgList(5)
			ElseIf MoveResult.x > 1 Then
				Temp = Replace$(MsgList(6),"%s",CStr$(MoveResult.x - 1))
			ElseIf MoveResult.x < 0 Then
				Temp = IIf(Selected(7) = "0",MsgList(7),MsgList(4))
			End If
		End If
	Case 1	'管理引用时
		Select Case BeMoved
		Case 1		'父字串(超长字串分配空余地址)
			If MoveResult.x = 1 Then
				Temp = MsgList(8)
			ElseIf MoveResult.x > 1 Then
				Temp = Replace$(MsgList(2),"%s",CStr$(MoveResult.x - 1))
			ElseIf MoveResult.x < 0 Then
				Temp = IIf(Selected(7) = "0",MsgList(9),MsgList(4))
			End If
		Case 2		'父字串(占用其他字串原始地址时的再分配
			If MoveResult.x = 1 Then
				Temp = MsgList(5)
			ElseIf MoveResult.x > 1 Then
				Temp = Replace$(MsgList(6),"%s",CStr$(MoveResult.x - 1))
			ElseIf MoveResult.x < 0 Then
				Temp = IIf(Selected(7) = "0",MsgList(7),MsgList(4))
			End If
		Case 3		'用父字串管理子字串时
			If MoveResult.x = 1 Then
				Temp = MsgList(10)
			ElseIf MoveResult.x > 1 Then
				Temp = Replace$(MsgList(11),"%s",CStr$(MoveResult.x - 1))
			ElseIf MoveResult.x < 0 Then
				Temp = IIf(Selected(7) = "0",MsgList(9),MsgList(4))
			End If
		Case Else	'直接管理子字串时
			If MoveResult.x = 1 Then
				Temp = MsgList(1)
			ElseIf MoveResult.x > 1 Then
				Temp = Replace$(MsgList(2),"%s",CStr$(MoveResult.x - 1))
			ElseIf MoveResult.x < 0 Then
				Temp = IIf(Selected(7) = "0",MsgList(9),MsgList(4))
			End If
		End Select
	Case 2	'全部重置 (包括因移位空间更改) 时
		If MoveResult.x > 1 Then
			Temp = Replace$(MsgList(2),"%s",CStr$(MoveResult.x - 1))
		ElseIf MoveResult.x < 0 Then
			Temp = IIf(Selected(7) = "0",MsgList(3),MsgList(4))
		End If
	Case 3	'取消翻译时
		If MoveResult.x = 1 Then
			Temp = MsgList(5)
		ElseIf MoveResult.x > 1 Then
			Temp = Replace$(MsgList(6),"%s",CStr$(MoveResult.x - 1))
		ElseIf MoveResult.x < 0 Then
			Temp = IIf(Selected(7) = "0",MsgList(7),MsgList(4))
		End If
	Case 4	'初始化时
		If MoveResult.x > 1 Then
			Temp = Replace$(MsgList(12),"%s",CStr$(MoveResult.x - 1))
		ElseIf MoveResult.x < 0 Then
			Temp = IIf(Selected(7) = "0",MsgList(13),MsgList(4))
		End If
	End Select
	Select Case Mode
	Case 0,1,3
		If MoveResult.y = 1 Then
			MsgBox Temp & MsgList(14) & MsgList(17),vbOkOnly+vbInformation,MsgList(0)
		ElseIf MoveResult.y > 1 Then
			MsgBox Temp & Replace$(MsgList(15),"%s",CStr$(MoveResult.y - 1)) & MsgList(17),vbOkOnly+vbInformation,MsgList(0)
		ElseIf MoveResult.y < 0 Then
			MsgBox Temp & MsgList(16) & MsgList(17),vbOkOnly+vbInformation,MsgList(0)
		ElseIf Temp <> "" Then
			MsgBox Temp & MsgList(17),vbOkOnly+vbInformation,MsgList(0)
		End If
	Case Else
		If MoveResult.y > 1 Then
			MsgBox Temp & Replace$(MsgList(15),"%s",CStr$(MoveResult.y - 1)) & MsgList(17),vbOkOnly+vbInformation,MsgList(0)
		ElseIf MoveResult.y < 0 Then
			MsgBox Temp & MsgList(16) & MsgList(17),vbOkOnly+vbInformation,MsgList(0)
		ElseIf Temp <> "" Then
			MsgBox Temp & MsgList(17),vbOkOnly+vbInformation,MsgList(0)
		End If
	End Select
End Sub


'写入翻译字串
Private Function WriteStrings(trnFile As FILE_PROPERTIE,ByVal hwnd As Long,intList() As Long,Optional ByVal fType As Boolean) As Boolean
	Dim i As Long,j As Long,k As Long,m As Long,n As Long,x As Long,y As Long,t As Long,e As Long
	Dim Mode As Long,MaxLength As Long,MaxItem As Long,z As Integer
	Dim Dic As Object,StartTime As Date,MsgList() As String
	Dim FN1 As FILE_IMAGE,FN2 As FILE_IMAGE,File As FILE_PROPERTIE

	If getMsgList(UIDataList,MsgList,"WriteStrings",1) = False Then Exit Function
	'备份文件
	i = InStrRev(LCase$(trnFile.FilePath),".bak")
	If i > 1 Then
		If Mid$(LCase$(trnFile.FilePath),i) = ".bak" Then
			trnFile.FilePath = Left$(trnFile.FilePath,i - 1)
		End If
	End If
	If Dir$(trnFile.FilePath & ".bak") <> "" Then
		MsgBox Replace$(MsgList(41),"%s",trnFile.FilePath),vbOkOnly+vbInformation,MsgList(40)
		GoTo ExitFunction
	End If
	If Dir$(trnFile.FilePath) = "" Then
		MsgBox Replace$(MsgList(42),"%s",trnFile.FilePath),vbOkOnly+vbInformation,MsgList(40)
		GoTo ExitFunction
	End If
	If GetAttr(trnFile.FilePath) <> vbNormal Then SetAttr trnFile.FilePath,vbNormal
	If WriteSet < 1 Then
		FileCopy trnFile.FilePath,trnFile.FilePath & ".bak"
	Else
		Name trnFile.FilePath As trnFile.FilePath & ".bak"
		'创建一个空的目标文件
		If LoadFile(trnFile.FilePath,FN2,0,1,0,-1) < -1 Then GoTo ExitFunction
		Put #FN2.hFile,,FN2.ImageByte
		UnLoadFile(FN2,0,-1)
	End If
	'设置备份文件的创建日期为当前日期，以免 Passolo 重新生成目标文件后启动宏时被删除
	SetFileCreatedDate(trnFile.FilePath & ".bak",Now)
	'打开文件
	Mode = LoadFile(trnFile.FilePath,FN2,0,1,0,StrToLong(Selected(1)))
	If Mode < -1 Then GoTo ExitFunction
	Mode = LoadFile(trnFile.FilePath & ".bak",FN1,0,0,0,Mode)
	If Mode < -1 Then
		UnLoadFile(FN2,0,Mode)
		GoTo ExitFunction
	End If

	Set WriteLogDic = CreateObject("Scripting.Dictionary")
	Set Dic = CreateObject("Scripting.Dictionary")
	x = StrToLong(Selected(15))
	z = StrToLong(Selected(16))
	y = IIf(fType = False,UBound(AllStrDataList),UBound(intList))
	ReDim WriteLog(y + 6) As String,TempList(1) As String,intArry(11) As Long
	ReDim FreeByte(trnFile.MaxSecIndex) As FREE_BTYE_SPACE
	ReDim FreeByte(0).IndexList(y) 'As Long
	Dim NetFreeByte As FREE_BTYE_SPACE
	ReDim NetFreeByte.IndexList(y) 'As Long
	WriteLog(0) = Replace$(MsgList(0),"%s",trnFile.FilePath)
	WriteLog(1) = MsgList(1)
	AddListBoxItems(hwnd,WriteLog(0),-1)
	AddListBoxItems(hwnd,WriteLog(1),-1)
	'开始写入
	StartTime = Timer: k = -1: m = -1: t = -1: e = -1
	For j = 0 To y
		TempList(0) = ""
		If fType = False Then i = j Else i = intList(j)
		With AllStrDataList(i)
			.WriteState = 0
			If .Missing > 0 Then
				TempList(0) = MsgList(6)
				intArry(1) = intArry(1) + 1
				GoTo NextPos
			'跳过被锁定字串
			ElseIf .LockState > 0 Then
				TempList(0) = MsgList(3)
				intArry(0) = intArry(0) + 1
				GoTo NextPos
			'跳过原始字串不存在的字串
			ElseIf ByteToString(GetBytes(FN1,.Source.lHexLength,.Source.lStartAddress,Mode),.Source.CodePage) <> Convert(.Source.sString) Then
				TempList(0) = MsgList(6)
				intArry(1) = intArry(1) + 1
				GoTo NextPos
			'跳过 .NET 字串，并分别计算其原始字串 intArry(9) 和翻译字串 NetFreeByte.Length 需要的总长度，不能用地址，因为会变
			'以便比较是否超过其所在区域的大小
			ElseIf .Moveable = 2 Then
				'跳过未翻译的字串(包括子字串，不包括父字串)
				If .WriteType = 0 And .SplitState < 1 Then
					TempList(0) = MsgList(2)
					intArry(0) = intArry(0) + 1
					GoTo NextPos
				'跳过全部拆分后的父字串
				ElseIf .SplitState > 0 And .Trans.lReferenceNum = .Source.lReferenceNum Then
					TempList(0) = MsgList(4)
					intArry(0) = intArry(0) + 1
					GoTo NextPos
				End If
				'记录已翻译字串数目
				e = e + 1
				'记录原始字串字节长度
				If .SplitState > -1 Then
					intArry(9) = intArry(9) + .Source.lMaxHexLength + .Source.StrTypeLength
				End If
				'记录翻译字串字节长度及所在节和索引号
				NetFreeByte.inSectionID = .Source.inSectionID
				NetFreeByte.IndexList(e) = i
				NetFreeByte.Length = NetFreeByte.Length + .Trans.lHexLength + .Trans.StrTypeLength
				'记录是否有拆分
				If .SplitState <> 0 Then intArry(11) = intArry(11) + 1
				'记录是否有超长
				If CheckStrVal(AllStrDataList(i),4) = False Then intArry(10) = intArry(10) + 1
				GoTo NextNo
			'跳过未翻译的字串
			ElseIf .WriteType = 0 Then
				TempList(0) = MsgList(2)
				intArry(0) = intArry(0) + 1
				GoTo NextPos
			'跳过未移位的子字串
			ElseIf .SplitState < 0 And .WriteType < 3 Then
				TempList(0) = MsgList(5)
				intArry(0) = intArry(0) + 1
				GoTo NextPos
			'检查原长写入、原址完整写入、原址截断写入的字串是否已写入
			ElseIf WriteSet < 1 And .MoveType < 4 Then
				TempList(1) = ReConvert(ByteToString(GetBytes(FN2,.Trans.lHexLength,.Trans.lStartAddress,Mode),.Trans.CodePage))
				If TempList(1) = .Trans.sString And TempList(1) <> Left$(.Source.sString,Len(TempList(1))) Then
					TempList(0) = MsgList(7)
					intArry(2) = intArry(2) + 1
					GoTo NextPos
				End If
			End If

			'修改移位到扩展区段字串的引用代码，翻译字串扩展后写入
			If .MoveType = 4 Then
				intArry(8) = WritePEString(trnFile,FN1,FN2,AllStrDataList,i,TempList(1),2,Mode)
			'修改移位到有隐藏区段文件的最大区段字串的引用代码，翻译字串扩展后写入
			'必须使用虚拟大小，因为其大小为最大节后的所有字节(包括子 PE)
			ElseIf .MoveType > 4 And trnFile.SecList(trnFile.MaxSecIndex).lVirtualSize > 0 Then
				intArry(8) = WritePEString(trnFile,FN1,FN2,AllStrDataList,i,TempList(1),2,Mode)
			'写入翻译字串和引用代码
			Else
				TempList(1) = .Trans.sString
				If WriteSet < 1 Then
					intArry(8) = WritePEString(trnFile,FN1,FN2,AllStrDataList,i,TempList(1),WriteSet,Mode)
				Else
					intArry(8) = WriteNotPEString(trnFile,FN1,FN2,AllStrDataList,i,m,WriteSet,Mode)
				End If
			End If
			'根据写入结果显示写入信息
			Select Case intArry(8)
			Case Is > 0		'写入成功
				'计算移位到每个扩展区段需要的总长度(先修改引用代码，后扩展区段并写入字串)
				If .MoveType = 4 Then
					If Not Dic.Exists(.Source.inSectionID) Then
						k = k + 1: t = 0
						Dic.Add(.Source.inSectionID,k)
						Dic.Add(-(.Source.inSectionID + 1),t)
						FreeByte(k).inSectionID = .Source.inSectionID
						FreeByte(k).Address = trnFile.SecList(.Source.inSectionID).lPointerToRawData
						ReDim FreeByte(k).IndexList(y) 'As Long
						FreeByte(k).IndexList(t) = i
						If .Trans.lMaxAddress > FreeByte(k).Length Then FreeByte(k).Length = .Trans.lMaxAddress
					Else
						Dic.Item(-(.Source.inSectionID + 1)) = Dic.Item(-(.Source.inSectionID + 1)) + 1
						t = Dic.Item(.Source.inSectionID)
						FreeByte(t).IndexList(Dic.Item(-(.Source.inSectionID + 1))) = i
						If .Trans.lMaxAddress > FreeByte(t).Length Then FreeByte(t).Length = .Trans.lMaxAddress
					End If
					GoTo NextNo
				'计算移位到有隐藏区段文件的新增区段需要的总长度(先修改引用代码，后增加区段并写入字串)
				'必须使用虚拟大小，因为其大小为最大节后的所有字节(包括子 PE)
				ElseIf .MoveType > 4 And trnFile.SecList(trnFile.MaxSecIndex).lVirtualSize > 0 Then
					k = k + 1
					FreeByte(0).IndexList(k) = i
					If .Trans.lMaxAddress > FreeByte(0).Length Then FreeByte(0).Length = .Trans.lMaxAddress
					GoTo NextNo
				ElseIf trnFile.Magic = "" Then
					Select Case .WriteType
					Case 1
						TempList(0) = Replace$(Replace$(MsgList(8),"%d",ValToStr(.Trans.lStartAddress,trnFile.FileSize,z)),"%s",TempList(1))
					Case 2
						TempList(0) = Replace$(Replace$(MsgList(9),"%d",ValToStr(.Trans.lStartAddress,trnFile.FileSize,z)),"%s",TempList(1))
					Case 3
						TempList(0) = Replace$(Replace$(MsgList(10),"%d",ValToStr(.Trans.lStartAddress,trnFile.FileSize,z)),"%s",TempList(1))
					Case 4
						TempList(0) = Replace$(Replace$(MsgList(11),"%d",ValToStr(.Trans.lStartAddress,trnFile.FileSize,z)),"%s",TempList(1))
					End Select
					If .WriteType <> 4 Then
						intArry(3) = intArry(3) + 1
						.WriteState = 1
					Else
						intArry(4) = intArry(4) + 1
						.WriteState = 2
					End If
				Else
					Select Case .WriteType
					Case 1
						TempList(0) = Replace$(Replace$(MsgList(12),"%d",ValToStr(.Trans.lStartAddress,trnFile.FileSize,z)),"%s",TempList(1))
					Case 2
						TempList(0) = Replace$(Replace$(MsgList(11),"%d",ValToStr(.Trans.lStartAddress,trnFile.FileSize,z)),"%s",TempList(1))
					Case 3
						TempList(0) = Replace$(Replace$(MsgList(13),"%d",ValToStr(.Trans.lStartAddress,trnFile.FileSize,z)),"%s",TempList(1))
					Case 4
						TempList(0) = Replace$(Replace$(MsgList(14),"%d",ValToStr(.Trans.lStartAddress,trnFile.FileSize,z)),"%s",TempList(1))
					Case 5
						TempList(0) = Replace$(Replace$(MsgList(43),"%d",ValToStr(.Trans.lStartAddress,trnFile.FileSize,z)),"%s",TempList(1))
					End Select
					If .WriteType <> 2 Then
						intArry(3) = intArry(3) + 1
						.WriteState = 1
					Else
						intArry(4) = intArry(4) + 1
						.WriteState = 2
					End If
					'计算移位到无隐藏区段文件的新增区段需要的总长度(先写入字串和引用代码，后增加区段)
					If .MoveType > 4 Then
						If .Trans.lMaxAddress > FreeByte(0).Length Then
							FreeByte(0).Length = .Trans.lMaxAddress
						End If
					End If
				End If
			Case 0 To -1	'写入失败，写入中出现系统错误
				TempList(0) = Replace$(MsgList(15),"%s",Err.Description)
				Err.Clear
				intArry(5) = intArry(5) + 1
				.WriteState = 3
			Case -2			'写入失败，引用代码未被修改或未被全部修改
				TempList(0) = MsgList(16)
				intArry(6) = intArry(6) + 1
				.WriteState = 4
			Case -3			'写入失败，字串标识符未被修改或未被全部修改
				TempList(0) = MsgList(17)
				intArry(7) = intArry(7) + 1
				.WriteState = 5
			End Select
			NextPos:
			'显示写入消息 (MoveNETString = 1 时 .NET 字串除外)
			If Abs(.WriteType) + .Missing - x > -1 Then
				WriteLog(n + 2) = Replace$(Replace$(Replace$(MsgList(18),"%n",CStr(.ID)), _
								"%d",ValToStr(.Source.lStartAddress,trnFile.FileSize,z)),"%s",TempList(0))
				If Len(WriteLog(n + 2)) > MaxLength Then
					MaxLength = Len(WriteLog(n + 2)): MaxItem = n + 2
				End If
				AddListBoxItems(hwnd,WriteLog(n + 2),-1)
				SetListBoxItems(hwnd,n + 2)
				WriteLogDic.Add(n,.ID)
				If Not WriteLogDic.Exists(CStr(.ID)) Then WriteLogDic.Add(CStr(.ID),n)
				n = n + 1
			End If
			NextNo:
		End With
	Next j
	If trnFile.Magic = "" Then
		'写入最后一段未提取字串的字节
		If WriteSet > 0 Then
			If m < 0 Then WriteNotPEString(trnFile,FN1,FN2,AllStrDataList,i,m,WriteSet,Mode,0)
			i = -2
			WriteNotPEString(trnFile,FN1,FN2,AllStrDataList,m,i,WriteSet,Mode,0)
			If i > 0 Then FN2.SizeOfFile = i
		End If
	End If
	If UnLoadFile(FN1,0,Mode) = False Or UnLoadFile(FN2,FN2.SizeOfFile,Mode) = False Then
		Set Dic = Nothing
		GoTo ExitFunction
	End If
	'写入字串到扩展节尾空间
	If k > -1 And FreeByte(0).Length > 0 Then
		If t > -1 Then
			ReDim Preserve FreeByte(k) As FREE_BTYE_SPACE
			For i = 0 To k
				FreeByte(i).Length = FreeByte(i).Length - _
									trnFile.SecList(FreeByte(i).inSectionID).lPointerToRawData - _
									trnFile.SecList(FreeByte(i).inSectionID).lSizeOfRawData + 1
				ReDim Preserve FreeByte(i).IndexList(Dic.Item(-(FreeByte(i).inSectionID + 1))) 'As Long
			Next i
			'从小到大对偏移地址进行排序，以避免因原节表乱序而扩展错误
			Call SortFreeByteByAddress(FreeByte,0,k,False)
		Else
			ReDim Preserve FreeByte(0) As FREE_BTYE_SPACE
			ReDim Preserve FreeByte(0).IndexList(k) 'As Long
			FreeByte(0).Length = FreeByte(0).Length - _
								trnFile.SecList(trnFile.MaxSecID).lPointerToRawData - _
								trnFile.SecList(trnFile.MaxSecID).lSizeOfRawData + 1
			If Selected(6) = "1" Then
				FreeByte(0).inSectionID = trnFile.MaxSecID
			End If
		End If
		'分段写入字串到扩展节尾空间，因为每段都是按照其他段不移位的情况下计算移位字串的地址的
		For j = UBound(FreeByte) To 0 Step -1
			m = 0
			ReDim tmpFreeByte(0) As FREE_BTYE_SPACE
			tmpFreeByte(0) = FreeByte(j)
			If t > -1 Or Selected(6) = "1" Or InStr(trnFile.Magic,"NotPE") Then
				m = AddSectionSize(trnFile,tmpFreeByte,1,Mode)
			ElseIf Selected(7) = "1" Then
				m = AddSection(trnFile,tmpFreeByte(0),1,Mode)
			End If
			If m >= FreeByte(j).Length Then
				'打开文件
				Mode = LoadFile(trnFile.FilePath,FN2,0,1,0,StrToLong(Selected(1)))
				If Mode < -1 Then GoTo ExitFunction
				Mode = LoadFile(trnFile.FilePath & ".bak",FN1,0,0,0,Mode)
				If Mode < -1 Then
					UnLoadFile(FN2,0,Mode)
					GoTo ExitFunction
				End If
				'开始写入字串到扩展节尾空间
				For i = 0 To UBound(FreeByte(j).IndexList)
					With AllStrDataList(FreeByte(j).IndexList(i))
						TempList(1) = .Trans.sString
						Select Case WritePEString(trnFile,FN1,FN2,AllStrDataList,FreeByte(j).IndexList(i),TempList(1),1,Mode,0)
						Case Is > 0		'写入成功
							If .WriteType <> 4 Then
								TempList(0) = Replace$(Replace$(MsgList(13),"%d",ValToStr(.Trans.lStartAddress,trnFile.FileSize,z)),"%s",TempList(1))
							Else
								TempList(0) = Replace$(Replace$(MsgList(14),"%d",ValToStr(.Trans.lStartAddress,trnFile.FileSize,z)),"%s",TempList(1))
							End If
							intArry(3) = intArry(3) + 1
							.WriteState = 1
						Case 0 To -1	'写入失败，写入中出现系统错误
							TempList(0) = Replace$(MsgList(15),"%s",Err.Description)
							Err.Clear
							intArry(5) = intArry(5) + 1
							.WriteState = 3
						Case -2			'写入失败，引用代码未被修改或未被全部修改
							TempList(0) = MsgList(16)
							intArry(6) = intArry(6) + 1
							.WriteState = 4
						Case -3			'写入失败，字串标识符未被修改或未被全部修改
							TempList(0) = MsgList(17)
							intArry(7) = intArry(7) + 1
							.WriteState = 5
						End Select
						If .WriteType - x > -1 Then
							WriteLog(n + 2) = Replace$(Replace$(Replace$(MsgList(18),"%n",CStr(.ID)), _
											"%d",ValToStr(.Source.lStartAddress,trnFile.FileSize,z)),"%s",TempList(0))
							If Len(WriteLog(n + 2)) > MaxLength Then
								MaxLength = Len(WriteLog(n + 2)): MaxItem = n + 2
							End If
							AddListBoxItems(hwnd,WriteLog(n + 2),-1)
							SetListBoxItems(hwnd,n + 2)
							WriteLogDic.Add(n,.ID)
							If Not WriteLogDic.Exists(CStr(.ID)) Then WriteLogDic.Add(CStr(.ID),n)
							n = n + 1
						End If
					End With
				Next i
				If UnLoadFile(FN1,0,Mode) = False Or UnLoadFile(FN2,IIf(Mode = 0,FN2.SizeOfFile,0),Mode) = False Then
					GoTo ExitFunction
				End If
			Else
				If t > -1 Or Selected(6) = "1" Then
					TempList(0) = IIf(m = 0,MsgList(19),IIf(m < 0,MsgList(20),MsgList(21)))
				ElseIf Selected(7) = "1" Then
					TempList(0) = IIf(m = 0,MsgList(22),IIf(m < 0,MsgList(23),MsgList(24)))
				End If
				For i = 0 To UBound(FreeByte(j).IndexList)
					With AllStrDataList(FreeByte(j).IndexList(i))
						intArry(5) = intArry(5) + 1
						.WriteState = 3
						If .WriteType - x > -1 Then
							WriteLog(n + 2) = Replace$(Replace$(Replace$(MsgList(18),"%n",CStr(.ID)), _
											"%d",ValToStr(.Source.lStartAddress,trnFile.FileSize,z)),"%s",TempList(0))
							If Len(WriteLog(n + 2)) > MaxLength Then
								MaxLength = Len(WriteLog(n + 2)): MaxItem = n + 2
							End If
							AddListBoxItems(hwnd,WriteLog(n + 2),-1)
							SetListBoxItems(hwnd,n + 2)
							WriteLogDic.Add(n,.ID)
							If Not WriteLogDic.Exists(CStr(.ID)) Then WriteLogDic.Add(CStr(.ID),n)
							n = n + 1
						End If
					End With
				Next i
			End If
		Next j
	End If
	Set Dic = Nothing
	'增加文件节或最后节大小
	If k = -1 And FreeByte(0).Length > 0 Then
		'必须使用虚拟大小，因为其大小为最大节后的所有字节(包括子 PE)
		If trnFile.SecList(trnFile.MaxSecIndex).lVirtualSize < 1 Then
			m = 0
			ReDim Preserve FreeByte(0) As FREE_BTYE_SPACE
			ReDim Preserve FreeByte(0).IndexList(0) 'As Long
			FreeByte(0).Length = FreeByte(0).Length - _
								trnFile.SecList(trnFile.MaxSecID).lPointerToRawData - _
								trnFile.SecList(trnFile.MaxSecID).lSizeOfRawData + 1
			If Selected(6) = "1" Or InStr(trnFile.Magic,"NotPE") Then		'扩展最后节大小
				FreeByte(0).inSectionID = trnFile.MaxSecID
				m = AddSectionSize(trnFile,FreeByte,1,Mode)
			ElseIf Selected(7) = "1" Then	'新增文件节
				m = AddSection(trnFile,FreeByte(0),1,Mode)
			End If
			If m = 0 Then
				If Selected(6) = "1" Then
					MsgBox MsgList(26),vbOkOnly+vbInformation,MsgList(25)
				ElseIf Selected(7) = "1" Then
					MsgBox MsgList(27),vbOkOnly+vbInformation,MsgList(25)
				End If
				GoTo ExitFunction
			ElseIf m < 0 Then
				Err.Source = "NotWriteFile"
				Err.Description = Err.Description & JoinStr & trnFile.FilePath
				Call sysErrorMassage(Err,2)
				GoTo ExitFunction
			End If
		End If
	End If
	'写入 .NET 字符串
	If e > -1 And NetFreeByte.Length > 0 Then
		ReDim Preserve NetFreeByte.IndexList(e) 'As Long
		'检查原始 .NET 字串流的 RVA 地址是否有改变
		File = trnFile
		If GetPEHeaders(File.FilePath,File,StrToLong(Selected(1))) = True Then
			If File.LangType = NET_FILE_SIGNATURE And File.USStreamID > -1 Then
				'无超长，无拆分时，按原址写入
				If intArry(10) + intArry(11) = 0 Then
					j = 0
				'有拆分或有超长且不超总长度时按非 PE 写入，否则按 PE 写入(可能被截断)
				Else
					j = NetFreeByte.Length - intArry(9)
					j = IIf(j > 0,0,-1)
				End If
				intArry(10) = -1
				'在扩展区段或新增区段中移位写入
				If j > 0 Then
					m = 0: t = 0
					'扩展区段
					If Selected(5) = "1" Or Selected(6) = "1" Then
						ReDim FreeByte(0) As FREE_BTYE_SPACE
						FreeByte(0) = NetFreeByte
						If Selected(6) = "1" Then FreeByte(0).inSectionID = File.MaxSecID
						If FreeByte(0).inSectionID = File.MaxSecID Then
							m = AddSectionSize(File,FreeByte,1,Mode)
						Else
							'获取可扩展空间的字节大小
							FreeByte(0).Length = 0
							m = AddSectionSize(File,FreeByte,0,Mode)
							If m >= NetFreeByte.Length Then
								File = trnFile
								FreeByte(0) = NetFreeByte
								m = AddSectionSize(File,FreeByte,1,Mode)
							End If
						End If
						t = 1
					'新增区段
					ElseIf Selected(7) = "1" Then
						ReDim FreeByte(0) As FREE_BTYE_SPACE
						FreeByte(0) = NetFreeByte
						FreeByte(0).inSectionID = File.MaxSecID
						If File.SecList(File.MaxSecIndex - 1).sName = NewPESecName Then
							m = AddSectionSize(File,FreeByte,1,Mode)
							t = 1
						Else
							m = AddSection(File,FreeByte(0),2,Mode)
							t = 2
						End If
					End If
					'扩展或增加区段成功时，复制整个 .NET 字串流到到扩展空间
					If m >= NetFreeByte.Length Then
						If t = 1 Then
							FreeByte(0).Address = File.SecList(FreeByte(0).inSectionID).lPointerToRawData + _
												  File.SecList(FreeByte(0).inSectionID).lSizeOfRawData + 16
						Else
							FreeByte(0).Address = File.SecList(File.MaxSecID).lPointerToRawData + 16
						End If
						'重新读取文件头，因为有可能增加了文件头长度
						GetPEHeaders(File.FilePath,File,StrToLong(Selected(1)))
						'打开文件
						Mode = LoadFile(File.FilePath,FN2,0,1,0,StrToLong(Selected(1)))
						If Mode < -1 Then
							UnLoadFile(FN2,0,Mode)
							GoTo ExitFunction
						End If
						With File.StreamList(File.USStreamID)
							'复制整个 #US 流到扩展位置
							PutBytes(FN2,FreeByte(0).Address,GetBytes(FN2,.lSizeOfRawData,.lPointerToRawData,Mode),.lSizeOfRawData,Mode)
							'清空原位置的整个 #US 流
							ReDim Bytes(.lSizeOfRawData - 1) As Byte
							PutBytes(FN2,.lPointerToRawData,Bytes,.lSizeOfRawData,Mode)
							'修改 #US 字串流的地址
							Bytes = Val2Bytes(FreeByte(0).Address - File.CLRList(0).lPointerToRawData ,4)
							PutBytes(FN2,.RWA,Bytes,4,Mode)
						End With
						If UnLoadFile(FN2,IIf(Mode = 0,FN2.SizeOfFile,0),Mode) = False Then GoTo ExitFunction
						'计算写入非 .NET 字串时扩展后的地址差额
						k = FreeByte(0).Address - trnFile.StreamList(trnFile.USStreamID).lPointerToRawData
					'扩展或增加区段失败时，原长写入不移位
					Else
						If t = 1 Then
							MsgBox IIf(m = 0,MsgList(28),IIf(m < 0,MsgList(29),MsgList(30))),vbOkOnly+vbInformation,MsgList(25)
						ElseIf t = 2 Then
							MsgBox IIf(m = 0,MsgList(31),IIf(m < 0,MsgList(32),MsgList(33))),vbOkOnly+vbInformation,MsgList(25)
						End If
						j = 0
					End If
				End If
				'计算 .NET 字串流的偏移位置改变值(可能因标准字串扩展而移位)
				If j < 1 Then
					k = File.StreamList(File.USStreamID).lPointerToRawData - trnFile.StreamList(trnFile.USStreamID).lPointerToRawData
				End If
				'删除备份文件
				If Dir$(File.FilePath & ".back") <> "" Then Kill File.FilePath & ".back"
				If j > -1 Then
					WriteSet = 0
					'备份目标文件
					FileCopy File.FilePath,File.FilePath & ".back"
				Else
					WriteSet = 3
					'备份目标文件
					Name File.FilePath As File.FilePath & ".back"
					'创建一个空的目标文件
					If LoadFile(File.FilePath,FN2,0,1,0,-1) < -1 Then GoTo ExitFunction
					Put #FN2.hFile,,FN2.ImageByte
					UnLoadFile(FN2,0,-1)
					'设置备份文件的创建日期为当前日期，以免 Passolo 重新生成目标文件后启动宏时被删除
					SetFileCreatedDate(trnFile.FilePath & ".bak",Now)
				End If
				'打开文件
				Mode = LoadFile(File.FilePath,FN2,0,1,0,StrToLong(Selected(1)))
				If Mode < -1 Then GoTo ExitFunction
				Mode = LoadFile(File.FilePath & ".back",FN1,0,0,0,Mode)
				If Mode < -1 Then
					UnLoadFile(FN2,0,Mode)
					GoTo ExitFunction
				End If
				'开始写入字串到原来的空间
				m = -1
				For i = 0 To e
					t = NetFreeByte.IndexList(i)
					With AllStrDataList(t)
						TempList(1) = .Trans.sString
						If j > -1 Then
							'跳过子字串
							If .SplitState < 0 Then
								TempList(0) = MsgList(5)
								intArry(0) = intArry(0) + 1
								GoTo EndPos
							End If
							'按 PE 方式写入(不移位)
							intArry(8) = WritePEString(File,FN1,FN2,AllStrDataList,t,TempList(1),1,Mode,k)
						Else
							'按非 PE 方式写入(移位)
							intArry(8) = WriteNotPEString(File,FN1,FN2,AllStrDataList,t,m,WriteSet,Mode,k)
							If intArry(10) = -1 Then
								If .SplitState <> 0 Then
									intArry(10) = t
								ElseIf .Trans.lHexLength <> .Source.lHexLength Then
									intArry(10) = t
								End If
							End If
						End If
						Select Case intArry(8)
						Case Is > 0		'写入成功
							Select Case .WriteType
							Case 0,1
								TempList(0) = Replace$(Replace$(MsgList(12),"%d",ValToStr(.Trans.lStartAddress,trnFile.FileSize,z)),"%s",TempList(1))
							Case 2
								TempList(0) = Replace$(Replace$(MsgList(11),"%d",ValToStr(.Trans.lStartAddress,trnFile.FileSize,z)),"%s",TempList(1))
							Case 3
								TempList(0) = Replace$(Replace$(MsgList(13),"%d",ValToStr(.Trans.lStartAddress,trnFile.FileSize,z)),"%s",TempList(1))
							Case 4
								TempList(0) = Replace$(Replace$(MsgList(14),"%d",ValToStr(.Trans.lStartAddress,trnFile.FileSize,z)),"%s",TempList(1))
							Case 5
								TempList(0) = Replace$(Replace$(MsgList(43),"%d",ValToStr(.Trans.lStartAddress,trnFile.FileSize,z)),"%s",TempList(1))
							End Select
							If .WriteType <> 2 Then
								intArry(3) = intArry(3) + 1
								.WriteState = 1
							Else
								intArry(4) = intArry(4) + 1
								.WriteState = 2
							End If
						Case 0 To -1	'写入失败，写入中出现系统错误
							TempList(0) = Replace$(MsgList(15),"%s",Err.Description)
							Err.Clear
							intArry(5) = intArry(5) + 1
							.WriteState = 3
						Case -2			'写入失败，引用代码未被修改或未被全部修改
							TempList(0) = MsgList(16)
							intArry(6) = intArry(6) + 1
							.WriteState = 4
						Case -3			'写入失败，字串标识符未被修改或未被全部修改
							TempList(0) = MsgList(17)
							intArry(7) = intArry(7) + 1
							.WriteState = 5
						End Select
						EndPos:
						If .WriteType - x > -1 Then
							WriteLog(n + 2) = Replace$(Replace$(Replace$(MsgList(18),"%n",CStr(.ID)), _
											"%d",ValToStr(.Source.lStartAddress,trnFile.FileSize,z)),"%s",TempList(0))
							If Len(WriteLog(n + 2)) > MaxLength Then
								MaxLength = Len(WriteLog(n + 2)): MaxItem = n + 2
							End If
							AddListBoxItems(hwnd,WriteLog(n + 2),-1)
							SetListBoxItems(hwnd,n + 2)
							WriteLogDic.Add(n,.ID)
							If Not WriteLogDic.Exists(CStr(.ID)) Then WriteLogDic.Add(CStr(.ID),n)
							n = n + 1
						End If
					End With
				Next i
				If j < 0 Then
					'写入最后一段未提取字串的字节
					i = -2 - IIf(j > 0,j,0)	'短于原始字串流长度的保留长度不变，否则增加
					'只在已翻译的首尾字串区间中移位
					t = NetFreeByte.IndexList(e)
					t = AllStrDataList(t).Source.lMaxAddress
					'在整个 #US 块中移位，不论翻译与否
					't = trnFile.StreamList(File.USStreamID).lPointerToRawData + trnFile.StreamList(File.USStreamID).lSizeOfRawData - 1
					WriteNotPEString(File,FN1,FN2,AllStrDataList,m,i,t,Mode,k)
					If i > 0 Then FN2.SizeOfFile = i
					'修改 #US 字串流的大小
					'If j > 0 Then
					'	PutBytes(FN2,File.StreamList(File.USStreamID).RWA + 4,Val2Bytes(NetFreeByte.Length,4),4,Mode)
					'End If
					If UnLoadFile(FN1,0,Mode) = False Or UnLoadFile(FN2,FN2.SizeOfFile,Mode) = False Then GoTo ExitFunction
					'打开文件
					Mode = LoadFile(File.FilePath,FN2,0,1,0,StrToLong(Selected(1)))
					If Mode < -1 Then GoTo ExitFunction
					Mode = LoadFile(trnFile.FilePath & ".bak",FN1,0,0,0,Mode)
					If Mode < -1 Then
						UnLoadFile(FN2,0,Mode)
						GoTo ExitFunction
					End If
					'修改引用代码
					If intArry(10) > -1 Then
						Dim Msg As PROGRESS_MSG
						Msg.hwnd = hwnd
						Msg.Massage = MsgList(45)
						Msg.Passed = n + 2
						Msg.Total = 1
						i = NetFreeByte.IndexList(e)
						With AllStrDataList(intArry(10))
							If WriteNETRefCode(trnFile,File,FN1,FN2,.Source.lStartAddress + .StrType, _
								AllStrDataList(i).Source.lStartAddress,.Trans.lStartAddress + .StrType, _
								AllStrDataList(i).Trans.lStartAddress,k,Mode,Msg) < 1 Then
								MsgBox MsgList(44),vbOkOnly+vbInformation,MsgList(25)
								If UnLoadFile(FN1,0,Mode) = False Or UnLoadFile(FN2,FN2.SizeOfFile,Mode) = False Then GoTo ExitFunction
								GoTo ExitFunction
							End If
						End With
					End If
				End If
				If UnLoadFile(FN1,0,Mode) = False Or UnLoadFile(FN2,FN2.SizeOfFile,Mode) = False Then GoTo ExitFunction
				If Dir$(File.FilePath & ".back") <> "" Then Kill File.FilePath & ".back"
			Else
				MsgBox MsgList(34),vbOkOnly+vbInformation,MsgList(25)
			End If
		Else
			MsgBox MsgList(35),vbOkOnly+vbInformation,MsgList(25)
		End If
	End If
	'显示写入总消息
	WriteLog(n + 2) = MsgList(1)
	WriteLog(n + 3) = Replace$(Replace$(Replace$(Replace$(Replace$(MsgList(36),"%s",CStr(y + 1)), _
					  "%d1!",CStr(intArry(3))),"%d2!",CStr(intArry(4))), _
					  "%d3!",CStr(intArry(0) + intArry(1) + intArry(2))), _
					  "%d4!",CStr(intArry(5) + intArry(6) + intArry(7)))
	WriteLog(n + 4) = MsgList(37) & Format(DateAdd("s",Timer - StartTime,0),MsgList(38))
	ReDim Preserve WriteLog(n + 4) As String
	'设置水平滚动条的长度以查看最长列表项的全部字符串
	i = GetStrPixels(hwnd,WriteLog(MaxItem))
	If i > SendMessageLNG(hwnd, LB_GETHORIZONTALEXTENT, 0&, 0&) Then
		SendMessageLNG(hwnd, LB_SETHORIZONTALEXTENT, i, 0&)
	End If
	AddListBoxItems(hwnd,WriteLog(n + 2),-1)
	AddListBoxItems(hwnd,WriteLog(n + 3),-1)
	AddListBoxItems(hwnd,WriteLog(n + 4),-1)
	SetListBoxItems(hwnd,n + 4,n + 4)
	'写入消息到记录文件
	If fType = False Then
		If Selected(13) = "1" Then
			TempList(0) = trnFile.FilePath & ".log"
			If WriteBinaryFile(TempList(0),CP_UNICODELITTLE,StrListJoin(WriteLog,vbCrLf)) = True Then
				If Selected(14) = "1" Then
					ReDim FileDataList(0) As String
					FileDataList(0) = TempList(0) & JoinStr & "unicodeFFFE"
					OpenFile(TempList(0),FileDataList,1,False)
				End If
			End If
		End If
	End If
	If StrToLong(Selected(29)) = 1 Then Beep
	WriteStrings = True
	ExitFunction:
	Set Dic = Nothing
	If e > -1 Then
		If Dir$(File.FilePath & ".back") <> "" Then Kill File.FilePath & ".back"
	End If
	If Dir$(trnFile.FilePath & ".bak") <> "" Then trnFile.FilePath = trnFile.FilePath & ".bak"
End Function


'不拆分字串时按常规字串计算移位或复位
'获取子字串的原始引用地址和引用代码
'返回索引 SubString =-1 未排序不需要刷新，>-1 已排序需要刷新
Private Function SubString(orgFile As FILE_PROPERTIE,trnFile As FILE_PROPERTIE,strData As STRING_PROPERTIE,ByVal strID As Long, _
		RefAddList() As String,ByVal AllShow As Boolean) As Long
	SubString = -1
	'父字串直接退出
	If AllStrDataList(strID).SplitState >= 0 Then Exit Function
	Dim i As Long,j As Long,m As Long,n As Long,x As Long
	Dim Temp As String,TempList() As String,TmpList() As String
	'获取子字串引用地址的引用代码，此时子字串的地址可能为原始地址也可能是移位地址
	With AllStrDataList(strID)
		'获取父子串的索引号
		i = StrIDIndexDic.Item(-.SplitState)
		'增减子字串的原始引用地址和引用代码
		.Source.Reference = AllStrDataList(i).Source.Reference
		.Source.lReferenceNum = AllStrDataList(i).Source.lReferenceNum
		Call GetRefList(.Source,RefAddList,TempList,True)
		'同步跟随引用地址的自定义字串类型
		.Trans.Reference = .Source.Reference
		.Trans.lReferenceNum = .Source.lReferenceNum
		'获取子字串引用地址的引用代码(获取类型必须为 2)
		Call GetVARefList(trnFile,"",.Trans,OrgStrTypeList,.TagType,.Moveable,StrListJoin(RefAddList,RefJoinStr),2,0,0)
		'获取子字串的写入类型
		.WriteType = WriteType(trnFile,AllStrDataList(strID),WriteSet)
		'获取子字串的移位模式
		.MoveMode = MoveMode(trnFile,AllStrDataList(strID))
	End With
	'更新父字串的引用地址和代码，此时父字串的地址为原始地址
	With AllStrDataList(i)
		Temp = StrListJoin(RefList2StrList(.Trans,0),RefJoinStr)
		TmpList = RefList2StrList(strData.Trans,0)
		'增加父子串引用地址
		TempList = ChangeList(RefAddList,TmpList)
		If CheckArray(TempList) = True Then
			TempList = ReSplit(Temp & RefJoinStr & StrListJoin(TempList,RefJoinStr),RefJoinStr)
			Call SortNumArray(TempList,0,UBound(TempList),False)
			Temp = StrListJoin(TempList,RefJoinStr)
		End If
		'删除父子串引用地址
		TempList = ChangeList(TmpList,RefAddList)
		If CheckArray(TempList) = True Then
			Temp = StrListJoin(ChangeList(ReSplit(Temp,RefJoinStr),TempList),RefJoinStr)
		End If
		'同步跟随引用地址的自定义字串类型
		.Trans.Reference = .Source.Reference
		.Trans.lReferenceNum = .Source.lReferenceNum
		'获取父字串引用地址的引用代码(获取类型必须为 2)
		Call GetVARefList(orgFile,"",.Trans,OrgStrTypeList,.TagType,.Moveable,Temp,2,0,0)
	End With
	'更改子字串的ID，此时子字串的地址可能为原始地址也可能是移位地址
	With AllStrDataList(strID)
		'如果子字串有2个及以上引用地址，并且ID不是首个引用地址，更改字串ID和字典
		strID = -.Source.Reference(0).lAddress
		If strID = .ID Then Exit Function
		'更改字串ID和字典
		If AllShow = True Then
			If UseStrIDIndexDic.Exists(.ID) Then
				UseStrIDIndexDic.Key(.ID) = strID
				UseStrDataList(UseStrIDIndexDic.Item(strID)).ID = strID
			End If
		End If
		StrIDIndexDic.Key(.ID) = strID
		.ID = strID
		'更改子字串所占用空余地址的被占用ID号
		If .ScapeIDForMove > -1 Then
			FreeByteList(FreeByteDic.Item(.ScapeIDForMove)).MoveType = strID
			AllStrDataList(StrIDIndexDic.Item(.ScapeIDForMove)).ScapeIDBeMoved = strID
		ElseIf .ScapeIDForMove < -1 Then
			If .MoveType < 3 Then FreeByteList(-.ScapeIDForMove).MoveType = strID
		End If
	End With
	'从小到大排序
	With AllStrDataList(i)
		'只有一个子字串时退出
		If .SplitState < 2 Then Exit Function
		If AllShow = True Then
			n = 0: m = -1
			For j = 0 To .Trans.lReferenceNum - 1
				If UseStrIDIndexDic.Exists(-.Trans.Reference(j).lAddress) Then
					x = UseStrIDIndexDic.Item(-.Trans.Reference(j).lAddress)
					If m = -1 Or x < m Then m = x
					n = n + 1
				End If
			Next j
			If n > 1 Then
				Call SortStrArraysByID(UseStrIDIndexDic,UseStrDataList,m,m + n - 1,True)
			End If
			Call SortStrArraysByID(StrIDIndexDic,AllStrDataList,i + 1,i + .SplitState,True)
			SubString = UseStrIDIndexDic.Item(strID)
		Else
			Call SortStrArraysByID(StrIDIndexDic,AllStrDataList,i + 1,i + .SplitState,True)
			UseStrDataList = AllStrDataList
			SubString = StrIDIndexDic.Item(strID)
		End If
	End With
End Function


'不拆分字串时按常规字串计算移位或复位
'获取父字串的原始引用地址和引用代码
'返回 =0 未被更改不需要刷新，ParentString =-1 已被更改需要刷新，=1 父字串超长移位，=2 父字串重新移位
Private Function ParentString(orgFile As FILE_PROPERTIE,trnFile As FILE_PROPERTIE,strData As STRING_PROPERTIE,ByVal strID As Long,RefAddList() As String) As Long
	Dim MsgList() As String
	'子字串直接退出
	If AllStrDataList(strID).SplitState < 0 Then Exit Function
	If getMsgList(UIDataList,MsgList,"EditReference",1) = False Then Exit Function
	With AllStrDataList(strID)
		'同步随引用地址的自定义字串类型
		.Trans.Reference = .Source.Reference
		.Trans.lReferenceNum = .Source.lReferenceNum
		'获取字串引用地址的引用代码(获取类型必须为 2)
		Call GetVARefList(trnFile,"",.Trans,OrgStrTypeList,.TagType,.Moveable,StrListJoin(RefAddList,RefJoinStr),2,0,0)
		'获取字串的移位模式
		.MoveMode = MoveMode(trnFile,AllStrDataList(strID))
		'重置父子串的地址
		If .Trans.lReferenceNum > 0 Then
			If .ScapeIDForMove = -1 Then
				ParentString = 1
			ElseIf .WriteType = 5 Then
				ResetStrVal(orgFile,AllStrDataList,FreeByteList,strID,0)
				ParentString = 2
			ElseIf .Trans.lReferenceNum = .Source.lReferenceNum Then
				ChangeStrVal(orgFile,AllStrDataList,FreeByteList,strID,2)
			ElseIf .WriteType = 3 Then
				If ResetStrVal(orgFile,AllStrDataList,FreeByteList,strID,2) = True Then ParentString = 2
			End If
		ElseIf .ScapeIDForMove <> -1 Then
			If CheckStrVal(AllStrDataList(strID),4,0) = False Then
				If MsgBox(MsgList(2),vbYesNo+vbInformation,MsgList(0)) = vbYes Then
					.MoveMode = 4
					If ResetStrVal(orgFile,AllStrDataList,FreeByteList,strID,1) = True Then ParentString = 2
				Else
					AllStrDataList(strID) = strData
					Exit Function
				End If
			Else
				'还原被占有字串的移位模式
				If .ScapeIDBeMoved > -1 Then
					With AllStrDataList(StrIDIndexDic.Item(.ScapeIDBeMoved))
						If .SplitState = 0 Then
							.MoveMode = IIf(.Source.MoveLength = 0,0,2)
						ElseIf .SplitState > 0 Then
							.MoveMode = IIf(.Source.MoveLength = 0,4,2)
						End If
					End With
				End If
				MsgBox MsgList(3),vbOkOnly+vbInformation,MsgList(1)
				If ResetStrVal(orgFile,AllStrDataList,FreeByteList,strID,1) = True Then ParentString = 2
			End If
		End If
		'获取字串的写入类型
		.WriteType = WriteType(trnFile,AllStrDataList(strID),WriteSet)
	End With
	If ParentString = 0 Then ParentString = -1
End Function


'用父字串管理子字串(增加、减少及合并)
'返回：
'ManageSubString =0 无增加和删除，否则有增加和删除，=-1 已重新排序需要刷新
'AddRefList 增加的子字串引用地址数 (= 子字串数)
'DelRefList 删除的子字串引用地址数 (>=子字串数)
Private Function ManageSubString(orgFile As FILE_PROPERTIE,trnFile As FILE_PROPERTIE,strData As STRING_PROPERTIE,ByVal strID As Long, _
		AddRefList() As String,DelRefList() As String,ByVal AllShow As Boolean) As Long
	'编辑子字串时直接退出
	If AllStrDataList(strID).SplitState < 0 Then Exit Function
	'不需要修改引用代码时直接退出
	If AllStrDataList(strID).Trans.lReferenceNum < 1 Then Exit Function
	Dim i As Long,j As Long,m As Long,n As Long,Temp As String,Stemp As Boolean
	Dim TempList() As String,TmpList() As String,MsgList() As String
	If getMsgList(UIDataList,MsgList,"EditReference",1) = False Then Exit Function
	With AllStrDataList(strID)
		TempList = RefList2StrList(.Trans,0)
		TmpList = RefList2StrList(strData.Trans,0)
		'计算要增加的子字串
		AddRefList = ChangeList(TempList,TmpList)
		'计算要删除的地址
		DelRefList = ChangeList(TmpList,TempList)
		'组织提示消息
		n = IIf(CheckArray(AddRefList) = True,UBound(AddRefList) + 1,0)
		m = IIf(CheckArray(DelRefList) = True,UBound(DelRefList) + 1,0)
		If n + m = 0 Then Exit Function
		If n > 0 And m > 0 Then
			Temp = MsgList(4)
		ElseIf n > 0 Then
			Temp = MsgList(5)
		Else
			Temp = MsgList(6)
		End If
		If MsgBox(Temp,vbYesNo+vbInformation,MsgList(0)) = vbNo Then
			AllStrDataList(strID) = strData
			Exit Function
		End If
		'计算要删除的地址是否在2个及以上引用地址的子字串中
		ReDim TempList(0) As String,TmpList(0) As String
		If m > 0 Then
			ReDim TempList(strData.Trans.lReferenceNum - 1) As String
			m = 0: Stemp = False
			For i = 0 To strData.Trans.lReferenceNum - 1
				j = -strData.Trans.Reference(i).lAddress
				If StrIDIndexDic.Exists(j) Then
					j = StrIDIndexDic.Item(j)
					With AllStrDataList(j)
						If .Source.lReferenceNum > 1 Then
							'返回子字串的原始引用地址中要删除的地址
							TmpList = RefList2StrList(.Source,0)
							Temp = StrListJoin(ChangeList(TmpList,DelRefList,1),RefJoinStr)
							If Temp <> "" And Temp <> StrListJoin(TmpList,RefJoinStr) Then
								'记录被删除的引用地址
								TempList(m) = Temp
								m = m + 1
								'更新子字串的原始引用地址和引用代码
								Call GetRefList(.Source,ChangeList(TmpList,DelRefList),TmpList,True)
								'更新子字串的翻译引用地址和引用代码
								Temp = StrListJoin(ChangeList(RefList2StrList(.Trans,0),DelRefList),RefJoinStr)
								If .MoveType < 4 Then
									Call GetVARefList(orgFile,"",.Trans,OrgStrTypeList,.TagType,.Moveable,Temp,2,0,0)
								Else
									Call GetVARefList(trnFile,"",.Trans,OrgStrTypeList,.TagType,.Moveable,Temp,2,0,0)
								End If
								'如果删除的是子字串的首个引用地址，更改字串ID和字典
								j = -.Source.Reference(0).lAddress
								If j <> .ID Then
									'更改字串ID和字典
									If AllShow = True Then
										If UseStrIDIndexDic.Exists(.ID) Then
											UseStrIDIndexDic.Key(.ID) = j
											UseStrDataList(UseStrIDIndexDic.Item(j)).ID = j
										End If
									End If
									StrIDIndexDic.Key(.ID) = j
									.ID = j
									'更改子字串所占用空余地址的被占用ID号
									If .ScapeIDForMove > -1 Then
										FreeByteList(FreeByteDic.Item(.ScapeIDForMove)).MoveType = j
										AllStrDataList(StrIDIndexDic.Item(.ScapeIDForMove)).ScapeIDBeMoved = j
									ElseIf .ScapeIDForMove < -1 Then
										If .MoveType < 3 Then FreeByteList(-.ScapeIDForMove).MoveType = j
									End If
									'标记为需排序
									Stemp = True
								End If
							End If
						End If
					End With
				End If
			Next i
		End If
		'更新删除地址列表
		If m > 0 Then
			ReDim Preserve TempList(m - 1) As String
			DelRefList = ChangeList(DelRefList,ReSplit(StrListJoin(TempList,RefJoinStr),RefJoinStr))
			m = IIf(CheckArray(DelRefList) = True,UBound(DelRefList) + 1,0)
			'从小到大排序
			If .SplitState > 1 And Stemp = True And n = 0 Then
				If AllShow = True Then
					j = 0
					With strData.Trans
						For i = 0 To .lReferenceNum - 1
							If UseStrIDIndexDic.Exists(-.Reference(i).lAddress) Then
								j = j + 1
							End If
						Next i
					End With
					If j > 1 Then
						i = UseStrIDIndexDic.Item(AllStrDataList(strID).ID)
						Call SortStrArraysByID(UseStrIDIndexDic,UseStrDataList,i + 1,i + j,True)
					End If
					Call SortStrArraysByID(StrIDIndexDic,AllStrDataList,strID + 1,strID + .SplitState,True)
				Else
					Call SortStrArraysByID(StrIDIndexDic,AllStrDataList,strID + 1,strID + .SplitState,True)
					UseStrDataList = AllStrDataList
				End If
				ManageSubString = -1
			End If
			If n + m = 0 Then Exit Function
		End If
	End With
	If ManageSubString = 0 Then ManageSubString = 1
End Function


'添加子字串(管理)
'返回 AddSubString 添加的子字串数
Private Function AddSubString(trnFile As FILE_PROPERTIE,DataList() As STRING_PROPERTIE,ByVal strID As Long, _
				AddRefList() As String,ByVal AllShow As Boolean,Optional ByVal QuickPos As Integer) As Long
	If CheckArray(AddRefList) = False Then Exit Function
	Dim i As Long,j As Long,k As Long,TempList() As String
	With DataList(0)
		If QuickPos = 1 Then
			'If .Source.Reference(i).Index = 0 Then
				For i = 0 To .Source.lReferenceNum - 1
					.Source.Reference(i).Index = i + 1
				Next i
			'End If
		End If
		Call GetRefList(.Source,AddRefList,TempList,True)
		AddSubString = .Source.lReferenceNum
	End With
	ReDim Preserve DataList(AddSubString - 1) As STRING_PROPERTIE
	For i = AddSubString - 1 To 0 Step -1
		DataList(i) = DataList(0)
		With DataList(i)
			.SplitState = -AllStrDataList(strID).ID
			.ID = -DataList(0).Source.Reference(i).lAddress
			.MoveType = 0
			.MoveMode = 1
			.LockState = 0
			.SourceStringClearState = 0
			.ScapeIDForMove = -1
			.ScapeIDBeMoved = -1
			'.Source.MoveLength = 0
			.Source.lReferenceNum = 1
			.Source.GetRefState = 1
			.Source.Reference(0) = DataList(0).Source.Reference(i)
			ReDim Preserve DataList(i).Source.Reference(0) 'As REFERENCE_PROPERTIE
			If QuickPos = 1 Then
				.Trans.sString = .Trans.sString & "_" & CStr(DataList(0).Source.Reference(i).Index)
				.Trans.lHexLength = .Trans.lHexLength + StrHexLength("_" & CStr(DataList(0).Source.Reference(i).Index),.Trans.CodePage,0)
				.Trans.lCharLength = .Trans.lCharLength + Len("_" & CStr(DataList(0).Source.Reference(i).Index))
			End If
			.Trans.MoveLength = 0
			.Trans.lReferenceNum = 1
			.Trans.GetRefState = 1
			.Trans.Reference(0) = .Source.Reference(0)
			.Trans.lStartAddress = .Source.lStartAddress + .Source.MoveLength
			.Trans.lEndAddress = .Trans.lStartAddress + .Trans.lHexLength - 1
			.Trans.lMaxAddress = GetMaxAddress(DataList(i),False)
			.Trans.lMaxHexLength = .Trans.lMaxAddress - .Trans.lStartAddress + 1 - .EndByteLength - .Trans.iNullByteLength
			.Trans.inSectionID = .Source.inSectionID
			'更新子字串的翻译引用地址和引用代码
			If .Source.MoveLength <> 0 Then
				Call GetVARefList(trnFile,"",.Trans,OrgStrTypeList,.TagType,.Moveable,"",1,0,0)
			End If
			.WriteType = WriteType(trnFile,DataList(i),WriteSet)
		End With
	Next i
	k = AllStrDataList(strID).SplitState + 1
	If AllShow = True Then
		j = 1
		With AllStrDataList(strID).Trans
			For i = 0 To .lReferenceNum - 1
				If UseStrIDIndexDic.Exists(-.Reference(i).lAddress) Then
					j = j + 1
				End If
			Next i
		End With
		i = UseStrIDIndexDic.Item(AllStrDataList(strID).ID)
		Call InsertDataArrays(UseStrIDIndexDic,UseStrDataList,DataList,i + j)
		Call InsertDataArrays(StrIDIndexDic,AllStrDataList,DataList,strID + k)
	Else
		Call InsertDataArrays(StrIDIndexDic,AllStrDataList,DataList,strID + k)
		UseStrDataList = AllStrDataList
	End If
End Function


'删除多个子字串(管理)
'返回 DelSubStrings 删除的子字串数
Private Function DelSubStrings(trnFile As FILE_PROPERTIE,DelRefList() As String,ByVal AllShow As Boolean) As Long
	If CheckArray(DelRefList) = False Then Exit Function
	Dim i As Long,j As Long,k As Long
	i = UBound(DelRefList)
	ReDim intArry(i) As Long,intList(i) As Long
	For i = 0 To UBound(DelRefList)
		If DelRefList(i) <> "" Then
			k = -CLng(DelRefList(i))
			If StrIDIndexDic.Exists(k) Then
				intList(DelSubStrings) = StrIDIndexDic.Item(k)
				If AllShow = True Then
					If UseStrIDIndexDic.Exists(k) Then
						intArry(j) = UseStrIDIndexDic.Item(k)
						j = j + 1
					End If
				End If
				If AllStrDataList(intList(DelSubStrings)).ScapeIDForMove <> -1 Then
					'标记原占有空间为未占有
					ChangeStrVal(trnFile,AllStrDataList,FreeByteList,intList(DelSubStrings),1)
				End If
				DelSubStrings = DelSubStrings + 1
			End If
		End If
	Next i
	If DelSubStrings = 0 Then Exit Function
	ReDim Preserve intList(DelSubStrings - 1) As Long
	If AllShow = True Then
		If j > 0 Then
			ReDim Preserve intArry(j - 1) As Long
			Call DelDataArray(UseStrIDIndexDic,UseStrDataList,intArry)
		End If
		Call DelDataArray(StrIDIndexDic,AllStrDataList,intList)
	Else
		Call DelDataArray(StrIDIndexDic,AllStrDataList,intList)
		UseStrDataList = AllStrDataList
	End If
End Function


'从小到大排序并刷新显示字串列表框
'返回 SortSubString =0 未排序不需要刷新，<0 需要刷新但不需要移位父或子字串，=1 需要移位父字串，=3 需要移位子字串
Private Function SortSubString(trnFile As FILE_PROPERTIE,ByVal StrID As Long,ByVal AddStrNum As Long,ByVal DelStrNum As Long,ByVal AllShow As Boolean) As Long
	If AddStrNum + DelStrNum < 1 Then Exit Function
	With AllStrDataList(StrID)
		.SplitState = .SplitState + AddStrNum - DelStrNum
		'从小到大排序
		If AddStrNum > 0 And .SplitState > 1 Then
			If AllShow = True Then
				Dim i As Long,j As Long
				For i = 0 To .Trans.lReferenceNum - 1
					If UseStrIDIndexDic.Exists(-.Trans.Reference(i).lAddress) Then
						j = j + 1
					End If
				Next i
				If j > 1 Then
					i = UseStrIDIndexDic.Item(AllStrDataList(StrID).ID)
					Call SortStrArraysByID(UseStrIDIndexDic,UseStrDataList,i + 1,i + j,True)
				End If
				Call SortStrArraysByID(StrIDIndexDic,AllStrDataList,StrID + 1,StrID + .SplitState,True)
			Else
				Call SortStrArraysByID(StrIDIndexDic,AllStrDataList,StrID + 1,StrID + .SplitState,True)
				UseStrDataList = AllStrDataList
			End If
		End If
		If .SplitState > 0 Then
			'获取父字串的移位模式
			.MoveMode = MoveMode(trnFile,AllStrDataList(StrID))
			'重置父字串地址
			If .ScapeIDForMove <> -1 Or .ScapeIDBeMoved <> -1 Then
				ResetStrVal(trnFile,AllStrDataList,FreeByteList,StrID,1)
				'获取父字串的引用代码
				Call GetVARefList(trnFile,"",.Trans,OrgStrTypeList,.TagType,.Moveable,"",1,0,0)
			End If
			'移位子字串
			SortSubString = 3
		Else
			If .WriteType = 5 Then ResetStrVal(trnFile,AllStrDataList,FreeByteList,StrID,0)
			'获取父字串的写入类型
			.WriteType = WriteType(trnFile,AllStrDataList(StrID),WriteSet)
			'获取父字串的移位模式
			.MoveMode = MoveMode(trnFile,AllStrDataList(StrID))
			'判断是否需要移动父字串
			If .WriteType = 2 Or .MoveMode = 1 Then SortSubString = 1 Else SortSubString = -1
		End If
	End With
End Function


'删除单个子字串
'返回 DelSubString =0 未删除和重新排序不需要刷新，=1 需要移位未拆分父字串 =4 需要移位已拆分父字串
Private Function DelSubString(trnFile As FILE_PROPERTIE,strData As STRING_PROPERTIE,ByVal StrID As Long,ByVal AllShow As Boolean) As Long
	Dim i As Long,j As Long,m As Long,n As Long,TempList() As String,MsgList() As String
	If getMsgList(UIDataList,MsgList,"EditReference",1) = False Then Exit Function
	StrID = StrIDIndexDic.Item(-AllStrDataList(StrID).SplitState)
	With AllStrDataList(StrID)
		If .SplitState > 1 Then
			If MsgBox(MsgList(7),vbYesNo+vbInformation,MsgList(0)) = vbNo Then Exit Function
			TempList = RefList2StrList(strData.Trans,0)
		Else
			If MsgBox(MsgList(8),vbYesNo+vbInformation,MsgList(0)) = vbNo Then Exit Function
			TempList = RefList2StrList(.Trans,0)
		End If
	End With
	i = UBound(TempList)
	ReDim intArry(i) As Long,intList(i) As Long
	For i = 0 To UBound(TempList)
		If TempList(i) <> "" Then
			j = -CLng(TempList(i))
			If StrIDIndexDic.Exists(j) Then
				intList(m) = StrIDIndexDic.Item(j)
				If AllShow = True Then
					If UseStrIDIndexDic.Exists(j) Then
						intArry(n) = UseStrIDIndexDic.Item(j)
						n = n + 1
					End If
				End If
				If AllStrDataList(intList(m)).ScapeIDForMove <> -1 Then
					'标记原占有空间为未占有
					ChangeStrVal(trnFile,AllStrDataList,FreeByteList,intList(m),1)
				End If
				m = m + 1
			End If
		End If
	Next i
	If m = 0 Then Exit Function
	ReDim Preserve intList(m - 1) As Long
	If AllShow = True Then
		If n > 0 Then
			ReDim Preserve intArry(n - 1) As Long
			Call DelDataArray(UseStrIDIndexDic,UseStrDataList,intArry)
		End If
		Call DelDataArray(StrIDIndexDic,AllStrDataList,intList)
	Else
		Call DelDataArray(StrIDIndexDic,AllStrDataList,intList)
		UseStrDataList = AllStrDataList
	End If
	With AllStrDataList(StrID)
		.SplitState = .SplitState - m
		If .SplitState > 0 Then
			'获取要增加的父子串引用地址
			TempList = ChangeList(RefList2StrList(.Trans,0),TempList)
			'同步随引用地址的自定义字串类型
			.Trans.Reference = .Source.Reference
			.Trans.lReferenceNum = .Source.lReferenceNum
			'获取父字串引用地址的引用代码(获取类型必须为 2)
			Call GetVARefList(trnFile,"",.Trans,OrgStrTypeList,.TagType,.Moveable,StrListJoin(TempList,RefJoinStr),2,0,0)
			DelSubString = 4
		Else
			'获取父字串的写入类型
			.WriteType = WriteType(trnFile,AllStrDataList(StrID),WriteSet)
			'获取父字串的移位模式
			.MoveMode = MoveMode(trnFile,AllStrDataList(StrID))
			'判断是否需要移动父字串
			If .WriteType = 2 Or .MoveMode = 1 Then DelSubString = 1 Else DelSubString = -1
		End If
	End With
End Function


'确定快速定位引用，返回修改翻译数
Private Function RefQuickPosition(trnFile As FILE_PROPERTIE,ByVal StrID As Long,ByVal QuickPos As Long,ByVal AllShow As Boolean) As Long
	Dim i As Long,k As Long,Temp As String,TempList() As String
	If AllStrDataList(StrID).Source.Reference(0).Index = QuickPos Then Exit Function
	If AllStrDataList(StrID).SplitState < 1 Then Exit Function
	AllStrDataList(StrID).Source.Reference(0).Index = QuickPos
	'备份当前字串数据
	ReDim DataList(1) As STRING_SUB_PROPERTIE
	DataList(0) = AllStrDataList(StrID).Source
	For i = 0 To DataList(0).lReferenceNum - 1
		DataList(0).Reference(i).Index = i + 1
	Next i
	If QuickPos = 0 Then
		'删除快速定位标记
		For i = 0 To AllStrDataList(StrID).SplitState - 1
			With AllStrDataList(StrID + i + 1)
				If .WriteType <> 0 Then
					DataList(1) = DataList(0)
					Call GetRefList(DataList(1),RefList2StrList(.Trans,0),TempList,True)
					Temp = "_" & CStr(DataList(1).Reference(0).Index)
					k = InStrRev(.Trans.sString,Temp)
					If k > 1 Then
						If Mid(.Trans.sString,k) <> Temp Then k = 0
					End If
					If k > 1 Then
						.Trans.sString = Left(.Trans.sString,k - 1)
						.Trans.lHexLength = .Trans.lHexLength - StrHexLength(Temp,.Trans.CodePage,0)
						.Trans.lCharLength = .Trans.lCharLength - Len(Temp)
						.WriteType = WriteType(trnFile,AllStrDataList(StrID + i + 1),WriteSet)
						RefQuickPosition = RefQuickPosition + 1
					End If
				End If
			End With
		Next i
	Else
		'附加快速定位标记
		For i = 0 To AllStrDataList(StrID).SplitState - 1
			With AllStrDataList(StrID + i + 1)
				If .WriteType <> 0 Then
					DataList(1) = DataList(0)
					Call GetRefList(DataList(1),RefList2StrList(.Trans,0),TempList,True)
					Temp = "_" & CStr(DataList(1).Reference(0).Index)
					k = InStrRev(.Trans.sString,Temp)
					If k > 1 Then
						If Mid(.Trans.sString,k) <> Temp Then k = 0
					End If
					If k = 0 Then
						.Trans.sString = .Trans.sString & Temp
						.Trans.lHexLength = .Trans.lHexLength + StrHexLength(Temp,.Trans.CodePage,0)
						.Trans.lCharLength = .Trans.lCharLength + Len(Temp)
						RefQuickPosition = RefQuickPosition + 1
					End If
				End If
			End With
		Next i
	End If
	If RefQuickPosition > 0 Then
		If AllShow = False Then
			For i = 0 To AllStrDataList(StrID).SplitState - 1
				UseStrDataList(StrID + i + 1) = AllStrDataList(StrID + i + 1)
			Next i
		Else
			For i = 0 To AllStrDataList(StrID).SplitState - 1
				If UseStrIDIndexDic.Exists(AllStrDataList(StrID + i + 1).ID) Then
					QuickPos = UseStrIDIndexDic.Item(AllStrDataList(StrID + i + 1).ID)
					UseStrDataList(QuickPos) = AllStrDataList(StrID + i + 1)
				End If
			Next i
		End If
	End If
End Function


'检查过滤字串设置
Private Function CheckFilterStrSet(FilterStrSet() As String) As Boolean
	Dim i As Integer
	For i = 0 To UBound(FilterStrSet)
		If InStr("12",ReSplit(FilterStrSet(i),ItemJoinStr,2)(0)) Then
			CheckFilterStrSet = True
			Exit For
		End If
	Next i
End Function


'过滤显示字串数据
'FilterString <0 不需要过滤，=0 全部被过滤，>0 部分被过滤
Private Function FilterString(DataList() As STRING_PROPERTIE,FilterStrSet() As String,intList() As Long,ByVal CompVal As Long) As Long
	Dim i As Long,j As Long,k As Long,m As Long,n As Long,x As Long,Mode As Long
	Dim TempList() As String,Dic As Object
	FilterString = -1
	If CheckFilterStrSet(FilterStrSet) = False Then Exit Function
	Set Dic = CreateObject("Scripting.Dictionary")

	'按选定语言获取其编码范围，这里不需要注意语言，因为检测代码页函数不使用编码范围
	TempList = ReSplit(FilterStrSet(5),ItemJoinStr)
	If TempList(0) <> "0" Then
		If TempList(1) <> "0" Then
			ReDim LangList(0) As LANG_PROPERTIE
			LangList = UniLangList
			For i = 1 To UBound(TempList)
				x = StrToLong(TempList(i))
				m = LangIDIndexDic.Item(x)
				k = UniLangList(m).CodePage
				If Not Dic.Exists(k) Then
					Dic.Add(k,x)
				Else
					Dic.Item(k) = Dic.Item(k) & ItemJoinStr & x
				End If
				LangList(n) = UniLangList(m)
				n = n + 1
			Next i
			If n > 0 Then
				'添加所有语言都兼容的英文，以区分英文还是其他文字
				If Not Dic.Exists(CP_WESTEUROPE) Then
					Dic.Add(CP_WESTEUROPE,1033)
					LangList(n) = UniLangList(LangIDIndexDic.Item(1033))
					n = n + 1
				End If
				ReDim Preserve LangList(n - 1) As LANG_PROPERTIE
				'从大到小排序，以区分英文和其他文字，因为其他语言兼容了英语，故需要先检查英语
				Call SortLangArrayByCP(LangList,0,n - 1,True)
			Else
				ReDim LangList(0) As LANG_PROPERTIE
			End If
			Dic.RemoveAll
		End If
	End If

	'获取检查过滤注释用的翻译字串列表
	If FilterStrSet(22) <> "0" Then
		Dim StrCountDiff As Long,hcsTrn As PslTransList
		For i = 1 To trn.Project.SourceLists.Count
			If trn.Project.SourceLists(i).SourceFile = SourceFile.hcsFile.FilePath Then
				Set hcsTrn = trn.Project.TransLists(trn.Project.SourceLists(i),trn.Language.LangID)
				If hcsTrn.SourceList.LastChange > hcsTrn.LastUpdate Then hcsTrn.Update
				Exit For
			End If
		Next i
		If hcsTrn Is Nothing Then
			FilterStrSet(22) = "0"
			If CheckFilterStrSet(FilterStrSet) = False Then
				Set Dic = Nothing
				Exit Function
			End If
		Else
			StrCountDiff = Abs(UBound(AllStrDataList) - hcsTrn.StringCount + 1)
		End If
	End If

	'转换过滤设置
	k = 1: n = UBound(FilterStrSet)
	ReDim Filters(n) As FILTER_PROPERTIE
	Filters(0).Mode = StrToLong(FilterStrSet(0))
	For i = 1 To n
		TempList = ReSplit(FilterStrSet(i),ItemJoinStr,2)
		x = StrToLong(TempList(0))
		If x > 0 Then
			With Filters(k)
				.Mode = x - 1
				Select Case i
				Case 1
					.Item = "inSection": .Value = TempList(1)
				Case 2
					.Item = "WriteType": .Value = TempList(1)
				Case 3
					.Item = "OverSrcLength": .Value = TempList(1)
				Case 4
					.Item = "SplitState": .Value = TempList(1)
				Case 5
					.Item = IIf(CompVal = 1,"Source.Lang","Trans.Lang")
					.Value = GetCPStrByLangID(LangList,TempList(1),ItemJoinStr)
				Case 6
					.Item = "Source.CodePage"
					.Value = TempList(1)
				Case 7
					.Item = "Trans.CodePage"
					.Value = TempList(1)
				Case 8 To 9
					.Item = "StrType"
					If i = 8 Then
						.Value = Replace$(Replace$(TempList(1),"5","-1"),"6","-2")
					Else
						.Value = TempList(1)
					End If
				Case 10
					.Item = "MoveMode": .Value = TempList(1)
				Case 11
					.Item = "MoveType": .Value = TempList(1)
				Case 12
					.Item = "WriteState": .Value = TempList(1)
				Case 13
					.Item = "StrTypeLength": .Value = TempList(1)
				Case 14
					Select Case TempList(1)
					Case "0"
						.Item = "Source.lReferenceNum"
					Case "1"
						.Item = "Trans.lReferenceNum"
					Case "01"
						.Item = "ReferenceNum"
					End Select
				Case 15
					.Item = "FillSpace": .Value = TempList(1)
				Case 16
					.Item = "DataComp": .Value = TempList(1)
				Case 17
					.Item = "FilterStr": .Other = TempList(1)
				Case 18
					.Item = "LockState"
				Case 19
					.Item = "NewStemp"
				Case 20
					.Item = "iError"
				Case 21
					.Item = "OverWrite"
				Case 22
					.Item = "Comment"
				Case 23
					.Item = "Custom"
					TempList = ReSplit(TempList(1),ItemJoinStr)
					Mode = GetFindMode(TempList(1))
					.Other = TempList(0): .Value = TempList(1)
				End Select
				If Not Dic.Exists(.Item) Then
					Dic.Add(.Item,k)
					If i < 13 Then
						.Value = ItemJoinStr & .Value & ItemJoinStr
						.Other = ItemJoinStr & .Other & ItemJoinStr
					End If
					k = k + 1
				ElseIf i < 13 Then
					With Filters(Dic.Item(.Item))
						.Value = .Value & Filters(k).Value & ItemJoinStr
						.Other = .Other & Filters(k).Other & ItemJoinStr
					End With
				End If
			End With
		End If
	Next i
	If k = 1 Then
		Set Dic = Nothing
		Exit Function
	End If
	k = k - 1
	ReDim Preserve Filters(k) As FILTER_PROPERTIE
	Dic.RemoveAll

	'准备字典
	If CheckArrEmpty(intList) = True Then
		For i = 0 To UBound(intList)
			If Not Dic.Exists(AllStrDataList(intList(i)).ID) Then
				Dic.Add(AllStrDataList(intList(i)).ID,"")
			End If
		Next i
	End If

	'开始过滤
	FilterString = 0
	n = 0: i = UBound(AllStrDataList): k = UBound(Filters)
	Set UseStrIDIndexDic = CreateObject("Scripting.Dictionary")
	ReDim DataList(i) As STRING_PROPERTIE,intList(i) As Long
	For i = 0 To UBound(AllStrDataList)
		m = 0
		With AllStrDataList(i)
		For j = 1 To k
			x = 0
			Select Case Filters(j).Item
			Case "inSection"
				If .Source.inSubSecID = -1 Then
					x = InStr(Filters(j).Value,ItemJoinStr & CStr(.Source.inSectionID) & ItemJoinStr)
				Else
					x = InStr(Filters(j).Value,ItemJoinStr & CStr(.Source.inSectionID) & "-" & CStr(.Source.inSubSecID) & ItemJoinStr)
				End If
			Case "WriteType"
				x = InStr(Filters(j).Value,CStr(.WriteType + 3))
			Case "OverSrcLength"
				If .Trans.lHexLength < .Source.lHexLength Then
					x = 0
				ElseIf .Trans.lHexLength = .Source.lHexLength Then
					x = 1
				ElseIf .Trans.lHexLength > .Source.lMaxHexLength Then
					x = 3
				Else
					x = 2
				End If
				x = InStr(Filters(j).Value,CStr$(x))
			Case "SplitState"
				x = InStr(Filters(j).Value,IIf(.SplitState = 0,"0",IIf(.SplitState > 0,"1","2")))
			Case "Source.Lang"
				Select Case .Source.CodePage
				Case CP_UTF7,CP_UTF8,CP_UNICODELITTLE,CP_UNICODEBIG,CP_UTF32LE,CP_UTF_32LE,CP_UTF32BE,CP_UTF_32BE
					x = InStr(Filters(j).Value,ItemJoinStr & CheckCodePage(.Source.sString,LangList,1) & ItemJoinStr)
				Case Else
					x = InStr(Filters(j).Value,ItemJoinStr & .Source.CodePage & ItemJoinStr)
				End Select
			Case "Trans.Lang"
				Select Case .Trans.CodePage
				Case CP_UTF7,CP_UTF8,CP_UNICODELITTLE,CP_UNICODEBIG,CP_UTF32LE,CP_UTF_32LE,CP_UTF32BE,CP_UTF_32BE
					x = InStr(Filters(j).Value,ItemJoinStr & CheckCodePage(.Trans.sString,LangList,1) & ItemJoinStr)
				Case Else
					x = InStr(Filters(j).Value,ItemJoinStr & .Trans.CodePage & ItemJoinStr)
				End Select
			Case "Source.CodePage"
				x = InStr(Filters(j).Value,ItemJoinStr & CStr$(.Source.CodePage) & ItemJoinStr)
			Case "Trans.CodePage"
				x = InStr(Filters(j).Value,ItemJoinStr & CStr$(.Trans.CodePage) & ItemJoinStr)
			Case "StrType"
				x = InStr(Filters(j).Value,ItemJoinStr & CStr$(IIf(.StrType < -4,-2,IIf(.StrType < 0,-1,.StrType))) & ItemJoinStr)
			Case "MoveMode"
				x = InStr(Filters(j).Value,CStr(.MoveMode))
			Case "MoveType"
				x = InStr(Filters(j).Value,CStr(.MoveType))
			Case "WriteState"
				x = InStr(Filters(j).Value,CStr(.WriteState))
			Case "StrTypeLength"
				x = InStr(Filters(j).Value,IIf(.Source.MoveLength < 0,"0",IIf(.Source.MoveLength = 0,"1","2")))
			Case "Source.lReferenceNum"
				x = IIf(.Source.lReferenceNum = 0,0,1)
			Case "Trans.lReferenceNum"
				x = IIf(.Trans.lReferenceNum = 0,0,1)
			Case "ReferenceNum"
				x = IIf(.Source.lReferenceNum + .Trans.lReferenceNum = 0,0,1)
			Case "FillSpace"
				x = InStr(Filters(j).Value,IIf(.FillLength = 0,"0",IIf(.FillLength > 0,"2","1")))
			Case "DataComp"
				TempList = ReSplit(Filters(j).Value,ItemJoinStr)
				For x = 0 To UBound(TempList)
					If DataCompByID(AllStrDataList(i),AllStrDataListBak,StrIDIndexDicBak,StrToLong(TempList(x)) + 9) = True Then
						x = -1
						Exit For
					End If
				Next x
				x = IIf(x > 0,0,-x)
			Case "FilterStr"
				If InStr(Filters(j).Other,"0") Then
					x = IIf(FilterStrDic.Exists(Trim$(.Source.sString)) = True,1,0)
				Else
					x = IIf(FilterStrDic.Exists(Trim$(DelAccKey(.Source.sString))) = True,1,0)
				End If
			Case "LockState"
				x = .LockState
			Case "NewStemp"
				x = IIf(CompVal = 1,.Source.NewStemp,.Trans.NewStemp)
			Case "iError"
				x = .iError
			Case "OverWrite"
				x = .OverLengthWrite
			Case "Comment"
				If i < StrCountDiff Then
					For x = i + 1 To IIf(i + 1 - StrCountDiff < 1,1,i + 1 - StrCountDiff) Step -1
						If hcsTrn.String(x).SourceText = .Source.sString Then
							If hcsTrn.String(x).TransComment <> "" Then x = -1
							Exit For
						End If
					Next x
				Else
					For x = i + 1 - StrCountDiff To IIf(i + 1 > hcsTrn.StringCount,hcsTrn.StringCount,i + 1)
						If hcsTrn.String(x).SourceText = .Source.sString Then
							If hcsTrn.String(x).TransComment <> "" Then x = -1
							Exit For
						End If
					Next x
				End If
				x = IIf(x > 0,0,-x)
			Case "Custom"
				If InStr(Filters(j).Other,"0") Then
					x = FilterStr(.Trans.sString,Filters(j).Value,Mode)
				Else
					x = FilterStr(DelAccKey(.Trans.sString),Filters(j).Value,Mode)
				End If
			End Select
			If Filters(0).Mode = 0 Then
				Select Case Filters(j).Mode
				Case 0
					If x = 0 Then GoTo NextNo
				Case 1
					If x > 0 Then GoTo NextNo
				End Select
			Else
				Select Case Filters(j).Mode
				Case 0
					If x > 0 Then
						m = m + 1
						Exit For
					End If
				Case 1
					If x = 0 Then
						m = m + 1
						Exit For
					End If
				End Select
			End If
		Next j
		If Filters(0).Mode > 0 Then
			If m = 0 Then GoTo NextNo
		End If
		DataList(FilterString) = AllStrDataList(i)
		If Dic.Exists(.ID) Then
			intList(n) = FilterString: n = n + 1
		End If
		If Not UseStrIDIndexDic.Exists(.ID) Then UseStrIDIndexDic.Add(.ID,FilterString)
		FilterString = FilterString + 1
		NextNo:
		End With
	Next i
	Set Dic = Nothing
	If FilterString = 0 Then
		ReDim DataList(0) As STRING_PROPERTIE
	Else
		ReDim Preserve DataList(FilterString - 1) As STRING_PROPERTIE
	End If
	If n > 0 Then n = n - 1
	ReDim Preserve intList(n) As Long
End Function


'添加字串
'返回值：AddString = -3 取消，0 无添加，>0 添加数
Private Function AddString(orgFile As FILE_PROPERTIE,AddStrSet() As String,IDList() As Long,ByVal ShowMsg As Long) As Long
	Dim i As Long,j As Long,n As Long,x As Long,y As Long,TagType As Integer
	Dim Max As Long,MinVal As Long,MaxVal As Long,RSize As Long,SkipVal As Long,Mode As Long
	Dim TempList() As String,MsgList() As String,Temp As String,EndChar As String
	Dim FeatureCode As String,FN As FILE_IMAGE,StartTime As Date,Stemp As Boolean
	Dim LangList() As LANG_PROPERTIE,TypeList() As STRING_TYPE,Dic As Object
	Dim DataList() As STRING_PROPERTIE,TempData As STRING_PROPERTIE

	If getMsgList(UIDataList,MsgList,"AddString",1) = False Then Exit Function
	'打开原始文件
	Mode = LoadFile(orgFile.FilePath,FN,0,0,0,StrToLong(Selected(1)))
	If Mode < -1 Then Exit Function
	'获取过滤和保留字串列表字典为提取字串用
	If AddStrSet(3) = "1" Then
		If ExtractSet(21) = "1" Then
			TempList = ReSplit(ReadBinaryFile(ExtractSet(35),CP_UNICODELITTLE,True),vbNullChar)
			StrList2StrDic(FilterStrDic,TempList,StrToLong(ExtractSet(22)),1)
		End If
		If ExtractSet(23) = "1" Then
			If Dir$(ExtractSet(37)) <> "" Then
				TempList = ReSplit(ReadBinaryFile(ExtractSet(37),CP_UNICODELITTLE,True),vbNullChar)
			Else
				TempList = ReSplit(ExcludeStr,ItemJoinStr)
			End If
			StrList2StrDic(ReserveStrDic,TempList,StrToLong(ExtractSet(24)),1)
		End If
	End If
	Set Dic = CreateObject("Scripting.Dictionary")
	CopyDic StrIDIndexDic,Dic
	DataList = AllStrDataList
	With TempData.Source
		.lStartAddress = StrToLong(AddStrSet(4))
		.lEndAddress = StrToLong(AddStrSet(5))
		.lMaxAddress = .lStartAddress
		.sString = AddStrSet(6)
		.CodePage = StrToLong(AddStrSet(7))
		'获取指定代码页的编码范围
		LangList = GetSubLangListByCP(UseLangList,.CodePage)
		'检查是否需要检测多字节字符串的代码页
		FeatureCode = GetFeaturePattern(LangList)
		'获取字串数据数组的最大索引值
		n = UBound(DataList)
		n = IIf(n = 0 And DataList(0).Source.CodePage = 0,0,n + 1)
		ReDim Preserve DataList(n) As STRING_PROPERTIE

		'获取提取设置，以便根据添加字串设置更改提取设置
		TempList = ExtractSet
		'合并选用和原始自定义字串类型
		AddStrTypeList(TypeList,orgFile.FileName,"",StrToLong("1" & TempList(10)))
		TempList(10) = IIf(CheckStrTypeArray(TypeList) = True,"1","0")
		'判断是否需要检查跟随引用地址的自定义字符类型
		If TempList(10) = "1" Then TagType = CheckRefCustomStrType(TypeList,IIf(orgFile.Magic = "",0,1))
		'添加到非空字串数据库时，使用原始结束符
		If n > 0 Then TempList(31) = AddStrEndCharSet(TempList(31),JoinStr & StringTerminator)
		'获取字符串结束符的正则表达式模板
		EndChar = StrEndChar2Pattern(TempList(31))(1)
		EndChar = Mid(EndChar,InStr(EndChar,")(") + 2)
		EndChar = Left(EndChar,InStrRev(EndChar,")") - 1)
		'根据代码页设置字符编码的提取选项
		Select Case .CodePage
		Case CP_UNICODELITTLE
			TempList(4) = "0100000"
		Case CP_UNICODEBIG
			TempList(4) = "0001000"
		Case CP_UTF8
			TempList(4) = "0010000"
		Case CP_UTF7
			TempList(4) = "0000100"
		Case CP_UTF32LE,CP_UTF_32LE
			TempList(4) = "0000010"
		Case CP_UTF32BE,CP_UTF_32BE
			TempList(4) = "0000001"
		Case Is <> CP_UNKNOWN
			TempList(4) = "1000000"
		End Select
		'更改提取字串的其他字符匹配方式 (为正则表达式并提取有非英文字串时改为常规方式)
		If AddStrSet(1) = "1" Then
			If TempList(42) = "2" Then
				If UBound(LangList) > 0 Then
					TempList(42) = "0"
				ElseIf LangList(0).CodePage <> CP_WESTEUROPE Then
					TempList(42) = "0"
				End If
			End If
		End If
		'定义搜索字串的最大区域值
		If .lEndAddress > 0 Then
			RSize = .lEndAddress
		Else
			RSize = orgFile.SecList(orgFile.MaxSecIndex).lPointerToRawData + orgFile.SecList(orgFile.MaxSecIndex).lSizeOfRawData - 1
		End If
		'批量添加时设置结束地址为 0，以便添加多个字串
		If AddStrSet(0) = "1" Then .lEndAddress = 0
		'初始化查找指定字串时的参数
		If AddStrSet(1) = "1" Then
			Temp = Convert(.sString)
			If Mode <> 0 Then FN.ImageByte = GetBytes(FN,RSize + 1,0,Mode)
		End If
		'初始化选定被添加字串显示用的索引号
		ReDim IDList(0) As Long
		'批量添加时设定为不在提取期间获取引用
		If AddStrSet(0) = "1" Then Stemp = True
		'初始化计数计时值
		StartTime = Timer: SkipVal = -1: x = .lStartAddress
		'初始化字串ID，以便不替换字串索引 Key
		TempData.ID = -1
		'显示主窗口的取消操作按钮和禁止主窗口的 Esc 键响应退出主窗口
		Call ShowButton(StopHwnd,VK_ESCAPE,True)
		'显示开始提取信息
		If TempList(25) = "1" Then
			If ShowMsg > 0 Then
				SetTextBoxString ShowMsg,MsgList(1)
			ElseIf ShowMsg < 0 Then
				PSL.OutputWnd(0).Clear
				PSL.Output MsgList(1)
			End If
		End If
		'开始提取字串
		Do While .lStartAddress < RSize
			'获取提取指定字串的有关数据
			If AddStrSet(1) = "1" Then
				.CodePage = StrToLong(AddStrSet(7))
				If .CodePage = CP_UNKNOWN Then
					y = UBound(LangList)
					For j = 0 To y + 6
						If j = y + 1 Then
							.CodePage = CP_UTF32BE
						ElseIf j = y + 2 Then
							.CodePage = CP_UTF32LE
						ElseIf j = y + 3 Then
							.CodePage = CP_UNICODELITTLE
						ElseIf j = y + 4 Then
							.CodePage = CP_UNICODEBIG
						ElseIf j = y + 5 Then
							.CodePage = CP_UTF8
						ElseIf j = y + 6 Then
							.CodePage = CP_UTF7
						Else
							.CodePage = LangList(j).CodePage
						End If
						i = InByteRegExp(FN.ImageByte,StringToByte(Temp,.CodePage),.lStartAddress,RSize,0,0) - 1
						If i >= .lStartAddress Then Exit For
					Next j
				Else
					i = InByteRegExp(FN.ImageByte,StringToByte(Temp,.CodePage),.lStartAddress,RSize,0,0) - 1
				End If
				'没有找到时退出
				If i < .lStartAddress Then Exit Do
				'判断其是否是其他字串的一部分
				.lHexLength = StrHexLength(Temp,.CodePage,0)
				If i > .lStartAddress And i + .lHexLength - 1 < RSize Then
					i = getEndByteRevRegExp(FN,i,.lStartAddress,Mode,EndChar,CP_ISOLATIN1) + 1
					If Dic.Exists(i) Then
						i = DataList(Dic.Item(i)).Source.lMaxAddress + 1
					End If
					.lStartAddress = getNotNullByte(FN,i,RSize,Mode)
				Else
					.lStartAddress = i
				End If
			End If
			'跳过 PE 文件数据目录，.NET 用户字串区域除外
			If AddStrSet(2) = "1" Then
				If .lStartAddress > SkipVal Then
					SkipHeader(orgFile,.lStartAddress,SkipVal,1,1)
					If .lStartAddress > SkipVal Or SkipVal > RSize Then SkipVal = RSize + 1
					If .lStartAddress > RSize Then Exit Do
				End If
			End If
			If Dic.Exists(.lStartAddress) Then
				.lMaxAddress = DataList(Dic.Item(.lStartAddress)).Source.lMaxAddress
			Else
				'获取所在区段ID
				If orgFile.Magic <> "" Then
					If .lStartAddress < MinVal Or .lStartAddress > MaxVal Then
						.inSectionID = SkipSection(orgFile,.lStartAddress,MinVal,MaxVal,1)
					End If
				End If
				'提取字串
				.lHexLength = .lEndAddress - .lStartAddress + 1
				DataList(n) = GetString(orgFile,FN,TempData,LangList,TypeList,TempList,-Abs(SkipVal),Mode,Stemp)
				If DataList(n).Source.sString = "" Then GoTo NextNo
				.lMaxAddress = DataList(n).Source.lMaxAddress
				'过滤字串
				If AddStrSet(1) = "1" Then
					If InStr(DataList(n).Source.sString,.sString) = 0 Then GoTo NextNo
				End If
				If Dic.Exists(DataList(n).Source.lStartAddress) Then GoTo NextNo
				If AddStrSet(3) = "1" Then
					If StrFilter(DataList(n).Source,DataList(n).StrType,TempList,FeatureCode,TagType) = False Then GoTo NextNo
				End If
				'显示提取信息
				If TempList(25) = "1" Then
					With DataList(n)
						If ShowMsg > 0 Then
							If Selected(16) = "1" Then
								SetTextBoxString ShowMsg,ValToStr(.Source.lStartAddress,orgFile.FileSize,True) & "-" & _
										ValToStr(.Source.lEndAddress,orgFile.FileSize,True) & "-" & _
										CStr$(.Source.CodePage) & "-" & CStr$(.StrType) & "-" & .Source.sString,True
							Else
								SetTextBoxString ShowMsg,CStr$(.Source.lStartAddress) & "-" & CStr$(.Source.lEndAddress) & "-" & _
										CStr$(.Source.CodePage) & "-" & CStr$(.StrType) & "-" & .Source.sString,True
							End If
						ElseIf ShowMsg < 0 Then
							If Selected(16) = "1" Then
								PSL.Output ValToStr(.Source.lStartAddress,orgFile.FileSize,True) & "-" & _
										ValToStr(.Source.lEndAddress,orgFile.FileSize,True) & _
										"-" & CStr$(.Source.CodePage) & "-" & CStr$(.StrType) & "-" & .Source.sString
							Else
								PSL.Output CStr$(.Source.lStartAddress) & "-" & CStr$(.Source.lEndAddress) & "-" & _
										CStr$(.Source.CodePage) & "-" & CStr$(.StrType) & "-" & .Source.sString
							End If
						End If
					End With
				End If
				'添加字串到字串数据库
				If n >= Max Then
					Max = n + 100
					ReDim Preserve DataList(Max) As STRING_PROPERTIE,IDList(Max) As Long
				End If
				DataList(n).Source.NewStemp = 2
				Dic.Add(DataList(n).ID,n)
				IDList(AddString) = n
				n = n + 1
				AddString = AddString + 1
				'单个添加时退出
				If AddStrSet(0) = "0" Then Exit Do
				NextNo:
			End If
			'跳到非 &H00 开始处
			.lStartAddress = getNotNullByte(FN,.lMaxAddress + 1,RSize,Mode)
			'显示完成率
			If TempList(25) = "0" Then
				If ShowMsg > 0 Then
					SetTextBoxString ShowMsg,MsgList(1) & Format$((.lStartAddress - x) / (RSize - x)," #%")
				ElseIf ShowMsg < 0 Then
					PSL.OutputWnd(0).Clear
					PSL.Output MsgList(1) & Format$((.lStartAddress - x) / (RSize - x)," #%")
				End If
			End If
			'DoEvents '转让控制权，允许操作系统处理其他事件
			If StopProcess(StopHwnd,VK_ESCAPE) = True Then
				AddString = -3
				GoTo ExitFunction
			End If
		Loop
	End With
	'显示完成率
	If TempList(25) = "0" Then
		If ShowMsg > 0 Then
			SetTextBoxString ShowMsg,MsgList(1) & " 100%"
		ElseIf ShowMsg < 0 Then
			PSL.OutputWnd(0).Clear
			PSL.Output MsgList(1) & " 100%"
		End If
	End If
	'显示使用时间和提取的字串数
	If AddString > 0 Then
		ReDim Preserve DataList(n - 1) As STRING_PROPERTIE
		ReDim Preserve IDList(AddString - 1) As Long
		Set StrIDIndexDic = Dic: Set Dic = Nothing
		'获取字串的引用列表和引用地址前的自定义类型，并过滤不需要提取的标准字串和无引用字串
		i = IIf(IIf(TempList(10) = "0",0,TagType) = 0,0,4)
		i = i + StrToLong(TempList(48)) + IIf(StrToLong(TempList(11)) = 0,0,2)
		AddString = getVAListAndStrTypeByVA(orgFile,FN,DataList,TypeList,IDList,n - AddString,i,Mode,MsgList(2),ShowMsg,True)
	End If
	Select Case AddString
	Case Is > 0
		'记录字串类型数组
		ExtractSet = TempList
		OrgStrTypeList = TypeList: UseStrTypeList = OrgStrTypeList
		AllStrDataList = DataList: Erase DataList,TempList,TypeList
		'排序字串
		Call SortStrArraysByAddress(StrIDIndexDic,AllStrDataList,0,UBound(AllStrDataList),False)
		UseStrDataList = AllStrDataList
		'记录字串结束符并保存对提取选项的修改
		StringTerminator = StrEndChar2Pattern(ExtractSet(31),2)(0)
		If ShowMsg > 0 Then
			SetTextBoxString ShowMsg,MsgList(3) & Format$(DateAdd("s",Timer - StartTime,0),MsgList(4)),True
			SetTextBoxString ShowMsg,Replace$(MsgList(5),"%s",CStr$(AddString)),True
		ElseIf ShowMsg < 0 Then
			PSL.Output MsgList(3) & Format$(DateAdd("s",Timer - StartTime,0),MsgList(4))
			PSL.Output Replace$(MsgList(5),"%s",CStr$(AddString))
		End If
	Case 0
		ReDim IDList(0) As Long
		If ShowMsg > 0 Then
			SetTextBoxString ShowMsg,MsgList(3) & Format$(DateAdd("s",Timer - StartTime,0),MsgList(4)),True
		ElseIf ShowMsg < 0 Then
			PSL.Output MsgList(3) & Format$(DateAdd("s",Timer - StartTime,0),MsgList(4))
		End If
		MsgBox MsgList(6),vbOkOnly+vbInformation,MsgList(0)
	Case Else
		ReDim IDList(0) As Long
	End Select
	If AddStrSet(0) = "1" Then
		If StrToLong(Selected(21)) = 1 Then Beep
	End If
	ExitFunction:
	Set Dic = Nothing
	UnLoadFile(FN,0,Mode)
	'隐藏主窗口中的取消操作按钮，启用 Esc 键的退出响应
	Call ShowButton(StopHwnd,VK_ESCAPE,False)
	'还原过滤字串列表字典为字串过滤显示用
	If AddStrSet(3) = "1" Then
		If ExtractSet(21) = "1" Then
			TempList = ReSplit(ReadBinaryFile(ExtractSet(35),CP_UNICODELITTLE,True),vbNullChar)
			StrList2StrDic(FilterStrDic,TempList,StrToLong(ReSplit(FilterStrSet(17),ItemJoinStr)(1)),1)
		End If
	End If
End Function


'添加字符串设置对话框
Private Function AddStringSet(OptionSet() As String) As Boolean
	Dim i As Long,MsgList() As String,TempList() As String
	StartDlg:
	If getMsgList(UIDataList,MsgList,"AddStringSet",1) = False Then Exit Function
	'分割代码页数组的名称和值，用于显示
	If OptionSet(7) = "" Then OptionSet(7) = CStr$(CP_UNKNOWN)
	TempList = GetLangStrList(UniLangList,3,True)
	Begin Dialog UserDialog 510,IIf(OptionSet(1) = "0",336,392),MsgList(0),.AddStringSetDlgFunc ' %GRID:10,7,1,1
		TextBox 0,0,0,21,.SuppValueBox
		Text 20,7,470,105,MsgList(1),.Text
		GroupBox 20,119,470,49,MsgList(2),.GetModeText
		OptionGroup .GetModeGroup
			OptionButton 40,140,110,14,MsgList(3),.SingleGetMode
			OptionButton 160,140,100,14,MsgList(4),.BatchGetMode
		OptionGroup .GetTypeGroup
			OptionButton 270,140,100,14,MsgList(5),.ByAddGetMode
			OptionButton 380,140,100,14,MsgList(6),.ByStrGetMode
		Text 20,178,330,14,IIf(StrToLong(Selected(16)) = 0,MsgList(7),MsgList(27)),.StartPosText
		Text 20,199,330,14,IIf(StrToLong(Selected(16)) = 0,MsgList(8),MsgList(28)),.EndPosText
		TextBox 20,224,470,49,.StrTextBox,1
		TextBox 20,224,470,49,.StrTextBoxBak,1
		TextBox 360,175,100,21,.StartPosBox
		TextBox 360,196,100,21,.EndPosBox
		PushButton 460,175,30,21,MsgList(9),.StartPosButton
		PushButton 460,196,30,21,MsgList(9),.EndPosButton
		Text 20,IIf(OptionSet(1) = "0",227,283),200,14,MsgList(10),.CodePageText
		DropListBox 230,IIf(OptionSet(1) = "0",224,280),260,21,TempList(),.CPNameList
		DropListBox 230,IIf(OptionSet(1) = "0",224,280),260,21,TempList(),.CPValList
		CheckBox 20,IIf(OptionSet(1) = "0",252,308),360,21,MsgList(11),.SkipHeadersCheckBox
		CheckBox 20,IIf(OptionSet(1) = "0",273,329),360,21,MsgList(12),.SkipStrCheckBox
		PushButton 390,IIf(OptionSet(1) = "0",252,308),100,21,MsgList(13),.ViewFileInfoButton
		PushButton 390,IIf(OptionSet(1) = "0",273,329),100,21,MsgList(14),.GetStrSetButton
		PushButton 20,IIf(OptionSet(1) = "0",308,364),100,21,MsgList(15),.Tools
		PushButton 130,IIf(OptionSet(1) = "0",308,364),100,21,MsgList(16),.ResetButton
		PushButton 280,IIf(OptionSet(1) = "0",308,364),100,21,"",.ExitButton
		OKButton 280,IIf(OptionSet(1) = "0",308,364),100,21,.OKButton
		CancelButton 390,IIf(OptionSet(1) = "0",308,364),100,21,.CancelButton
	End Dialog
	Dim dlg As UserDialog
	dlg.StrTextBoxBak = MsgList(17)
	i = Dialog(dlg)
	If i = 0 Then Exit Function
	If i = -1 Then
		AddStringSet = True
		Exit Function
	End If
	GoTo StartDlg
End Function


'添加字符串对话框函数
Private Function AddStringSetDlgFunc(DlgItem$, Action%, SuppValue&) As Boolean
	Dim i As Long,j As Long,MinVal As Long,MaxVal As Long
	Dim MsgList() As String,TempList() As String,TempArray() As String
	Select Case Action%
	Case 1 ' 对话框窗口初始化
		DlgText "SuppValueBox",CStr$(SuppValue)
		DlgVisible "SuppValueBox",False
		DlgVisible "StrTextBoxBak",False
		DlgVisible "ExitButton",False
		DlgVisible "CPValList",False

		'TempList = GetLangStrList(UniLangList,3,True)
		'DlgListBoxArray "CPNameList",TempList()
		TempList = GetLangStrList(UniLangList,4,True)
		DlgListBoxArray "CPValList",TempList()

		DlgValue "GetModeGroup",StrToLong(AddStrSet(0))
		DlgValue "GetTypeGroup",StrToLong(AddStrSet(1))
		DlgValue "SkipHeadersCheckBox",StrToLong(AddStrSet(2))
		DlgValue "SkipStrCheckBox",StrToLong(AddStrSet(3))
		DlgText "StartPosBox",ValToStr(StrToLong(AddStrSet(4)),SourceFile.FileSize,StrToLong(Selected(16)))
		DlgText "EndPosBox",ValToStr(StrToLong(AddStrSet(5)),SourceFile.FileSize,StrToLong(Selected(16)))
		DlgText "StrTextBox",AddStrSet(6)
		If AddStrSet(6) = "" Then DlgText "StrTextBox",DlgText("StrTextBoxBak")
		DlgText "CPValList",AddStrSet(7)
		If DlgValue("CPValList") < 0 Then
			DlgValue "CPNameList",0
			DlgValue "CPValList",0
		End If
		DlgValue "CPNameList",DlgValue("CPValList")
		If DlgValue("GetTypeGroup") = 0 Then DlgVisible "StrTextBox",False

		'设置当前对话框字体
		If CheckFont(LFList(0)) = True Then
			j = CreateFont(0,LFList(0))
			If j = 0 Then Exit Function
			For i = 0 To DlgCount() - 1
				SendMessageLNG(GetDlgItem(SuppValue,DlgControlId(DlgName(i))),WM_SETFONT,j,0)
			Next i
		End If
	Case 2 ' 数值更改或者按下了按钮
		AddStringSetDlgFunc = True '防止按下按钮关闭对话框窗口
		Select Case DlgItem$
		Case "CancelButton", "ExitButton"
			AddStringSetDlgFunc = False
		Case "GetTypeGroup"
			If DlgValue("GetTypeGroup") = StrToLong(AddStrSet(1)) Then Exit Function
			AddStrSet(0) = CStr$(DlgValue("GetModeGroup"))
			AddStrSet(1) = CStr$(DlgValue("GetTypeGroup"))
			AddStrSet(2) = CStr$(DlgValue("SkipHeadersCheckBox"))
			AddStrSet(3) = CStr$(DlgValue("SkipStrCheckBox"))
			AddStrSet(4) = CStr$(StrToVal(DlgText("StartPosBox"),StrToLong(Selected(16))))
			AddStrSet(5) = CStr$(StrToVal(DlgText("EndPosBox"),StrToLong(Selected(16))))
			If DlgText("StrTextBox") <> DlgText("StrTextBoxBak") Then AddStrSet(6) = DlgText("StrTextBox")
			AddStrSet(7) = DlgText("CPValList")
			DlgFocus("ExitButton")  '设置焦点到退出按钮
			SendMessageLNG GetFocus(), BM_CLICK, 0, 0
			AddStringSetDlgFunc = False
		Case "CPNameList"
			DlgValue "CPValList",DlgValue("CPNameList")
		Case "OKButton"
			If getMsgList(UIDataList,MsgList,"AddStringSet",1) = False Then Exit Function
			With SourceFile
				MinVal = .SecList(.MinSecID).lPointerToRawData
				MaxVal = .SecList(.MaxSecIndex).lPointerToRawData + .SecList(.MaxSecIndex).lSizeOfRawData - 1
				DlgText "StartPosBox",Trim$(DlgText("StartPosBox"))
				DlgText "EndPosBox",Trim$(DlgText("EndPosBox"))
				If DlgValue("GetTypeGroup") = 1 Then
					If DlgText("StrTextBox") = "" Or DlgText("StrTextBox") = MsgList(17) Then
						MsgBox MsgList(24),vbOkOnly+vbInformation,MsgList(18)
						Exit Function
					End If
				End If
				If DlgText("StartPosBox") <> "" Then
					i = StrToVal(DlgText("StartPosBox"),StrToLong(Selected(16)))
					If i < 0 Then
						MsgBox MsgList(19),vbOkOnly+vbInformation,MsgList(18)
						Exit Function
					End If
					If i < MinVal Or i > MaxVal Then
						MsgBox Replace$(MsgList(20),"%s",ValToStr(MinVal,.FileSize,StrToLong(Selected(16))) & " - " & _
								ValToStr(MaxVal,.FileSize,StrToLong(Selected(16)))),vbOkOnly+vbInformation,MsgList(18)
						Exit Function
					End If
				End If
				If DlgText("EndPosBox") <> "" Then
					j = StrToVal(DlgText("EndPosBox"),StrToLong(Selected(16)))
					If j < 0 Then
						MsgBox MsgList(22),vbOkOnly+vbInformation,MsgList(18)
						Exit Function
					End If
					i = StrToVal(DlgText("StartPosBox"),StrToLong(Selected(16)))
					If (j > 0 And j < i) Or j > MaxVal Then
						MsgBox Replace$(MsgList(23),"%s",ValToStr(i,.FileSize,StrToLong(Selected(16))) & " - " & _
								ValToStr(MaxVal,.FileSize,StrToLong(Selected(16)))),vbOkOnly+vbInformation,MsgList(18)
						Exit Function
					End If
				End If
			End With
			AddStrSet(0) = CStr$(DlgValue("GetModeGroup"))
			AddStrSet(1) = CStr$(DlgValue("GetTypeGroup"))
			AddStrSet(2) = CStr$(DlgValue("SkipHeadersCheckBox"))
			AddStrSet(3) = CStr$(DlgValue("SkipStrCheckBox"))
			AddStrSet(4) = CStr$(StrToVal(DlgText("StartPosBox"),StrToLong(Selected(16))))
			AddStrSet(5) = CStr$(StrToVal(DlgText("EndPosBox"),StrToLong(Selected(16))))
			If DlgText("StrTextBox") <> DlgText("StrTextBoxBak") Then AddStrSet(6) = DlgText("StrTextBox")
			AddStrSet(7) = DlgText("CPValList")
			AddStringSetDlgFunc = False
		Case "StartPosButton"
			If getMsgList(UIDataList,MsgList,"AddStringSet",1) = False Then Exit Function
			j = StrToLong(AddStrSet(8))
			With SourceFile
				TempArray = getSectionList(.SecList,6,.FileSize,StrToLong(Selected(16)))
				ReDim TempList(UBound(TempArray) + 2) As String
				If j = 0 Then
					TempList(0) = Replace$(MsgList(31),"%d", _
								ValToStr(.SecList(.MinSecID).lPointerToRawData,.FileSize,StrToLong(Selected(16))))
				Else
					TempList(0) = Replace$(MsgList(31),"%d", _
								ValToStr(AllStrDataList(j - 1).Source.lMaxAddress + 1,.FileSize,StrToLong(Selected(16))))
				End If
				If AllStrDataList(0).Source.CodePage = 0 Then
					TempList(1) = Replace$(MsgList(32),"%d", _
								ValToStr(.SecList(.MaxSecIndex).lPointerToRawData + .SecList(.MaxSecIndex).lSizeOfRawData - 1, _
										.FileSize,StrToLong(Selected(16))))
				Else
					TempList(1) = Replace$(MsgList(32),"%d", _
								ValToStr(AllStrDataList(j).Source.lMaxAddress + 1,.FileSize,StrToLong(Selected(16))))
				End If
				For i = 0 To UBound(TempArray)
					TempList(2 + i) = Replace$(MsgList(25),"%s",TempArray(i))
				Next i
				TempList(0) = PopupMenuShow(TempList)
				If TempList(0) = "" Then Exit Function
				DlgText "StartPosBox",Split(Split(TempList(0),"(",2)(1),")")(0)
			End With
		Case "EndPosButton"
			If getMsgList(UIDataList,MsgList,"AddStringSet",1) = False Then Exit Function
			j = StrToLong(AddStrSet(8))
			With SourceFile
				MaxVal = UBound(AllStrDataList)
				TempArray = getSectionList(.SecList,8,.FileSize,StrToLong(Selected(16)))
				If j < MaxVal Then
					ReDim Preserve TempList(UBound(TempArray) + 1) As String
					MinVal = StrToVal(DlgText("StartPosBox"),StrToLong(Selected(16)))
					For i = j To MaxVal
						If AllStrDataList(i).Source.lStartAddress > MinVal Then
							TempList(0) = Replace$(MsgList(21),"%d", _
										ValToStr(AllStrDataList(i).Source.lStartAddress - 1,.FileSize,StrToLong(Selected(16))))
							Exit For
						End If
					Next i
					For i = 0 To UBound(TempArray)
						TempList(1 + i) = Replace$(MsgList(26),"%s",TempArray(i))
					Next i
					TempList(0) = PopupMenuShow(TempList)
					If TempList(0) = "" Then Exit Function
					DlgText "EndPosBox",Split(Split(TempList(0),"(",2)(1),")")(0)
				Else
					TempList = TempArray
					For i = 0 To UBound(TempArray)
						TempList(i) = Replace$(MsgList(26),"%s",TempArray(i))
					Next i
					TempList(0) = PopupMenuShow(TempList)
					If TempList(0) = "" Then Exit Function
					DlgText "EndPosBox",Split(Split(TempList(0),"(",2)(1),")")(0)
				End If
			End With
		Case "ViewFileInfoButton"
			TempList = GetToolNameList(Tools,0)
			i = ShowPopupMenu(TempList,vbPopupUseRightButton)
			If i < 0 Then Exit Function
			Call FileInfoView(SourceFile,FreeByteList,i,0,StrToLong(Selected(16)))
		Case "Tools"
			TempList = GetToolNameList(Tools,3)
			i = ShowPopupMenu(TempList,vbPopupUseRightButton)
			If i < 0 Then Exit Function
			ReDim TempList(0) As String
			TempList(0) = SourceFile.FilePath & JoinStr
			If OpenFile(SourceFile.FilePath,TempList,i + 3,False) = True Then
				If i = 0 Then WriteSettings("Tools")
			End If
		Case "ResetButton"
			DlgValue "GetModeGroup",StrToLong(AddStrSet(0))
			'DlgValue "GetTypeGroup",StrToLong(AddStrSet(1))
			DlgValue "SkipHeadersCheckBox",StrToLong(AddStrSet(2))
			DlgValue "SkipStrCheckBox",StrToLong(AddStrSet(3))
			DlgText "StartPosBox",ValToStr(StrToLong(AddStrSet(4)),SourceFile.FileSize,StrToLong(Selected(16)))
			DlgText "EndPosBox",ValToStr(StrToLong(AddStrSet(5)),SourceFile.FileSize,StrToLong(Selected(16)))
			DlgText "StrTextBox",AddStrSet(6)
			If AddStrSet(6) = "" Then DlgText "StrTextBox",DlgText("StrTextBoxBak")
			DlgText "CPValList",AddStrSet(7)
			DlgValue "CPNameList",DlgValue("CPValList")
			'DlgVisible "StrTextBox",IIf(DlgValue("GetTypeGroup"),False,True)
		Case "GetStrSetButton"
			TempList = Selected
			ReDim tmpLFList(0) As LOG_FONT
			tmpLFList(0) = LFList(0)
			MsgList = UseSectionList
			Select Case SourceFile.Magic
			Case "NotPE32","NotPE64",""
				UseRefTypeList(1) = UseRefTypeList(0)
			End Select
			'转到提取对话框
			If ExtractString(SourceFile,0) = 0 Then UseSectionList = MsgList
			If UseRefTypeList(0).Template <> UseRefTypeList(1).Template Then
				Select Case SourceFile.Magic
				Case ""
					For i = 0 To UBound(AllStrDataList)
						AllStrDataList(i).Moveable = Moveable(SourceFile,AllStrDataList(i))
						AllStrDataList(i).Source.lReferenceNum = 0
						AllStrDataList(i).Source.GetRefState = 0
						AllStrDataList(i).Trans.lReferenceNum = 0
						AllStrDataList(i).Trans.GetRefState = 0
					Next i
				Case "NotPE32","NotPE64"
					For i = 0 To UBound(AllStrDataList)
						AllStrDataList(i).Moveable = Moveable(SourceFile,AllStrDataList(i))
						AllStrDataList(i).Source.lReferenceNum = 0
						AllStrDataList(i).Source.GetRefState = 0
						AllStrDataList(i).Trans.lReferenceNum = 0
						AllStrDataList(i).Trans.GetRefState = 0
					Next i
				End Select
			End If
			If Selected(16) <> TempList(16) Then
				With SourceFile
					DlgText "StartPosBox",ValToStr(StrToVal(DlgText("StartPosBox"),StrToLong(TempList(16))),.FileSize,StrToLong(Selected(16)))
					DlgText "EndPosBox",ValToStr(StrToVal(DlgText("EndPosBox"),StrToLong(TempList(16))),.FileSize,StrToLong(Selected(16)))
				End With
				If Selected(0) = TempList(0) Then
					If getMsgList(UIDataList,MsgList,"AddStringSet",1) = True Then
						DlgText "StartPosText",IIf(StrToLong(Selected(16)) = 0,MsgList(7),MsgList(27))
						DlgText "EndPosText",IIf(StrToLong(Selected(16)) = 0,MsgList(8),MsgList(28))
					End If
				End If
			End If
			If Selected(0) <> TempList(0) Then
				'重置非 PE 文件
				Select Case SourceFile.Magic
				Case "NotPE32","NotPE64",""
					If getMsgList(UIDataList,MsgList,"CheckFile",1) = True Then
						UseSectionList(0) = MsgList(10)
						SourceFile.SecList(0).sName = MsgList(10)
						TargetFile.SecList(0).sName = MsgList(10)
					End If
				Case Else
					If SourceFile.SecList(SourceFile.MaxSecIndex).lSizeOfRawData > 0 Then
						If getMsgList(UIDataList,MsgList,"CheckFile",1) = True Then
							For i = 0 To UBound(UseSectionList)
								If UseSectionList(i) = SourceFile.SecList(SourceFile.MaxSecIndex).sName Then
									UseSectionList(i) = MsgList(9)
									Exit For
								End If
							Next i
							SourceFile.SecList(SourceFile.MaxSecIndex).sName = MsgList(9)
							TargetFile.SecList(SourceFile.MaxSecIndex).sName = MsgList(9)
						End If
					End If
				End Select
				'重置当前对话框字串
				If getMsgList(UIDataList,MsgList,"AddStringSet",1) = True Then
					DlgText -1,MsgList(0)
					DlgText "Text",MsgList(1)
					DlgText "GetModeText",MsgList(2)
					DlgText "SingleGetMode",MsgList(3)
					DlgText "BatchGetMode",MsgList(4)
					DlgText "ByAddGetMode",MsgList(5)
					DlgText "ByStrGetMode",MsgList(6)
					DlgText "StartPosText",IIf(StrToLong(Selected(16)) = 0,MsgList(7),MsgList(27))
					DlgText "EndPosText",IIf(StrToLong(Selected(16)) = 0,MsgList(8),MsgList(28))
					DlgText "StartPosButton",MsgList(9)
					DlgText "EndPosButton",MsgList(9)
					DlgText "CodePageText",MsgList(10)
					DlgText "SkipHeadersCheckBox",MsgList(11)
					DlgText "SkipStrCheckBox",MsgList(12)
					DlgText "ViewFileInfoButton",MsgList(13)
					DlgText "GetStrSetButton",MsgList(14)
					DlgText "Tools",MsgList(15)
					DlgText "ResetButton",MsgList(16)
					If DlgText("StrTextBox") = DlgText("StrTextBoxBak") Then
						DlgText "StrTextBox",MsgList(17)
						DlgText "StrTextBoxBak",MsgList(17)
					End If
					'重置代码页名称列表
					i = DlgValue("CPNameList")
					TempList = GetLangStrList(UniLangList,4,True)
					DlgListBoxArray "CPValList",TempList()
					DlgValue "CPValList",i
					TempList = GetLangStrList(UniLangList,3,True)
					DlgListBoxArray "CPNameList",TempList()
					DlgValue "CPNameList",DlgValue("CPValList")
				End If
			End If
			'判断对话框字体是否已被改变
			If FontComp(LFList(0),tmpLFList(0)) = True Then
				MinVal = CLng(DlgText("SuppValueBox"))
				j = CreateFont(MinVal,LFList(0))
				If j = 0 Then Exit Function
				For i = 0 To DlgCount() - 1
					SendMessageLNG(GetDlgItem(MinVal,DlgControlId(DlgName(i))),WM_SETFONT,j,0)
				Next i
				DrawWindow(MinVal,j)
			End If
		Case "SkipHeadersCheckBox"
			If DlgValue("SkipHeadersCheckBox") = 0 Then
				i = StrToLong(AddStrSet(9))
				If i > 0 Then Exit Function
				AddStrSet(9) = CStr$(i + 1)
				If getMsgList(UIDataList,MsgList,"AddStringSet",1) = False Then Exit Function
				If MsgBox(MsgList(30),vbYesNo+vbInformation,MsgList(29)) = vbYes Then Exit Function
				DlgValue "SkipHeadersCheckBox",1
			End If
		End Select
	Case 3 ' 文本框或者组合框文本被更改
		Select Case DlgItem$
		Case "StartPosBox"
			DlgText "StartPosBox",UCase$(Trim$(DlgText("StartPosBox")))
			If DlgText("StartPosBox") = ValToStr(StrToLong(AddStrSet(4)),SourceFile.FileSize,StrToLong(Selected(16))) Then Exit Function
			If StrToLong(Selected(16)) = 0 Then
				If CheckStrRegExp(DlgText("StartPosBox"),"[0-9]",0,1) = False Then
					If getMsgList(UIDataList,MsgList,"AddStringSet",1) = False Then Exit Function
					MsgBox MsgList(19),vbOkOnly+vbInformation,MsgList(18)
					Exit Function
				End If
			Else
				If CheckStrRegExp(DlgText("StartPosBox"),CheckSkipStr(6),0,1,True) = False Then
					If getMsgList(UIDataList,MsgList,"AddStringSet",1) = False Then Exit Function
					MsgBox MsgList(19),vbOkOnly+vbInformation,MsgList(18)
					Exit Function
				End If
			End If
		Case "EndPosBox"
			DlgText "EndPosBox",UCase$(Trim$(DlgText("EndPosBox")))
			If DlgText("EndPosBox") = "" Then Exit Function
			If DlgText("EndPosBox") = ValToStr(StrToLong(AddStrSet(5)),SourceFile.FileSize,StrToLong(Selected(16))) Then Exit Function
			If StrToLong(Selected(16)) = 0 Then
				If CheckStrRegExp(DlgText("EndPosBox"),"[0-9]",0,1) = False Then
					If getMsgList(UIDataList,MsgList,"AddStringSet",1) = False Then Exit Function
					MsgBox MsgList(22),vbOkOnly+vbInformation,MsgList(18)
					Exit Function
				End If
			Else
				If CheckStrRegExp(DlgText("EndPosBox"),CheckSkipStr(6),0,1,True) = False Then
					If getMsgList(UIDataList,MsgList,"AddStringSet",1) = False Then Exit Function
					MsgBox MsgList(22),vbOkOnly+vbInformation,MsgList(18)
					Exit Function
				End If
			End If
		Case "StrTextBox"
			DlgText "StrTextBox",ReConvert(Convert(DlgText("StrTextBox")))
		End Select
	Case 6 ' 函数快捷键
		Select Case SuppValue
		Case 2, 11
			TempList = GetToolNameList(Tools,0)
			i = ShowPopupMenu(TempList,vbPopupUseRightButton)
			If i < 0 Then Exit Function
			Call FileInfoView(SourceFile,FreeByteList,i,0,StrToLong(Selected(16)))
		Case 9
			TempList = GetToolNameList(Tools,3)
			i = ShowPopupMenu(TempList,vbPopupUseRightButton)
			If i < 0 Then Exit Function
			ReDim TempList(0) As String
			TempList(0) = SourceFile.FilePath & JoinStr
			If OpenFile(SourceFile.FilePath,TempList,i + 3,False) = True Then
				If i = 0 Then WriteSettings("Tools")
			End If
		End Select
	End Select
End Function


'重置字串地址占用和被占用链(长度、代码页除外)
'Mode = 0 仅重置当前值为原始值，不重置被占用的关联值
'Mode = 1 重置当前值为原始值，并重置被占用的关联值
'Mode = 2 不重置当前值为原始值，但重置被占用的关联值
Private Function ResetStrVal(trnFile As FILE_PROPERTIE,DataList() As STRING_PROPERTIE,ByteList() As FREE_BTYE_SPACE, _
		ByVal Index As Long,ByVal Mode As Long,Optional ByVal Stemp As Boolean) As Boolean
	Dim i As Long,k As Long
	'If DataList(Index).Moveable > 0 Then GoTo ExitFunction
	If Mode < 2 Then
		With DataList(Index)
			k = .MoveType
			.MoveType = 0
			.Trans.MoveLength = 0
			.Trans.lStartAddress = .Source.lStartAddress + .Source.MoveLength
			.Trans.lMaxAddress = GetMaxAddress(DataList(Index),False)
			.Trans.lEndAddress = .Trans.lStartAddress + .Trans.lHexLength - 1
			.Trans.lMaxHexLength = .Trans.lMaxAddress - .Trans.lStartAddress + 1 - .EndByteLength - .Trans.iNullByteLength
			.Trans.inSectionID = .Source.inSectionID
			If .MoveMode = 0 Then .Trans.lReferenceNum = 0
			If .Moveable = 0 Or .Moveable = 2 Then
				Call GetVARefList(trnFile,"",.Trans,OrgStrTypeList,.TagType,.Moveable,"",1,0,0)
			End If
			'.SourceStringClearState = 0
			'.ScapeIDForMove = -1
			'.ScapeIDBeMoved = -1
			.WriteType = WriteType(trnFile,DataList(Index),WriteSet)
		End With

		i = DataList(Index).ScapeIDForMove
		If i > -1 Then
			'标记占用的字串空余空间为未被占用
			ByteList(FreeByteDic.Item(i)).MoveType = -1
			i = StrIDIndexDic.Item(i)
			With DataList(i)
				'标记占用的字串为未被其他字串占用
				.ScapeIDBeMoved = -1
				'还原占用的未移位字串空间为原始值
				If .ScapeIDForMove = -1 Then
					.Trans.lMaxAddress = GetMaxAddress(DataList(i),False)
					.Trans.lMaxHexLength = .Trans.lMaxAddress - .Trans.lStartAddress + 1 - .EndByteLength - .Trans.iNullByteLength
				End If
			End With
		ElseIf i < -1 Then
			If k < 3 Then
				'标记占用的非字串空余空间为未被占用
				ByteList(-i).MoveType = -1
			End If
		End If
		'标记当前字串为未占用其他空间
		DataList(Index).ScapeIDForMove = -1
	End If

	'重置被占用链中的所有字串
	If Mode > 0 Then
		i = DataList(Index).ScapeIDBeMoved
		If i <> -1 Then
			Stemp = True
			'标记当前字串空间未被其他字串占用
			DataList(Index).ScapeIDBeMoved = -1
			'重置被占用链中的所有字串为原始值，并释放所有被占用的空间
			i = StrIDIndexDic.Item(i)
			If DataList(i).MoveMode = 3 Then DataList(i).MoveMode = 0
			ResetStrVal(trnFile,DataList,ByteList,i,1,Stemp)
		End If
	End If
	ExitFunction:
	ResetStrVal = Stemp
End Function


'更改原被占用过的字串和可用空间为最大值
'Mode = 0 更改占用或被占用值
'Mode = 1 仅更改占用值
'Mode = 2 仅更改被占用值
Private Function ChangeStrVal(trnFile As FILE_PROPERTIE,DataList() As STRING_PROPERTIE,ByteList() As FREE_BTYE_SPACE,ByVal Index As Long,ByVal Mode As Long) As Boolean
	Dim i As Long
	If DataList(Index).Moveable > 0 Then Exit Function
	'更改未移位字串为最大值，并标记其空间为未占有
	If Mode < 2 And DataList(Index).ScapeIDForMove <> -1 Then
		i = DataList(Index).ScapeIDForMove
		If i > -1 Then
			ByteList(FreeByteDic.Item(i)).MoveType = -1
			i = StrIDIndexDic.Item(i)
			With DataList(i)
				If .ScapeIDForMove = -1 Then
					.Trans.lMaxAddress = GetMaxAddress(DataList(i),False)
					.Trans.lMaxHexLength = .Trans.lMaxAddress - .Trans.lStartAddress + 1 - .EndByteLength - .Trans.iNullByteLength
				End If
				.ScapeIDBeMoved = -1
				ChangeStrVal = True
			End With
		ElseIf i < -1 Then
			If DataList(Index).MoveType < 3 Then
				ByteList(-i).MoveType = -1
				ChangeStrVal = True
			End If
		End If
	'更改占有该空间的字串为当前字串的开始地址和最大可写长度
	ElseIf Mode <> 1 And DataList(Index).ScapeIDBeMoved <> -1 Then
		i = StrIDIndexDic.Item(DataList(Index).ScapeIDBeMoved)
		With DataList(i)
			If .Trans.lReferenceNum <> 0 Then
				.Trans.MoveLength = 0
				.Trans.lStartAddress = DataList(Index).Source.lStartAddress - DataList(Index).Source.StrTypeLength + .Trans.StrTypeLength
				.Trans.lEndAddress = .Trans.lStartAddress + .Trans.lHexLength - 1
				.Trans.lMaxAddress = GetMaxAddress(DataList(Index),False)
				.Trans.lMaxHexLength = .Trans.lMaxAddress - .Trans.lStartAddress + 1 - .EndByteLength - .Trans.iNullByteLength
				.Trans.inSectionID = DataList(Index).Source.inSectionID
				Call GetVARefList(trnFile,"",.Trans,OrgStrTypeList,.TagType,.Moveable,"",1,0,0)
			End If
		End With
		With DataList(Index)
			i = FreeByteDic.Item(.ID)
			ByteList(i).Address = .Source.lStartAddress - .Source.StrTypeLength
			ByteList(i).MaxAddress = GetMaxAddress(DataList(Index),False)
			ByteList(i).Length = ByteList(i).MaxAddress - ByteList(i).Address + 1
		End With
		ChangeStrVal = True
	End If
End Function


'检查字串数据值
'Mode = 0 比较原始和翻译的开始地址、字节长度和最大长度
'Mode = 1 比较原始和翻译的开始地址(对可变型字串长度标识符的字串类型长度更改值进行调整后的地址)、字节长度和最大长度
'Mode = 2 比较原始和翻译的开始地址
'Mode = 3 比较原始和翻译的开始地址(对可变型字串长度标识符的字串类型长度更改值进行调整后的地址)
'Mode = 4 比较原始和翻译的字节长度和最大长度
'Mode = 5 比较翻译的字节长度和最大长度
'Mode = 6 比较翻译的字节长度和最大长度，原始和翻译的字节长度和最大长度，用于判断是否需要移位操作
'MoveVal = 未移位前就存在的原始和翻译的地址差异值
Private Function CheckStrVal(strData As STRING_PROPERTIE,ByVal Mode As Long,Optional ByVal MoveVal As Long) As Boolean
	With strData
		Select Case Mode
		Case 0
			If .Trans.lStartAddress <> .Source.lStartAddress + MoveVal Then Exit Function
			If .OverLengthWrite = 0 Then
				If .Trans.lHexLength > .Source.lMaxHexLength Then Exit Function
			Else
				If .Trans.lHexLength > .Source.lHexLength Then Exit Function
			End If
			If .Trans.lHexLength > .Trans.lMaxHexLength Then Exit Function
		Case 1
			If .Trans.lStartAddress - .Trans.MoveLength <> .Source.lStartAddress + MoveVal + .Source.MoveLength Then Exit Function
			If .OverLengthWrite = 0 Then
				If .Trans.lHexLength > .Source.lMaxHexLength Then Exit Function
			Else
				If .Trans.lHexLength > .Source.lHexLength Then Exit Function
			End If
			If .Trans.lHexLength > .Trans.lMaxHexLength Then Exit Function
		Case 2
			If .Trans.lStartAddress <> .Source.lStartAddress + MoveVal Then Exit Function
		Case 3
			If .Trans.lStartAddress - .Trans.MoveLength <> .Source.lStartAddress + MoveVal + .Source.MoveLength Then Exit Function
		Case 4
			If .OverLengthWrite = 0 Then
				If .Trans.lHexLength > .Source.lMaxHexLength Then Exit Function
			Else
				If .Trans.lHexLength > .Source.lHexLength Then Exit Function
			End If
		Case 5
			If .Trans.lHexLength > .Trans.lMaxHexLength Then Exit Function
		Case 6
			If .Trans.lHexLength > .Trans.lMaxHexLength Then Exit Function
			If .ScapeIDForMove <> -1 Then
				If .OverLengthWrite = 0 Then
					If .Trans.lHexLength <= .Source.lMaxHexLength Then Exit Function
				Else
					If .Trans.lHexLength <= .Source.lHexLength Then Exit Function
				End If
			End If
		End Select
	End With
	CheckStrVal = True
End Function


'检查字串开始地址和是否首尾直接相连
Private Function CheckStrVals(DataList() As STRING_PROPERTIE,ByVal StrID As Long,ByVal MaxID As Long) As Boolean
	With DataList(StrID)
		If .SplitState < 0 Then Exit Function
		If StrID + .SplitState + 1 > MaxID Then
			If .Trans.lStartAddress - .Trans.MoveLength <> .Source.lStartAddress + .Source.MoveLength Then Exit Function
		ElseIf .Trans.lStartAddress - .Trans.MoveLength <> .Source.lStartAddress + .Source.MoveLength Then
			Exit Function
		Else
			StrID = StrID + .SplitState + 1
			If DataList(StrID).Source.lReferenceNum > 0 Then
				If .Source.lMaxAddress + 1 = DataList(StrID).Source.lStartAddress - DataList(StrID).Source.StrTypeLength Then Exit Function
			End If
		End If
	End With
	CheckStrVals = True
End Function


'检查并更改可变类型长度字串的开始地址
'注意：这里的 .lStartAddress 均为翻译文件的实际地址
Private Function ChangeStartAddress(strData As STRING_PROPERTIE,ByVal VerCompVal As Integer) As Boolean
	With strData
		Select Case .StrType
		Case Is < -4	'Android 字串类型
			If .Trans.lStartAddress = .Source.lStartAddress + .Source.MoveLength Then Exit Function
			If VerCompVal < 1 Then
				If Abs(.Trans.lStartAddress - .Source.lStartAddress) > Abs(8 - .Trans.StrTypeLength - .Trans.MoveLength) Then
					.Trans.lStartAddress = .Trans.lStartAddress + .Source.MoveLength
					Exit Function
				End If
			End If
			.Trans.lStartAddress = .Source.lStartAddress + .Source.MoveLength
		Case Is < 0		'.NET 字串类型
			If .Trans.lStartAddress = .Source.lStartAddress + .Source.MoveLength Then Exit Function
			If VerCompVal < 1 Then
				If Abs(.Trans.lStartAddress - .Source.lStartAddress) > Abs(4 - .Trans.StrTypeLength - .Trans.MoveLength) Then
					.Trans.lStartAddress = .Trans.lStartAddress + .Source.MoveLength
					Exit Function
				End If
			End If
			.Trans.lStartAddress = .Source.lStartAddress + .Source.MoveLength
		Case Is > 4		'自定义字串类型
			If .TagType > 1 Then Exit Function
			If .Trans.lStartAddress = .Source.lStartAddress + .Source.MoveLength Then Exit Function
			Select Case .LengthModeID
			Case 5, 6, 9
				If VerCompVal < 1 Then
					If Abs(.Trans.lStartAddress - .Source.lStartAddress) > Abs(4 - .Trans.StrTypeLength - .Trans.MoveLength) Then
						.Trans.lStartAddress = .Trans.lStartAddress + .Source.MoveLength
						Exit Function
					End If
				End If
				.Trans.lStartAddress = .Source.lStartAddress + .Source.MoveLength
			Case 7, 8
				If VerCompVal < 1 Then
					If Abs(.Trans.lStartAddress - .Source.lStartAddress) > Abs(8 - .Trans.StrTypeLength - .Trans.MoveLength) Then
						.Trans.lStartAddress = .Trans.lStartAddress + .Source.MoveLength
						Exit Function
					End If
				End If
				.Trans.lStartAddress = .Source.lStartAddress + .Source.MoveLength
			Case Else
				.Trans.lStartAddress = .Source.lStartAddress + .Source.MoveLength
			End Select
		Case Else
			Exit Function
		End Select
	End With
	ChangeStartAddress = True
End Function


'根据是否允许超长写入，获取最大允许地址
'Mode = False 根据是否已翻译获取原始字串的最大允许地址
'Mode = True  不论是否翻译获取原始字串的最大允许地址
Private Function GetMaxAddress(strData As STRING_PROPERTIE,ByVal Mode As Boolean) As Long
	With strData
		If .OverLengthWrite = 0 Then
			GetMaxAddress = .Source.lMaxAddress
		ElseIf Mode = False Then
			If .WriteType > -2 And .WriteType < 1 Then
				GetMaxAddress = .Source.lMaxAddress
			Else
				GetMaxAddress = .Source.lEndAddress + .EndByteLength + .Source.iNullByteLength
			End If
		Else
			GetMaxAddress = .Source.lEndAddress + .EndByteLength + .Source.iNullByteLength
		End If
	End With
End Function


'检查数据文件
'Mode <0 不获取文件中的字串类型数据，=0 获取文件中的字串类型数据，>0 合并原始、选用及文件中的字串类型数据
'Mode =0 获取文件中的引用类型数据
'DataType = False HCS 文件，否则 DAT 文件
Private Sub CheckData(ByVal orgFileName,trnFile As FILE_PROPERTIE,ByVal Data As String,ByVal DataType As Boolean, _
					TypeList() As STRING_TYPE,ByVal Mode As Long)
	Dim i As Long,TempArray() As String,TempList() As String
	If DataType = False Then
		TempArray = ReSplit(Data,TextJoinStr)
	Else
		TempArray = ReSplit(Data,vbNullChar)
	End If
	With trnFile.hcsFile
		For i = 0 To UBound(TempArray)
			Data = Trim$(TempArray(i))
			If Data <> "" Then
				If Left$(Data,1) <> ";" Then Exit For
				If InStr(Data,"Source File Name") Then
					.SourceFileName = Trim$(Mid$(Data,InStr(Data,":") + 1))
				ElseIf InStr(Data,"Source File Version") Then
					.SourceFileVersion = Trim$(Mid$(Data,InStr(Data,":") + 1))
				ElseIf InStr(Data,"Source File Size") Then
					.SourceFileSize = StrToLong(Trim(Mid$(Data,InStr(Data,":") + 1)))
				ElseIf InStr(Data,"Source File DateTime") Then
					Data = Trim$(Mid$(Data,InStr(Data,":") + 1))
					If IsDate(Data) Then
						.SourceFileDateTime = CDate(Data)
					Else
						.SourceFileDateTime = StrToDate(Data)
					End If
				ElseIf InStr(Data,"Source File LanguageID") Then
					.SourceFileLangID = Trim$(Mid$(Data,InStr(Data,":") + 1))
				ElseIf InStr(Data,"Application Version") Then
					.AppVersion = Trim$(Mid$(Data,InStr(Data,":") + 1))
				ElseIf InStr(Data,"Custom String Types") Then
					If Mode > -1 Then
						AddStrTypeList(TypeList,orgFileName,Trim$(Mid$(Data,InStr(Data,":") + 1)),Mode)
					End If
				ElseIf InStr(Data,"String Terminator") Then
					StringTerminator = Trim$(Mid$(Data,InStr(Data,":") + 1))
				ElseIf InStr(Data,"Reference Algorithm") Then
					If Mode < 1 Then
						AddRefTypeList(UseRefTypeList,orgFileName,Trim$(Mid$(Data,InStr(Data,":") + 1)),Mode)
					End If
				ElseIf InStr(Data,"Use Original Null Bytes at End of String for Write") Then
					If Mode < 1 Then
						Selected(10) = Trim$(Mid$(Data,InStr(Data,":") + 1))
						SelectedBak(10) = Selected(10)
					End If
				End If
			End If
		Next i
		If .AppVersion = "" Then .AppVersion = ToUpdateDataVersion
		'If UBound(ReSplit(ReSplit(Data,":")(0),ValJoinStr)) > 2 Then .FileFormat = True
		.FileFormat =  CheckStrRegExp(Data,"^(?:[0-9]+,){3,}[0-9,\|\-]+:[^\r\n]*",0,2)
	End With
End Sub


'修改数据文件中的大小和日期记录
'DifFile = 1 修改大小，= 10 修改日期，= 11 二者都修改
'DataType = False HCS 文件，否则 DAT 文件
Private Function ModifyDataFile(File As FILE_PROPERTIE,ByVal Data As String,ByVal DataType As Boolean,ByVal DifFile As Integer) As Boolean
	Dim i As Long,TempArray() As String,FileBak As FILE_PROPERTIE
	If DataType = False Then
		TempArray = ReSplit(Data,TextJoinStr)
	Else
		TempArray = ReSplit(Data,vbNullChar)
	End If
	FileBak = File
	With FileBak
		For i = 0 To UBound(TempArray)
			Data = Trim$(TempArray(i))
			If Data <> "" Then
				If Left$(Data,1) <> ";" Then Exit For
				Select Case DifFile
				Case 1
					If InStr(Data,"Source File Size") Then
						.hcsFile.SourceFileSize = .FileSize
						TempArray(i) = "; Source File Size: " & CStr$(.FileSize)
						ModifyDataFile = True
					End If
				Case 10
					If InStr(Data,"Source File DateTime") Then
						.hcsFile.SourceFileDateTime = .DateLastModified
						TempArray(i) = "; Source File DateTime: " & Format$(.DateLastModified,"yyyy-M-d H:mm:ss")
						ModifyDataFile = True
					End If
				Case 11
					If InStr(Data,"Source File Size") Then
						.hcsFile.SourceFileSize = .FileSize
						TempArray(i) = "; Source File Size: " & CStr$(.FileSize)
					ElseIf InStr(Data,"Source File DateTime") Then
						.hcsFile.SourceFileDateTime = .DateLastModified
						TempArray(i) = "; Source File DateTime: " & Format$(.DateLastModified,"yyyy-M-d H:mm:ss")
						ModifyDataFile = True
					End If
				End Select
			End If
		Next i
		If ModifyDataFile = False Then Exit Function
		If DataType = False Then
			ModifyDataFile = WriteToFile(.hcsFile.FilePath,StrListJoin(TempArray,TextJoinStr),"unicodeFFFE")
		Else
			ModifyDataFile = WriteBinaryFile(.hcsFile.FilePath,CP_UNICODELITTLE,StrListJoin(TempArray,vbNullChar),True)
		End If
	End With
	If ModifyDataFile = True Then File = FileBak
End Function


'转换包含非数字日期时间的字符串为日期
Private Function StrToDate(ByVal strDate As String) As Date
	Dim i As Long,Matches As Object
	With RegExp
		.Global = True
		.IgnoreCase = True
		.Pattern = "[^\x20-\x7E]+"
		Set Matches = .Execute(strDate)
		If Matches.Count > 0 Then
			For i = 0 To Matches.Count - 1
				strDate = Replace$(strDate,Matches(i).Value," ")
			Next i
		End If
	End With
	If IsDate(strDate) Then StrToDate = CDate(strDate)
End Function


'获取自定义字串类型列表(全部列表、原始列表、使用列表)
'Mode < 00 直接退出
'Mode = 00 使用文件中的字串类型数据
'Mode = 01 按文件、选用顺序合并字串类型数据
'Mode = 10 按原始、文件顺序合并字串类型数据
'Mode = 11 按原始、选用和文件顺序合并字串类型数据
'FileName = "" 直接退出
'返回 AddStrTypeList = True 表示有新增类型
Private Function AddStrTypeList(TypeList() As STRING_TYPE,ByVal FileName As String,ByVal Data As String,ByVal Mode As Long) As Boolean
	Dim i As Long,j As Long,k As Long,n As Long,Stemp As Boolean
	Dim TempArray() As String,TempList() As String,RuleDic As Object,NameDic As Object
	If FileName = "" Then Exit Function
	If Mode < 0 Then Exit Function
	ReDim TypeList(0) As STRING_TYPE
	If Mode > 0 Then
		ReDim TempList(2) As String
		If Mode <> 1 Then
			If CheckStrTypeArray(OrgStrTypeList) = True Then
				TempList(0) = StrTypeToString(OrgStrTypeList,-1)
				i = 1
			End If
		End If
		If Mode <> 10 Then
			If CheckStrTypeArray(UseStrTypeList) = True Then
				If Mode = 11 Then
					TempList(1) = StrTypeToString(UseStrTypeList,-1)
				Else
					TempList(2) = StrTypeToString(UseStrTypeList,-1)
				End If
				j = 1
			End If
		End If
		If Data <> "" Then
			If Mode = 11 Then TempList(2) = Data Else TempList(1) = Data
		ElseIf i + j < 2 Then
			If i = 1 Then
				TypeList = OrgStrTypeList
			ElseIf j = 1 Then
				TypeList = UseStrTypeList
			End If
			Exit Function
		End If
		Data = StrListJoin(TempList,RefJoinStr)
		TempArray = ClearTextArray(ReSplit(UCase$(Data),RefJoinStr),True)
	Else
		If Data = "" Then Exit Function
		TempArray = ReSplit(UCase$(Data),RefJoinStr)
	End If
	j = UBound(TempArray)
	If CheckStrTypeArray(StrTypeList) = True Then
		Set RuleDic = CreateObject("Scripting.Dictionary")
		Set NameDic = CreateObject("Scripting.Dictionary")
		n = UBound(StrTypeList)
		For i = 0 To n
			Data = StrTypeToString(StrTypeList,i)
			If Not RuleDic.Exists(Data) Then
				RuleDic.Add(Data,i)
			End If
			If Not NameDic.Exists(StrTypeList(i).sName) Then
				NameDic.Add(StrTypeList(i).sName,i)
			End If
		Next i
		Stemp = True
	End If
	ReDim TypeList(j) As STRING_TYPE
	ReDim Preserve StrTypeList(n + j + 1) As STRING_TYPE
	For i = 0 To UBound(TempArray)
		If TempArray(i) <> "" Then
			TempList = ReSplit(TempArray(i),ValJoinStr)
			Select Case UBound(TempList)
			Case Is < 9
				ReDim Preserve TempList(14) As String
				For j = 8 To 6 Step -1
					TempList(j + 1) = TempList(j)
				Next j
				TempList(6) = "1"
				TempList(10) = "0"
				TempList(12) = "0"
				TempList(13) = TempList(5)
				TempList(14) = TempList(5)
			Case Is < 12
				ReDim Preserve TempList(14) As String
				For j = 11 To 10 Step -1
					TempList(j + 1) = TempList(j)
				Next j
				TempList(10) = "0"
				TempList(12) = "0"
				TempList(13) = TempList(5)
				TempList(14) = TempList(5)
			Case Is < 14
				ReDim Preserve TempList(14) As String
				TempList(13) = TempList(5)
				TempList(14) = TempList(5)
			End Select
			With TypeList(k)
				.CodeLoc = StrToLong(TempList(12))
				.FristCodePos = StrToLong(TempList(0))
				.CPCodePos = StrToLong(TempList(1))
				.CPCodeSize = StrToLong(TempList(2))
				.LengthCodePos = StrToLong(TempList(3))
				.LengthCodeSize = StrToLong(TempList(4))
				.LengthReviseVal = StrToLong(TempList(5))
				.LengthMode = StrToLong(TempList(6))
				If .CodeLoc = 0 Then
					.StartCodePos = StrToLong(TempList(7))
					.StartCodeString = TempList(8)
					.StartCodeLength = Len(TempList(8)) \ 2
					.StartCodeByte = HexStr2Bytes(TempList(8))
					.EndCodeString = TempList(9)
					.EndCodeLength = Len(TempList(9)) \ 2
					.EndCodeByte = HexStr2Bytes(TempList(9))
				Else
					.CPCodeStartString = TempList(8)
					.CPCodeStartLength = Len(TempList(8)) \ 2
					.CPCodeStartByte = HexStr2Bytes(TempList(8))
					.LengthCodeStartString = TempList(9)
					.LengthCodeStartLength = Len(TempList(9)) \ 2
					.LengthCodeStartByte = HexStr2Bytes(TempList(9))
					.RefCodeStartPos = StrToLong(TempList(10))
					.RefCodeStartString = TempList(11)
					.RefCodeStartLength = Len(TempList(11)) \ 2
					.RefCodeStartByte = HexStr2Bytes(TempList(11))
				End If
				.ByteLengthReviseVal = StrToLong(TempList(13))
				.CharLengthReviseVal = StrToLong(TempList(14))
				If .LengthMode = 1 Or .LengthMode = 5 Then
					.CharLengthReviseVal = 0
				ElseIf .LengthMode = 2 Or .LengthMode = 6 Then
					.ByteLengthReviseVal = 0
				End If
				'转换自定义字串类型为正则表达式模板
				Call StrType2RegExpPattern(TypeList,k)
				If Stemp = True Then
					Data = StrTypeToString(TypeList,k)
					If Not RuleDic.Exists(Data) Then
						j = 0
						Do
							.sName = FileName & IIf(j = 0,"","_" & CStr$(j))
							If Not NameDic.Exists(.sName) Then Exit Do
							j = j + 1
						Loop
						n = n + 1
						StrTypeList(n) = TypeList(k)
						RuleDic.Add(Data,n)
						NameDic.Add(.sName,n)
						AddStrTypeList = True
					Else
						.sName = StrTypeList(RuleDic.Item(TempArray(i))).sName
					End If
				Else
					n = k
					.sName = FileName
					StrTypeList(n) = TypeList(k)
					AddStrTypeList = True
				End If
			End With
			k = k + 1
		End If
	Next i
	If k > 0 Then k = k - 1
	ReDim Preserve TypeList(k) As STRING_TYPE
	ReDim Preserve StrTypeList(n) As STRING_TYPE
	Set RuleDic = Nothing
	Set NameDic = Nothing
End Function


'转换字串数据为字串
'Mode = False 字串化所有字串参数，用于保存来源字串数据和全文查看和编辑
'Mode = True  只字串化所有原始字串参数以及重新生成 HCS 目标文件时丢失的翻译字串参数，并且字串化写入到 DAT 文件的字串参数
Private Function StrDataToString(orgFile As FILE_PROPERTIE,DataList() As STRING_PROPERTIE,TypeList() As STRING_TYPE,ByVal Mode As Boolean) As String()
	Dim i As Long,n As Long,m As Long,sb As Object
	ReDim List(12) As String
	List(0) = "; PslHardCodeString Data File"
	List(1) = "; " & String$(70,"-")
	List(2) = "; Application Version: " & Version
	List(3) = "; Source File Name: " & orgFile.OrigionalFileName
	List(4) = "; Source File Version: " & orgFile.FileVersion
	List(5) = "; Source File Size: " & CStr$(orgFile.FileSize)
	List(6) = "; Source File DateTime: " & Format$(orgFile.DateLastModified,"yyyy-M-d H:mm:ss")
	List(7) = "; Source File LanguageID: " & orgFile.LanguageID
	List(8) = "; Custom String Types: " & StrTypeToString(TypeList,-1)
	List(9) = "; String Terminator: " & StringTerminator
	List(10) = "; Reference Algorithm: " & UseRefTypeList(0).Template
	List(11) = "; Use Original Null Bytes at End of String for Write: " & Selected(10)
	List(12) = "; " & String$(70,"-")
	On Error Resume Next
	Set sb = CreateObject("System.Text.StringBuilder")
	On Error GoTo 0
	If sb Is Nothing Then
		ReDim TempList(UBound(DataList) + 1) As String
		TempList(0) = Join$(List,TextJoinStr)
		'编辑翻译字串时将写入地址、最大地址、选用引用地址、移位模式等参数信息
		'写入字串设置到数据文件，以免 PSL 重新生成翻译时被覆盖
		If Mode = False Then
			ReDim List(6) As String
			For i = LBound(DataList) To UBound(DataList)
				With DataList(i)
					If .iError <> 2 Then
						m = m + 1
						If .Source.inSectionID > orgFile.MaxSecIndex - 1 Then
							List(0) = IIf(.iError = 0,"",";") & CStr$(.Source.lStartAddress - HideSecMoveVal)
							List(1) = CStr$(.Trans.lStartAddress - .Source.MoveLength - .Trans.MoveLength - HideSecMoveVal)
							List(2) = CStr$(.Trans.lMaxAddress - HideSecMoveVal)
						Else
							List(0) = IIf(.iError = 0,"",";") & CStr$(.Source.lStartAddress)
							List(1) = CStr$(.Trans.lStartAddress - .Source.MoveLength - .Trans.MoveLength)
							List(2) = CStr$(.Trans.lMaxAddress)
						End If
						List(3) = CStr$(.Source.CodePage)
						List(4) = CStr$(.Trans.CodePage)
						'List(5) = StrListJoin(RefList2StrList(.Trans,0),RefJoinStr)
						List(6) = CStr$(.StrType) & ":" & .Source.sString
						TempList(m) = TextJoinStr & Join$(List,ValJoinStr) & TextJoinStr & .Trans.sString
					End If
				End With
			Next i
			ReDim Preserve TempList(m) As String
			ReDim List(1) As String
			List(0) = Join$(TempList,TextJoinStr) & TextJoinStr
			List(1) = ""
		Else
			ReDim iTempList(UBound(DataList) + 1) As String
			iTempList(0) = Join$(List,vbNullChar)
			ReDim List(6) As String
			For i = LBound(DataList) To UBound(DataList)
				With DataList(i)
					If .iError <> 2 Then
						m = m + 1
						If .Source.inSectionID > orgFile.MaxSecIndex - 1 Then
							List(0) = IIf(.iError = 0,"",";") & CStr$(.Source.lStartAddress - HideSecMoveVal)
						Else
							List(0) = IIf(.iError = 0,"",";") & CStr$(.Source.lStartAddress)
						End If
						List(1) = CStr$(.Trans.lStartAddress - .Source.MoveLength - .Trans.MoveLength)
						List(2) = CStr$(.Trans.lMaxAddress)
						List(3) = CStr$(.Source.CodePage)
						List(4) = CStr$(.Trans.CodePage)
						List(5) = StrListJoin(RefList2StrList(.Trans,0),RefJoinStr)
						List(6) = CStr$(.StrType) & ":" & .Source.sString
						TempList(m) = TextJoinStr & Join$(List,ValJoinStr) & TextJoinStr & .Trans.sString
						If .WriteType > 0 Or .SplitState <> 0 Then
							n = n + 1
							If .Source.GetRefState = 0 Then
								List(6) = CStr$(.StrType) & ValJoinStr & CStr$(.MoveMode) & ValJoinStr & _
									  	CStr$(.SplitState) & ValJoinStr & CStr$(.OverLengthWrite) & ValJoinStr & _
									 	CStr$(.FillLength) & ValJoinStr & "0" & ValJoinStr & _
									 	"0" & ValJoinStr & CStr$(.LockState) & ":"
							Else
								List(6) = CStr$(.StrType) & ValJoinStr & CStr$(.MoveMode) & ValJoinStr & _
										CStr$(.SplitState) & ValJoinStr & CStr$(.OverLengthWrite) & ValJoinStr & _
										CStr$(.FillLength) & ValJoinStr & StrListJoin(RefList2StrList(.Source,0),RefJoinStr) & ValJoinStr & _
										"0" & ValJoinStr & CStr$(.LockState) & ":"
							End If
							If .SplitState < 0 Then
								List(6) = List(6) & .Trans.sString
							ElseIf .WriteType > 0 Then
								If .Trans.sString = .Source.sString Then
									List(6) = List(6) & .Trans.sString
								ElseIf .iError > 0 Then
									List(6) = List(6) & .Trans.sString
								End If
							End If
							iTempList(n) = Join$(List,ValJoinStr)
						End If
					End If
				End With
			Next i
			ReDim Preserve TempList(m) As String,iTempList(n) As String
			ReDim List(1) As String
			List(0) = Join$(TempList,TextJoinStr) & TextJoinStr
			List(1) = Join$(iTempList,vbNullChar) & vbNullChar
		End If
	Else
		sb.AppendFormat("{0}",StrListJoin(List,TextJoinStr,True))
		'编辑翻译字串时将写入地址、最大地址、选用引用地址、移位模式等参数信息
		'写入字串设置到数据文件，以免 PSL 重新生成翻译时被覆盖
		If Mode = False Then
			ReDim List(6) As String
			For i = LBound(DataList) To UBound(DataList)
				With DataList(i)
					If .iError <> 2 Then
						If .Source.inSectionID > orgFile.MaxSecIndex - 1 Then
							List(0) = IIf(.iError = 0,"",";") & CStr$(.Source.lStartAddress - HideSecMoveVal)
							List(1) = CStr$(.Trans.lStartAddress - .Source.MoveLength - .Trans.MoveLength - HideSecMoveVal)
							List(2) = CStr$(.Trans.lMaxAddress - HideSecMoveVal)
						Else
							List(0) = IIf(.iError = 0,"",";") & CStr$(.Source.lStartAddress)
							List(1) = CStr$(.Trans.lStartAddress - .Source.MoveLength - .Trans.MoveLength)
							List(2) = CStr$(.Trans.lMaxAddress)
						End If
						List(3) = CStr$(.Source.CodePage)
						List(4) = CStr$(.Trans.CodePage)
						'List(5) = StrListJoin(RefList2StrList(.Trans,0),RefJoinStr)
						List(6) = CStr$(.StrType) & ":" & .Source.sString
						sb.AppendFormat("{0}",TextJoinStr & StrListJoin(List,ValJoinStr) & TextJoinStr & .Trans.sString & TextJoinStr)
					End If
				End With
			Next i
			ReDim List(1) As String
			List(0) = sb.ToString()
		Else
			Dim isb As Object
			Set isb = CreateObject("System.Text.StringBuilder")
			isb.AppendFormat("{0}",StrListJoin(List,vbNullChar,True))
			ReDim List(6) As String
			For i = LBound(DataList) To UBound(DataList)
				With DataList(i)
					If .iError <> 2 Then
						If .Source.inSectionID > orgFile.MaxSecIndex - 1 Then
							List(0) = IIf(.iError = 0,"",";") & CStr$(.Source.lStartAddress - HideSecMoveVal)
						Else
							List(0) = IIf(.iError = 0,"",";") & CStr$(.Source.lStartAddress)
						End If
						List(1) = CStr$(.Trans.lStartAddress - .Source.MoveLength - .Trans.MoveLength)
						List(2) = CStr$(.Trans.lMaxAddress)
						List(3) = CStr$(.Source.CodePage)
						List(4) = CStr$(.Trans.CodePage)
						List(5) = StrListJoin(RefList2StrList(.Trans,0),RefJoinStr)
						List(6) = CStr$(.StrType) & ":" & .Source.sString
						sb.AppendFormat("{0}",TextJoinStr & StrListJoin(List,ValJoinStr) & TextJoinStr & .Trans.sString & TextJoinStr)
						If .WriteType > 0 Or .SplitState <> 0 Then
							If .Source.GetRefState = 0 Then
								List(6) = CStr$(.StrType) & ValJoinStr & CStr$(.MoveMode) & ValJoinStr & _
									  	CStr$(.SplitState) & ValJoinStr & CStr$(.OverLengthWrite) & ValJoinStr & _
									 	CStr$(.FillLength) & ValJoinStr & "0" & ValJoinStr & _
									 	"0" & ValJoinStr & CStr$(.LockState) & ":"
							Else
								List(6) = CStr$(.StrType) & ValJoinStr & CStr$(.MoveMode) & ValJoinStr & _
										CStr$(.SplitState) & ValJoinStr & CStr$(.OverLengthWrite) & ValJoinStr & _
										CStr$(.FillLength) & ValJoinStr & StrListJoin(RefList2StrList(.Source,0),RefJoinStr) & ValJoinStr & _
										"0" & ValJoinStr & CStr$(.LockState) & ":"
							End If
							If .SplitState < 0 Then
								List(6) = List(6) & .Trans.sString
							ElseIf .WriteType > 0 Then
								If .Trans.sString = .Source.sString Then
									List(6) = List(6) & .Trans.sString
								ElseIf .iError > 0 Then
									List(6) = List(6) & .Trans.sString
								End If
							End If
							isb.AppendFormat("{0}",StrListJoin(List,ValJoinStr) & vbNullChar)
						End If
					End If
				End With
			Next i
			ReDim List(1) As String
			List(0) = sb.ToString()
			List(1) = isb.ToString()
			Set isb = Nothing
		End If
	End If
	Set sb = Nothing
	StrDataToString = List
End Function


'写入字串数据到文件
'Mode = False 写入所有字串参数，用于保存来源字串数据
'Mode = True  只写入所有原始字串参数以及重新生成 HCS 目标文件时丢失的翻译字串参数，并且字串化写入到 DAT 文件的字串参数
Private Function SaveStrData(ByVal FilePath As String,ByVal DatFilePath As String,orgFile As FILE_PROPERTIE,DataList() As STRING_PROPERTIE, _
		TypeList() As STRING_TYPE,ByVal Mode As Boolean) As Boolean
	Dim i As Long,FN1 As Variant,FN2 As Variant
	'打开文件
	On Error GoTo ErrHandle
	If Mode = False Then
		If Dir$(FilePath) <> "" Then Kill FilePath
		FN1 = FreeFile
		Open FilePath For Binary Access Write Lock Write As #FN1
	Else
		If Dir$(FilePath) <> "" Then Kill FilePath
		If Dir$(DatFilePath) <> "" Then Kill DatFilePath
		FN1 = FreeFile
		Open FilePath For Binary Access Write Lock Write As #FN1
		FN2 = FreeFile
		Open DatFilePath For Binary Access Write Lock Write As #FN2
	End If
	ReDim List(12) As String
	List(0) = "; PslHardCodeString Data File"
	List(1) = "; " & String$(70,"-")
	List(2) = "; Application Version: " & Version
	List(3) = "; Source File Name: " & orgFile.OrigionalFileName
	List(4) = "; Source File Version: " & orgFile.FileVersion
	List(5) = "; Source File Size: " & CStr$(orgFile.FileSize)
	List(6) = "; Source File DateTime: " & Format$(orgFile.DateLastModified,"yyyy-M-d H:mm:ss")
	List(7) = "; Source File LanguageID: " & orgFile.LanguageID
	List(8) = "; Custom String Types: " & StrTypeToString(TypeList,-1)
	List(9) = "; String Terminator: " & StringTerminator
	List(10) = "; Reference Algorithm: " & UseRefTypeList(0).Template
	List(11) = "; Use Original Null Bytes at End of String for Write: " & Selected(10)
	List(12) = "; " & String$(70,"-")
	WriteBinaryFile FN1,CP_UNICODELITTLE,StrListJoin(List,TextJoinStr) & TextJoinStr
	If Mode = True Then WriteBinaryFile FN2,CP_UNICODELITTLE,StrListJoin(List,vbNullChar)
	'编辑翻译字串时将写入地址、最大地址、选用引用地址、移位模式等参数信息
	'写入字串设置到数据文件，以免 PSL 重新生成翻译时被覆盖
	ReDim List(6) As String
	If Mode = False Then
		For i = LBound(DataList) To UBound(DataList)
			With DataList(i)
				If .iError <> 2 Then
					If .Source.inSectionID > orgFile.MaxSecIndex - 1 Then
						List(0) = IIf(.iError = 0,"",";") & CStr$(.Source.lStartAddress - HideSecMoveVal)
						List(1) = CStr$(.Trans.lStartAddress - .Source.MoveLength - .Trans.MoveLength - HideSecMoveVal)
						List(2) = CStr$(.Trans.lMaxAddress - HideSecMoveVal)
					Else
						List(0) = IIf(.iError = 0,"",";") & CStr$(.Source.lStartAddress)
						List(1) = CStr$(.Trans.lStartAddress - .Source.MoveLength - .Trans.MoveLength)
						List(2) = CStr$(.Trans.lMaxAddress)
					End If
					List(3) = CStr$(.Source.CodePage)
					List(4) = CStr$(.Trans.CodePage)
					List(5) = StrListJoin(RefList2StrList(.Trans,0),RefJoinStr)
					List(6) = CStr$(.StrType) & ":" & .Source.sString
					WriteBinaryFile FN1,CP_UNICODELITTLE,TextJoinStr & StrListJoin(List,ValJoinStr) & TextJoinStr & .Trans.sString & TextJoinStr,True
				End If
			End With
		Next i
	Else
		For i = LBound(DataList) To UBound(DataList)
			With DataList(i)
				If .iError <> 2 Then
					If .Source.inSectionID > orgFile.MaxSecIndex - 1 Then
						List(0) = IIf(.iError = 0,"",";") & CStr$(.Source.lStartAddress - HideSecMoveVal)
					Else
						List(0) = IIf(.iError = 0,"",";") & CStr$(.Source.lStartAddress)
					End If
					List(1) = CStr$(.Trans.lStartAddress - .Source.MoveLength - .Trans.MoveLength)
					List(2) = CStr$(.Trans.lMaxAddress)
					List(3) = CStr$(.Source.CodePage)
					List(4) = CStr$(.Trans.CodePage)
					List(5) = StrListJoin(RefList2StrList(.Trans,0),RefJoinStr)
					List(6) = CStr$(.StrType) & ":" & .Source.sString
					WriteBinaryFile FN1,CP_UNICODELITTLE,TextJoinStr & StrListJoin(List,ValJoinStr) & TextJoinStr & .Trans.sString & TextJoinStr,True
					If .WriteType > 0 Or .SplitState <> 0 Then
						If .Source.GetRefState = 0 Then
							List(6) = CStr$(.StrType) & ValJoinStr & CStr$(.MoveMode) & ValJoinStr & _
									CStr$(.SplitState) & ValJoinStr & CStr$(.OverLengthWrite) & ValJoinStr & _
									CStr$(.FillLength) & ValJoinStr & "0" & ValJoinStr & _
									"0" & ValJoinStr & CStr$(.LockState) & ":"
						Else
							List(6) = CStr$(.StrType) & ValJoinStr & CStr$(.MoveMode) & ValJoinStr & _
									CStr$(.SplitState) & ValJoinStr & CStr$(.OverLengthWrite) & ValJoinStr & _
									CStr$(.FillLength) & ValJoinStr & StrListJoin(RefList2StrList(.Source,0),RefJoinStr) & ValJoinStr & _
									"0" & ValJoinStr & CStr$(.LockState) & ":"
						End If
						If .SplitState < 0 Then
							List(6) = List(6) & .Trans.sString
						ElseIf .WriteType > 0 Then
							If .Trans.sString = .Source.sString Then
								List(6) = List(6) & .Trans.sString
							ElseIf .iError > 0 Then
								List(6) = List(6) & .Trans.sString
							End If
						End If
						WriteBinaryFile FN2,CP_UNICODELITTLE,vbNullChar & StrListJoin(List,ValJoinStr),True
					End If
				End If
			End With
		Next i
	End If
	Close #FN1
	If Mode = True Then Close #FN2
	SaveStrData = True
	Exit Function
	'错误处理
	ErrHandle:
	On Error Resume Next
	Close #FN1
	Err.Source = "NotWriteFile"
	If Mode = False Then
		Err.Description = Err.Description & JoinStr & FilePath
	Else
		Close #FN2
		Err.Description = Err.Description & JoinStr & FilePath & TextJoinStr & DatFilePath
	End If
	Call sysErrorMassage(Err,1)
End Function


'转换自定义字符串类型为字串
Private Function StrTypeToString(TypeList() As STRING_TYPE,ByVal Index As Long) As String
	Dim i As Long,Min As Long,Max As Long,List(14) As String
	If CheckStrTypeArray(TypeList) = False Then Exit Function
	If Index > -1 Then
		Min = Index: Max = Index
		ReDim TempList(0) As String
	Else
		Min = LBound(TypeList): Max = UBound(TypeList)
		ReDim TempList(Min To Max) As String
	End If
	For i = Min To Max
		With TypeList(i)
			List(0) = CStr(.FristCodePos)
			List(1) = CStr(.CPCodePos)
			List(2) = CStr(.CPCodeSize)
			List(3) = CStr(.LengthCodePos)
			List(4) = CStr(.LengthCodeSize)
			List(5) = CStr(.LengthReviseVal)
			List(6) = CStr(.LengthMode)
			If .CodeLoc = 0 Then
				List(7) = CStr(.StartCodePos)
				List(8) = .StartCodeString
				List(9) = .EndCodeString
				List(10) = "0"
				List(11) = ""
			Else
				List(7) = "0"
				List(8) = .CPCodeStartString
				List(9) = .LengthCodeStartString
				List(10) = CStr(.RefCodeStartPos)
				List(11) = .RefCodeStartString
			End If
			List(12) = CStr(.CodeLoc)
			List(13) = CStr(.ByteLengthReviseVal)
			List(14) = CStr(.CharLengthReviseVal)
			If Index > -1 Then
				TempList(0) = StrListJoin(List,ValJoinStr)
			Else
				TempList(i) = StrListJoin(List,ValJoinStr)
			End If
		End With
	Next i
	StrTypeToString = StrListJoin(TempList,RefJoinStr)
End Function


'解析字串数据文件
'DifFile 是否允许 DAT 中记录的原始文件大小和日期和实际不同，False = 不允许，True = 允许并修改
'ParseHCSFile 返回值，-3 = 用户取消，-2 = 因有检测不到的字串而取消 ，-1 = 没有成功，0 = 成功但不需要移位，>0 = 需要移位字串数
Private Function ParseHCSFile(orgFile As FILE_PROPERTIE,trnFile As FILE_PROPERTIE, _
		ByVal Data As String,ByVal Mode As Long,ByVal DifFile As Boolean,ByVal ShowMsg As Long) As Long
	Dim i As Long,j As Long,k As Long,m As Long,n As Long,x As Long,y As Long,t As Long
	Dim SetArray() As String,FN As FILE_IMAGE,MsgList() As String
	Dim Matches As Object,SectionDic As Object,AnsiCPDic As Object,UnicodeDic As Object,orgMaxPosDic As Object
	Dim StrCompVal As Integer,VerCompVal As Integer,RefCompVal As Integer,VACompVal As Integer
	Dim orgMinVal As Long,orgMaxVal As Long,orgSecID As Integer
	Dim trnMinVal As Long,trnMaxVal As Long,trnSecID As Integer
	Dim orgSubMinVal As Long,orgSubMaxVal As Long,orgSubSecID As Integer
	Dim trnSubMinVal As Long,trnSubMaxVal As Long,trnSubSecID As Integer
	Dim StrNums As Long,StrNo As Long,SubStrNo As Long,SplitState As Long,OverWrite As Integer
	Dim DatDic As Object,iMatches As Object,Dic As Object,FreeByteDicBak As Object
	Dim iSetArray() As String,TempList() As String,ParentStrNumBak As Long,EndChar As String
	Dim UseSectionListBak() As String,UseSubSecListBak() As String,UseLangListBak() As LANG_PROPERTIE
	If trnFile.hcsFile.FilePath = orgFile.hcsFile.FilePath Then ParseHCSFile = -1
	If getMsgList(UIDataList,MsgList,"ParseHCSFile",1) = False Then Exit Function
	'打开翻译文件
	Mode = LoadFile(trnFile.FilePath,FN,0,0,0,Mode)
	If Mode < -1 Then
		ParseHCSFile = -1
		Exit Function
	End If
	'执行正则表达式
	RegExp.Global = True
	RegExp.IgnoreCase = False
	If ParseHCSFile = -1 Then
		RegExp.Pattern = "[\r\n]+(;)?([0-9,\|\-]{4,}):([^\r\n]+)[\r\n]+[^\r\n]+"
	Else
		RegExp.Pattern = "[\r\n]+(;)?([0-9,\|\-]{4,}):([^\r\n]+)[\r\n]+([^\r\n]+)"
	End If
	Set Matches = RegExp.Execute(Data)
	Data = ""
	'没有匹配的字串时退出
	If Matches.Count = 0 Then
		ReDim DataList(0) As STRING_PROPERTIE
		ParseHCSFile = -1
		GoTo ExitFunction
	End If
	'获取 HCS 的 DAT 文件的字串参数
	If ParseHCSFile > -1 Then
		'检查 DAT 文件是否适用
		Dim File As FILE_PROPERTIE
		File = orgFile
		With File.hcsFile
			.FilePath = trnFile.FilePath & ".dat"
			i = InStrRev(LCase$(trnFile.FilePath),".bak")
			If i > 1 Then
				If Mid$(LCase$(trnFile.FilePath),i) = ".bak" Then
					.FilePath = Left$(trnFile.FilePath,i - 1) & ".dat"
				End If
			End If
			If Dir$(.FilePath) <> "" Then
				If DifFile = False Then
					If orgFile.DateLastModified > FileDateTime(.FilePath) Then
						StrNums = StrNums + 1
					End If
				End If
				If StrNums = 0 Then
					Data = ReadBinaryFile(.FilePath,CP_UNICODELITTLE,True)
					Call CheckData(orgFile.FileName,File,Data,True,UseStrTypeList,-1)
					If UseRefTypeList(1).Template <> UseRefTypeList(0).Template Then
						StrNums = StrNums + 1
					ElseIf .SourceFileName <> orgFile.OrigionalFileName Then
						StrNums = StrNums + 1
					ElseIf .SourceFileVersion <> orgFile.FileVersion Then
						StrNums = StrNums + 1
					ElseIf .SourceFileLangID <> orgFile.LanguageID Then
						StrNums = StrNums + 1
					ElseIf .FileFormat = False Then
						StrNums = StrNums + 1
					ElseIf DifFile = False Then
						If .SourceFileSize <> orgFile.FileSize Then
							StrNums = StrNums + 1
						Else
							Select Case DateDiff("s",orgFile.DateLastModified,.SourceFileDateTime)
							Case Is < -5
								StrNums = StrNums + 1
							Case Is > 5
								StrNums = StrNums + 1
							End Select
						End If
					End If
				End If
				'执行正则表达式
				If StrNums = 0 Then
					RegExp.Global = True
					RegExp.IgnoreCase = False
					RegExp.Pattern = "[\r\n](;)?([0-9,\|\-]{4,}):([^\r\n]*)"
					Set iMatches = RegExp.Execute(Replace$(Data,vbNullChar,TextJoinStr))
					StrNums = iMatches.Count
					Data = ""
					'创建 DAT 中的字串开始地址和索引字典
					If StrNums > 0 Then
						Set DatDic = CreateObject("Scripting.Dictionary")
						For i = 0 To iMatches.Count - 1
							SetArray = ReSplit(iMatches(i).SubMatches(1),ValJoinStr)
							If Not DatDic.Exists(SetArray(0)) Then DatDic.Add(SetArray(0),i)
						Next i
					End If
					trnFile.hcsFile.AppVersion = File.hcsFile.AppVersion
				Else
					StrNums = 0
				End If
			End If
		End With
	End If
	'获取字符串结束符的正则表达式模板
	EndChar = Mid(StringTerminator,InStr(StringTerminator,"(") + 1)
	EndChar = Left(EndChar,InStrRev(EndChar,")") - 1)
	'初始化有关数据
	TempList = ExtractSet
	For i = 1 To 10
		TempList(i) = "0"
	Next i
	TempList(4) = "0000000"
	TempList(48) = "0"
	If trnFile.Magic = "" Then
		TempList(11) = "0"
	Else
		Set SectionDic = CreateObject("Scripting.Dictionary")
		If ParseHCSFile > -1 Then
			OverWrite = StrToLong(Selected(10))
			Set orgMaxPosDic = CreateObject("Scripting.Dictionary")
			'为了可以中途可以终止而这样处理
			Set FreeByteDicBak = CreateObject("Scripting.Dictionary")
		End If
	End If
	StrCompVal = StrComp(ToUpdateDataVersion,trnFile.hcsFile.AppVersion)
	If StrComp(trnFile.hcsFile.AppVersion,"2015.05.14") < 0 Then
		VerCompVal = 1
	ElseIf StrComp(trnFile.hcsFile.AppVersion,"2015.06.07") < 1 Then
		VerCompVal = 2
	End If
	RefCompVal = StrComp(trnFile.hcsFile.AppVersion,"2017.05.14")
	VACompVal = StrComp(trnFile.hcsFile.AppVersion,"2018.02.10")
	orgSecID = SkipSection(orgFile,orgFile.SecList(orgFile.MinSecID).lPointerToRawData,orgMinVal,orgMaxVal,1)
	trnSecID = SkipSection(trnFile,trnFile.SecList(orgFile.MinSecID).lPointerToRawData,trnMinVal,trnMaxVal,1)
	If InStr(trnFile.Magic,"MAC") = 0 Then orgSubSecID = -1
	'创建适合多种语言的代码页字典
	Set AnsiCPDic = CreateObject("Scripting.Dictionary")
	For i = 0 To UBound(AllLangList)
		With AllLangList(i)
			If Not AnsiCPDic.Exists(.CodePage) Then
				AnsiCPDic.Add(.CodePage,i)
			Else
				AnsiCPDic.Item(.CodePage) = AnsiCPDic.Item(.CodePage) & ItemJoinStr & i
			End If
		End With
	Next i
	'显示主窗口的取消操作按钮和禁止主窗口的 Esc 键响应退出主窗口
	Call ShowButton(StopHwnd,VK_ESCAPE,True)
	'开始解析 HCS 数据文件
	StrNo = -1
	Set Dic = CreateObject("Scripting.Dictionary")
	Set UnicodeDic = CreateObject("Scripting.Dictionary")
	UnicodeDic.Add(CP_UNICODELITTLE,0)
	UnicodeDic.Add(CP_UNICODEBIG,1)
	UnicodeDic.Add(CP_UTF7,2)
	UnicodeDic.Add(CP_UTF8,3)
	UnicodeDic.Add(CP_UTF32LE,4)
	UnicodeDic.Add(CP_UTF32BE,5)
	ReDim DataList(Matches.Count * 2) As STRING_PROPERTIE
	ReDim RefAddList(Matches.Count * 2) As String,intList(Matches.Count * 2) As Long
	UseSectionListBak = UseSectionList
	UseSubSecListBak = UseSubSecList
	UseLangListBak = UseLangList
	ReDim Preserve UseSectionListBak(orgFile.MaxSecIndex) As String
	ReDim Preserve UseSubSecListBak(orgFile.MaxSecIndex * 50) As String
	ReDim Preserve UseLangListBak(UBound(UniLangList)) As LANG_PROPERTIE
	For i = 0 To Matches.Count - 1
		Do
			With DataList(t)
				SetArray = ReSplit(Matches(i).SubMatches(1),ValJoinStr)
				'更新旧数据文件的数据
				If StrCompVal = 1 Then
					Select Case UBound(SetArray)
					Case 3
						ReDim Preserve SetArray(6) As String
						SetArray(5) = SetArray(3)
						SetArray(4) = SetArray(2)
						SetArray(3) = SetArray(2)
						SetArray(2) = ""
						If SetArray(3) = CStr(CP_UNICODEBIG) Then SetArray(3) = CStr(CP_UNICODELITTLE)
						If SetArray(4) = CStr(CP_UNICODEBIG) Then SetArray(4) = CStr(CP_UNICODELITTLE)
					Case 4
						ReDim Preserve SetArray(6) As String
						SetArray(5) = SetArray(4)
						SetArray(4) = SetArray(3)
						If SetArray(3) = CStr(CP_UNICODEBIG) Then SetArray(3) = CStr(CP_UNICODELITTLE)
						If SetArray(4) = CStr(CP_UNICODEBIG) Then SetArray(4) = CStr(CP_UNICODELITTLE)
					Case 5
						ReDim Preserve SetArray(6) As String
					End Select
				End If
				'获取来源字串的基本数据
				SplitState = 0: StrNo = -1
				Data = Convert(Matches(i).SubMatches(2))
				.Source.sString = ReConvert(Data)
				.Source.lStartAddress = StrToLong(SetArray(0))
				.Source.CodePage = StrToLong(SetArray(3))
				.Source.lHexLength = StrHexLength(Data,.Source.CodePage,0)
				'获取字串所在区段ID
				If orgFile.Magic <> "" Then
					If .Source.lStartAddress < orgMinVal Or .Source.lStartAddress > orgMaxVal Then
						orgSecID = SkipSection(orgFile,.Source.lStartAddress,orgMinVal,orgMaxVal,1)
					End If
					If orgSecID < 0 Then GoTo NextNo
					.Source.inSectionID = orgSecID
					.Source.inSubSecID = -1
					If orgSubSecID > -1 Then
						If .Source.lStartAddress < orgSubMinVal Or .Source.lStartAddress > orgSubMaxVal Then
							orgSubSecID = SkipSubSection(orgFile.SecList(.Source.inSectionID), _
										.Source.lStartAddress,orgSubMinVal,orgSubMaxVal)
						End If
						.Source.inSubSecID = orgSubSecID
					End If
				End If
				'更改来源字串的开始地址为翻译文件中的地址(隐藏区段)
				If .Source.inSectionID > orgFile.MaxSecIndex - 1 Then
					.Source.lStartAddress = .Source.lStartAddress + HideSecMoveVal
				End If
				'检查原始字串是否存在，不存在时跳过
				If Data <> ByteToString(GetBytes(FN,.Source.lHexLength,.Source.lStartAddress,Mode),.Source.CodePage) Then
					.Missing = 1: .WriteType = -1
					m = m + 1
				End If
				'获取后面需要用到的参数
				.iError = IIf(Matches(i).SubMatches(0) = ";",1,0)
				.OverLengthWrite = OverWrite
				'获取字串的主数据
				.ID = .Source.lStartAddress
				.StrType = StrToLong(SetArray(6))
				.TagType = TagType(.StrType,OrgStrTypeList)
				.EndByteLength = EndByteLength(.StrType,OrgStrTypeList)
				.ScapeIDBeMoved = -1
				.ScapeIDForMove = -1
				.Moveable = Moveable(orgFile,DataList(t))
				'获取来源字串的其他数据
				.Source.lCharLength = Len(Data)
				.Source.lEndAddress = .Source.lStartAddress + .Source.lHexLength - 1
				If .Missing = 0 Then
					'.Source.lMaxAddress = getNotNullByte(FN,.Source.lEndAddress + .EndByteLength + 1,orgMaxVal,Mode) - 1
					.Source.lMaxAddress = getEndByteRegExp(FN,.Source.lEndAddress + .EndByteLength + 1,orgMaxVal,Mode,EndChar,CP_ISOLATIN1,True) - 1
					'避开 Delphi 窗体代码
					If orgFile.LangType = DELPHI_FILE_SIGNATURE And .Source.lMaxAddress + 6 < orgMaxVal Then
						If GetLong(FN,.Source.lMaxAddress + 1,Mode) = &HFFFFFFFF Then
							If .Source.lMaxAddress - 4 > .Source.lEndAddress Then
								.Source.lMaxAddress = .Source.lMaxAddress - 4
							End If
						End If
					End If
				Else
					.Source.lMaxAddress = .Source.lEndAddress
				End If
				.Source.iNullByteLength = NullByteLength(DataList(t),False)
				.Source.lMaxHexLength = .Source.lMaxAddress - .Source.lStartAddress + 1 - .EndByteLength - .Source.iNullByteLength
				If StrNums > 0 Then
					'翻译字串和代码页等于原始字串和代码页的，说明字串没有翻译
					If DatDic.Exists(SetArray(0)) Then
						StrNo = DatDic.Item(SetArray(0))
						iSetArray = ReSplit(iMatches(StrNo).SubMatches(1),ValJoinStr)
						If StrToLong(iSetArray(7)) > 2 Then
							.MoveMode = StrToLong(iSetArray(7))
							SetArray(1) = iSetArray(1)
							SetArray(2) = iSetArray(2)
						End If
						If SetArray(5) = "" Then
							SetArray(4) = iSetArray(4)
							SetArray(5) = iSetArray(5)
							SplitState = StrToLong(iSetArray(8))
							If SplitState > 0 Then
								SubStrNo = SplitState
								DatDic.Item(SetArray(0)) = StrNo + 1
							ElseIf SplitState < 0 Then
								SubStrNo = SubStrNo - 1
								If SubStrNo > 0 Then
									DatDic.Item(SetArray(0)) = StrNo + 1
								Else
									DatDic.Remove(SetArray(0))
								End If
							Else
								SubStrNo = 0
							End If
						Else
							SubStrNo = 0
						End If
						Select Case UBound(iSetArray)
						Case Is > 12
							.LockState = StrToLong(iSetArray(13))
							'.MoveNotTran = StrToLong(iSetArray(12))
							If OverWrite = 0 Then .OverLengthWrite = StrToLong(iSetArray(9))
							.FillLength = StrToLong(iSetArray(10))
							Call GetRefFromRefAdd(orgFile,FN,.Source,OrgStrTypeList,.TagType,iSetArray(11),Mode,VACompVal)
						Case Is > 11
							'.MoveNotTran = StrToLong(iSetArray(12))
							If OverWrite = 0 Then .OverLengthWrite = StrToLong(iSetArray(9))
							.FillLength = StrToLong(iSetArray(10))
							Call GetRefFromRefAdd(orgFile,FN,.Source,OrgStrTypeList,.TagType,iSetArray(11),Mode,VACompVal)
						Case Is > 10
							If OverWrite = 0 Then .OverLengthWrite = StrToLong(iSetArray(9))
							.FillLength = StrToLong(iSetArray(10))
							Call GetRefFromRefAdd(orgFile,FN,.Source,OrgStrTypeList,.TagType,iSetArray(11),Mode,VACompVal)
						Case Is > 9
							If OverWrite = 0 Then .OverLengthWrite = StrToLong(iSetArray(9))
							.FillLength = StrToLong(iSetArray(10))
						Case Is > 8
							If OverWrite = 0 Then .OverLengthWrite = StrToLong(iSetArray(9))
						End Select
					Else
						SubStrNo = 0
					End If
				Else
					SubStrNo = 0
				End If
				'原始字串
				If ParseHCSFile = -1 Then
					ReDim DataList(t).Source.Reference(0) 'As REFERENCE_PROPERTIE
					.Trans = .Source
					'获取字串类型长度
					Call StrTypeLength(DataList(t),OrgStrTypeList,FN,Mode,0)
				'未翻译字串
				ElseIf SplitState = 0 And Matches(i).SubMatches(3) = Matches(i).SubMatches(2) And _
					StrToLong(SetArray(4),.Source.CodePage) = .Source.CodePage Then
					If SetArray(5) <> "" Then
						.Trans = .Source
						intList(j) = t
						RefAddList(j) = SetArray(5)
						j = j + 1
						ParseHCSFile = ParseHCSFile + 1
					Else
						ReDim DataList(t).Source.Reference(0) 'As REFERENCE_PROPERTIE
						.Source.lReferenceNum = 0
						.Trans = .Source
					End If
					'获取字串类型长度
					Call StrTypeLength(DataList(t),OrgStrTypeList,FN,Mode,0)
				'获取翻译字串的数据
				Else
					If StrNo < 0 Then
						Data = Convert(Matches(i).SubMatches(3))
					ElseIf iMatches(StrNo).SubMatches(2) <> "" Then
						Data = Convert(iMatches(StrNo).SubMatches(2))
					Else
						Data = Convert(Matches(i).SubMatches(3))
					End If
					.Trans.sString = ReConvert(Data)
					.Trans.CodePage = StrToLong(SetArray(4),.Source.CodePage)
					If .Trans.CodePage = .Source.CodePage Then
						If Not UnicodeDic.Exists(.Trans.CodePage) Then
							.Trans.CodePage = trnFile.CopePage
							If .Trans.CodePage = 0 Then .Trans.CodePage = .Source.CodePage
						End If
					End If
					.Trans.lCharLength = Len(Data)
					.Trans.lHexLength = StrHexLength(Data,.Trans.CodePage,0)
					.Trans.iNullByteLength = NullByteLength(DataList(t),True)
					.FillLength = FillLength(DataList(t),Data)
					'已翻译可移位字串
					If .Moveable = 0 Or .Moveable = 2 Then
						'获取字串类型长度
						Call StrTypeLength(DataList(t),OrgStrTypeList,FN,Mode,1)
						'获取翻译开始地址
						.Trans.lStartAddress = StrToLong(SetArray(1))
						'更改翻译的开始地址并获取翻译的最大地址
						If ChangeStartAddress(DataList(t),VerCompVal) = True Then
							.Trans.lMaxAddress = GetMaxAddress(DataList(t),True)
						ElseIf SetArray(2) = "" Then
							.Trans.lMaxAddress = GetMaxAddress(DataList(t),True)
						Else
							'更改和来源字串的最大地址相同的翻译字串的最大地址(有隐藏区段时)
							.Trans.lMaxAddress = StrToLong(SetArray(2))
							If .Source.inSectionID > orgFile.MaxSecIndex - 1 Then
								If .Trans.lMaxAddress + HideSecMoveVal = .Source.lMaxAddress Then
									.Trans.lMaxAddress = GetMaxAddress(DataList(t),True)
								End If
							ElseIf .Trans.lMaxAddress = .Source.lMaxAddress Then
								.Trans.lMaxAddress = GetMaxAddress(DataList(t),True)
							End If
						End If
						.Trans.lEndAddress = .Trans.lStartAddress + .Trans.lHexLength - 1
						.Trans.lMaxHexLength = .Trans.lMaxAddress - .Trans.lStartAddress + 1 - .EndByteLength - .Trans.iNullByteLength
						If trnFile.Magic <> "" Then
							If .Source.inSectionID > orgFile.MaxSecIndex - 1 Then
								.Trans.inSectionID = .Source.inSectionID
								.Trans.inSubSecID = .Source.inSubSecID
							ElseIf CheckStrVal(DataList(t),3,0) = True Then
								.Trans.inSectionID = .Source.inSectionID
								.Trans.inSubSecID = .Source.inSubSecID
							Else
								If .Trans.lStartAddress < trnMinVal Or .Trans.lStartAddress > trnMaxVal Then
									trnSecID = SkipSection(trnFile,.Trans.lStartAddress,trnMinVal,trnMaxVal,0)
								End If
								.Trans.inSectionID = trnSecID
								.Source.inSubSecID = -1
								If orgSubSecID > -1 Then
									If .Source.lStartAddress < orgSubMinVal Or .Source.lStartAddress > orgSubMaxVal Then
										orgSubSecID = SkipSubSection(orgFile.SecList(.Source.inSectionID), _
													.Source.lStartAddress,orgSubMinVal,orgSubMaxVal)
									End If
									.Source.inSubSecID = orgSubSecID
								End If
							End If
						End If
						'获取来源字串的引用代码和地址列表
						If CheckStrVal(DataList(t),0,0) = False Or SetArray(5) <> "" Then
							intList(j) = t
							RefAddList(j) = SetArray(5)
							j = j + 1
							ParseHCSFile = ParseHCSFile + 1
						ElseIf .TagType > 1 Then
							intList(j) = t
							RefAddList(j) = SetArray(5)
							j = j + 1
						ElseIf .Source.GetRefState = 0 Then
							ReDim DataList(t).Source.Reference(0) 'As REFERENCE_PROPERTIE
							.Trans.Reference = .Source.Reference
							.Source.lReferenceNum = 0
							.Trans.lReferenceNum = 0
						End If
						'当不需要移位或节外移位时，重置翻译字串的地址为和来源相同
						If Selected(8) = "0" Or .Trans.inSectionID < 0 Then
							.Trans.lStartAddress = .Source.lStartAddress + .Source.MoveLength
							.Trans.lEndAddress = .Trans.lStartAddress + .Trans.lHexLength - 1
							.Trans.lMaxAddress = GetMaxAddress(DataList(t),True)
							.Trans.lMaxHexLength = .Trans.lMaxAddress - .Trans.lStartAddress + 1 - .EndByteLength - .Trans.iNullByteLength
							.Trans.inSectionID = .Source.inSectionID
						End If
					'已翻译不可移位字串
					Else
						'获取字串类型长度
						Call StrTypeLength(DataList(t),OrgStrTypeList,FN,Mode,0)
						.Trans.lStartAddress = .Source.lStartAddress
						.Trans.lMaxAddress = GetMaxAddress(DataList(t),True)
						.Trans.lEndAddress = .Trans.lStartAddress + .Trans.lHexLength - 1
						.Trans.lMaxHexLength = .Trans.lMaxAddress - .Trans.lStartAddress + 1 - .EndByteLength - .Trans.iNullByteLength
						.Trans.inSectionID = .Source.inSectionID
						ReDim DataList(t).Source.Reference(0) 'As REFERENCE_PROPERTIE
						.Trans.Reference = .Source.Reference
					End If
				End If
				'获取字串 ID 和索引号字典和写入类型
				If Not Dic.Exists(.ID) Then
					Dic.Add(.ID,t)
					If ParseHCSFile > -1 Then
						If .Moveable = 0 Then FreeByteDicBak.Add(.ID,ParentStrNumBak)
						ParentStrNumBak = ParentStrNumBak + 1
					End If
					'获取字串写入类型
					.WriteType = WriteType(trnFile,DataList(t),WriteSet)
					'获取字串移位模式（不可获取，因为此时未获取引用，否则将置零）
					'.MoveMode = MoveMode(trnFile,DataList(t))
					t = t + 1
				'编辑原始字串时仅保留原始字串开始地址重复的最长字串
				ElseIf ParseHCSFile = -1 Then
					x = Dic.Item(.ID)
					If .Source.lHexLength > DataList(x).Source.lHexLength Then DataList(x) = DataList(t)
					GoTo NextNo
				'解析原始字串开始地址重复且字串类型大于 -1 的字串为子字串
				ElseIf .Moveable = 0 Or .Moveable = 2 Then
					'检测旧版宏获取引用是否是真正的引用，不是的话跳过该子字串
					'非拆分的字串会在获取翻译的引用时 通过 getRefList 函数而自动过滤
					If RefCompVal = -1 Then
						.Source.GetRefState = 0
						Call GetVARefList(trnFile,FN,.Source,OrgStrTypeList,.TagType,.Moveable,"",0,Mode,0)
						.Trans.Reference = .Source.Reference
						.Trans.lReferenceNum = .Source.lReferenceNum
						Call GetVARefList(trnFile,"",.Trans,OrgStrTypeList,.TagType,.Moveable,SetArray(5),2,Mode,0)
						If .Trans.lReferenceNum = 0 Then
							'还原引用数据为初始状态，否则后面的字串可能会无法获取正确的引用
							ReDim DataList(t).Source.Reference(0) 'As REFERENCE_PROPERTIE
							.Source.lReferenceNum = 0
							.Source.GetRefState = 0
							j = j - 1
							GoTo NextNo
						End If
						'获取子字串的引用地址
						SetArray(5) = StrListJoin(RefList2StrList(.Trans,0),RefJoinStr)
					End If
					'标注父字串的子字串，并添加子字串
					x = Dic.Item(.ID)
					DataList(x).SplitState = DataList(x).SplitState + 1
					.SplitState = -.ID
					.ID = -StrToLong(ReSplit(SetArray(5),RefJoinStr)(0))
					If Not Dic.Exists(.ID) Then Dic.Add(.ID,t)
					'获取子字串写入类型
					.WriteType = WriteType(trnFile,DataList(t),WriteSet)
					'获取字串移位模式（不可获取，因为此时未获取引用，否则将置零）
					'.MoveMode = MoveMode(trnFile,DataList(t))
					t = t + 1
				'过滤原始字串开始地址重复的非 PE 字串和字串类型小于 0 的 PE 字串
				Else
					GoTo NextNo
				End If
				If trnFile.Magic <> "" Then
					'获取字串所在节的节名列表
					If .Source.inSectionID > -1 Then
						If Not SectionDic.Exists(.Source.inSectionID) Then
							SectionDic.Add(.Source.inSectionID,.Source.lStartAddress)
							SectionDic.Add(-.Source.inSectionID - 2,.Source.lMaxAddress)
							UseSectionListBak(k) = orgFile.SecList(.Source.inSectionID).sName
							k = k + 1
						Else
							SectionDic.Item(-.Source.inSectionID - 2) = .Source.lMaxAddress
						End If
						If InStr(trnFile.Magic,"MAC") Then
							If Not SectionDic.Exists(CStr$(.Source.inSectionID) & "+" & CStr$(.Source.inSubSecID)) Then
								SectionDic.Add(CStr$(.Source.inSectionID) & "+" & CStr$(.Source.inSubSecID),"")
								If .Source.inSubSecID > -1 Then
									UseSubSecListBak(y) = orgFile.SecList(.Source.inSectionID).sName & "-" & _
												orgFile.SecList(.Source.inSectionID).SubSecList(.Source.inSubSecID).sName
								Else
									UseSubSecListBak(y) = orgFile.SecList(.Source.inSectionID).sName
								End If
								y = y + 1
							End If
						End If
					End If
					'为查找移位写入使用的空间ID号做准备
					If ParseHCSFile > -1 Then
						'允许超长写入时，移位字串的最大结束位置和占用字串的最大结束位置相同
						If Not orgMaxPosDic.Exists(.Source.lMaxAddress) Then
							orgMaxPosDic.Add(.Source.lMaxAddress,t - 1)
						End If
						'不允许超长写入时，移位字串的最大结束位置为占用字串的结束位置 + 结束符长度 + 最少空字节数
						x = GetMaxAddress(DataList(t - 1),True)
						If Not orgMaxPosDic.Exists(x) Then orgMaxPosDic.Add(x,t - 1)
					End If
				End If
				'获取提取字串的字串类型选项值
				Select Case .StrType
				Case 0
					If TempList(48) = "0" Then TempList(48) = "1"
				Case 1
					If TempList(5) = "0" Then TempList(5) = "1"
				Case 2
					If TempList(6) = "0" Then TempList(6) = "1"
				Case 3
					If TempList(7) = "0" Then TempList(7) = "1"
				Case 4
					If TempList(8) = "0" Then TempList(8) = "1"
				Case Is < -4
					If TempList(41) = "0" Then
						TempList(41) = "1"
						'TempList(31) = "0" & ItemJoinStr & ReSplit(TempList(31),ItemJoinStr,2)(1)
					End If
				Case Is < 0
					If TempList(9) = "0" Then TempList(9) = "1"
				Case Is > 4
					If TempList(10) = "0" Then TempList(10) = "1"
				End Select
				'获取字串的代码页列表和字符编码选项值
				If Not AnsiCPDic.Exists(-.Source.CodePage) Then
					Select Case .Source.CodePage
					Case CP_UNICODELITTLE
						If Mid$(TempList(4),2,1) = "0" Then Mid$(TempList(4),2,1) = "1"
						x = CheckCodePage(.Source.sString,AllLangList,2)
					Case CP_UTF8
						If Mid$(TempList(4),3,1) = "0" Then Mid$(TempList(4),3,1) = "1"
						x = CheckCodePage(.Source.sString,AllLangList,2)
					Case CP_UNICODEBIG
						If Mid$(TempList(4),4,1) = "0" Then Mid$(TempList(4),4,1) = "1"
						x = CheckCodePage(.Source.sString,AllLangList,2)
					Case CP_UTF7
						If Mid$(TempList(4),5,1) = "0" Then Mid$(TempList(4),5,1) = "1"
						x = CheckCodePage(.Source.sString,AllLangList,2)
					Case CP_UTF32LE
						If Mid$(TempList(4),6,1) = "0" Then Mid$(TempList(4),6,1) = "1"
						x = CheckCodePage(.Source.sString,AllLangList,2)
					Case CP_UTF32BE
						If Mid$(TempList(4),7,1) = "0" Then Mid$(TempList(4),7,1) = "1"
						x = CheckCodePage(.Source.sString,AllLangList,2)
					Case Else
						If Mid$(TempList(4),1,1) = "0" Then Mid$(TempList(4),1,1) = "1"
						x = .Source.CodePage
					End Select
					If x <> CP_UNKNOWN Then
						AnsiCPDic.Add(-.Source.CodePage,"")
						If Not AnsiCPDic.Exists(CStr$(x)) Then
							AnsiCPDic.Add(CStr$(x),"")
							If AnsiCPDic.Exists(x) Then
								SetArray = ReSplit(AnsiCPDic.Item(x),ItemJoinStr)
								If CheckArray(SetArray) = True Then
									For x = 0 To UBound(SetArray)
										UseLangListBak(n) = AllLangList(StrToLong(SetArray(x)))
										n = n + 1
									Next x
								End If
							'ElseIf x <> CP_WESTEUROPE Then
							'	AnsiCPDic.Add(x,"")
							'	SetArray = AddLangList(AllLangList,GetSubLangListByCP(UniLangList,x,True))
							'	If CheckArray(SetArray) = True Then
							'		For x = 0 To UBound(SetArray)
							'			UseLangListBak(n) = AllLangList(StrToLong(SetArray(x)))
							'			n = n + 1
							'		Next x
							'	End If
							End If
						End If
					End If
				End If
				NextNo:
			End With
		Loop Until SubStrNo <= 0
		If ShowMsg > 0 Then
			SetTextBoxString ShowMsg,MsgList(0) & " " & Format$(i / Matches.Count,"#%")
		ElseIf ShowMsg < 0 Then
			PSL.OutputWnd(0).Clear
			PSL.Output MsgList(0) & " " & Format$(i / Matches.Count,"#%")
		End If
		'DoEvents '转让控制权，允许操作系统处理其他事件
		If StopProcess(StopHwnd,VK_ESCAPE) = True Then
			ParseHCSFile = -3
			GoTo ExitFunction
		End If
	Next i
	'隐藏主窗口中的取消操作按钮，启用 Esc 键的退出响应
	Call ShowButton(StopHwnd,VK_ESCAPE,False)
	Set Matches = Nothing: Set iMatches = Nothing
	If n > 0 Then n = n - 1
	If k > 0 Then k = k - 1
	If y > 0 Then y = y - 1
	If t > 0 Then t = t - 1
	ReDim Preserve UseSectionListBak(k) As String
	ReDim Preserve UseSubSecListBak(y) As String
	ReDim Preserve UseLangListBak(n) As LANG_PROPERTIE
	ReDim Preserve DataList(t) As STRING_PROPERTIE
	'显示完成率
	If ShowMsg > 0 Then
		SetTextBoxString ShowMsg,MsgList(0) & " 100%"
	ElseIf ShowMsg < 0 Then
		PSL.OutputWnd(0).Clear
		PSL.Output MsgList(0) & " 100%"
	End If
	'显示有丢失的字串信息
	If m > 0 Then
		If t = 0 Then
			If TempList(48) = "0" Then TempList(48) = "1"
		End If
		If ParseHCSFile = -1 Then
			If MsgBox(Replace$(Replace$(MsgList(5),"%s",CStr$(m)),"%d",trnFile.FilePath),vbYesNo+vbInformation,MsgList(2)) = vbNo Then
				ParseHCSFile = -2
				GoTo ExitFunction
			End If
		Else
			i = InStrRev(LCase$(trnFile.FilePath),".bak")
			If i > 0 Then
				If Mid$(LCase$(trnFile.FilePath),i) <> ".bak" Then i = 0
			End If
			If i < 1 Then
				If MsgBox(Replace$(Replace$(MsgList(3),"%s",CStr$(m)),"%d",trnFile.FilePath),vbYesNo+vbInformation,MsgList(2)) = vbNo Then
					ParseHCSFile = -2
					GoTo ExitFunction
				End If
			ElseIf MsgBox(Replace$(Replace$(MsgList(4),"%s",CStr$(m)),"%d",trnFile.FilePath),vbYesNo+vbInformation,MsgList(2)) = vbNo Then
				ParseHCSFile = -2
				GoTo ExitFunction
			End If
		End If
	End If
	'备份公用参数和提取设置，为了可以中途可以终止而这样处理
	ExtractSet = TempList
	ParentStrNum = ParentStrNumBak
	UseSectionList = UseSectionListBak
	UseSubSecList = UseSubSecListBak
	UseLangList = UseLangListBak
	Erase TempList,UseSectionListBak,UseLangListBak
	Set StrIDIndexDic = Dic: Set Dic = Nothing: Set DatDic = Nothing
	'获取空余地址的ID索引字典
	If ParseHCSFile > -1 Then
		Set FreeByteDic = CreateObject("Scripting.Dictionary")
		Set FreeByteDic = FreeByteDicBak: Set FreeByteDicBak = Nothing
	End If
	'不需要提取自定义字串类型时，原始字串类型列表置空
	If ExtractSet(10) = "0" Then ReDim OrgStrTypeList(0) As STRING_TYPE
	'获取提取字串的字符编码顺序选项值
	ExtractSet(4) = GetEncodeLevel(ExtractSet(4),"7453621","2100000")
	'更改提取字串的其他字符匹配方式 (为正则表达式并提取有非英文字串时改为常规方式)
	If ExtractSet(42) = "2" Then
		If UBound(UseLangList) > 0 Then
			ExtractSet(42) = "0"
		ElseIf UseLangList(0).LangID <> 1033 Then
			ExtractSet(42) = "0"
		End If
	End If
	'确定字符编码
	If Mid$(ExtractSet(4),1,1) <> "0" Then ExtractSet(1) = "1"
	If Mid$(ExtractSet(4),2,1) <> "0" Then ExtractSet(2) = "1"
	If Mid$(ExtractSet(4),3,1) <> "0" Then ExtractSet(3) = "1"
	'获取指定区域提起时的地址范围
	If trnFile.Magic = "" Then
		ExtractSet(50) = DataList(0).Source.lStartAddress & "-" & DataList(t).Source.lMaxAddress
	ElseIf SectionDic.Count > 0 Then
		For i = 0 To SectionDic.Count - 1
			If IsNumeric(SectionDic.Keys(i)) Then
				If SectionDic.Keys(i) > -1 Then
					If ExtractSet(50) = "" Then
						ExtractSet(50) = SectionDic.Item(SectionDic.Keys(i))
					Else
						ExtractSet(50) = ExtractSet(50) & "," & SectionDic.Item(SectionDic.Keys(i))
					End If
				ElseIf ExtractSet(50) <> "" Then
					ExtractSet(50) = ExtractSet(50) & "-" & SectionDic.Item(SectionDic.Keys(i))
				End If
			End If
		Next i
	End If
	'备份提取设置
	ExtractSetBak = ExtractSet
	'按代码页值从小到大排序，以便兼容英语的代码页可以优先提取
	If n > 0 Then Call SortLangArrayByCP(UseLangList,0,n,False)
	If trnFile.Magic <> "" Then
		If j > 0 Then
			ReDim Preserve intList(j - 1) As Long,RefAddList(j - 1) As String
			'获取字串的引用代码和引用地址
			If ShowMsg > 0 Then
				SetTextBoxString ShowMsg,MsgList(1),True
			ElseIf ShowMsg < 0 Then
				PSL.Output MsgList(1)
			End If
			'getVARefListBatch 函数的 fType 值必须为 3，以便获取子字串的引用
			If GetVARefListBatch(trnFile,FN,DataList,OrgStrTypeList,intList,RefAddList,3,Mode,ShowMsg,True) < -1 Then
				GoTo ExitFunction
			End If
			'获取字串的写入类型和移位模式
			For i = 0 To UBound(intList)
				With DataList(intList(i))
					'获取字串写入类型
					.WriteType = WriteType(trnFile,DataList(intList(i)),WriteSet)
					'获取字串移位模式
					.MoveMode = MoveMode(trnFile,DataList(intList(i)))
					'清空截断写入的超长移位模式字串的引用地址，以便超长移位模式的引用地址为空
					If .MoveMode = 0 And .WriteType = 2 Then
						ReDim DataList(intList(i)).Trans.Reference(0) 'As REFERENCE_PROPERTIE
						.Trans.lReferenceNum = 0
						.Trans.GetRefState = 0
					End If
				End With
			Next i
		End If
		'查找节尾空余地址
		If ParseHCSFile > -1 And ParentStrNum > 0 Then
			x = IIf(ParentStrNum = 1,2,ParentStrNum)	'避开 ScapeIDForMove = -1 的情况
			If UBound(FreeByteList) < x + k Then
				ReDim Preserve FreeByteList(x + k) As FREE_BTYE_SPACE
			End If
			n = 0
			For i = 0 To SectionDic.Count - 1
				If IsNumeric(SectionDic.Keys(i)) Then
					j = SectionDic.Keys(i)
					If j > -1 And j < orgFile.MaxSecIndex Then
						SectionDic.Item(j) = x + n
						GetSecEndFreeBytesRegExp(trnFile,FN,j,orgMaxPosDic,FreeByteList,x + n,Mode)
						n = n + 1
					End If
				End If
			Next i
		End If
	End If
	'无父字串、非 PE 文件、不需要移位时退出
	If ParentStrNum = 0 Or ParseHCSFile < 1 Or trnFile.Magic = ""  Or Selected(8) = "0" Then
		ParseHCSFile = 0
		AllStrDataList = DataList
		GoTo ExitFunction
	End If
	'查找移位写入使用的空间ID号并确定移位字串所使用的空位地址和移位类型
	ReDim intList(t) As Long
	j = 0: n = UBound(FreeByteList)
	For i = 0 To t
		With DataList(i)
			If .Moveable = 0 Then
				If CheckStrVal(DataList(i),3,0) = False Then
				'If CheckStrVals(DataList,i,t) = False Then
					'检查占用的地址是否在字串所在节
					If .Trans.inSectionID = .Source.inSectionID Then
						'检查占用的地址是否是字串地址
						If orgMaxPosDic.Exists(.Trans.lMaxAddress) Then
							k = orgMaxPosDic.Item(.Trans.lMaxAddress)
							.ScapeIDForMove = DataList(k).ID
							DataList(k).ScapeIDBeMoved = .ID
							.MoveType = 1
							'标记占有其他字串的空间为占有
							FreeByteList(FreeByteDic.Item(DataList(k).ID)).MoveType = .ID
							'被占用字串的开始地址小于当前字串的最大地址时
							'重置当前字串及被占用字串的地址 (该操作会造成 MoveMode > 2 的移位模式丢失)
							ResetStrVal(trnFile,DataList,FreeByteList,i,1)
						Else
							'检查占用的地址是否是节尾地址
							k = SectionDic.Item(.Trans.inSectionID)
							If .Trans.lStartAddress >= FreeByteList(k).Address And _
								.Trans.lEndAddress <= FreeByteList(k).MaxAddress Then
								.ScapeIDForMove = FreeByteList(k).lNumber
								.MoveType = 3
							Else
								'检查占用非字串地址是否已经被提取过
								'- 1 避开以空字节开始的双字节字符的开始地址和前一个字串的最大地址相同)
								If Not FreeByteDic.Exists(.Trans.lMaxAddress - 1) Then
									intList(j) = i: n = n + 1
									FreeByteDic.Add(.Trans.lMaxAddress - 1,-n)
								Else
									intList(j) = -i
								End If
								j = j + 1
								.MoveType = 2
							End If
						End If
					ElseIf .Trans.inSectionID > -1 Then
						.MoveType = 4	'所在节尾扩展空间
					Else
						'根据使用空间位置判断其移位类型
						.MoveType = IIf(Selected(6) = "1",5,6)
					End If
				End If
			End If
		End With
	Next i
	'添加未被提取但被使用的非字串空余空间
	If j > 0 Then
		ReDim Preserve intList(j - 1) As Long
		AddFreeByteListRegExp(trnFile,FN,FreeByteList,DataList,intList,Mode)
	End If
	'重置未选定移位空间的移位字串
	Call ResetAndMoveStrings(trnFile,DataList,0,"","",ShowMsg)
	AllStrDataList = DataList
	'退出函数
	ExitFunction:
	'隐藏主窗口中的取消操作按钮，启用 Esc 键的退出响应
	Call ShowButton(StopHwnd,VK_ESCAPE,False)
	UnLoadFile(FN,0,Mode)
	Set Matches = Nothing: Set iMatches = Nothing
	Set orgMaxPosDic = Nothing: Set SectionDic = Nothing
	Set AnsiCPDic = Nothing: Set UnicodeDic = Nothing
	Set Dic = Nothing: Set DatDic = Nothing: Set FreeByteDicBak = Nothing
	If ParseHCSFile = 0 Then
		If StrToLong(Selected(24)) = 1 Then Beep
	End If
End Function


'计算字符编码的默认优先级
Private Function GetEncodeLevel(ByVal EncodeLevel As String,ByVal Template As String,ByVal DefaultLevel As String) As String
	Dim i As Integer,j As Integer,k As Integer,n As Integer
	i = Len(EncodeLevel)
	j = Len(Template)
	If i < j Then
		EncodeLevel = EncodeLevel & String(j - i,"0")
	ElseIf i > j Then
		EncodeLevel = Left$(EncodeLevel,j)
	End If
	ReDim intList(1 To j) As Integer
	For i = 1 To j
		k = StrToLong(Mid$(EncodeLevel,i,1))
		If k > 0 Then
			k = StrToLong(Mid$(Template,i,1))
			Mid$(EncodeLevel,i,1) = CStr$(k)
			intList(k) = i
			n = n + 1
		End If
	Next i
	If n = 0 Then
		EncodeLevel = DefaultLevel
	Else
		n = 1
		For i = 1 To j
			k = intList(i)
			If k > 0 Then
				Mid$(EncodeLevel,k,1) = CStr$(n)
				n = n + 1
			End If
		Next i
	End If
	GetEncodeLevel = EncodeLevel
End Function


'转换字符编码的优先级为显示
Private Function ConvertEncodeLevel(ByVal EncodeLevel As String,ByVal MsgText As String,ByVal Separator As String) As String
	Dim i As Integer,j As Integer,n As Integer
	Dim TempList() As String,TempArray() As String
	TempArray = ReSplit(MsgText,Separator)
	TempList = TempArray
	For i = 0 To UBound(TempArray)
		j = StrToLong(Mid$(EncodeLevel,i + 1,1))
		If j > 0 Then
			TempList(j - 1) = TempArray(i)
			n = n + 1
		End If
	Next i
	If n > 0 Then
		ReDim Preserve TempList(n - 1) As String
	Else
		ReDim TempList(n) As String
	End If
	ConvertEncodeLevel = StrListJoin(TempList,Separator)
End Function


'增加字符编码的优先级
Private Function AddEncodeLevel(ByVal EncodeLevel As String,ByVal Pos As Integer) As String
	Dim i As Integer,j As Integer,n As Integer
	For i = 1 To Len(EncodeLevel)
		j = StrToLong(Mid$(EncodeLevel,i,1))
		If j > n Then n = j
	Next i
	Mid$(EncodeLevel,Pos,1) = CStr$(n + 1)
	AddEncodeLevel = EncodeLevel
End Function


'删除字符编码的优先级
Private Function DelEncodeLevel(ByVal EncodeLevel As String,ByVal Pos As Integer) As String
	Dim i As Integer,j As Integer,k As Integer,n As Integer
	j = Len(EncodeLevel)
	ReDim intList(1 To j) As Integer
	Mid$(EncodeLevel,Pos,1) = "0"
	For i = 1 To j
		k = StrToLong(Mid$(EncodeLevel,i,1))
		If k > 0 Then
			intList(k) = i
			n = n + 1
		End If
	Next i
	If n > 0 Then
		n = 1
		For i = 1 To j
			k = intList(i)
			If k > 0 Then
				Mid$(EncodeLevel,k,1) = CStr$(n)
				n = n + 1
			End If
		Next i
	End If
	DelEncodeLevel = EncodeLevel
End Function


'获取写入类型
'PE 文件: -3=丢失(原址截断写入)，-2=丢失(原址完整写入)，-1=丢失(未翻译)，0=未翻译，1=原址完整写入，2=原址截断写入，3=全部移位写入，4=部分移位写入，5=原址超长写入
'非PE文件: -3=丢失(原址截断写入)，-2=丢失(原址完整写入)，-1=丢失(未翻译)，0=未翻译，1=原长完整写入，2=最长完整写入，3=超长完整写入，4=原址截断写入
Private Function WriteType(File As FILE_PROPERTIE,strData As STRING_PROPERTIE,ByVal WriteOption As Long) As Integer
	With strData
		If .Trans.sString = .Source.sString And .Trans.CodePage = .Source.CodePage And .MoveMode < 5 Then
			If .Missing > 0 Then
				WriteType = -1
			ElseIf CheckStrVal(strData,3,0) = False Then
				WriteType = IIf(.Trans.lReferenceNum = .Source.lReferenceNum,3,4)
			End If
		ElseIf .Missing > 0 Then
			WriteType = IIf(CheckStrVal(strData,4,0) = False,-3,-2)
		ElseIf File.Magic = "" Then
			If WriteOption < 0 Then
				WriteType = IIf(.Trans.lHexLength > .Source.lHexLength,4,1)
			ElseIf WriteOption > 0 Then
				If CheckStrVal(strData,4,0) = False Then
					WriteType = 3
				Else
					WriteType = IIf(.Trans.lHexLength > .Source.lHexLength,2,1)
				End If
			Else
				If CheckStrVal(strData,3,0) = False Then
					WriteType = 3
				ElseIf CheckStrVal(strData,4,0) = False Then
					WriteType = 4
				Else
					WriteType = IIf(.Trans.lHexLength > .Source.lHexLength,2,1)
				End If
			End If
		Else
			If .Moveable = 0 Then
				If CheckStrVal(strData,3,0) = False Then
					WriteType = IIf(.Trans.lReferenceNum = .Source.lReferenceNum,3,4)
				ElseIf .ScapeIDForMove > -1 Then
					WriteType = IIf(CheckStrVal(strData,4,0) = False,5,1)
				Else
					WriteType = IIf(CheckStrVal(strData,4,0) = False,2,1)
				End If
			ElseIf .Moveable = 2 Then
				If WriteOption < 0 Then
					WriteType = IIf(CheckStrVal(strData,4,0) = False,2,1)
				ElseIf WriteOption > 0 Then
					If CheckStrVal(strData,3,0) = False Then
						WriteType = 3
					Else
						WriteType = IIf(CheckStrVal(strData,4,0) = False,5,1)
					End If
				Else
					If CheckStrVal(strData,3,0) = False Then
						WriteType = 3
					Else
						WriteType = IIf(CheckStrVal(strData,4,0) = False,2,1)
					End If
				End If
			Else
				WriteType = IIf(CheckStrVal(strData,4,0) = False,2,1)
			End If
		End If
	End With
End Function


'获取移位模式
'0 = 超长移位，1 = 强制移位 (未移位时引用地址非空)，2 = 原址移位 (字串类型字节长度更改)，3 = 人工移位，4 = 不移位，5 = 原址扩展
'Mode = True 不更改未拆分字串的现有移位模式
Private Function MoveMode(trnFile As FILE_PROPERTIE,strData As STRING_PROPERTIE) As Integer
	If trnFile.Magic = "" Then Exit Function
	With strData
		If .WriteType > -2 And .WriteType < 1 Then
			If .Trans.lReferenceNum > 0 Then
				If .Trans.lReferenceNum = .Source.lReferenceNum Then MoveMode = 1
			ElseIf .MoveMode = 5 Then
				MoveMode = 5
			ElseIf .Source.lReferenceNum = 0 Then
				If .ScapeIDForMove > -1 Then MoveMode = 5
			End If
		ElseIf .Source.lReferenceNum = 0 Then
			If .ScapeIDForMove > -1 Then
				MoveMode = 5
			ElseIf .MoveMode = 5 Then
				MoveMode = 5
			ElseIf .Source.MoveLength <> 0 Then
				MoveMode = 2
			End If
		ElseIf .SplitState = 0 Then
			If .Trans.lReferenceNum = .Source.lReferenceNum Then
				If .MoveMode = 3 Then
					MoveMode = 3
				ElseIf CheckStrVal(strData,4,0) = True Then
					MoveMode = 1
				End If
			ElseIf .Trans.lReferenceNum > 0 Then
				MoveMode = IIf(.MoveMode = 3,3,1)
			ElseIf .ScapeIDForMove > -1 Then
				MoveMode = 5
			ElseIf .MoveMode = 4 Then
				MoveMode = 4
			ElseIf .MoveMode = 5 Then
				MoveMode = 5
			ElseIf .Source.MoveLength <> 0 Then
				If CheckStrVal(strData,4,0) = True Then MoveMode = 2
			End If
		ElseIf .SplitState > 0 Then
			If .ScapeIDForMove > -1 Then
				MoveMode = 5
			ElseIf .MoveMode = 5 Then
				MoveMode = 5
			Else
				MoveMode = IIf(.Source.MoveLength = 0,4,2)
			End If
		Else
			MoveMode = IIf(.MoveMode = 3,3,1)
		End If
	End With
End Function


'可移位属性(和有无引用无关), 0 = 可移位, >0 = 不可移位
Private Function Moveable(srcFile As FILE_PROPERTIE,strData As STRING_PROPERTIE) As Integer
	With strData
		If .Missing > 0 Then
			Moveable = 4
		ElseIf srcFile.Magic = "" Then
			Moveable = 1
		ElseIf srcFile.LangType = NET_FILE_SIGNATURE And .StrType < 0 Then
			Moveable = 2
		ElseIf .Source.inSectionID > srcFile.MaxSecIndex - 1 Then
			Moveable = 3
		End If
	End With
End Function


'导入来源字串
'返回值：ImportSrcString = -3 取消，-2 文件不适用，-1 格式不对，0 无导入，>0 导入数
'IDList = 导入成功的字串索引号
Private Function ImportSrcString(orgFile As FILE_PROPERTIE,ImportSet() As String,IDList() As Long,ByVal ShowMsg As Long) As Long
	Dim i As Long,m As Long,n As Long,s As Long,k As Long,CP As Long,LangList() As LANG_PROPERTIE
	Dim SecID As Long,MinVal As Long,MaxVal As Long,MinPos As Long,MaxPos As Long,Mode As Long
	Dim FN As FILE_IMAGE,MsgList() As String,TempList() As String,StrCompVal As Integer,TagType As Integer
	Dim DataList() As STRING_PROPERTIE,TempData As STRING_PROPERTIE,TypeList() As STRING_TYPE
	Dim Temp As String,Msg As PROGRESS_MSG,Dic As Object,DataDic As Object,Matches As Object
	'检查导入文件的字符编码
	If ImportSet(0) <> "0" Then
		ReDim FileDataList(0) As String
		FileDataList(0) = ImportSet(1) & JoinStr
		If EditFile(ImportSet(1),FileDataList,False) = False Then
			ImportSrcString = -3
			Exit Function
		End If
		Temp = ReSplit(FileDataList(0),JoinStr)(1)
	End If
	'检查导入文件和本地化文件的日期
	If getMsgList(UIDataList,MsgList,"ImportString",1) = False Then Exit Function
	If orgFile.DateLastModified > FileDateTime(ImportSet(1)) Then
		If  MsgBox(Replace(MsgList(13),"%s",ImportSet(1)),vbYesNo+vbInformation,MsgList(12)) = vbNo Then
			ImportSrcString = -2
			Exit Function
		End If
	End If
	'读取导入文件并数组化
	Temp = ReadTextFile(ImportSet(1),Temp)
	If Temp = "" Then
		MsgBox Replace(MsgList(14),"%s",ImportSet(1)),vbOkOnly+vbInformation,MsgList(11)
		Exit Function
	End If
	'检查要导入的 HCS 文件的合法性并获取自定义字串类型的设置
	If ImportSet(0) = "0" Then
		Dim File As FILE_PROPERTIE
		With File.hcsFile
			File.FileName = orgFile.FileName
			Call CheckData(orgFile.FileName,File,Temp,False,TypeList,StrToLong(ImportSet(3) & ExtractSet(10)))
			MsgList(13) = ""
			If .SourceFileName <> orgFile.OrigionalFileName Then
				MsgList(13) = MsgList(15)
			ElseIf .SourceFileVersion <> orgFile.FileVersion Then
				MsgList(13) = MsgList(16)
			ElseIf .SourceFileLangID <> orgFile.LanguageID Then
				MsgList(13) = MsgList(17)
			ElseIf .FileFormat = False Then
				MsgList(13) = MsgList(18)
			End If
			If MsgList(13) <> "" Then
				MsgBox Replace(MsgList(13),"%s",ImportSet(1)),vbOkOnly+vbInformation,MsgList(11)
				ImportSrcString = -2
				Exit Function
			End If
			MsgList(14) = ""
			If .SourceFileSize <> orgFile.FileSize Then
				MsgList(14) = MsgList(19)
			ElseIf CStr(.SourceFileDateTime) <> CStr(orgFile.DateLastModified) Then
				MsgList(14) = MsgList(20)
			End If
			If MsgList(14) <> "" Then
				If MsgBox(Replace(MsgList(14),"%s",ImportSet(1)),vbYesNo+vbInformation,MsgList(12)) = vbNo Then
					ImportSrcString = -2
					Exit Function
				End If
			End If
		End With
		StrTypeListBak = StrTypeList
		StrCompVal = StrComp(ToUpdateDataVersion,File.hcsFile.AppVersion)
	Else
		AddStrTypeList(TypeList,orgFile.FileName,"",StrToLong(ImportSet(3) & ExtractSet(10)))
	End If
	'执行正则表达式
	RegExp.Global = True
	RegExp.IgnoreCase = False
	Select Case ImportSet(0)
	Case "0"
		RegExp.Pattern = "[\r\n]+(;)?([0-9,\|\-]{4,}):([^\r\n]+)[\r\n]+[^\r\n]+"
	Case "1"
		RegExp.Pattern = "[\r\n]+([0-9]+):([^\r\n]+)[\r\n]+[^\r\n]+"
	Case "2"
		RegExp.Pattern = "[\r\n]+0x([0-9A-F]+),[0-9]+=([^\r\n]+)"
	Case "3"
		RegExp.Pattern = "[\r\n]*'([0-9A-F]+)\t([^\r\n\t]+)"
	End Select
	Set Matches = RegExp.Execute(Temp)
	If Matches.Count = 0 Then
		MsgBox MsgList(21),vbOkOnly+vbInformation,MsgList(11)
		ImportSrcString = -1
		Exit Function
	End If
	'打开本地化来源文件
	Mode = LoadFile(orgFile.FilePath,FN,0,0,0,StrToLong(Selected(1)))
	If Mode < -1 Then Exit Function
	'获取过滤和保留字串列表字典用于提取
	If ImportSet(5) = "1" Then
		If ExtractSet(21) = "1" Then
			TempList = ReSplit(ReadBinaryFile(ExtractSet(35),CP_UNICODELITTLE,True),vbNullChar)
			StrList2StrDic(FilterStrDic,TempList,StrToLong(ExtractSet(22)),1)
		End If
		If ExtractSet(23) = "1" Then
			If Dir$(ExtractSet(37)) <> "" Then
				TempList = ReSplit(ReadBinaryFile(ExtractSet(37),CP_UNICODELITTLE,True),vbNullChar)
			Else
				TempList = ReSplit(ExcludeStr,ItemJoinStr)
			End If
			StrList2StrDic(ReserveStrDic,TempList,StrToLong(ExtractSet(24)),1)
		End If
	End If
	'显示主窗口的取消操作按钮和禁止主窗口的 Esc 键响应退出主窗口
	Call ShowButton(StopHwnd,VK_ESCAPE,True)
	'根据导入参数中的是否重建数据项，确定是否重新初始化 HCS 字串数据数组
	Set Dic = CreateObject("Scripting.Dictionary")
	Set DataDic = CreateObject("Scripting.Dictionary")
	ReDim IDList(Matches.Count) As Long
	If ImportSet(3) = "0" Then
		n = 0
		Msg.Total = Matches.Count
	Else
		DataList = AllStrDataList
		n = UBound(DataList)
		n = IIf(n = 0 And DataList(0).Source.CodePage = 0,0,n + 1)
		Msg.Total = n + Matches.Count: Msg.Passed = n
		'创建现有 HCS 字串开始地址的字典，以便不会导入重复的来源字串开始地址
		If n > 0 Then
			For i = 0 To n - 1
				With DataList(i).Source
					If Not Dic.Exists(.lStartAddress) Then Dic.Add(.lStartAddress,"")
					'重置标志，以便为过滤显示设置导入字串标志
					'If .NewStemp = 1 Then .NewStemp = 0
					If ShowMsg > 0 Then
						SetTextBoxString ShowMsg,MsgList(0) & Format$(i / Msg.Total,"#%")
					ElseIf ShowMsg < 0 Then
						PSL.OutputWnd(0).Clear
						PSL.Output MsgList(0) & Format$(i / Msg.Total,"#%")
					End If
					'DoEvents '转让控制权，允许操作系统处理其他事件
					If StopProcess(StopHwnd,VK_ESCAPE) = True Then
						ImportSrcString = -3
						GoTo ExitFunction
					End If
				End With
			Next i
			CopyDic StrIDIndexDic,DataDic
		End If
	End If
	ReDim Preserve DataList(Msg.Total) As STRING_PROPERTIE
	'获取提取设置，以便根据添加字串设置更改提取设置
	TempList = ExtractSet
	TempList(10) = IIf(CheckStrTypeArray(TypeList) = True,"1","0")
	'判断是否需要检查跟随引用地址的自定义字符类型
	If TempList(10) = "1" Then TagType = CheckRefCustomStrType(TypeList,IIf(orgFile.Magic = "",0,1))
	If n > 0 Then TempList(31) = AddStrEndCharSet(TempList(31),JoinStr & StringTerminator)
	'初始化其他参数
	SecID = SkipSection(orgFile,orgFile.SecList(orgFile.MinSecID).lPointerToRawData,MinVal,MaxVal,1)
	s = orgFile.SecList(orgFile.MinSecID).lPointerToRawData
	m = orgFile.SecList(orgFile.MaxSecIndex).lPointerToRawData + orgFile.SecList(orgFile.MaxSecIndex).lSizeOfRawData - 1
	MaxPos = -1
	'初始化字串ID，以便不替换字串索引 Key
	TempData.ID = -1
	'开始导入
	ReDim TempArray(0) As String
	With TempData.Source
		'根据导入参数中的代码页项，获取默认代码页
		.CodePage = StrToLong(ImportSet(2))
		'获取默认代码页的编码范围
		LangList = GetSubLangListByCP(UseLangList,.CodePage)
		'根据代码页设置字符编码的提取选项
		Select Case .CodePage
		Case CP_UNICODELITTLE
			TempList(4) = "0100000"
		Case CP_UNICODEBIG
			TempList(4) = "0001000"
		Case CP_UTF8
			TempList(4) = "0010000"
		Case CP_UTF7
			TempList(4) = "0000100"
		Case CP_UTF32LE,CP_UTF_32LE
			TempList(4) = "0000010"
		Case CP_UTF32BE,CP_UTF_32BE
			TempList(4) = "0000001"
		Case Is <> CP_UNKNOWN
			TempList(4) = "1000000"
		End Select
		'检查是否需要检测多字节字符串的代码页
		CP = .CodePage
		Temp = GetFeaturePattern(LangList)
		'更改提取字串的其他字符匹配方式 (为正则表达式并提取有非英文字串时改为常规方式)
		If ImportSet(5) = "1" Then
			If TempList(42) = "2" Then
				If UBound(LangList) > 0 Then
					TempList(42) = "0"
				ElseIf LangList(0).CodePage <> CP_WESTEUROPE Then
					TempList(42) = "0"
				End If
			End If
		End If
		'开始导入字串
		For i = 0 To Matches.Count - 1
			'获取字串数据
			Select Case ImportSet(0)
			Case "0"
				TempData.iError = IIf(Matches(i).SubMatches(0) = ";",1,0)
				.sString = Matches(i).SubMatches(2)
				TempArray = ReSplit(Matches(i).SubMatches(1),ValJoinStr)
				'更新旧数据文件的数据
				If StrCompVal = 1 Then
					If UBound(TempArray) = 3 Then TempArray(3) = TempArray(2)
					If TempArray(3) = CStr(CP_UNICODEBIG) Then TempArray(3) = CStr(CP_UNICODELITTLE)
				End If
				'获取来源字串的基本数据
				.lStartAddress = StrToLong(TempArray(0))
				.CodePage = StrToLong(TempArray(3))
				'过滤未被选定编码的字串
				If CP <> CP_UNKNOWN Then
					If CP <> .CodePage Then GoTo NextNo
				End If
			Case "1"
				'转换点睛文件中的 \" 转义符
				.sString = Replace$(Matches(i).SubMatches(1),"\""","""")
				.lStartAddress = StrToLong(Matches(i).SubMatches(0))
			Case "2"
				.sString = Matches(i).SubMatches(1)
				.lStartAddress = Val("&H" & Matches(i).SubMatches(0))
			Case "3"
				'转换 Athena-A 中的 [\x] 形式的转义符
				.sString = AthenaA(Matches(i).SubMatches(1))
				.lStartAddress = Val("&H" & Matches(i).SubMatches(0))
			End Select
			'跳过原始字串为空的字串
			If .sString = "" Then GoTo NextNo
			'跳过小于最小节开始地址
			If .lStartAddress < s Then GoTo NextNo
			'跳过大于最大节结束地址
			If .lStartAddress >= m Then GoTo NextNo
			'过滤已提取字串的字串开始地址
			If Dic.Exists(.lStartAddress) Then GoTo NextNo
			Dic.Add(.lStartAddress,"")
			'跳过 PE 文件数据目录，.NET 用户字串区域除外
			If ImportSet(4) = "1" Then
				If .lStartAddress < k Or .lStartAddress > MaxPos Then
					k = .lStartAddress: MinPos = .lStartAddress
					If SkipHeader(orgFile,MinPos,MaxPos,1,1) > -1 Then GoTo NextNo
					If MinPos > MaxPos Or MaxPos > m Then MaxPos = m + 1
					If MinPos > m Then GoTo NextNo
				ElseIf .lStartAddress < MinPos Then
					GoTo NextNo
				End If
			End If
			'获取所在节ID号
			If orgFile.Magic <> "" Then
				If .lStartAddress < MinVal Or .lStartAddress > MaxVal Then
					SecID = SkipSection(orgFile,.lStartAddress,MinVal,MaxVal,1)
				End If
			End If
			'添加其他字串数据参数
			.inSectionID = SecID
			If .CodePage <> CP_UNKNOWN Then
				.lHexLength = StrHexLength(.sString,.CodePage,1)
				.lEndAddress = .lStartAddress + .lHexLength - 1
				.lMaxAddress = IIf(ImportSet(0) = "0",.lEndAddress,0)
			End If
			'提取字串
			DataList(n) = GetString(orgFile,FN,TempData,LangList,TypeList,TempList,0,Mode,True)
			With DataList(n)
				If .Source.sString = "" Then GoTo NextPos
				If .Source.sString <> TempData.Source.sString Then GoTo NextPos
				If .Source.lStartAddress <> TempData.Source.lStartAddress Then
					If Dic.Exists(.Source.lStartAddress) Then GoTo NextPos
					Dic.Add(.Source.lStartAddress,"")
				End If
				'过滤字串
				If ImportSet(5) = "1" Then
					If StrFilter(.Source,.StrType,TempList,Temp,TagType) = False Then GoTo NextPos
				End If
				If ImportSet(3) = "1" Then .Source.NewStemp = 1
				.iError = TempData.iError
				If Not DataDic.Exists(.ID) Then DataDic.Add(.ID,n)
				IDList(ImportSrcString) = n
				ImportSrcString = ImportSrcString + 1
				n = n + 1
				NextPos:
			End With
			NextNo:
			If ShowMsg > 0 Then
				SetTextBoxString ShowMsg,MsgList(0) & Format$((i + Msg.Passed) / Msg.Total,"#%")
			ElseIf ShowMsg < 0 Then
				PSL.OutputWnd(0).Clear
				PSL.Output MsgList(0) & Format$((i + Msg.Passed) / Msg.Total,"#%")
			End If
			'DoEvents '转让控制权，允许操作系统处理其他事件
			If StopProcess(StopHwnd,VK_ESCAPE) = True Then
				ImportSrcString = -3
				GoTo ExitFunction
			End If
		Next i
	End With
	Erase TempArray
	Set Matches = Nothing
	'显示完成率
	If ShowMsg > 0 Then
		SetTextBoxString ShowMsg,MsgList(0) & "100%"
	ElseIf ShowMsg < 0 Then
		PSL.OutputWnd(0).Clear
		PSL.Output MsgList(0) & "100%"
	End If
	If ImportSrcString > 0 Then
		'处理导入数据
		ReDim Preserve IDList(ImportSrcString - 1) As Long
		ReDim Preserve DataList(n - 1) As STRING_PROPERTIE
		Set StrIDIndexDic = DataDic
		'获取字串的引用列表和引用地址前的自定义类型，并过滤不需要提取的标准字串和无引用字串
		i = IIf(IIf(TempList(10) = "0",0,TagType) = 0,0,4)
		i = i + StrToLong(TempList(48)) + IIf(StrToLong(TempList(11)) = 0,0,2)
		ImportSrcString = getVAListAndStrTypeByVA(orgFile,FN,DataList,TypeList,IDList,n - ImportSrcString,i,Mode,MsgList(2),ShowMsg,True)
	End If
	Set Dic = Nothing: Set DataDic = Nothing
	Select Case ImportSrcString
	Case Is > 0
		'记录字串类型数组
		ExtractSet = TempList
		If ExtractSet(10) = "1" Then
			OrgStrTypeList = TypeList: UseStrTypeList = TypeList
		Else
			ReDim OrgStrTypeList(0) As STRING_TYPE
		End If
		'字串排序
		AllStrDataList = DataList: Erase DataList,TempList,TypeList
		Call SortStrArraysByAddress(StrIDIndexDic,AllStrDataList,0,UBound(AllStrDataList),False)
		UseStrDataList = AllStrDataList
		'记录字串结束符并保存对提取选项的修改
		StringTerminator = StrEndChar2Pattern(ExtractSet(31),2)(0)
		'清空过滤器的自定义字串类型
		FilterStrSet(9) = Left$(FilterStrSet(9),2)
		'MsgBox Replace$(MsgList(23),"%s",CStr$(ImportSrcString)),vbOkOnly+vbInformation,MsgList(11)
		'显示完成率
		If ShowMsg > 0 Then
			SetTextBoxString ShowMsg,Replace$(MsgList(23),"%s",CStr$(ImportSrcString)),True
		ElseIf ShowMsg < 0 Then
			PSL.Output Replace$(MsgList(23),"%s",CStr$(ImportSrcString))
		End If
	Case 0
		ReDim IDList(0) As Long
		MsgBox MsgList(22),vbOkOnly+vbInformation,MsgList(11)
	Case Else
		ReDim IDList(0) As Long
	End Select
	If StrToLong(Selected(22)) = 1 Then Beep
	'退出函数
	ExitFunction:
	'隐藏主窗口中的取消操作按钮，启用 Esc 键的退出响应
	Call ShowButton(StopHwnd,VK_ESCAPE,False)
	UnLoadFile(FN,0,Mode)
	Set Matches = Nothing
	Set Dic = Nothing: Set DataDic = Nothing
	'还原过滤字串列表字典用于字串过滤显示
	If ImportSet(5) = "1" Then
		If ExtractSet(21) = "1" Then
			TempList = ReSplit(ReadBinaryFile(ExtractSet(35),CP_UNICODELITTLE,True),vbNullChar)
			StrList2StrDic(FilterStrDic,TempList,StrToLong(ReSplit(FilterStrSet(17),ItemJoinStr)(1)),1)
		End If
	End If
End Function


'导入翻译字串
'返回值：ImportTranString = -2 取消，-1 格式不对，0 无导入，>0 导入数
'        IntList = 导入成功的字串索引号
Private Function ImportTranString(trnFile As FILE_PROPERTIE,ImportSet() As String,intList() As Long,ByVal ShowMsg As Long) As Long
	Dim i As Long,j As Long,k As Long,x As Long,m As Long,n As Long
	Dim AddDic As Object,StrDic As Object,Matches As Object,Stemp As Boolean
	Dim FN As FILE_IMAGE,MsgList() As String,Max As Long,Mode As Long
	ReDim TempList(1) As String
	'读取导入文件并数组化
	If ImportSet(0) <> "0" And ImportSet(0) <> "4" Then
		ReDim FileDataList(0) As String
		FileDataList(0) = ImportSet(1) & JoinStr
		If EditFile(ImportSet(1),FileDataList,False) = False Then
			ImportTranString = -2
			Exit Function
		End If
		TempList(0) = ReSplit(FileDataList(0),JoinStr)(1)
	End If
	'初始化进度消息
	If getMsgList(UIDataList,MsgList,"ImportString",1) = False Then Exit Function
	'显示主窗口的取消操作按钮和禁止主窗口的 Esc 键响应退出主窗口
	Call ShowButton(StopHwnd,VK_ESCAPE,True)
	'转换导入参数
	ReDim intArray(3) As Long
	intArray(0) = StrToLong(ImportSet(4) & ImportSet(5))	'已翻译与未翻译
	intArray(1) = StrToLong(ImportSet(6) & ImportSet(7))	'地址相同与不同
	intArray(2) = StrToLong(ImportSet(8) & ImportSet(9))	'已锁定与未锁定
	'根据导入选项中的选定或未选定字串项选择不同的数据列表
	If ImportSet(2) & ImportSet(3) = "11" Then
		Max = UBound(AllStrDataList) + 1: Stemp = False
		ReDim intList(Max - 1) As Long
	Else
		Max = UBound(intList) + 1: Stemp = True
	End If
	'创建 HCS 字串和开始地址的字典，以便快速定位相同来源字串和相同开始地址的索引号
	Set AddDic = CreateObject("Scripting.Dictionary")
	Set StrDic = CreateObject("Scripting.Dictionary")
	'获取导入文件的字串数据
	If ImportSet(0) <> "4" Then
		'执行正则表达式
		RegExp.Global = True
		RegExp.IgnoreCase = False
		Select Case ImportSet(0)
		Case "0"
			RegExp.Pattern = "[\r\n]+(;)?([0-9]+),[0-9,\|\-]{4,}:([^\r\n]+)[\r\n]+([^\r\n]+)"
		Case "1"
			RegExp.Pattern = "[\r\n]+([0-9]+):([^\r\n]+)[\r\n]+([^\r\n]+)"
		Case "2"
			RegExp.Pattern = "[\r\n]+0x([0-9A-F]+),[0-9]+=([^\r\n]+)"
		Case "3"
			RegExp.Pattern = "[\r\n]*'([0-9A-F]+)\t([^\r\n]+)\t([^\r\n]+)"
		End Select
		Set Matches = RegExp.Execute(ReadTextFile(ImportSet(1),TempList(0)))
		If Matches.Count = 0 Then
			ImportTranString = -1
			MsgBox MsgList(21),vbOkOnly+vbInformation,MsgList(11)
			GoTo ExitFunction
		End If
		For i = 0 To Matches.Count - 1
			Select Case ImportSet(0)
			Case "0"
				j = StrToLong(Matches(i).SubMatches(1))
				TempList(0) = Matches(i).SubMatches(2)
				TempList(1) = Matches(i).SubMatches(3)
			Case "1"
				j = StrToLong(Matches(i).SubMatches(0))
				'转换点睛文件中的 \" 转义符
				TempList(0) = Replace$(Matches(i).SubMatches(1),"\""","""")
				TempList(1) = Replace$(Matches(i).SubMatches(2),"\""","""")
			Case "2"
				j = Val("&H" & Matches(i).SubMatches(0))
				TempList(0) = ""
				'判断开始地址是否存在
				If StrIDIndexDic.Exists(j) Then
					TempList(0) = AllStrDataList(StrIDIndexDic.Item(j)).Source.sString
					TempList(1) = Matches(i).SubMatches(1)
				End If
			Case "3"
				j = Val("&H" & Matches(i).SubMatches(0))
				'转换 Athena-A 中的 [\x] 形式的转义符
				TempList(0) = AthenaA(Matches(i).SubMatches(1))
				TempList(1) = AthenaA(Matches(i).SubMatches(2))
			End Select
			'跳过未翻译字串
			If TempList(0) <> "" And TempList(0) <> TempList(1) Then
				If Not StrDic.Exists(TempList(0)) Then
					StrDic.Add(TempList(0),TempList(1))
					AddDic.Add(TempList(0),j)
				Else
					StrDic.Item(TempList(0)) = StrDic.Item(TempList(0)) & vbNullChar & TempList(1)
					AddDic.Item(TempList(0)) = AddDic.Item(TempList(0)) & vbNullChar & j
				End If
				k = k + 1
			End If
			If ShowMsg > 0 Then
				SetTextBoxString ShowMsg,MsgList(3) & " " & Format$(i / Matches.Count,"#%")
			ElseIf ShowMsg < 0 Then
				PSL.OutputWnd(0).Clear
				PSL.Output MsgList(3) & " " & Format$(i / Matches.Count,"#%")
			End If
			'DoEvents '转让控制权，允许操作系统处理其他事件
			If StopProcess(StopHwnd,VK_ESCAPE) = True Then
				ImportTranString = -2
				GoTo ExitFunction
			End If
		Next i
		If ShowMsg > 0 Then
			SetTextBoxString ShowMsg,MsgList(3) & " 100%"
		ElseIf ShowMsg < 0 Then
			PSL.Output MsgList(3) & " 100%"
		End If
		MsgList(1) = MsgList(3) & " 100%" & vbCrLf & MsgList(1)
		Set Matches = Nothing
	Else
		Dim File As FILE_PROPERTIE,TempData As STRING_PROPERTIE
		ReDim orgList(Max) As Long,LangList(0) As LANG_PROPERTIE,DataList(0) As STRING_PROPERTIE
		'查找未获取引用的字串索引
		If trnFile.Magic <> "" Then
			For i = 0 To Max - 1
				If Stemp = False Then j = i Else j = intList(i)
				With AllStrDataList(j)
					If .Moveable = 0 Or .Moveable = 2 Then
						If .Source.GetRefState = 0 Then
							orgList(x) = j
							x = x + 1
						End If
					End If
				End With
			Next i
			'获取引用地址和代码
			If x > 0 Then
				'打开原始文件，以便查找引用代码和列表
				Mode = LoadFile(trnFile.FilePath,FN,0,0,0,StrToLong(Selected(1)))
				If Mode < -1 Then GoTo ExitFunction
				If ShowMsg > 0 Then
					SetTextBoxString ShowMsg,MsgList(2)
				ElseIf ShowMsg < 0 Then
					PSL.OutputWnd(0).Clear
					PSL.Output MsgList(2)
				End If
				ReDim Preserve orgList(x - 1) As Long
				i = GetVARefListBatch(trnFile,FN,AllStrDataList,OrgStrTypeList,orgList,TempList,0,Mode,ShowMsg,True)
				UnLoadFile(FN,0,Mode)
				'取消获取引用时退出
				If i < -1 Then
					ImportTranString = -2
					GoTo ExitFunction
				End If
				MsgList(4) = MsgList(2) & " 100%" & vbCrLf & MsgList(4)
			End If
		End If
		'检查文件类型并读取来源文件头
		File.FilePath = ImportSet(1)
		GetHeaders(File.FilePath,File,StrToLong(Selected(1)),File.FileType)
		If File.Magic = "" Then File.Magic = trnFile.Magic
		'获取二个文件每个节的偏移地址差额(File - orgFile)
		orgList = GetSecHeaderDiff(trnFile,File)
		'获取翻译的代码页编码范围
		'If LangIDIndexDic.Exists(trn.Language.LangID) Then
		'	LangList(0) = UniLangList(LangIDIndexDic.Item(trn.Language.LangID))
		'Else
		'	LangList = UseLangList
		'End If
		'打开导入文件，以便获取每个引用代码所引用的字串地址及字串
		Mode = LoadFile(File.FilePath,FN,0,0,0,StrToLong(Selected(1)))
		If Mode < -1 Then GoTo ExitFunction
		'获取翻译
		For i = 0 To Max - 1
			If Stemp = False Then j = i Else j = intList(i)
			TempData = AllStrDataList(j)
			With TempData
				If .WriteType < 0 Then GoTo NextPos
				'判断是否已翻译
				If intArray(0) = 1 Then
					If .WriteType > 0 Then GoTo NextPos
				ElseIf intArray(0) = 10 Then
					If .WriteType = 0 Then GoTo NextPos
				End If
				'判断是否已锁定
				If intArray(2) = 1 Then
					If .LockState = 1 Then GoTo NextPos
				ElseIf intArray(2) = 10 Then
					If .LockState = 0 Then GoTo NextPos
				End If
				'定义翻译的代码页
				If .WriteType = 0 Then
					If .Source.CodePage <> CP_UNICODELITTLE And .Source.CodePage <> CP_UNICODEBIG And _
						.Source.CodePage <> CP_UTF7 And .Source.CodePage <> CP_UTF8 And _
						.Source.CodePage <> CP_UTF32LE And .Source.CodePage <> CP_UTF32BE Then
						.Source.CodePage = trnFile.CopePage
					End If
					.Trans.CodePage = trnFile.CopePage
				Else
					.Source.CodePage = .Trans.CodePage
				End If
				'结束地址置零，以便自动获取结束地址
				.Source.lEndAddress = 0
				'初始化字串ID，以便不替换字串索引 Key
				.ID = -1
				'获取翻译的代码页编码范围
				LangList = GetSubLangListByCP(AllLangList,.Trans.CodePage)
				'获取提取设置，以便根据导入设置更改提取设置
				TempList = ExtractSet
				'根据代码页设置字符编码的提取选项
				Select Case .Source.CodePage
				Case CP_UNICODELITTLE
					TempList(4) = "0100000"
				Case CP_UNICODEBIG
					TempList(4) = "0001000"
				Case CP_UTF8
					TempList(4) = "0010000"
				Case CP_UTF7
					TempList(4) = "0000100"
				Case CP_UTF32LE,CP_UTF_32LE
					TempList(4) = "0000010"
				Case CP_UTF32BE,CP_UTF_32BE
					TempList(4) = "0000001"
				Case Is <> CP_UNKNOWN
					TempList(4) = "1000000"
				End Select
			End With
			'获取被引用的字串地址及所在区段
			DataList = GetStrAddressByVA(File,FN,TempData,orgList,Mode)
			'获取翻译
			For x = 0 To UBound(DataList)
				If DataList(x).Source.lStartAddress > -1 Then
					With GetString(File,FN,DataList(x),LangList,OrgStrTypeList,TempList,0,Mode,True).Source
						'跳过未翻译字串
						If .sString <> "" And .sString <> DataList(x).Source.sString Then
							If Not StrDic.Exists(AllStrDataList(j).Source.sString) Then
								StrDic.Add(TempData.Source.sString,.sString)
								AddDic.Add(TempData.Source.sString,.lStartAddress)
							Else
								StrDic.Item(TempData.Source.sString) = StrDic.Item(TempData.Source.sString) & vbNullChar & .sString
								AddDic.Item(TempData.Source.sString) = AddDic.Item(TempData.Source.sString) & vbNullChar & .lStartAddress
							End If
							k = k + 1
						End If
					End With
				End If
			Next x
			NextPos:
			If ShowMsg > 0 Then
				SetTextBoxString ShowMsg,MsgList(4) & " " & Format$(i / Max,"#%")
			ElseIf ShowMsg < 0 Then
				PSL.OutputWnd(0).Clear
				PSL.Output MsgList(4) & " " & Format$(i / Max,"#%")
			End If
			'DoEvents '转让控制权，允许操作系统处理其他事件
			If StopProcess(StopHwnd,VK_ESCAPE) = True Then
				ImportTranString = -2
				GoTo ExitFunction
			End If
		Next i
		UnLoadFile(FN,0,Mode)
		If ShowMsg > 0 Then
			SetTextBoxString ShowMsg,MsgList(4) & " 100%"
		ElseIf ShowMsg < 0 Then
			PSL.OutputWnd(0).Clear
			PSL.Output MsgList(4) & " 100%"
		End If
		MsgList(1) = MsgList(4) & " 100%" & vbCrLf & MsgList(1)
	End If
	'没有需要导入的翻译时退出
	If k = 0 Then
		ReDim intList(0) As Long
		MsgBox MsgList(24),vbOkOnly+vbInformation,MsgList(11)
		GoTo ExitFunction
	End If
	'打开原始文件，以便查找引用代码和列表
	Mode = LoadFile(trnFile.FilePath,FN,0,0,0,StrToLong(Selected(1)))
	If Mode < -1 Then GoTo ExitFunction
	'开始导入
	ReDim orgList(Max) As Long,trnList(Max) As Long
	ReDim DataList(0) As STRING_PROPERTIE
	DataList = AllStrDataList
	For i = 0 To Max - 1
		If Stemp = False Then k = i Else k = intList(i)
		With DataList(k)
			If Not StrDic.Exists(.Source.sString) Then GoTo NextNo
			'重置标志，以便为过滤显示设置导入翻译标志
			'If .Trans.NewStemp = 1 Then .Trans.NewStemp = 0
			'判断是否已翻译
			If intArray(0) = 1 Then
				If .WriteType > 0 Then GoTo NextNo
			ElseIf intArray(0) = 10 Then
				If .WriteType = 0 Then GoTo NextNo
			End If
			'判断是否已锁定
			If intArray(2) = 1 Then
				If .LockState = 1 Then GoTo NextNo
			ElseIf intArray(2) = 10 Then
				If .LockState = 0 Then GoTo NextNo
			End If
			'判断开始地址是否相同
			If intArray(1) <> 11 Then
				TempList = ReSplit(AddDic.Item(.Source.sString),vbNullChar)
				x = -1
				ReDim intArry(UBound(TempList)) As Long
				If intArray(1) = 1 Then
					For j = 0 To UBound(TempList)
						If .Source.lStartAddress = StrToLong(TempList(j)) Then
							x = x + 1
							intArry(x) = j
						End If
					Next j
				Else
					For j = 0 To UBound(TempList)
						If .Source.lStartAddress <> StrToLong(TempList(j)) Then
							x = x + 1
							intArry(x) = j
						End If
					Next j
				End If
				If x = UBound(TempList) Then GoTo NextNo
				TempList = ReSplit(StrDic.Item(.Source.sString),vbNullChar)
				If x > -1 Then
					ReDim Preserve intArry(x) As Long
					Call DelArray(TempList,intArry)
				End If
			Else
				TempList = ReSplit(StrDic.Item(.Source.sString),vbNullChar)
			End If
			'同个字串有多个翻译时选择翻译
			x = 0
			If intArray(3) = 0 Then
				TempList = ClearTextArray(TempList)
				If UBound(TempList) > 0 Then
					x = SelectTrans(.Source.sString,TempList,MsgList,intArray(3))
					If x = -2 Then Exit For
					If x = -1 Then GoTo NextNo
				End If
			End If
			'导入符合条件的翻译，并更改相应的字串数据参数，记录是否需要重置的占用链列表和移位
			If .Trans.sString = TempList(x) Then GoTo NextNo
			'为过滤显示设置导入翻译标志
			.Trans.NewStemp = 1
			.FillLength = 0
			.Trans.sString = TempList(x)
			If .WriteType > -2 And .WriteType < 1 Then
				If .Source.CodePage <> CP_UNICODELITTLE And .Source.CodePage <> CP_UNICODEBIG And _
					.Source.CodePage <> CP_UTF7 And .Source.CodePage <> CP_UTF8 And _
					.Source.CodePage <> CP_UTF32LE And .Source.CodePage <> CP_UTF32BE Then
					.Trans.CodePage = trnFile.CopePage
					If .Trans.CodePage = 0 Then .Trans.CodePage = .Source.CodePage
				End If
				.Trans.lMaxAddress = GetMaxAddress(DataList(k),True)
			End If
			TempList(x) = Convert(.Trans.sString)
			.Trans.lCharLength = Len(TempList(x))
			.Trans.lHexLength = StrHexLength(TempList(x),.Trans.CodePage,0)
			'获取字串类型长度及其翻译更改和截断写入引起的差额，用于还原开始地址为完整翻译的地址
			'.Trans.MoveLength 为截断写入后与完整翻译之间的长度差额
			.Trans.MoveLength = StrTypeLength(DataList(k),OrgStrTypeList,FN,Mode,1) - .Trans.MoveLength
			'更改翻译地址及需要获取引用的字串索引
			ChangeStrAddAndGetRefIndex(DataList,orgList,trnList,m,n,k,IIf(.WriteType > -2 And .WriteType < 1,1,0))
			intList(ImportTranString) = k
			ImportTranString = ImportTranString + 1
			NextNo:
		End With
		If ShowMsg > 0 Then
			SetTextBoxString ShowMsg,MsgList(1) & " " & Format$(i / Max,"#%")
		ElseIf ShowMsg < 0 Then
			PSL.OutputWnd(0).Clear
			PSL.Output MsgList(1) & " " & Format$(i / Max,"#%")
		End If
		'DoEvents '转让控制权，允许操作系统处理其他事件
		If StopProcess(StopHwnd,VK_ESCAPE) = True Then
			ImportTranString = -2
			GoTo ExitFunction
		End If
	Next i
	Set AddDic = Nothing: Set StrDic = Nothing
	'显示完成率
	If ShowMsg > 0 Then
		SetTextBoxString ShowMsg,MsgList(1) & " 100%"
	ElseIf ShowMsg < 0 Then
		PSL.OutputWnd(0).Clear
		PSL.Output MsgList(1) & " 100%"
	End If
	'获取字串的引用地址和引用代码
	If m + n > 0 Then
		If m > 0 Then
			If ShowMsg > 0 Then
				SetTextBoxString ShowMsg,MsgList(2),True
			ElseIf ShowMsg < 0 Then
				PSL.Output MsgList(2)
			End If
			ReDim Preserve orgList(m - 1) As Long
			i = GetVARefListBatch(trnFile,FN,DataList,OrgStrTypeList,orgList,TempList,0,Mode,ShowMsg,True)
			If i < -1 Then
				ImportTranString = -2
				GoTo ExitFunction
			End If
		End If
		If n > 0 Then
			ReDim Preserve trnList(n - 1) As Long
			ReDim TempList(n - 1) As String
			Call GetVARefListBatch(trnFile,"",DataList,OrgStrTypeList,trnList,TempList,1,0,0)
		End If
	End If
	If ImportTranString > 0 Then
		ReDim Preserve intList(ImportTranString - 1) As Long
		AllStrDataList = DataList: Erase DataList
		'显示导入数
		If ShowMsg > 0 Then
			SetTextBoxString ShowMsg,Replace$(MsgList(25),"%s",CStr$(ImportTranString)),True
		ElseIf ShowMsg < 0 Then
			PSL.Output Replace$(MsgList(25),"%s",CStr$(ImportTranString))
		End If
	Else
		ReDim intList(0) As Long
		MsgBox MsgList(24),vbOkOnly+vbInformation,MsgList(11)
	End If
	If StrToLong(Selected(23)) = 1 Then Beep
	'退出函数
	ExitFunction:
	'隐藏主窗口中的取消操作按钮，启用 Esc 键的退出响应
	Call ShowButton(StopHwnd,VK_ESCAPE,False)
	UnLoadFile(FN,0,Mode)
	Set Matches = Nothing
	Set AddDic = Nothing: Set StrDic = Nothing
End Function


'选择翻译对话框
Private Function SelectTrans(ByVal Source As String,TransList() As String,MsgList() As String,FristCheck As Long) As Long
	Begin Dialog UserDialog 650,238,MsgList(5),.SelectTransDlgFunc ' %GRID:10,7,1,1
		Text 10,7,630,14,MsgList(6),.MsgText
		TextBox 10,28,630,49,.SourceTextBox,1
		ListBox 10,84,630,112,TransList(),.TransListBox,1
		CheckBox 10,210,300,21,MsgList(7),.CheckBox
		PushButton 320,210,100,21,MsgList(8),.ExitButton
		PushButton 430,210,100,21,MsgList(9),.SkipButton
		PushButton 540,210,100,21,MsgList(10),.AbortButton
	End Dialog
	Dim dlg As UserDialog
	dlg.SourceTextBox = Source
	dlg.CheckBox = FristCheck
	SelectTrans = Dialog(dlg)
	FristCheck = dlg.CheckBox
	If SelectTrans > 1 Then
		SelectTrans = -(SelectTrans - 1)
		Exit Function
	End If
	SelectTrans = dlg.TransListBox
End Function


'选择翻译对话框函数
Private Function SelectTransDlgFunc(DlgItem$, Action%, SuppValue&) As Boolean
	Dim i As Long,j As Long
	Select Case Action%
	Case 1 ' 对话框窗口初始化
		DlgEnable "SourceTextBox",False
		'设置当前对话框字体
		If CheckFont(LFList(0)) = True Then
			j = CreateFont(0,LFList(0))
			If j = 0 Then Exit Function
			For i = 0 To DlgCount() - 1
				SendMessageLNG(GetDlgItem(SuppValue,DlgControlId(DlgName(i))),WM_SETFONT,j,0)
			Next i
		End If
	Case 2 ' 数值更改或者按下按钮时
		If DlgItem$ = "CheckBox" Then
			SelectTransDlgFunc = True ' 防止按下按钮时关闭对话框窗口
		End If
	End Select
End Function


'获取二个文件的文件节开始地址的差额，不存在时返回目标文件大小值
'Mode = False，检查偏移地址，否则检查相对虚拟地址
Private Function GetSecHeaderDiff(srcFile As FILE_PROPERTIE,trgFile As FILE_PROPERTIE,Optional ByVal Mode As Boolean) As Long()
	Dim i As Integer
	ReDim TempList(srcFile.MaxSecIndex) As Long
	For i = 0 To srcFile.MaxSecIndex
		If Mode = False Then
			TempList(i) = trgFile.SecList(i).lPointerToRawData - srcFile.SecList(i).lPointerToRawData
		Else
			TempList(i) = trgFile.SecList(i).lVirtualAddress - srcFile.SecList(i).lVirtualAddress
		End If
	Next i
	GetSecHeaderDiff = TempList
End Function


'按引用地址和引用代码获取字串地址
Private Function GetStrAddressByVA(File As FILE_PROPERTIE,FN As FILE_IMAGE,strData As STRING_PROPERTIE, _
				DiffList() As Long,ByVal Mode As Long) As STRING_PROPERTIE()
	Dim i As Long,j As Long,k As Long,n As Long,x As Long
	Dim ROffset As Long,RVA As Long,VRK As Long,Dic As Object
	ReDim DataList(0) As STRING_PROPERTIE
	DataList(0) = strData
	'无字串开始地址算法时，非 PE 文件直接退出
	If InStr(File.Magic,"NotPE") Then
		If UseRefTypeList(0).StrAddAlgorithm = "" Then
			GetStrAddressByVA = DataList
			Exit Function
		End If
	End If
	'无引用时返回原始地址
	If strData.Source.lReferenceNum = 0 Then
		With DataList(0).Source
			If DiffList(strData.Source.inSectionID) = File.FileSize Then
				.lStartAddress = -1
			Else
				.lStartAddress = .lStartAddress + DiffList(strData.Source.inSectionID)
			End If
		End With
		GetStrAddressByVA = DataList
		Exit Function
	End If
	'设置地址为 -1，以便和无引用字串区分地址
	DataList(0).Source.lStartAddress = -1
	Set Dic = CreateObject("Scripting.Dictionary")
	ReDim Preserve DataList(strData.Source.lReferenceNum * (File.MaxSecIndex + 1)) As STRING_PROPERTIE
	For i = 0 To strData.Source.lReferenceNum - 1
		On Error Resume Next
		With strData.Source.Reference(i)
			'跳过目标文件不存在的区段
			If DiffList(.inSecID) = File.FileSize Then GoTo NextNo
			'检查引用地址是否在文件最大区段内
			x = .lAddress + DiffList(.inSecID)
			If x + 4 > File.SecList(File.MaxSecIndex).lPointerToRawData Then GoTo NextNo
			'获取字串开始地址
			If InStr(File.Magic,"NotPE") = 0 Then
				RVA = GetLong(FN,x,Mode)
			ElseIf UseRefTypeList(0).ByteOrder = 0 Then
				RVA = Bytes2Val(GetBytes(FN,UseRefTypeList(0).ByteLength,x,Mode),UseRefTypeList(0).ByteLength,False)
			Else
				RVA = Bytes2Val(GetBytes(FN,UseRefTypeList(0).ByteLength,x,Mode),UseRefTypeList(0).ByteLength,True)
			End If
			'获取引用地址所在节的虚拟开始地址和偏移开始地址的差额
			With File.SecList(.inSecID)
				ROffset = .lPointerToRawData
				VRK = .lVirtualAddress - .lPointerToRawData
			End With
		End With
		On Error GoTo 0
		'按引用代码值获取字串地址
		Select Case File.Magic
		Case "PE64","NET64","MAC64"
			On Error GoTo NextPE64
			For j = 0 To File.MaxSecIndex - 1
				With File.SecList(j)
					If .lPointerToRawData >= ROffset Then
						k = .lVirtualAddress - .lPointerToRawData
						k = CheckLongPlus(RVA,x + VRK + 4 - k)
						If k > x Then	'字串地址都等于或大于引用地址
							If k >= .lPointerToRawData And k < .lPointerToRawData + .lSizeOfRawData - 1 Then
								If Not Dic.Exists(k) Then
									Dic.Add(k,i)
									DataList(n) = strData
									DataList(n).Source.lStartAddress = k
									DataList(n).Source.inSectionID = j
									n = n + 1
								End If
							End If
						End If
					End If
				End With
				NextPE64:
			Next j
			On Error GoTo 0
		Case "PE32","NET32","MAC32"
			On Error GoTo NextPE32
			For j = 0 To File.MaxSecIndex - 1
				With File.SecList(j)
					If .SubSecs > 0 Then
						For x = 0 To .SubSecs - 1
							k = .SubSecList(x).lVirtualAddress - .SubSecList(x).lPointerToRawData
							k = (RVA - File.ImageBase) - k
							If k >= .SubSecList(x).lPointerToRawData And _
								k < .SubSecList(x).lPointerToRawData + .SubSecList(x).lSizeOfRawData - 1 Then
								If Not Dic.Exists(k) Then
									Dic.Add(k,i)
									DataList(n) = strData
									DataList(n).Source.lStartAddress = k
									DataList(n).Source.inSectionID = j
									n = n + 1
								End If
							End If
						Next x
					Else
						k = .lVirtualAddress - .lPointerToRawData
						k = (RVA - File.ImageBase) - k
						If k >= .lPointerToRawData And k < .lPointerToRawData + .lSizeOfRawData - 1 Then
							If Not Dic.Exists(k) Then
								Dic.Add(k,i)
								DataList(n) = strData
								DataList(n).Source.lStartAddress = k
								DataList(n).Source.inSectionID = j
								n = n + 1
							End If
						End If
					End If
				End With
				NextPE32:
			Next j
			On Error GoTo 0
		Case "NotPE64"
			On Error GoTo NextNotPE64
			With File.SecList(0)
				k = Eval(Replace(Replace(Replace(UseRefTypeList(0).StrAddAlgorithm,"{refcode}",CStr(RVA)), _
					"{refstartaddress}",CStr(x)),"{strtypelength}",CStr(strData.Source.StrTypeLength)))
				If k > x Then	'字串地址都等于或大于引用地址
					If k >= .lPointerToRawData And k < .lPointerToRawData + .lSizeOfRawData - 1 Then
						If Not Dic.Exists(k) Then
							Dic.Add(k,i)
							DataList(n) = strData
							DataList(n).Source.lStartAddress = k
							DataList(n).Source.inSectionID = 0
							n = n + 1
						End If
					End If
				End If
			End With
			NextNotPE64:
			On Error GoTo 0
		Case "NotPE32"
			On Error GoTo NextNotPE32
			With File.SecList(0)
				k = Eval(Replace(Replace(Replace(UseRefTypeList(0).StrAddAlgorithm,"{refcode}",CStr(RVA)), _
					"{refstartaddress}",CStr(x)),"{strtypelength}",CStr(strData.Source.StrTypeLength)))
				If k >= .lPointerToRawData And k < .lPointerToRawData + .lSizeOfRawData - 1 Then
					If Not Dic.Exists(k) Then
						Dic.Add(k,i)
						DataList(n) = strData
						DataList(n).Source.lStartAddress = k
						DataList(n).Source.inSectionID = 0
						n = n + 1
					End If
				End If
			End With
			NextNotPE32:
			On Error GoTo 0
		End Select
		NextNo:
	Next i
	If n > 0 Then n = n - 1
	ReDim Preserve DataList(n) As STRING_PROPERTIE
	GetStrAddressByVA = DataList
	Set Dic = Nothing
End Function


'查看空余字节数据库的详细情况
'Mode = 6 查看所有可用空余字节详细信息
'Mode = 7 查看所有已被占用的空余字节详细信息
'Mode = 8 查看全部空余字节的详细信息
Private Sub FreeByteView(File As FILE_PROPERTIE,DataList() As FREE_BTYE_SPACE,ByVal AppID As Long,ByVal Mode As Long, _
			ByVal DisPlayFormat As Boolean,ByVal ShowMsg As Long)
	Dim i As Long,j As Long,k As Long,n As Long,m As Long
	Dim MsgList() As String,FN As Variant,sb As Object
	If getMsgList(UIDataList,MsgList,"FreeByteView",2) = False Then Exit Sub
	If Mode = 7 Then
		MsgList(0) = MsgList(1)
	ElseIf Mode = 8 Then
		MsgList(0) = MsgList(2)
	End If
	'打开文件
	On Error GoTo ErrHandle
	If Dir$(File.FilePath & ".xls") <> "" Then Kill File.FilePath & ".xls"
	FN = FreeFile
	Open File.FilePath & ".xls" For Binary Access Read Write Lock Write As #FN
	'写入说明
	WriteBinaryFile FN,CP_UNICODELITTLE,MsgList(0) & MsgList(3) & MsgList(4) & MsgList(7) & MsgList(7) & vbCrLf
	WriteBinaryFile FN,CP_UNICODELITTLE,MsgList(5) & MsgList(7) & MsgList(7) & vbCrLf,True
	'准备保存为文件的进度数据
	m = UBound(DataList)
	If m > 5000 Then
		If ShowMsg > 0 Then
			MsgList(9) = GetTextBoxString(ShowMsg) & vbCrLf & MsgList(9) & " "
		ElseIf ShowMsg < 0 Then
			ReDim TempList(PSL.OutputWnd(0).LineCount - 1) As String
			For i = 1 To PSL.OutputWnd(0).LineCount
				TempList(i - 1) = PSL.OutputWnd(0).Text(i)
			Next i
			MsgList(9) = StrListJoin(TempList,vbCrLf) & vbCrLf & MsgList(9) & " "
			Erase TempList
		End If
		'显示主窗口的取消操作按钮和禁止主窗口的 Esc 键响应退出主窗口
		Call ShowButton(StopHwnd,VK_ESCAPE,True)
	End If
	'写入数据
	On Error Resume Next
	Set sb = CreateObject("System.Text.StringBuilder")
	On Error GoTo 0
	If sb Is Nothing Then
		For i = LBound(DataList) To m
			With DataList(i)
				If .Length > 0 Then
					If Mode = 6 Then
						If .MoveType <> -1 And .MoveType <> -2 Then GoTo NextPos
					ElseIf Mode = 7 Then
						If .MoveType < 0 And .MoveType > -3 Then GoTo NextPos
					End If
					MsgList(0) = Replace$(MsgList(6),"%s!1!","#" & CStr$(i))
					MsgList(0) = Replace$(MsgList(0),"%s!2!",CStr$(IIf(.lNumber < 0,.lNumber,StrIDIndexDic.Item(.lNumber))))
					MsgList(0) = Replace$(MsgList(0),"%s!3!",File.SecList(.inSectionID).sName)
					MsgList(0) = Replace$(MsgList(0),"%s!4!",ValToStr(.Address,File.FileSize,DisPlayFormat))
					MsgList(0) = Replace$(MsgList(0),"%s!5!",ValToStr(.MaxAddress,File.FileSize,DisPlayFormat))
					MsgList(0) = Replace$(MsgList(0),"%s!6!",CStr$(.Length))
					MsgList(0) = Replace$(MsgList(0),"%s!7!",CStr$(IIf(.MoveType = -1 Or .MoveType = -2,.MoveType,StrIDIndexDic.Item(.MoveType))))
					If .lNumber < 0 Then j = j + 1
					If .MoveType = -1 Or .MoveType = -2 Then k = k + 1
					n = n + 1
					WriteBinaryFile FN,CP_UNICODELITTLE,MsgList(0),True
					NextPos:
					If m > 5000 Then
						If ShowMsg > 0 Then
							SetTextBoxString ShowMsg,MsgList(9) & Format$(i / m,"#%")
						ElseIf ShowMsg < 0 Then
							PSL.OutputWnd(0).Clear
							PSL.Output MsgList(9) & Format$(i / m,"#%")
						End If
						'DoEvents '转让控制权，允许操作系统处理其他事件
						If StopProcess(StopHwnd,VK_ESCAPE) = True Then Exit For
					End If
				End If
			End With
		Next i
	Else
		For i = LBound(DataList) To m
			With DataList(i)
				If .Length > 0 Then
					If Mode = 6 Then
						If .MoveType <> -1 And .MoveType <> -2 Then GoTo NextNo
					ElseIf Mode = 7 Then
						If .MoveType < 0 And .MoveType > -3 Then GoTo NextNo
					End If
					MsgList(0) = Replace$(MsgList(6),"%s!1!","#" & CStr$(i))
					MsgList(0) = Replace$(MsgList(0),"%s!2!",CStr$(IIf(.lNumber < 0,.lNumber,StrIDIndexDic.Item(.lNumber))))
					MsgList(0) = Replace$(MsgList(0),"%s!3!",File.SecList(.inSectionID).sName)
					MsgList(0) = Replace$(MsgList(0),"%s!4!",ValToStr(.Address,File.FileSize,DisPlayFormat))
					MsgList(0) = Replace$(MsgList(0),"%s!5!",ValToStr(.MaxAddress,File.FileSize,DisPlayFormat))
					MsgList(0) = Replace$(MsgList(0),"%s!6!",CStr$(.Length))
					MsgList(0) = Replace$(MsgList(0),"%s!7!",CStr$(IIf(.MoveType = -1 Or .MoveType = -2,.MoveType,StrIDIndexDic.Item(.MoveType))))
					If .lNumber < 0 Then j = j + 1
					If .MoveType = -1 Or .MoveType = -2 Then k = k + 1
					n = n + 1
					sb.AppendFormat "{0}",MsgList(0)
					NextNo:
					If m > 5000 Then
						If ShowMsg > 0 Then
							SetTextBoxString ShowMsg,MsgList(9) & Format$(i / m,"#%")
						ElseIf ShowMsg < 0 Then
							PSL.OutputWnd(0).Clear
							PSL.Output MsgList(9) & Format$(i / m,"#%")
						End If
						'DoEvents '转让控制权，允许操作系统处理其他事件
						If StopProcess(StopHwnd,VK_ESCAPE) = True Then Exit For
					End If
				End If
			End With
		Next i
		WriteBinaryFile FN,CP_UNICODELITTLE,sb.ToString(),True
	End If
	'显示主窗口的取消操作按钮和禁止主窗口的 Esc 键响应退出主窗口
	Call ShowButton(StopHwnd,VK_ESCAPE,False)
	WriteBinaryFile FN,CP_UNICODELITTLE,MsgList(7) & MsgList(7) & vbCrLf,True
	WriteBinaryFile FN,CP_UNICODELITTLE,Replace$(Replace$(Replace$(Replace$(Replace$( _
				MsgList(8),"%s",CStr$(n)),"%d",CStr$(n - j)),"%k",CStr$(j)),"%m",CStr$(k)),"%n",CStr$(n - k)) & vbCrLf,True
	WriteBinaryFile FN,CP_UNICODELITTLE,MsgList(7) & MsgList(7) & vbCrLf,True
	Set sb = Nothing
	Close #FN
	Erase MsgList
	'查看数据
	ReDim FileDataList(0) As String
	FileDataList(0) = File.FilePath & ".xls" & JoinStr & "unicodeFFFE"
	If OpenFile(File.FilePath & ".xls",FileDataList,AppID,False) = True Then
		If AppID = 3 Then WriteSettings("Tools")
	End If
	If AppID = 0 Then
		 On Error Resume Next
		 If Dir$(File.FilePath & ".xls") <> "" Then Kill File.FilePath & ".xls"
		 On Error GoTo 0
	End If
	Exit Sub
	'错误处理
	ErrHandle:
	On Error Resume Next
	Close #FN
	Err.Source = "NotWriteFile"
	Err.Description = Err.Description & JoinStr & File.FilePath & ".xls"
	Call sysErrorMassage(Err,1)
End Sub


'查看字串前和引用前后的字节，用于字串类型的定义
Private Sub FileByteView(File As FILE_PROPERTIE,DataList() As STRING_PROPERTIE,intList() As Long,ByVal AppID As Long,ByVal DisPlayFormat As Boolean)
	Dim i As Long,j As Long,Mode As Long,Stemp As Boolean
	Dim LogFN As Variant,FN1 As FILE_IMAGE,FN2 As FILE_IMAGE,MsgList() As String,sb As Object
	If getMsgList(UIDataList,MsgList,"FileByteView",2) = False Then Exit Sub
	'打开原始文件
	Mode = LoadFile(File.FilePath,FN1,0,0,0,StrToLong(Selected(1)))
	If Mode < -1 Then GoTo ErrHandle
	'获取实际目标文件
	i = InStrRev(LCase$(File.FilePath),".bak")
	If i > 1 Then
		If Mid$(LCase$(File.FilePath),i) = ".bak" Then
			Mode = LoadFile(Left$(File.FilePath,i - 1),FN2,0,0,0,Mode)
			If Mode < -1 Then GoTo ErrHandle
			Stemp = True
		End If
	End If
	'打开文件
	On Error GoTo ErrHandle
	If Dir$(File.FilePath & ".xls") <> "" Then Kill File.FilePath & ".xls"
	LogFN = FreeFile
	Open File.FilePath & ".xls" For Binary Access Read Write Lock Write As #LogFN
	'写入数据
	WriteBinaryFile LogFN,CP_UNICODELITTLE,MsgList(0)
	On Error Resume Next
	Set sb = CreateObject("System.Text.StringBuilder")
	On Error GoTo 0
	If sb Is Nothing Then
		For i = 0 To UBound(intList)
			ReDim TempList(9) As String
			With DataList(intList(i)).Source
				TempList(0) = Replace$(MsgList(1),"%s",.sString)
				TempList(1) = Replace$(Replace$(Replace$(MsgList(2),"%s!1!",CStr$(.CodePage)),"%s!2!",ValToStr(.CodePage,0,True)), _
								"%s!3!",Byte2Hex(CorSigCompressByte(.CodePage),0,-1))
				TempList(2) = Replace$(Replace$(Replace$(MsgList(3),"%s!1!",CStr$(.lHexLength)),"%s!2!",ValToStr(.lHexLength,0,True)), _
								"%s!3!",Byte2Hex(CorSigCompressByte(.lHexLength),0,-1))
				TempList(3) = Replace$(Replace$(Replace$(MsgList(4),"%s!1!",CStr$(.lCharLength)),"%s!2!",ValToStr(.lCharLength,0,True)), _
								"%s!3!",Byte2Hex(CorSigCompressByte(.lCharLength),0,-1))
				TempList(4) = Replace$(Replace$(Replace$(MsgList(5),"%s!1!",CStr$(.lHexLength + .lCharLength)), _
								"%s!2!",ValToStr(.lHexLength + .lCharLength,0,True)), _
								"%s!3!",Byte2Hex(CorSigCompressByte(.lHexLength + .lCharLength),0,-1))
				TempList(5) = Replace$(MsgList(6),"%s",CStr$(.lReferenceNum))
				TempList(6) = Replace$(MsgList(7),"%s",SeparatHex(Byte2Hex(GetBytes(FN1,32,.lStartAddress - 32,Mode),0,-1)))
				If .lReferenceNum > 0 Then
					ReDim Preserve TempList(10 + .lReferenceNum) As String
					TempList(7) = MsgList(8) & MsgList(8) & vbCrLf
					TempList(8) = MsgList(9)
					TempList(9) = MsgList(8) & MsgList(8) & vbCrLf
					For j = 0 To .lReferenceNum - 1
						TempList(10 + j) = Replace$(MsgList(10),"%s!1!",ValToStr(.Reference(j).lAddress,File.FileSize,DisPlayFormat))
						TempList(10 + j) = Replace$(TempList(10 + j),"%s!2!",.Reference(j).sCode)
						TempList(10 + j) = Replace$(TempList(10 + j),"%s!3!",SeparatHex(Byte2Hex(GetBytes(FN1,32,.Reference(j).lAddress - 32,Mode),0,-1)))
						TempList(10 + j) = Replace$(TempList(10 + j),"%s!4!",SeparatHex(Byte2Hex(GetBytes(FN1,32,.Reference(j).lAddress + 4,Mode),0,-1)))
					Next j
					TempList(10 + .lReferenceNum) = MsgList(8) & MsgList(8) & vbCrLf & vbCrLf
				Else
					TempList(7) = MsgList(8) & MsgList(8) & vbCrLf & vbCrLf
				End If
			End With
			WriteBinaryFile LogFN,CP_UNICODELITTLE,Join$(TempList,""),True
			If Stemp = True Then
				ReDim TempList(9) As String
				With DataList(intList(i)).Trans
					TempList(0) = Replace$(MsgList(11),"%s",.sString)
					TempList(1) = Replace$(Replace$(Replace$(MsgList(12),"%s!1!",CStr$(.CodePage)),"%s!2!",ValToStr(.CodePage,0,True)), _
									"%s!3!",Byte2Hex(CorSigCompressByte(.CodePage),0,-1))
					TempList(2) = Replace$(Replace$(Replace$(MsgList(13),"%s!1!",CStr$(.lHexLength)),"%s!2!",ValToStr(.lHexLength,0,True)), _
									"%s!3!",Byte2Hex(CorSigCompressByte(.lHexLength),0,-1))
					TempList(3) = Replace$(Replace$(Replace$(MsgList(14),"%s!1!",CStr$(.lCharLength)),"%s!2!",ValToStr(.lCharLength,0,True)), _
									"%s!3!",Byte2Hex(CorSigCompressByte(.lCharLength),0,-1))
					TempList(4) = Replace$(Replace$(Replace$(MsgList(15),"%s!1!",CStr$(.lHexLength + .lCharLength)), _
									"%s!2!",ValToStr(.lHexLength + .lCharLength,0,True)), _
									"%s!3!",Byte2Hex(CorSigCompressByte(.lHexLength + .lCharLength),0,-1))
					TempList(5) = Replace$(MsgList(16),"%s",CStr$(.lReferenceNum))
					TempList(6) = Replace$(MsgList(17),"%s",SeparatHex(Byte2Hex(GetBytes(FN2,32,.lStartAddress - 32,Mode),0,-1)))
				End With
				With DataList(intList(i)).Source
					If .lReferenceNum > 0 Then
						ReDim TempArray(0) As String
						TempArray = GetRefCodeList(GetVARefForMoveMode2(File,DataList(intList(i))),True)
						ReDim Preserve TempList(10 + .lReferenceNum) As String
						TempList(7) = MsgList(8) & MsgList(8) & vbCrLf
						TempList(8) = MsgList(9)
						TempList(9) = MsgList(8) & MsgList(8) & vbCrLf
						For j = 0 To .lReferenceNum - 1
							TempList(10 + j) = Replace$(MsgList(10),"%s!1!",ValToStr(.Reference(j).lAddress,File.FileSize,DisPlayFormat))
							TempList(10 + j) = Replace$(TempList(10 + j),"%s!2!",TempArray(j))
							TempList(10 + j) = Replace$(TempList(10 + j),"%s!3!",SeparatHex(Byte2Hex(GetBytes(FN2,32,.Reference(j).lAddress - 32,Mode),0,-1)))
							TempList(10 + j) = Replace$(TempList(10 + j),"%s!4!",SeparatHex(Byte2Hex(GetBytes(FN2,32,.Reference(j).lAddress + 4,Mode),0,-1)))
						Next j
						TempList(10 + .lReferenceNum) = MsgList(8) & MsgList(8) & vbCrLf & vbCrLf
					Else
						TempList(7) = MsgList(8) & MsgList(8) & vbCrLf & vbCrLf
					End If
				End With
				WriteBinaryFile LogFN,CP_UNICODELITTLE,Join$(TempList,""),True
			End If
		Next i
	Else
		For i = 0 To UBound(intList)
			With DataList(intList(i)).Source
				sb.AppendFormat "{0}",Replace$(MsgList(1),"%s",.sString)
				sb.AppendFormat "{0}",Replace$(Replace$(Replace$(MsgList(2),"%s!1!",CStr$(.CodePage)),"%s!2!",ValToStr(.CodePage,0,True)), _
								"%s!3!",Byte2Hex(CorSigCompressByte(.CodePage),0,-1))
				sb.AppendFormat "{0}",Replace$(Replace$(Replace$(MsgList(3),"%s!1!",CStr$(.lHexLength)),"%s!2!",ValToStr(.lHexLength,0,True)), _
								"%s!3!",Byte2Hex(CorSigCompressByte(.lHexLength),0,-1))
				sb.AppendFormat "{0}",Replace$(Replace$(Replace$(MsgList(4),"%s!1!",CStr$(.lCharLength)),"%s!2!",ValToStr(.lCharLength,0,True)), _
								"%s!3!",Byte2Hex(CorSigCompressByte(.lCharLength),0,-1))
				sb.AppendFormat "{0}",Replace$(Replace$(Replace$(MsgList(5),"%s!1!",CStr$(.lHexLength + .lCharLength)), _
								"%s!2!",ValToStr(.lHexLength + .lCharLength,0,True)), _
								"%s!3!",Byte2Hex(CorSigCompressByte(.lHexLength + .lCharLength),0,-1))
				sb.AppendFormat "{0}",Replace$(MsgList(6),"%s",CStr$(.lReferenceNum))
				sb.AppendFormat "{0}",Replace$(MsgList(7),"%s",SeparatHex(Byte2Hex(GetBytes(FN1,32,.lStartAddress - 32,Mode),0,-1)))
				If .lReferenceNum > 0 Then
					sb.AppendFormat "{0}",MsgList(8) & MsgList(8) & vbCrLf
					sb.AppendFormat "{0}",MsgList(9)
					sb.AppendFormat "{0}",MsgList(8) & MsgList(8) & vbCrLf
					ReDim TempList(.lReferenceNum) As String
					For j = 0 To .lReferenceNum - 1
						TempList(j) = Replace$(MsgList(10),"%s!1!",ValToStr(.Reference(j).lAddress,File.FileSize,DisPlayFormat))
						TempList(j) = Replace$(TempList(j),"%s!2!",.Reference(j).sCode)
						TempList(j) = Replace$(TempList(j),"%s!3!",SeparatHex(Byte2Hex(GetBytes(FN1,32,.Reference(j).lAddress - 32,Mode),0,-1)))
						TempList(j) = Replace$(TempList(j),"%s!4!",SeparatHex(Byte2Hex(GetBytes(FN1,32,.Reference(j).lAddress + 4,Mode),0,-1)))
					Next j
					sb.AppendFormat "{0}",StrListJoin(TempList,"") & MsgList(8) & MsgList(8) & vbCrLf & vbCrLf
				Else
					sb.AppendFormat "{0}",MsgList(8) & MsgList(8) & vbCrLf & vbCrLf
				End If
			End With
			If Stemp = True Then
				With DataList(intList(i)).Trans
					sb.AppendFormat "{0}",Replace$(MsgList(11),"%s",.sString)
					sb.AppendFormat "{0}",Replace$(Replace$(Replace$(MsgList(12),"%s!1!",CStr$(.CodePage)),"%s!2!",ValToStr(.CodePage,0,True)), _
									"%s!3!",Byte2Hex(CorSigCompressByte(.CodePage),0,-1))
					sb.AppendFormat "{0}",Replace$(Replace$(Replace$(MsgList(13),"%s!1!",CStr$(.lHexLength)),"%s!2!",ValToStr(.lHexLength,0,True)), _
									"%s!3!",Byte2Hex(CorSigCompressByte(.lHexLength),0,-1))
					sb.AppendFormat "{0}",Replace$(Replace$(Replace$(MsgList(14),"%s!1!",CStr$(.lCharLength)),"%s!2!",ValToStr(.lCharLength,0,True)), _
									"%s!3!",Byte2Hex(CorSigCompressByte(.lCharLength),0,-1))
					sb.AppendFormat "{0}",Replace$(Replace$(Replace$(MsgList(15),"%s!1!",CStr$(.lHexLength + .lCharLength)), _
									"%s!2!",ValToStr(.lHexLength + .lCharLength,0,True)), _
									"%s!3!",Byte2Hex(CorSigCompressByte(.lHexLength + .lCharLength),0,-1))
					sb.AppendFormat "{0}",Replace$(MsgList(16),"%s",CStr$(.lReferenceNum))
					sb.AppendFormat "{0}",Replace$(MsgList(17),"%s",SeparatHex(Byte2Hex(GetBytes(FN2,32,.lStartAddress - 32,Mode),0,-1)))
				End With
				With DataList(intList(i)).Source
					If .lReferenceNum > 0 Then
						ReDim TempArray(0) As String
						TempArray = GetRefCodeList(GetVARefForMoveMode2(File,DataList(intList(i))),True)
						sb.AppendFormat "{0}",MsgList(8) & MsgList(8) & vbCrLf
						sb.AppendFormat "{0}",MsgList(9)
						sb.AppendFormat "{0}",MsgList(8) & MsgList(8) & vbCrLf
						ReDim TempList(.lReferenceNum) As String
						For j = 0 To .lReferenceNum - 1
							TempList(j) = Replace$(MsgList(10),"%s!1!",ValToStr(.Reference(j).lAddress,File.FileSize,DisPlayFormat))
							TempList(j) = Replace$(TempList(j),"%s!2!",TempArray(j))
							TempList(j) = Replace$(TempList(j),"%s!3!",SeparatHex(Byte2Hex(GetBytes(FN2,32,.Reference(j).lAddress - 32,Mode),0,-1)))
							TempList(j) = Replace$(TempList(j),"%s!4!",SeparatHex(Byte2Hex(GetBytes(FN2,32,.Reference(j).lAddress + 4,Mode),0,-1)))
						Next j
						sb.AppendFormat "{0}",StrListJoin(TempList,"") & MsgList(8) & MsgList(8) & vbCrLf & vbCrLf
					Else
						sb.AppendFormat "{0}",MsgList(8) & MsgList(8) & vbCrLf & vbCrLf
					End If
				End With
			End If
		Next i
		WriteBinaryFile LogFN,CP_UNICODELITTLE,sb.ToString(),True
	End If
	Set sb = Nothing
	UnLoadFile(FN1,0,Mode)
	UnLoadFile(FN2,0,Mode)
	Close #LogFN
	Erase MsgList
	'查看数据
	ReDim FileDataList(0) As String
	FileDataList(0) = File.FilePath & ".xls" & JoinStr & "unicodeFFFE"
	If OpenFile(File.FilePath & ".xls",FileDataList,AppID,False) = True Then
		If AppID = 3 Then WriteSettings("Tools")
	End If
	If AppID = 0 Then
		 On Error Resume Next
		 If Dir$(File.FilePath & ".xls") <> "" Then Kill File.FilePath & ".xls"
		 On Error GoTo 0
	End If
	Exit Sub
	'错误处理
	ErrHandle:
	On Error Resume Next
	UnLoadFile(FN1,0,Mode)
	UnLoadFile(FN2,0,Mode)
	Close #LogFN
	Err.Source = "NotWriteFile"
	Err.Description = Err.Description & JoinStr & File.FilePath & ".xls"
	Call sysErrorMassage(Err,1)
End Sub


'查看字串数据详细或差异情况
'Mode = 2 查看选定字串数据详细信息
'Mode = 4 查看选定字串数据和备份字串数据的差异信息
Private Sub StrDataView(File As FILE_PROPERTIE,uDataList() As STRING_PROPERTIE,oDataList() As STRING_PROPERTIE, _
			intList() As Long,ByVal AppID As Long,ByVal Mode As Long,ByVal DisPlayFormat As Boolean)
	Dim i As Long,j As Long,n As Long,FN As Variant,MsgList() As String,sb As Object
	Dim uData As STRING_SUB_PROPERTIE,oData As STRING_SUB_PROPERTIE
	If getMsgList(UIDataList,MsgList,"StrDataView",2) = False Then Exit Sub
	If Mode = 4 Then
		MsgList(0) = MsgList(1)
		MsgList(6) = MsgList(7)
	End If
	If File.Magic = "" Then MsgList(10) = MsgList(11)
	'打开文件
	On Error GoTo ErrHandle
	If Dir$(File.FilePath & ".xls") <> "" Then Kill File.FilePath & ".xls"
	FN = FreeFile
	Open File.FilePath & ".xls" For Binary Access Read Write Lock Write As #FN
	'写入说明
	WriteBinaryFile FN,CP_UNICODELITTLE,MsgList(0) & MsgList(8) & MsgList(9) & MsgList(10) & MsgList(12) & MsgList(13) & MsgList(14)
	WriteBinaryFile FN,CP_UNICODELITTLE,MsgList(15) & MsgList(16) & MsgList(17) & MsgList(18) & MsgList(19) & MsgList(20),True
	WriteBinaryFile FN,CP_UNICODELITTLE,MsgList(5) & MsgList(5) & vbCrLf & MsgList(6) & MsgList(5) & MsgList(5) & vbCrLf,True
	'写入数据
	ReDim TempArray(0) As String
	TempArray = getSectionList(File.SecList,1)
	On Error Resume Next
	Set sb = CreateObject("System.Text.StringBuilder")
	On Error GoTo 0
	If sb Is Nothing Then
		ReDim TempList(40) As String
		For i = LBound(intList) To UBound(intList)
			With uDataList(intList(i))
				If Mode = 4 Then
					If StrIDIndexDicBak.Exists(.ID) Then
						j = StrIDIndexDicBak.Item(.ID)
						n = 1
					Else
						j = 0: n = 2
					End If
				End If
				TempList(0) = "#" & CStr$(.ID) & DataInfo(MsgList(21),CStr$(intList(i)),CStr$(j),MsgList,n)
				TempList(1) = DataInfo(MsgList(22),CStr$(.StrType),CStr$(oDataList(j).StrType),MsgList,n)
				TempList(2) = DataInfo(MsgList(23),CStr$(.WriteType),CStr$(oDataList(j).WriteType),MsgList,n)
				TempList(3) = DataInfo(MsgList(24),CStr$(.WriteState),CStr$(oDataList(j).WriteState),MsgList,n)
				TempList(4) = DataInfo(MsgList(25),CStr$(.MoveType),CStr$(oDataList(j).MoveType),MsgList,n)
				TempList(5) = DataInfo(MsgList(26),CStr$(.MoveMode),CStr$(oDataList(j).MoveMode),MsgList,n)
				TempList(6) = DataInfo(MsgList(27),CStr$(.LockState),CStr$(oDataList(j).LockState),MsgList,n)
				TempList(7) = DataInfo(MsgList(28),CStr$(.SplitState),CStr$(oDataList(j).SplitState),MsgList,n)
				TempList(8) = DataInfo(MsgList(29),CStr$(.TagType),CStr$(oDataList(j).TagType),MsgList,n)
				TempList(9) = DataInfo(MsgList(30),CStr$(IIf(.ScapeIDBeMoved = -1,.ScapeIDBeMoved,StrIDIndexDic.Item(.ScapeIDBeMoved))), _
							CStr$(IIf(oDataList(j).ScapeIDBeMoved = -1,oDataList(j).ScapeIDBeMoved,StrIDIndexDicBak.Item(oDataList(j).ScapeIDBeMoved))),MsgList,n)
				TempList(10) = DataInfo(MsgList(31),CStr$(IIf(.ScapeIDForMove < 0,.ScapeIDForMove,StrIDIndexDic.Item(.ScapeIDForMove))), _
							CStr$(IIf(oDataList(j).ScapeIDForMove < 0,oDataList(j).ScapeIDForMove,StrIDIndexDicBak.Item(oDataList(j).ScapeIDForMove))),MsgList,n)
				TempList(11) = DataInfo(MsgList(32),CStr$(.SourceStringClearState),CStr$(oDataList(j).SourceStringClearState),MsgList,n)
				TempList(12) = DataInfo(MsgList(33),CStr$(.Source.sString),CStr$(oDataList(j).Source.sString),MsgList,n)
				TempList(13) = DataInfo(MsgList(34),GetSectionName(File,.Source.inSectionID,.Source.inSubSecID), _
							GetSectionName(File,oDataList(j).Source.inSectionID,oDataList(j).Source.inSubSecID),MsgList,n)
				TempList(14) = DataInfo(MsgList(35),ValToStr(.Source.lStartAddress,File.FileSize,DisPlayFormat), _
							ValToStr(oDataList(j).Source.lStartAddress,File.FileSize,DisPlayFormat),MsgList,n)
				TempList(15) = DataInfo(MsgList(36),ValToStr(.Source.lEndAddress,File.FileSize,DisPlayFormat), _
							ValToStr(oDataList(j).Source.lEndAddress,File.FileSize,DisPlayFormat),MsgList,n)
				TempList(16) = DataInfo(MsgList(37),ValToStr(.Source.lMaxAddress,File.FileSize,DisPlayFormat), _
							ValToStr(oDataList(j).Source.lMaxAddress,File.FileSize,DisPlayFormat),MsgList,n)
				TempList(17) = DataInfo(MsgList(38),CStr$(.Source.lHexLength),CStr$(oDataList(j).Source.lHexLength),MsgList,n)
				TempList(18) = DataInfo(MsgList(39),CStr$(.Source.lMaxHexLength),CStr$(oDataList(j).Source.lMaxHexLength),MsgList,n)
				TempList(19) = DataInfo(MsgList(40),CStr$(.Source.CodePage),CStr$(oDataList(j).Source.CodePage),MsgList,n)
				TempList(20) = DataInfo(MsgList(41),CStr$(.Source.lReferenceNum),CStr$(oDataList(j).Source.lReferenceNum),MsgList,n)

				TempList(21) = DataInfo(MsgList(42),StrListJoin(RefList2StrList(.Source,1),ValJoinStr), _
							StrListJoin(RefList2StrList(oDataList(j).Source,1),ValJoinStr),MsgList,n)
				TempList(22) = DataInfo(MsgList(43),StrListJoin(DecStrListToHexStrList(RefList2StrList(.Source,0),File.FileSize,DisPlayFormat),ValJoinStr), _
							StrListJoin(DecStrListToHexStrList(RefList2StrList(oDataList(j).Source,0),File.FileSize,DisPlayFormat),ValJoinStr),MsgList,n)
				TempList(23) = DataInfo(MsgList(44),StrListJoin(SecIDListToNameList(RefList2StrList(.Source,3),TempArray),ValJoinStr), _
							StrListJoin(SecIDListToNameList(RefList2StrList(oDataList(j).Source,3),TempArray),ValJoinStr),MsgList,n)
				TempList(24) = DataInfo(MsgList(45),StrListJoin(RefList2StrList(.Source,2),ValJoinStr), _
							StrListJoin(RefList2StrList(oDataList(j).Source,2),ValJoinStr),MsgList,n)
				TempList(25) = DataInfo(MsgList(46),CStr$(.Source.StrTypeLength),CStr$(oDataList(j).Source.StrTypeLength),MsgList,n)
				TempList(26) = DataInfo(MsgList(47),.Trans.sString,oDataList(j).Trans.sString,MsgList,n)
				'注意：移位到新增节的.Trans.inSectionID 会发生错误，故不能使用 IIF 函数
				If .MoveType < 6 Then
					If oDataList(j).MoveType < 6 Then
				 		TempList(27) = DataInfo(MsgList(48),GetSectionName(File,.Trans.inSectionID,.Trans.inSubSecID), _
				 						GetSectionName(File,oDataList(j).Trans.inSectionID,oDataList(j).Trans.inSubSecID),MsgList,n)
					ElseIf InStr(File.Magic,"PE") Then
						TempList(27) = DataInfo(MsgList(48),GetSectionName(File,.Trans.inSectionID,.Trans.inSubSecID),NewPESecName,MsgList,n)
					Else
						TempList(27) = DataInfo(MsgList(48),GetSectionName(File,.Trans.inSectionID,.Trans.inSubSecID),NewMacSecName,MsgList,n)
					End If
				Else
					If oDataList(j).MoveType < 6 Then
						If InStr(File.Magic,"PE") Then
							TempList(28) = DataInfo(MsgList(48),NewPESecName,GetSectionName(File,oDataList(j).Trans.inSectionID,oDataList(j).Trans.inSubSecID),MsgList,n)
						Else
							TempList(28) = DataInfo(MsgList(48),NewMacSecName,GetSectionName(File,oDataList(j).Trans.inSectionID,oDataList(j).Trans.inSubSecID),MsgList,n)
						End If
					ElseIf InStr(File.Magic,"PE") Then
						TempList(28) = DataInfo(MsgList(48),NewPESecName,NewPESecName,MsgList,n)
					Else
						TempList(28) = DataInfo(MsgList(48),NewMacSecName,NewMacSecName,MsgList,n)
					End If
				End If
				TempList(29) = DataInfo(MsgList(49),ValToStr(.Trans.lStartAddress,File.FileSize,DisPlayFormat), _
													ValToStr(oDataList(j).Trans.lStartAddress,File.FileSize,DisPlayFormat),MsgList,n)
				TempList(30) = DataInfo(MsgList(50),ValToStr(.Trans.lEndAddress,File.FileSize,DisPlayFormat), _
													ValToStr(oDataList(j).Trans.lEndAddress,File.FileSize,DisPlayFormat),MsgList,n)
				TempList(31) = DataInfo(MsgList(51),ValToStr(.Trans.lMaxAddress,File.FileSize,DisPlayFormat), _
													ValToStr(oDataList(j).Trans.lMaxAddress,File.FileSize,DisPlayFormat),MsgList,n)
				TempList(32) = DataInfo(MsgList(52),CStr$(.Trans.lHexLength),CStr$(oDataList(j).Trans.lHexLength),MsgList,n)
				TempList(33) = DataInfo(MsgList(53),CStr$(.Trans.lMaxHexLength),CStr$(oDataList(j).Trans.lMaxHexLength),MsgList,n)
				TempList(34) = DataInfo(MsgList(54),CStr$(.Trans.CodePage),CStr$(oDataList(j).Trans.CodePage),MsgList,n)
				uData = GetVARefForMoveMode2(File,uDataList(intList(i))).Trans
				oData = GetVARefForMoveMode2(File,oDataList(j)).Trans
				TempList(35) = DataInfo(MsgList(55),CStr$(uData.lReferenceNum),CStr$(oData.lReferenceNum),MsgList,n)
				TempList(36) = DataInfo(MsgList(56),StrListJoin(RefList2StrList(uData,1),ValJoinStr), _
							StrListJoin(RefList2StrList(oData,1),ValJoinStr),MsgList,n)
				TempList(37) = DataInfo(MsgList(57),StrListJoin(DecStrListToHexStrList(RefList2StrList(uData,0),File.FileSize,DisPlayFormat),ValJoinStr), _
							StrListJoin(DecStrListToHexStrList(RefList2StrList(oData,0),File.FileSize,DisPlayFormat),ValJoinStr),MsgList,n)
				TempList(38) = DataInfo(MsgList(58),StrListJoin(SecIDListToNameList(RefList2StrList(uData,3),TempArray),ValJoinStr), _
							StrListJoin(SecIDListToNameList(RefList2StrList(oData,3),TempArray),ValJoinStr),MsgList,n)
				TempList(39) = DataInfo(MsgList(59),StrListJoin(RefList2StrList(uData,2),ValJoinStr), _
							StrListJoin(RefList2StrList(oData,2),ValJoinStr),MsgList,n)
				TempList(40) = DataInfo(MsgList(60),CStr$(.Trans.StrTypeLength),CStr$(oDataList(j).Trans.StrTypeLength),MsgList,n)
			End With
			WriteBinaryFile FN,CP_UNICODELITTLE,Join$(TempList,"") & MsgList(5) & MsgList(5) & vbCrLf,True
		Next i
	Else
		For i = LBound(intList) To UBound(intList)
			With uDataList(intList(i))
				If Mode = 4 Then
					If StrIDIndexDicBak.Exists(.ID) Then
						j = StrIDIndexDicBak.Item(.ID)
						n = 1
					Else
						j = 0: n = 2
					End If
				End If
				sb.AppendFormat "{0}","#" & CStr$(.ID) & DataInfo(MsgList(21),CStr$(intList(i)),CStr$(j),MsgList,n)
				sb.AppendFormat "{0}",DataInfo(MsgList(22),CStr$(.StrType),CStr$(oDataList(j).StrType),MsgList,n)
				sb.AppendFormat "{0}",DataInfo(MsgList(23),CStr$(.WriteType),CStr$(oDataList(j).WriteType),MsgList,n)
				sb.AppendFormat "{0}",DataInfo(MsgList(24),CStr$(.WriteState),CStr$(oDataList(j).WriteState),MsgList,n)
				sb.AppendFormat "{0}",DataInfo(MsgList(25),CStr$(.MoveType),CStr$(oDataList(j).MoveType),MsgList,n)
				sb.AppendFormat "{0}",DataInfo(MsgList(26),CStr$(.MoveMode),CStr$(oDataList(j).MoveMode),MsgList,n)
				sb.AppendFormat "{0}",DataInfo(MsgList(27),CStr$(.LockState),CStr$(oDataList(j).LockState),MsgList,n)
				sb.AppendFormat "{0}",DataInfo(MsgList(28),CStr$(.SplitState),CStr$(oDataList(j).SplitState),MsgList,n)
				sb.AppendFormat "{0}",DataInfo(MsgList(29),CStr$(.TagType),CStr$(oDataList(j).TagType),MsgList,n)
				sb.AppendFormat "{0}",DataInfo(MsgList(30),CStr$(IIf(.ScapeIDBeMoved = -1,.ScapeIDBeMoved,StrIDIndexDic.Item(.ScapeIDBeMoved))), _
							CStr$(IIf(oDataList(j).ScapeIDBeMoved = -1,oDataList(j).ScapeIDBeMoved,StrIDIndexDicBak.Item(oDataList(j).ScapeIDBeMoved))),MsgList,n)
				sb.AppendFormat "{0}",DataInfo(MsgList(31),CStr$(IIf(.ScapeIDForMove < 0,.ScapeIDForMove,StrIDIndexDic.Item(.ScapeIDForMove))), _
							CStr$(IIf(oDataList(j).ScapeIDForMove < 0,oDataList(j).ScapeIDForMove,StrIDIndexDicBak.Item(oDataList(j).ScapeIDForMove))),MsgList,n)
				sb.AppendFormat "{0}",DataInfo(MsgList(32),CStr$(.SourceStringClearState),CStr$(oDataList(j).SourceStringClearState),MsgList,n)
				sb.AppendFormat "{0}",DataInfo(MsgList(33),CStr$(.Source.sString),CStr$(oDataList(j).Source.sString),MsgList,n)
				sb.AppendFormat "{0}",DataInfo(MsgList(34),GetSectionName(File,.Source.inSectionID,.Source.inSubSecID), _
							GetSectionName(File,oDataList(j).Source.inSectionID,oDataList(j).Source.inSubSecID),MsgList,n)
				sb.AppendFormat "{0}",DataInfo(MsgList(35),ValToStr(.Source.lStartAddress,File.FileSize,DisPlayFormat), _
							ValToStr(oDataList(j).Source.lStartAddress,File.FileSize,DisPlayFormat),MsgList,n)
				sb.AppendFormat "{0}",DataInfo(MsgList(36),ValToStr(.Source.lEndAddress,File.FileSize,DisPlayFormat), _
							ValToStr(oDataList(j).Source.lEndAddress,File.FileSize,DisPlayFormat),MsgList,n)
				sb.AppendFormat "{0}",DataInfo(MsgList(37),ValToStr(.Source.lMaxAddress,File.FileSize,DisPlayFormat), _
							ValToStr(oDataList(j).Source.lMaxAddress,File.FileSize,DisPlayFormat),MsgList,n)
				sb.AppendFormat "{0}",DataInfo(MsgList(38),CStr$(.Source.lHexLength),CStr$(oDataList(j).Source.lHexLength),MsgList,n)
				sb.AppendFormat "{0}",DataInfo(MsgList(39),CStr$(.Source.lMaxHexLength),CStr$(oDataList(j).Source.lMaxHexLength),MsgList,n)
				sb.AppendFormat "{0}",DataInfo(MsgList(40),CStr$(.Source.CodePage),CStr$(oDataList(j).Source.CodePage),MsgList,n)
				sb.AppendFormat "{0}",DataInfo(MsgList(41),CStr$(.Source.lReferenceNum),CStr$(oDataList(j).Source.lReferenceNum),MsgList,n)

				sb.AppendFormat "{0}",DataInfo(MsgList(42),StrListJoin(RefList2StrList(.Source,1),ValJoinStr), _
							StrListJoin(RefList2StrList(oDataList(j).Source,1),ValJoinStr),MsgList,n)
				sb.AppendFormat "{0}",DataInfo(MsgList(43),StrListJoin(DecStrListToHexStrList(RefList2StrList(.Source,0),File.FileSize,DisPlayFormat),ValJoinStr), _
							StrListJoin(DecStrListToHexStrList(RefList2StrList(oDataList(j).Source,0),File.FileSize,DisPlayFormat),ValJoinStr),MsgList,n)
				sb.AppendFormat "{0}",DataInfo(MsgList(44),StrListJoin(SecIDListToNameList(RefList2StrList(.Source,3),TempArray),ValJoinStr), _
							StrListJoin(SecIDListToNameList(RefList2StrList(oDataList(j).Source,3),TempArray),ValJoinStr),MsgList,n)
				sb.AppendFormat "{0}",DataInfo(MsgList(45),StrListJoin(RefList2StrList(.Source,2),ValJoinStr), _
							StrListJoin(RefList2StrList(oDataList(j).Source,2),ValJoinStr),MsgList,n)
				sb.AppendFormat "{0}",DataInfo(MsgList(46),CStr$(.Source.StrTypeLength),CStr$(oDataList(j).Source.StrTypeLength),MsgList,n)
				sb.AppendFormat "{0}",DataInfo(MsgList(47),.Trans.sString,oDataList(j).Trans.sString,MsgList,n)
				'注意：移位到新增节的.Trans.inSectionID 会发生错误，故不能使用 IIF 函数
				If .MoveType < 6 Then
					If oDataList(j).MoveType < 6 Then
				 		sb.AppendFormat "{0}",DataInfo(MsgList(48),GetSectionName(File,.Trans.inSectionID,.Trans.inSubSecID), _
				 			GetSectionName(File,oDataList(j).Trans.inSectionID,oDataList(j).Trans.inSubSecID),MsgList,n)
					ElseIf InStr(File.Magic,"PE") Then
						sb.AppendFormat "{0}",DataInfo(MsgList(48),GetSectionName(File,.Trans.inSectionID,.Trans.inSubSecID),NewPESecName,MsgList,n)
					Else
						sb.AppendFormat "{0}",DataInfo(MsgList(48),GetSectionName(File,.Trans.inSectionID,.Trans.inSubSecID),NewMacSecName,MsgList,n)
					End If
				Else
					If oDataList(j).MoveType < 6 Then
						If InStr(File.Magic,"PE") Then
							sb.AppendFormat "{0}",DataInfo(MsgList(48),NewPESecName,GetSectionName(File,oDataList(j).Trans.inSectionID,oDataList(j).Trans.inSubSecID),MsgList,n)
						Else
							sb.AppendFormat "{0}",DataInfo(MsgList(48),NewMacSecName,GetSectionName(File,oDataList(j).Trans.inSectionID,oDataList(j).Trans.inSubSecID),MsgList,n)
						End If
					ElseIf InStr(File.Magic,"PE") Then
						sb.AppendFormat "{0}",DataInfo(MsgList(48),NewPESecName,NewPESecName,MsgList,n)
					Else
						sb.AppendFormat "{0}",DataInfo(MsgList(48),NewMacSecName,NewMacSecName,MsgList,n)
					End If
				End If
				sb.AppendFormat "{0}",DataInfo(MsgList(49),ValToStr(.Trans.lStartAddress,File.FileSize,DisPlayFormat), _
													ValToStr(oDataList(j).Trans.lStartAddress,File.FileSize,DisPlayFormat),MsgList,n)
				sb.AppendFormat "{0}",DataInfo(MsgList(50),ValToStr(.Trans.lEndAddress,File.FileSize,DisPlayFormat), _
													ValToStr(oDataList(j).Trans.lEndAddress,File.FileSize,DisPlayFormat),MsgList,n)
				sb.AppendFormat "{0}",DataInfo(MsgList(51),ValToStr(.Trans.lMaxAddress,File.FileSize,DisPlayFormat), _
													ValToStr(oDataList(j).Trans.lMaxAddress,File.FileSize,DisPlayFormat),MsgList,n)
				sb.AppendFormat "{0}",DataInfo(MsgList(52),CStr$(.Trans.lHexLength),CStr$(oDataList(j).Trans.lHexLength),MsgList,n)
				sb.AppendFormat "{0}",DataInfo(MsgList(53),CStr$(.Trans.lMaxHexLength),CStr$(oDataList(j).Trans.lMaxHexLength),MsgList,n)
				sb.AppendFormat "{0}",DataInfo(MsgList(54),CStr$(.Trans.CodePage),CStr$(oDataList(j).Trans.CodePage),MsgList,n)
				uData = GetVARefForMoveMode2(File,uDataList(intList(i))).Trans
				oData = GetVARefForMoveMode2(File,oDataList(j)).Trans
				sb.AppendFormat "{0}",DataInfo(MsgList(55),CStr$(uData.lReferenceNum),CStr$(oData.lReferenceNum),MsgList,n)
				sb.AppendFormat "{0}",DataInfo(MsgList(56),StrListJoin(RefList2StrList(uData,1),ValJoinStr), _
							StrListJoin(RefList2StrList(oData,1),ValJoinStr),MsgList,n)
				sb.AppendFormat "{0}",DataInfo(MsgList(57),StrListJoin(DecStrListToHexStrList(RefList2StrList(uData,0),File.FileSize,DisPlayFormat),ValJoinStr), _
							StrListJoin(DecStrListToHexStrList(RefList2StrList(oData,0),File.FileSize,DisPlayFormat),ValJoinStr),MsgList,n)
				sb.AppendFormat "{0}",DataInfo(MsgList(58),StrListJoin(SecIDListToNameList(RefList2StrList(uData,3),TempArray),ValJoinStr), _
							StrListJoin(SecIDListToNameList(RefList2StrList(oData,3),TempArray),ValJoinStr),MsgList,n)
				sb.AppendFormat "{0}",DataInfo(MsgList(59),StrListJoin(RefList2StrList(uData,2),ValJoinStr), _
							StrListJoin(RefList2StrList(oData,2),ValJoinStr),MsgList,n)
				sb.AppendFormat "{0}",DataInfo(MsgList(60),CStr$(.Trans.StrTypeLength),CStr$(oDataList(j).Trans.StrTypeLength),MsgList,n)
				sb.AppendFormat "{0}",MsgList(5) & MsgList(5) & vbCrLf
			End With
		Next i
		WriteBinaryFile FN,CP_UNICODELITTLE,sb.ToString(),True
	End If
	Set sb = Nothing
	Close #FN
	Erase MsgList
	'查看数据
	ReDim FileDataList(0) As String
	FileDataList(0) = File.FilePath & ".xls" & JoinStr & "unicodeFFFE"
	If OpenFile(File.FilePath & ".xls",FileDataList,AppID,False) = True Then
		If AppID = 3 Then WriteSettings("Tools")
	End If
	If AppID = 0 Then
		 On Error Resume Next
		 If Dir$(File.FilePath & ".xls") <> "" Then Kill File.FilePath & ".xls"
		 On Error GoTo 0
	End If
	Exit Sub
	'错误处理
	ErrHandle:
	On Error Resume Next
	Close #FN
	Err.Source = "NotWriteFile"
	Err.Description = Err.Description & JoinStr & File.FilePath & ".xls"
	Call sysErrorMassage(Err,1)
End Sub


'生成字串数据信息
'Mode = 0 生成字串数据的详细信息，否则生成字串数据的差异信息
Private Function DataInfo(ByVal Msg As String,ByVal uData As String,ByVal oData As String,MsgList() As String,ByVal Mode As Long) As String
	Select Case Mode
	Case 0
		DataInfo = Replace$(Replace$(Replace$(Msg,"%s!1!",uData),"%d!2!",""),"%l!3!","")
	Case 1
		If uData = oData Then
			DataInfo = Replace$(Replace$(Replace$(Msg,"%s!1!",uData),"%d!2!",oData),"%l!3!",MsgList(2))
		Else
			DataInfo = Replace$(Replace$(Replace$(Msg,"%s!1!",uData),"%d!2!",oData),"%l!3!",MsgList(3))
		End If
	Case Else
		DataInfo = Replace$(Replace$(Replace$(Msg,"%s!1!",uData),"%d!2!",MsgList(4)),"%l!3!",MsgList(3))
	End Select
End Function


'文件区段 ID 索引列表转区段名称列表
Private Function SecIDListToNameList(SecIDList() As String,AllSecNameList() As String) As String()
	Dim i As Integer,j As Long,k As Integer
	ReDim TempList(UBound(SecIDList)) As String
	For i = 0 To UBound(SecIDList)
		j = StrToLong(SecIDList(i),-1)
		If j > -1 Then
			TempList(i) = AllSecNameList(j)
			k = k + 1
		End If
	Next i
	If k > 0 Then k = k - 1
	ReDim Preserve TempList(k) As String
	SecIDListToNameList = TempList
End Function


'导入设置
'Mode = 0 编辑导入翻译设置
'Mode = 1 编辑导入源文设置(可附加导入)
'Mode = 2 编辑导入源文设置(不可附加导入)
Private Function ImportSet(ByVal Mode As Long) As Boolean
	Dim MsgList() As String,TempList() As String
	If getMsgList(UIDataList,MsgList,"ImportSet",1) = False Then Exit Function
	If Mode = 0 Then
		TempList = ReSplit(MsgList(1),";")
	Else
		TempList = ReSplit(MsgList(2),";")
	End If
	Begin Dialog UserDialog 590,441,IIf(Mode = 0,MsgList(52),MsgList(0)),.ImportSetDlgFunc ' %GRID:10,7,1,1
		TextBox 0,0,0,21,.SuppValueBox
		CheckBox 220,0,40,21,"",.ModeCheckBox,2

		GroupBox 20,14,550,112,MsgList(3),.ImpFileGroup
		Text 40,35,450,14,MsgList(4),.ImpFileTypeText
		DropListBox 40,49,480,21,TempList(),.ImpFileTypeListBox
		Text 40,77,450,14,MsgList(5),.ImpFilePathText
		TextBox 40,91,480,21,.ImpFilePathBox
		PushButton 520,91,30,21,MsgList(6),.ImpFileBrowseButton

		GroupBox 20,133,550,266,MsgList(7),.ImportTranOption
		Text 40,154,510,28,MsgList(8),.ImportTranText
		CheckBox 70,189,480,21,MsgList(9),.SelectedStrBox
		CheckBox 70,210,480,21,MsgList(10),.NotSelectedStrBox
		CheckBox 70,231,480,21,MsgList(11),.TranslatedStrBox
		CheckBox 70,252,480,21,MsgList(12),.NotTranslatedStrBox
		CheckBox 70,273,480,21,MsgList(13),.SomeStrIDBox
		CheckBox 70,294,480,21,MsgList(14),.NotSomeStrIDBox
		CheckBox 70,315,480,21,MsgList(15),.LockedStrBox
		CheckBox 70,336,480,21,MsgList(16),.NotLockedStrBox
		PushButton 190,364,170,21,MsgList(17),.OrgFileViewButton
		PushButton 380,364,170,21,MsgList(18),.ImpFileViewButton

		GroupBox 20,133,550,98,MsgList(19),.CodepageGroup
		DropListBox 40,154,480,21,TempList(),.CPNameList
		DropListBox 40,154,480,21,TempList(),.CPValList
		Text 40,182,510,35,MsgList(20),.CodePageOPTText

		GroupBox 20,238,550,161,MsgList(21),.ImportSrcGroup
		OptionGroup .AdditionOption
			OptionButton 40,259,510,21,MsgList(22),.ReplaceOPTButton
			OptionButton 40,301,510,21,MsgList(23),.AdditionOPTButton
		Text 60,280,490,14,MsgList(24),.ReplaceOPTText
		Text 60,322,490,14,MsgList(25),.AdditionOPTText
		CheckBox 40,343,400,21,MsgList(26),.SkipHeadersCheckBox
		CheckBox 40,364,400,21,MsgList(27),.SkipStrCheckBox
		PushButton 450,343,100,21,MsgList(28),.ViewFileInfoButton
		PushButton 450,364,100,21,MsgList(29),.GetStrSetButton

		PushButton 20,413,100,21,MsgList(30),.ResetButton
		PushButton 130,413,100,21,MsgList(31),.AllSelectButton
		PushButton 240,413,100,21,MsgList(32),.RevSelectButton
		OKButton 360,413,100,21,.OKButton
		CancelButton 470,413,100,21,.CancelButton
	End Dialog
	Dim dlg As UserDialog
	dlg.ModeCheckBox = Mode
	If Dialog(dlg) = 0 Then Exit Function
	ImportSet = True
End Function


'导入设置对话框函数
Private Function ImportSetDlgFunc(DlgItem$, Action%, SuppValue&) As Boolean
	Dim i As Long,n As Long,Temp As String,File As FILE_PROPERTIE
	Dim TempList() As String,MsgList() As String

	Select Case Action%
	Case 1 ' 对话框窗口初始化
		DlgText "SuppValueBox",CStr$(SuppValue)
		DlgVisible "ModeCheckBox",False
		DlgVisible "SuppValueBox",False
		DlgVisible "CPValList",False
		If DlgValue("ModeCheckBox") = 0 Then
			DlgVisible "CodepageGroup",False
			DlgVisible "CPNameList",False
			DlgVisible "CodePageOPTText",False
			DlgVisible "ImportSrcGroup",False
			DlgVisible "AdditionOption",False
			DlgVisible "ReplaceOPTText",False
			DlgVisible "AdditionOPTText",False
			DlgVisible "SkipHeadersCheckBox",False
			DlgVisible "SkipStrCheckBox",False
			DlgVisible "ViewFileInfoButton",False
			DlgVisible "GetStrSetButton",False
			If DlgValue("ImpFileTypeListBox") < 4 Then
				DlgVisible "OrgFileViewButton",False
				DlgVisible "ImpFileViewButton",False
			End If
			DlgValue "ImpFileTypeListBox",StrToLong(ImportTranSet(0))
			DlgText "ImpFilePathBox",ImportTranSet(1)
			DlgValue "SelectedStrBox",StrToLong(ImportTranSet(2))
			DlgValue "NotSelectedStrBox",StrToLong(ImportTranSet(3))
			DlgValue "TranslatedStrBox",StrToLong(ImportTranSet(4))
			DlgValue "NotTranslatedStrBox",StrToLong(ImportTranSet(5))
			DlgValue "SomeStrIDBox",StrToLong(ImportTranSet(6))
			DlgValue "NotSomeStrIDBox",StrToLong(ImportTranSet(7))
			DlgValue "LockedStrBox",StrToLong(ImportTranSet(8))
			DlgValue "NotLockedStrBox",StrToLong(ImportTranSet(9))
		Else
			TempList = GetLangStrList(UniLangList,3,True)
			DlgListBoxArray "CPNameList",TempList()
			TempList = GetLangStrList(UniLangList,4,True)
			DlgListBoxArray "CPValList",TempList()

			DlgVisible "ImportTranOption",False
			DlgVisible "ImportTranText",False
			DlgVisible "SelectedStrBox",False
			DlgVisible "NotSelectedStrBox",False
			DlgVisible "TranslatedStrBox",False
			DlgVisible "NotTranslatedStrBox",False
			DlgVisible "SomeStrIDBox",False
			DlgVisible "NotSomeStrIDBox",False
			DlgVisible "LockedStrBox",False
			DlgVisible "NotLockedStrBox",False
			DlgVisible "OrgFileViewButton",False
			DlgVisible "ImpFileViewButton",False
			DlgValue "ImpFileTypeListBox",StrToLong(ImportSrcSet(0))
			DlgText "ImpFilePathBox",ImportSrcSet(1)

			DlgText "CPValList",ImportSrcSet(2)
			If DlgValue("CPValList") < 0 Then
				DlgValue "CPNameList",0
				DlgValue "CPValList",0
			End If
			DlgValue "CPNameList",DlgValue("CPValList")

			DlgValue "AdditionOption",StrToLong(ImportSrcSet(3))
			DlgValue "SkipHeadersCheckBox",StrToLong(ImportSrcSet(4))
			DlgValue "SkipStrCheckBox",StrToLong(ImportSrcSet(5))
			If SourceFile.FilePath = "" Then
				DlgEnable "ImpFilePathBox",False
				DlgEnable "ImpFileBrowseButton",False
				DlgEnable "ViewFileInfoButton",False
				DlgEnable "AdditionOPTButton",False
				DlgValue "AdditionOption",0
				If getMsgList(UIDataList,MsgList,"ImportSet",1) = False Then Exit Function
				MsgBox MsgList(56),vbOkOnly+vbInformation,MsgList(40)
			ElseIf Dir$(SourceFile.FilePath) = "" Then
				DlgEnable "ImpFilePathBox",False
				DlgEnable "ImpFileBrowseButton",False
				DlgEnable "ViewFileInfoButton",False
				DlgEnable "AdditionOPTButton",False
				DlgValue "AdditionOption",0
				If getMsgList(UIDataList,MsgList,"ImportSet",1) = False Then Exit Function
				MsgBox MsgList(57),vbOkOnly+vbInformation,MsgList(40)
			ElseIf CheckDataArray(AllStrDataList) = False Then
				DlgEnable "AdditionOPTButton",False
				DlgValue "AdditionOption",0
			ElseIf DlgValue("ModeCheckBox") = 2 Then
				DlgEnable "AdditionOPTButton",False
				DlgValue "AdditionOption",0
			End If
		End If
		'设置当前对话框字体
		If CheckFont(LFList(0)) = True Then
			n = CreateFont(0,LFList(0))
			If n = 0 Then Exit Function
			For i = 0 To DlgCount() - 1
				SendMessageLNG(GetDlgItem(SuppValue,DlgControlId(DlgName(i))),WM_SETFONT,n,0)
			Next i
		End If
	Case 2 ' 数值更改或者按下按钮时
		ImportSetDlgFunc = True ' 防止按下按钮时关闭对话框窗口
		Select Case DlgItem$
		Case "CancelButton"
			ImportSetDlgFunc = False
			Exit Function
		Case "OKButton"
			If getMsgList(UIDataList,MsgList,"ImportSet",1) = False Then Exit Function
			File.FilePath = DlgText("ImpFilePathBox")
			If File.FilePath = "" Then
				MsgBox MsgList(42),vbOkOnly+vbInformation,MsgList(40)
				Exit Function
			ElseIf Dir$(File.FilePath) = "" Then
				MsgBox MsgList(43),vbOkOnly+vbInformation,MsgList(40)
				Exit Function
			ElseIf DlgValue("ModeCheckBox") = 0 Then
				If DlgValue("ImpFileTypeListBox") > 3 Then
					If GetFileInfo(File.FilePath,File) = True Then
						If File.OrigionalFileName <> SourceFile.OrigionalFileName Then
							If MsgBox(MsgList(44) & MsgList(51),vbYesNo+vbInformation,MsgList(39)) = vbNo Then Exit Function
						End If
						If File.FileVersion <> SourceFile.FileVersion Then
							If MsgBox(MsgList(45) & MsgList(51),vbYesNo+vbInformation,MsgList(39)) = vbNo Then Exit Function
						End If
						If File.LanguageID <> TargetFile.LanguageID Then
							If MsgBox(MsgList(46) & MsgList(51),vbYesNo+vbInformation,MsgList(39)) = vbNo Then Exit Function
						End If
					End If
					If GetHeaders(File.FilePath,File,StrToLong(Selected(1)),File.FileType) = True Then
						Temp = JoinStr & StrListJoin(UseSectionList,JoinStr) & JoinStr
						TempList = UseSectionList
						For i = 0 To File.MaxSecIndex
							If InStr(Temp,JoinStr & File.SecList(i).sName & JoinStr) Then
								TempList(n) = CStr$(i)
								n = n + 1
							End If
						Next i
						If n > 0 Then n = n - 1
						ReDim Preserve TempList(n) As String
						Select Case CompSecHeader(TargetFile,File,TempList)
						Case -1
							If MsgBox(MsgList(47) & MsgList(51),vbYesNo+vbInformation,MsgList(39)) = vbNo Then Exit Function
						Case 1
							If MsgBox(MsgList(48) & MsgList(51),vbYesNo+vbInformation,MsgList(39)) = vbNo Then Exit Function
						Case 2
							If MsgBox(MsgList(49) & MsgList(51),vbYesNo+vbInformation,MsgList(39)) = vbNo Then Exit Function
						End Select
					ElseIf File.FileSize <> TargetFile.FileSize Then
						If MsgBox(MsgList(50) & MsgList(51),vbYesNo+vbInformation,MsgList(39)) = vbNo Then Exit Function
					End If
				End If
				ImportTranSet(0) = CStr$(DlgValue("ImpFileTypeListBox"))
				ImportTranSet(1) = DlgText("ImpFilePathBox")
				ImportTranSet(2) = CStr$(DlgValue("SelectedStrBox"))
				ImportTranSet(3) = CStr$(DlgValue("NotSelectedStrBox"))
				ImportTranSet(4) = CStr$(DlgValue("TranslatedStrBox"))
				ImportTranSet(5) = CStr$(DlgValue("NotTranslatedStrBox"))
				ImportTranSet(6) = CStr$(DlgValue("SomeStrIDBox"))
				ImportTranSet(7) = CStr$(DlgValue("NotSomeStrIDBox"))
				ImportTranSet(8) = CStr$(DlgValue("LockedStrBox"))
				ImportTranSet(9) = CStr$(DlgValue("NotLockedStrBox"))
			Else
				If InStr(SourceFile.FileName,".") > 1 Then
					Temp = Left$(SourceFile.FileName,InStrRev(SourceFile.FileName,".") - 1)
				Else
					Temp = SourceFile.FileName
				End If
				If InStr(LCase$(File.FilePath),LCase$(Temp)) = 0 Then
					If MsgBox(MsgList(41),vbYesNo+vbInformation,MsgList(39)) = vbNo Then Exit Function
				End If
				ImportSrcSet(0) = CStr$(DlgValue("ImpFileTypeListBox"))
				ImportSrcSet(1) = DlgText("ImpFilePathBox")
				ImportSrcSet(2) = DlgText("CPValList")
				ImportSrcSet(3) = CStr$(DlgValue("AdditionOption"))
				ImportSrcSet(4) = CStr$(DlgValue("SkipHeadersCheckBox"))
				ImportSrcSet(5) = CStr$(DlgValue("SkipStrCheckBox"))
			End If
			ImportSetDlgFunc = False
			Exit Function
		Case "CPNameList"
			DlgValue "CPValList",DlgValue("CPNameList")
		Case "ResetButton"
			n = 2
			If DlgValue("ModeCheckBox") = 0 Then
				For i = 2 To DlgCount() -1
					If DlgType(i) = "CheckBox" And DlgVisible(DlgName(i)) = True Then
						DlgValue DlgName(i),StrToLong(ImportTranSet(n))
						n = n + 1
					End If
				Next i
			Else
				For i = 0 To DlgCount() -1
					If DlgType(i) = "OptionGroup" Then
						DlgValue DlgName(i),StrToLong(ImportSrcSet(n))
						n = n + 1
					End If
				Next i
				DlgValue "SkipHeadersCheckBox",StrToLong(ImportSrcSet(4))
				DlgValue "SkipStrCheckBox",StrToLong(ImportSrcSet(5))
			End If
		Case "AllSelectButton"
			For i = 0 To DlgCount() -1
				If DlgType(i) = "CheckBox" And DlgVisible(DlgName(i)) = True Then
					DlgValue DlgName(i),1
				End If
			Next i
		Case "RevSelectButton"
			For i = 0 To DlgCount() -1
				If DlgType(i) = "CheckBox" Or DlgName(i) = "AdditionOption" Then
					If DlgVisible(DlgName(i)) = True Then
						DlgValue DlgName(i),IIf(DlgValue(DlgName(i)) = 0,1,0)
					End If
				End If
			Next i
		Case "ImpFileTypeListBox"
			DlgText "ImpFilePathBox",""
			If DlgValue("ModeCheckBox") > 0 Then Exit Function
			If DlgValue("ImpFileTypeListBox") < 4 Then
				DlgVisible "OrgFileViewButton",False
				DlgVisible "ImpFileViewButton",False
			ElseIf Dir$(DlgText("ImpFilePathBox")) = "" Then
				DlgVisible "OrgFileViewButton",False
				DlgVisible "ImpFileViewButton",False
			Else
				DlgVisible "OrgFileViewButton",True
				DlgVisible "ImpFileViewButton",True
			End If
			If DlgValue("ImpFileTypeListBox") < 4 Then Exit Function
			If DlgValue("NotSomeStrIDBox") = 1 Then Exit Function
			i = StrToLong(ImportTranSet(10))
			If i > 0 Then Exit Function
			ImportTranSet(10) = CStr$(i + 1)
			If getMsgList(UIDataList,MsgList,"ImportSet",1) = False Then Exit Function
			If MsgBox(MsgList(54),vbYesNo+vbInformation,MsgList(39)) = vbNo Then Exit Function
			DlgValue "NotSomeStrIDBox",1
		Case "ImpFileBrowseButton"
			If getMsgList(UIDataList,MsgList,"ImportSet",1) = False Then Exit Function
			If InStr(SourceFile.FileName,".") > 1 Then
				Temp = Left$(SourceFile.FileName,InStrRev(SourceFile.FileName,".") - 1)
			Else
				Temp = SourceFile.FileName
			End If
			i = DlgValue("ImpFileTypeListBox")
			MsgList(i + 34) = Replace$(MsgList(i + 34),"*.",Temp & "*.",,2)
			If PSL.SelectFile(File.FilePath,True,MsgList(i + 34),MsgList(33)) = False Then Exit Function
			If DlgValue("ModeCheckBox") = 0 Then
				If DlgValue("ImpFileTypeListBox") < 4 Then
					DlgVisible "OrgFileViewButton",False
					DlgVisible "ImpFileViewButton",False
				Else
					DlgVisible "OrgFileViewButton",True
					DlgVisible "ImpFileViewButton",True
				End If
			ElseIf InStr(LCase$(File.FilePath),LCase$(Temp)) = 0 Then
				If MsgBox(MsgList(41),vbYesNo+vbInformation,MsgList(39)) = vbNo Then Exit Function
			End If
			DlgText "ImpFilePathBox",File.FilePath
			File.FilePath = LCase$(File.FilePath)
			If InStr(File.FilePath,".hcs") Then
				DlgText "CPValList",CStr$(CP_UNKNOWN)
				DlgValue "ImpFileTypeListBox",0
			ElseIf InStr(File.FilePath,".a.txt") Then
				DlgText "CPValList",CStr$(CP_WESTEUROPE)
				DlgValue "ImpFileTypeListBox",1
			ElseIf InStr(File.FilePath,".u.txt") Then
				DlgText "CPValList",CStr$(CP_UNICODELITTLE)
				DlgValue "ImpFileTypeListBox",1
			ElseIf InStr(File.FilePath,".d.txt") Then
				DlgText "CPValList",CStr$(CP_WESTEUROPE)
				DlgValue "ImpFileTypeListBox",1
			ElseIf InStr(File.FilePath,".ttt") Then
				DlgText "CPValList",CStr$(CP_UNKNOWN)
				DlgValue "ImpFileTypeListBox",2
			ElseIf InStr(File.FilePath," ansi ") Then
				DlgText "CPValList",CStr$(CP_WESTEUROPE)
				DlgValue "ImpFileTypeListBox",3
			ElseIf InStr(File.FilePath," unicode ") Then
				DlgText "CPValList",CStr$(CP_UNICODELITTLE)
				DlgValue "ImpFileTypeListBox",3
			ElseIf InStr(File.FilePath," utf8 ") Then
				DlgText "CPValList",CStr$(CP_UTF8)
				DlgValue "ImpFileTypeListBox",3
			ElseIf DlgValue("ModeCheckBox") = 0 Then
				DlgText "CPValList",CStr$(CP_UNKNOWN)
				DlgValue "ImpFileTypeListBox",4
			Else
				DlgText "CPValList",CStr$(CP_UNKNOWN)
			End If
			DlgValue "CPNameList",DlgValue("CPValList")
			If DlgValue("ModeCheckBox") > 0 Then Exit Function
			If DlgValue("ImpFileTypeListBox") < 4 Then Exit Function
			If DlgValue("NotSomeStrIDBox") = 1 Then Exit Function
			i = StrToLong(ImportTranSet(10))
			If i > 0 Then Exit Function
			ImportTranSet(10) = CStr$(i + 1)
			If MsgBox(MsgList(54),vbYesNo+vbInformation,MsgList(39)) = vbNo Then Exit Function
			DlgValue "NotSomeStrIDBox",1
		Case "SelectedStrBox"
			If DlgValue("SelectedStrBox") + DlgValue("NotSelectedStrBox") = 0 Then
				DlgValue "NotSelectedStrBox",1
			End If
		Case "NotSelectedStrBox"
			If DlgValue("SelectedStrBox") + DlgValue("NotSelectedStrBox") = 0 Then
				DlgValue "SelectedStrBox",1
			End If
		Case "TranslatedStrBox"
			If DlgValue("TranslatedStrBox") + DlgValue("NotTranslatedStrBox") = 0 Then
				DlgValue "NotTranslatedStrBox",1
			End If
		Case "NotTranslatedStrBox"
			If DlgValue("TranslatedStrBox") + DlgValue("NotTranslatedStrBox") = 0 Then
				DlgValue "TranslatedStrBox",1
			End If
		Case "SomeStrIDBox"
			If DlgValue("SomeStrIDBox") + DlgValue("NotSomeStrIDBox") = 0 Then
				DlgValue "NotSomeStrIDBox",1
			End If
		Case "NotSomeStrIDBox"
			If DlgValue("SomeStrIDBox") + DlgValue("NotSomeStrIDBox") = 0 Then
				DlgValue "SomeStrIDBox",1
			End If
			If DlgValue("NotSomeStrIDBox") = 1 Then Exit Function
			If DlgValue("ImpFileTypeListBox") < 4 Then Exit Function
			i = StrToLong(ImportTranSet(10))
			If i > 0 Then Exit Function
			ImportTranSet(10) = CStr$(i + 1)
			If getMsgList(UIDataList,MsgList,"ImportSet",1) = False Then Exit Function
			If MsgBox(MsgList(55),vbYesNo+vbInformation,MsgList(39)) = vbYes Then Exit Function
			DlgValue "NotSomeStrIDBox",1
		Case "LockedStrBox"
			If DlgValue("LockedStrBox") + DlgValue("NotLockedStrBox") = 0 Then
				DlgValue "NotLockedStrBox",1
			End If
		Case "NotLockedStrBox"
			If DlgValue("LockedStrBox") + DlgValue("NotLockedStrBox") = 0 Then
				DlgValue "LockedStrBox",1
			End If
		Case "SkipHeadersCheckBox"
			If DlgValue("SkipHeadersCheckBox") = 0 Then
				i = StrToLong(ImportSrcSet(6))
				If i > 0 Then Exit Function
				ImportSrcSet(6) = CStr$(i + 1)
				If getMsgList(UIDataList,MsgList,"ImportSet",1) = False Then Exit Function
				If MsgBox(MsgList(53),vbYesNo+vbInformation,MsgList(39)) = vbYes Then Exit Function
				DlgValue "SkipHeadersCheckBox",1
			End If
		Case "ViewFileInfoButton","OrgFileViewButton"
			TempList = GetToolNameList(Tools,0)
			i = ShowPopupMenu(TempList,vbPopupUseRightButton)
			If i < 0 Then Exit Function
			Call FileInfoView(SourceFile,FreeByteList,i,0,StrToLong(Selected(16)))
		Case "ImpFileViewButton"
			File.FilePath = DlgText("ImpFilePathBox")
			If File.FilePath = "" Then Exit Function
			If Dir$(File.FilePath) = "" Then Exit Function
			TempList = GetToolNameList(Tools,0)
			i = ShowPopupMenu(TempList,vbPopupUseRightButton)
			If i < 0 Then Exit Function
			If GetFileInfo(File.FilePath,File) = False Then Exit Function
			GetHeaders(File.FilePath,File,StrToLong(Selected(1)),File.FileType)
			Call FileInfoView(File,FreeByteList,i,0,StrToLong(Selected(16)))
		Case "GetStrSetButton"
        	Temp = Selected(0)
        	ReDim tmpLFList(0) As LOG_FONT
			tmpLFList(0) = LFList(0)
        	TempList = UseSectionList
			Select Case SourceFile.Magic
			Case "NotPE32","NotPE64",""
				UseRefTypeList(1) = UseRefTypeList(0)
			End Select
			'转到提取对话框
			If Dir$(SourceFile.FilePath) = "" Then
				i = -1
			ElseIf CheckDataArray(AllStrDataList) = False Then
				i = -1
			End If
			If ExtractString(SourceFile,i) = 0 Then UseSectionList = TempList
			If UseRefTypeList(0).Template <> UseRefTypeList(1).Template Then
				Select Case SourceFile.Magic
				Case ""
					For i = 0 To UBound(AllStrDataList)
						AllStrDataList(i).Moveable = Moveable(SourceFile,AllStrDataList(i))
						AllStrDataList(i).Source.lReferenceNum = 0
						AllStrDataList(i).Source.GetRefState = 0
						AllStrDataList(i).Trans.lReferenceNum = 0
						AllStrDataList(i).Trans.GetRefState = 0
					Next i
				Case "NotPE32","NotPE64"
					For i = 0 To UBound(AllStrDataList)
						AllStrDataList(i).Moveable = Moveable(SourceFile,AllStrDataList(i))
						AllStrDataList(i).Source.lReferenceNum = 0
						AllStrDataList(i).Source.GetRefState = 0
						AllStrDataList(i).Trans.lReferenceNum = 0
						AllStrDataList(i).Trans.GetRefState = 0
					Next i
				End Select
			End If
			If Dir$(SourceFile.FilePath) = "" Then
				DlgEnable "ImpFilePathBox",False
				DlgEnable "ImpFileBrowseButton",False
				DlgEnable "ViewFileInfoButton",False
			Else
				DlgEnable "ImpFilePathBox",True
				DlgEnable "ImpFileBrowseButton",True
				DlgEnable "ViewFileInfoButton",True
			End If
			If Selected(0) <> Temp Then
				'重置非 PE 文件和隐藏区段名
				Select Case SourceFile.Magic
				Case "NotPE32","NotPE64",""
					If getMsgList(UIDataList,MsgList,"CheckFile",1) = True Then
						UseSectionList(0) = MsgList(10)
						SourceFile.SecList(0).sName = MsgList(10)
						TargetFile.SecList(0).sName = MsgList(10)
					End If
				Case Else
					If SourceFile.SecList(SourceFile.MaxSecIndex).lSizeOfRawData > 0 Then
						If getMsgList(UIDataList,MsgList,"CheckFile",1) = True Then
							For i = 0 To UBound(UseSectionList)
								If UseSectionList(i) = SourceFile.SecList(SourceFile.MaxSecIndex).sName Then
									UseSectionList(i) = MsgList(9)
									Exit For
								End If
							Next i
							SourceFile.SecList(SourceFile.MaxSecIndex).sName = MsgList(9)
							TargetFile.SecList(SourceFile.MaxSecIndex).sName = MsgList(9)
						End If
					End If
				End Select
				'重置当前对话框字串
				If getMsgList(UIDataList,MsgList,"ImportSet",1) = True Then
					DlgText -1,IIf(DlgValue("ModeCheckBox") = 0,MsgList(52),MsgList(0))
					i = DlgValue("ImpFileTypeListBox")
					If DlgValue("ModeCheckBox") = 0 Then
						TempList = ReSplit(MsgList(1),";")
					Else
						TempList = ReSplit(MsgList(2),";")
					End If
					DlgListBoxArray "ImpFileTypeListBox",TempList()
					DlgValue "ImpFileTypeListBox",i
   					DlgText "ImpFileGroup",MsgList(3)
   					DlgText "ImpFileTypeText",MsgList(4)
   					DlgText "ImpFilePathText",MsgList(5)
   					DlgText "ImpFileBrowseButton",MsgList(6)
   					DlgText "ImportTranOption",MsgList(7)
   					DlgText "ImportTranText",MsgList(8)
   					DlgText "SelectedStrBox",MsgList(9)
   					DlgText "NotSelectedStrBox",MsgList(10)
   					DlgText "TranslatedStrBox",MsgList(11)
   					DlgText "NotTranslatedStrBox",MsgList(12)
   					DlgText "SomeStrIDBox",MsgList(13)
   					DlgText "NotSomeStrIDBox",MsgList(14)
   					DlgText "LockedStrBox",MsgList(15)
   					DlgText "NotLockedStrBox",MsgList(16)
   					DlgText "OrgFileViewButton",MsgList(17)
   					DlgText "ImpFileViewButton",MsgList(18)
   					DlgText "CodepageGroup",MsgList(19)
   					'重置代码页名称列表
					i = DlgValue("CPNameList")
					TempList = GetLangStrList(UniLangList,4,True)
					DlgListBoxArray "CPValList",TempList()
					DlgValue "CPValList",i
					TempList = GetLangStrList(UniLangList,3,True)
					DlgListBoxArray "CPNameList",TempList()
					DlgValue "CPNameList",DlgValue("CPValList")
   					DlgText "CodePageOPTText",MsgList(20)
   					DlgText "ImportSrcGroup",MsgList(21)
   					DlgText "ReplaceOPTButton",MsgList(22)
   					DlgText "AdditionOPTButton",MsgList(23)
   					DlgText "ReplaceOPTText",MsgList(24)
   					DlgText "AdditionOPTText",MsgList(25)
   					DlgText "SkipHeadersCheckBox",MsgList(26)
   					DlgText "SkipStrCheckBox",MsgList(27)
   					DlgText "ViewFileInfoButton",MsgList(28)
   					DlgText "GetStrSetButton",MsgList(29)
   					DlgText "ResetButton",MsgList(30)
   					DlgText "AllSelectButton",MsgList(31)
   					DlgText "RevSelectButton",MsgList(32)
   				End If
   			End If
   			'判断对话框字体是否已被改变
			If FontComp(LFList(0),tmpLFList(0)) = True Then
				n = CreateFont(CLng(DlgText("SuppValueBox")),LFList(0))
				If n = 0 Then Exit Function
				For i = 0 To DlgCount() - 1
					SendMessageLNG(GetDlgItem(CLng(DlgText("SuppValueBox")),DlgControlId(DlgName(i))),WM_SETFONT,n,0)
				Next i
				DrawWindow(CLng(DlgText("SuppValueBox")),n)
			End If
		End Select
	Case 3 ' 文本框或者组合框文本被更改
		If DlgItem$ = "ImpFilePathBox" Then
			DlgText "ImpFilePathBox",Trim$(DlgText("ImpFilePathBox"))
			File.FilePath = LCase$(DlgText("ImpFilePathBox"))
			If File.FilePath = "" Then
				DlgVisible "OrgFileViewButton",False
				DlgVisible "ImpFileViewButton",False
				Exit Function
			End If
			If InStr(SourceFile.FileName,".") > 1 Then
				Temp = Left$(SourceFile.FileName,InStrRev(SourceFile.FileName,".") - 1)
			Else
				Temp = SourceFile.FileName
			End If
			If DlgValue("ModeCheckBox") = 0 Then
				If DlgValue("ImpFileTypeListBox") < 4 Then
					DlgVisible "OrgFileViewButton",False
					DlgVisible "ImpFileViewButton",False
				ElseIf Dir$(DlgText("ImpFilePathBox")) = "" Then
					DlgVisible "OrgFileViewButton",False
					DlgVisible "ImpFileViewButton",False
				Else
					DlgVisible "OrgFileViewButton",True
					DlgVisible "ImpFileViewButton",True
				End If
			ElseIf InStr(File.FilePath,LCase$(Temp)) = 0 Then
				If getMsgList(UIDataList,MsgList,"ImportSet",1) = False Then Exit Function
				If MsgBox(MsgList(41),vbYesNo+vbInformation,MsgList(39)) = vbNo Then Exit Function
			End If
			If InStr(File.FilePath,".hcs") Then
				DlgText "CPValList",CStr$(CP_UNKNOWN)
				DlgValue "ImpFileTypeListBox",0
			ElseIf InStr(File.FilePath,".a.txt") Then
				DlgText "CPValList",CStr$(CP_WESTEUROPE)
				DlgValue "ImpFileTypeListBox",1
			ElseIf InStr(File.FilePath,".u.txt") Then
				DlgText "CPValList",CStr$(CP_UNICODELITTLE)
				DlgValue "ImpFileTypeListBox",1
			ElseIf InStr(File.FilePath,".d.txt") Then
				DlgText "CPValList",CStr$(CP_WESTEUROPE)
				DlgValue "ImpFileTypeListBox",1
			ElseIf InStr(File.FilePath,".ttt") Then
				DlgText "CPValList",CStr$(CP_UNKNOWN)
				DlgValue "ImpFileTypeListBox",2
			ElseIf InStr(File.FilePath," ansi ") Then
				DlgText "CPValList",CStr$(CP_WESTEUROPE)
				DlgValue "ImpFileTypeListBox",3
			ElseIf InStr(File.FilePath," unicode ") Then
				DlgText "CPValList",CStr$(CP_UNICODELITTLE)
				DlgValue "ImpFileTypeListBox",3
			ElseIf InStr(File.FilePath," utf8 ") Then
				DlgText "CPValList",CStr$(CP_UTF8)
				DlgValue "ImpFileTypeListBox",3
			ElseIf DlgValue("ModeCheckBox") = 0 Then
				DlgText "CPValList",CStr$(CP_UNKNOWN)
				DlgValue "ImpFileTypeListBox",4
			Else
				DlgText "CPValList",CStr$(CP_UNKNOWN)
			End If
			DlgValue "CPNameList",DlgValue("CPValList")
		End If
	Case 6 ' 函数快捷键
		Select Case SuppValue
		Case 2, 11
			TempList = GetToolNameList(Tools,0)
			i = ShowPopupMenu(TempList,vbPopupUseRightButton)
			If i < 0 Then Exit Function
			Call FileInfoView(SourceFile,FreeByteList,i,0,StrToLong(Selected(16)))
		Case 9
			TempList = GetToolNameList(Tools,3)
			i = ShowPopupMenu(TempList,vbPopupUseRightButton)
			If i < 0 Then Exit Function
			ReDim TempList(0) As String
			TempList(0) = SourceFile.FilePath & JoinStr
			If OpenFile(SourceFile.FilePath,TempList,i + 3,False) = True Then
				If i = 0 Then WriteSettings("Tools")
			End If
		Case 10
			If DlgText("ImpFilePathBox") = "" Then Exit Function
			If Dir$(DlgText("ImpFilePathBox")) = "" Then Exit Function
			TempList = GetToolNameList(Tools,3)
			i = ShowPopupMenu(TempList,vbPopupUseRightButton)
			If i < 0 Then Exit Function
			ReDim TempList(0) As String
			TempList(0) = DlgText("ImpFilePathBox") & JoinStr
			If OpenFile(DlgText("ImpFilePathBox"),TempList,i + 3,False) = True Then
				If i = 0 Then WriteSettings("Tools")
			End If
		Case 12
			File.FilePath = DlgText("ImpFilePathBox")
			If File.FilePath = "" Then Exit Function
			If Dir$(File.FilePath) = "" Then Exit Function
			TempList = GetToolNameList(Tools,0)
			i = ShowPopupMenu(TempList,vbPopupUseRightButton)
			If i < 0 Then Exit Function
			If GetFileInfo(File.FilePath,File) = False Then Exit Function
			GetHeaders(File.FilePath,File,StrToLong(Selected(1)),File.FileType)
			Call FileInfoView(File,FreeByteList,i,0,StrToLong(Selected(16)))
		End Select
	End Select
End Function


'查找字符串设置
Public Function FindSet(ByVal FindLoc As Long) As Boolean
	Dim MsgList() As String
	If getMsgList(UIDataList,MsgList,"FindSet",1) = False Then Exit Function
	Begin Dialog UserDialog 650,259,MsgList(0),.FindSetDlgFunc ' %GRID:10,7,1,1
		TextBox 0,0,0,21,.SuppValueBox
		CheckBox 20,10,110,14,"",.ModeCheckBox
		Text 20,10,110,14,MsgList(1),.FindText
		DropListBox 140,7,330,21,MsgList(),.FindTextBox,1
		Text 20,35,480,49,MsgList(3),.HelpText
		GroupBox 20,91,480,154,MsgList(4),.OptionGroup
		CheckBox 50,112,200,14,MsgList(5),.MatchCaseBox
		CheckBox 50,133,200,14,MsgList(6),.MatchFullWordBox
		CheckBox 50,154,200,14,MsgList(7),.MatchFullTextBox
		CheckBox 50,175,200,14,MsgList(8),.IgnoreCheckBox
		CheckBox 50,196,200,14,MsgList(9),.CycleCheckBox
		Text 260,112,90,14,MsgList(10),.DirectionText
		OptionGroup .DirectionGroup
			OptionButton 350,112,140,14,MsgList(11),.UpOption
			OptionButton 350,133,140,14,MsgList(12),.DowdOption
		Text 260,154,90,14,MsgList(13),.LocationText
		CheckBox 350,154,140,14,MsgList(14),.OrgStrBox
		CheckBox 350,175,140,14,MsgList(15),.TrnStrBox
		CheckBox 350,196,140,14,MsgList(16),.StrIDBox
		CheckBox 50,217,420,14,MsgList(21),.FindAllBox
		PushButton 520,7,110,21,MsgList(17),.FindButton
		PushButton 520,63,110,21,MsgList(18),.HelpButton
		PushButton 470,7,30,21,MsgList(2),.RegExpTipButton
		CancelButton 520,35,110,21,.CancelButton
	End Dialog
	Dim dlg As UserDialog
	dlg.ModeCheckBox = FindLoc
	If Dialog(dlg) = 0 Then Exit Function
	FindSet = True
End Function


'查找对话框函数
Private Function FindSetDlgFunc(DlgItem$, Action%, SuppValue&) As Boolean
	Dim i As Long,j As Long,MsgList() As String
	Select Case Action%
	Case 1 ' 对话框窗口初始化
		DlgText "SuppValueBox",CStr$(SuppValue)
		DlgVisible "SuppValueBox",False
		DlgVisible "ModeCheckBox",False
		GetHistory(MsgList,"FindStrings","FindSetDlg")
		DlgListBoxArray "FindTextBox",MsgList()
		If FindStrSet(0) = "" Then
			DlgText "FindTextBox",MsgList(0)
			MsgList = ReSplit(GetSetting(AppName,"FindStrings","FindSetting",StrListJoin(FindStrSet,ValJoinStr)),ValJoinStr)
			i = UBound(FindStrSet)
			If UBound(MsgList) < i Then ReDim Preserve MsgList(i) As String
			FindStrSet = MsgList
		Else
			DlgText "FindTextBox",FindStrSet(0)
		End If
		DlgValue "MatchCaseBox",StrToLong(FindStrSet(1))
		DlgValue "MatchFullWordBox",StrToLong(FindStrSet(2))
		DlgValue "MatchFullTextBox",StrToLong(FindStrSet(3))
		DlgValue "IgnoreCheckBox",StrToLong(FindStrSet(4))
		DlgValue "CycleCheckBox",StrToLong(FindStrSet(5))
		DlgValue "DirectionGroup",StrToLong(FindStrSet(6))
		DlgValue "OrgStrBox",StrToLong(FindStrSet(7))
		DlgValue "TrnStrBox",StrToLong(FindStrSet(8))
		DlgValue "StrIDBox",StrToLong(FindStrSet(9))
		DlgValue "FindAllBox",StrToLong(FindStrSet(10))
		If DlgValue("StrIDBox") = 0 Then
			If DlgValue("OrgStrBox") + DlgValue("TrnStrBox") = 0 Then
				If DlgValue("ModeCheckBox") = 0 Then
					DlgValue "OrgStrBox",1
				Else
					DlgValue "TrnStrBox",1
				End If
			End If
		Else
			DlgValue "OrgStrBox",0: DlgValue "TrnStrBox",0
		End If
		'设置当前对话框字体
		If CheckFont(LFList(0)) = True Then
			j = CreateFont(0,LFList(0))
			If j = 0 Then Exit Function
			For i = 0 To DlgCount() - 1
				SendMessageLNG(GetDlgItem(SuppValue,DlgControlId(DlgName(i))),WM_SETFONT,j,0)
			Next i
		End If
	Case 2 ' 数值更改或者按下按钮时
		FindSetDlgFunc = True ' 防止按下按钮时关闭对话框窗口
		Select Case DlgItem$
		Case "CancelButton"
			FindSetDlgFunc = False
		Case "FindButton"
			If DlgText("FindTextBox") = "" Then
				If getMsgList(UIDataList,MsgList,"FindSet",1) = False Then Exit Function
				MsgBox MsgList(20),vbOkOnly+vbInformation,MsgList(19)
				Exit Function
			Else
				Select Case FilterStr("CheckRegExp",DlgText("FindTextBox"),GetFindMode(DlgText("FindTextBox")))
				Case -2
					If getMsgList(UIDataList,MsgList,"FindSet",1) = False Then Exit Function
					MsgBox MsgList(22),vbOkOnly+vbInformation,MsgList(19)
					Exit Function
				Case -3
					If getMsgList(UIDataList,MsgList,"FindSet",1) = False Then Exit Function
					MsgBox MsgList(23),vbOkOnly+vbInformation,MsgList(19)
					Exit Function
				End Select
			End If
			FindStrSet(0) = ""
			FindStrSet(1) = CStr(DlgValue("MatchCaseBox"))
			FindStrSet(2) = CStr(DlgValue("MatchFullWordBox"))
			FindStrSet(3) = CStr(DlgValue("MatchFullTextBox"))
			FindStrSet(4) = CStr(DlgValue("IgnoreCheckBox"))
			FindStrSet(5) = CStr(DlgValue("CycleCheckBox"))
			FindStrSet(6) = CStr(DlgValue("DirectionGroup"))
			FindStrSet(7) = CStr(DlgValue("OrgStrBox"))
			FindStrSet(8) = CStr(DlgValue("TrnStrBox"))
			FindStrSet(9) = CStr(DlgValue("StrIDBox"))
			FindStrSet(10) = CStr(DlgValue("FindAllBox"))
			SaveSetting(AppName,"FindStrings","FindSetting",StrListJoin(FindStrSet,ValJoinStr))
			FindStrSet(0) = DlgText("FindTextBox")
			'添加查找内容
			GetHistory(MsgList,"FindStrings","FindSetDlg")
			If InsertArray(MsgList,DlgText("FindTextBox"),0,True) = True Then
				WriteHistory(MsgList,"FindStrings","FindSetDlg")
			End If
			FindSetDlgFunc = False
		Case "HelpButton"
			If StrToLong(Selected(30)) = 1 Then
				If OpenCHM(CLng(DlgText("SuppValueBox")),1016,Selected(0),OSLanguage,UIFileList) = True Then Exit Function
			End If
			Call Help("FindSetHelp")
		Case "MatchFullWordBox"
			If DlgValue("MatchFullWordBox") = 1 Then DlgValue "MatchFullTextBox",0
		Case "MatchFullTextBox"
			If DlgValue("MatchFullTextBox") = 1 Then DlgValue "MatchFullWordBox",0
		Case "OrgStrBox"
			If DlgValue("OrgStrBox") = 1 Then
				DlgValue "StrIDBox",0
			ElseIf DlgValue("TrnStrBox") = 0 Then
				DlgValue "StrIDBox",1
			End If
		Case "TrnStrBox"
			If DlgValue("TrnStrBox") = 1 Then
				DlgValue "StrIDBox",0
			ElseIf DlgValue("OrgStrBox") = 0 Then
				DlgValue "StrIDBox",1
			End If
		Case "StrIDBox"
			If DlgValue("StrIDBox") = 1 Then
				DlgValue "OrgStrBox",0
				DlgValue "TrnStrBox",0
			Else
				DlgValue "OrgStrBox",1
				DlgValue "TrnStrBox",1
			End If
		Case "RegExpTipButton"
			If getMsgList(UIDataList,MsgList,"RegExpRuleTip",1) = False Then Exit Function
			i = ShowPopupMenu(MsgList,vbPopupUseRightButton)
			If i < 0 Then Exit Function
			If i = UBound(MsgList) Then
				If StrToLong(Selected(30)) = 1 Then
					If OpenCHM(CLng(DlgText("SuppValueBox")),1022,Selected(0),OSLanguage,UIFileList) = True Then Exit Function
				End If
				Call Help("RegExpRuleHelp")
				Exit Function
			End If
			If DlgText("FindTextBox") = "" Then
				DlgText "FindTextBox",Mid$(MsgList(i),InStrRev(MsgList(i),vbTab) + 1)
			Else
				DlgFocus("FindTextBox")  '设置焦点到文本框
				DlgText "FindTextBox",InsertStr(GetFocus(),DlgText("FindTextBox"), _
						Mid$(MsgList(i),InStrRev(MsgList(i),vbTab) + 1))
			End If
		End Select
	Case 6 ' 函数快捷键
		Select Case SuppValue
		Case 1
			If StrToLong(Selected(30)) = 1 Then
				If OpenCHM(CLng(DlgText("SuppValueBox")),1016,Selected(0),OSLanguage,UIFileList) = True Then Exit Function
			End If
			Call Help("FindSetHelp")
		Case 2
			If getMsgList(UIDataList,MsgList,"RegExpRuleTip",1) = False Then Exit Function
			i = ShowPopupMenu(MsgList,vbPopupUseRightButton)
			If i < 0 Then Exit Function
			If i = UBound(MsgList) Then
				If StrToLong(Selected(30)) = 1 Then
					If OpenCHM(CLng(DlgText("SuppValueBox")),1022,Selected(0),OSLanguage,UIFileList) = True Then Exit Function
				End If
				Call Help("RegExpRuleHelp")
				Exit Function
			End If
			If DlgText("FindTextBox") = "" Then
				DlgText "FindTextBox",Mid$(MsgList(i),InStrRev(MsgList(i),vbTab) + 1)
			Else
				DlgFocus("FindTextBox")  '设置焦点到文本框
				DlgText "FindTextBox",InsertStr(GetFocus(),DlgText("FindTextBox"), _
						Mid$(MsgList(i),InStrRev(MsgList(i),vbTab) + 1))
			End If
		End Select
	End Select
End Function


'查找字符串
'FindString > -1 找到的字串列表索引号，= -1 未找到，= -2 程序错误, = -3 通配符语法错误 = -4 正则表达式语法错误
'Mode = 0 只找一次，否则找出所有
Private Function FindString(strData() As STRING_PROPERTIE,FindSet() As String,ByVal StartPos As Long,Optional Mode As Long) As Long
	Dim i As Long,j As Long,EndPos As Long,StepNum As Long,FindMode As Long
	Dim FindStr As String,TempList() As String,RegEx As Object
	FindString = -1
	On Error GoTo errHandle
	FindStr = FindSet(0)
	'检测查找内容的查找方式，并转为正则表达式
	FindMode = GetFindMode(FindStr)
	Select Case FindMode
	Case 0
		If (FindStr Like "*\[*?#[]*") = True Then
			TempList = ReSplit("*,?,#,[",",",-1)
			For i = 0 To UBound(TempList)
				FindStr = Replace$(FindStr,"\" & TempList(i),TempList(i))
			Next i
		End If
	Case 1
		'转换通配符为正则表达式模板
		TempList = ReSplit("\*,\#,\?,\[",",",-1)
		For i = 0 To UBound(TempList)
			FindStr = Replace$(FindStr,TempList(i),CStr$(i) & vbNullChar & CStr$(i) & vbNullChar & CStr$(i))
		Next i
		FindStr = Replace$(FindStr,"?",".")
		FindStr = Replace$(FindStr,"*",".*")
		FindStr = Replace$(FindStr,"#","\d")
		FindStr = Replace$(FindStr,"[!","[^")
		For i = 0 To UBound(TempList)
			FindStr = Replace(FindStr,CStr$(i) & vbNullChar & CStr$(i) & vbNullChar & CStr$(i),TempList(i))
		Next i
		FindStr = Replace$(FindStr,"\#","#")
	End Select
	'检查表达式是否正确
	If CheckRegExp(RegExp,FindStr) = False Then
		If FindMode > 0 Then FindString = -(FindMode + 2)
		Exit Function
	End If
	Set RegEx = CreateObject("VBScript.RegExp")
	With RegEx
    	.Global = False
		.IgnoreCase = IIf(FindSet(1) = "0",True,False)
		If FindSet(3) = "1" Then
			.Pattern = AppendBackslash(FindStr,"^","$",1)
		ElseIf FindSet(2) = "1" Then
			'检查是不是全英文或符号
			If CheckStrRegExp(FindStr,"[\x01-\xFE]",0,1) = True Then
				.Pattern = AppendBackslash(FindStr,"\b","\b",1)
			Else
				.Pattern = FindStr
			End If
		Else
			.Pattern = FindStr
		End If
	End With
	'查找字串
	If Mode = 0 Then
		If FindSet(6) = "0" Then
			EndPos = LBound(strData)
			If StartPos > EndPos Then StartPos = StartPos - 1 Else StartPos = UBound(strData)
			StepNum = -1
		Else
			EndPos = UBound(strData)
			If StartPos < EndPos Then StartPos = StartPos + 1 Else StartPos = LBound(strData)
			StepNum = 1
		End If
		Mode = -1
	Else
		StartPos = LBound(strData): EndPos = UBound(strData): StepNum = 1
		ReDim FindLog(EndPos) As String
		Set FindLogDic = CreateObject("Scripting.Dictionary")
		Mode = 0
	End If
	For i = StartPos To EndPos Step StepNum
		If FindSet(9) = "1" Then
			FindStr = CStr(strData(i).ID)
		ElseIf FindSet(7) & FindSet(8) = "10" Then
			FindStr = strData(i).Source.sString
		ElseIf FindSet(7) & FindSet(8) = "01" Then
			FindStr = strData(i).Trans.sString
		Else
			FindStr = strData(i).Trans.sString & JoinStr & strData(i).Source.sString
		End If
		If FindSet(4) = "1" Then FindStr = DelAccKey(FindStr)
		TempList = ReSplit(FindStr,JoinStr)
		For j = 0 To UBound(TempList)
			If RegEx.Test(TempList(j)) Then
				If Mode < 0 Then
					FindString = i
					Exit Function
				Else
					If FindString = -1 Then FindString = i
					FindLog(Mode) = strData(i).Trans.sString
					FindLogDic.Add(Mode,strData(i).ID)
					If Not FindLogDic.Exists(CStr(strData(i).ID)) Then FindLogDic.Add(CStr(strData(i).ID),Mode)
					Mode = Mode + 1
					Exit For
				End If
			End If
		Next j
	Next i
	If Mode > 0 Then
		ReDim Preserve FindLog(Mode - 1) As String
	Else
		FindString = -1
		ReDim FindLog(0) As String
	End If
	Set RegEx = Nothing
	Exit Function
	errHandle:
	Set RegEx = Nothing
	FindString = -2
End Function


'获取选定字串类型的前置字节长度，用于自定义引用算法
Private Function GetStrTypeLength(TypeList() As STRING_TYPE,GetOption() As String,Optional ByVal Mode As Long) As String()
	Dim i As Long
	If Mode = 0 Then
		ReDim TempList(0) As String
	ElseIf GetOption(10) = "1" Then
		Mode = 0
		If CheckStrTypeArray(TypeList,0) = True Then	'自定义字串类型
			ReDim TempList(UBound(TypeList)) As String
			For i = 0 To UBound(TypeList)
				If TypeList(i).CodeLoc = 0 Then
					TempList(Mode) = CStr(TypeList(i).FristCodePos)
					Mode = Mode + 1
				End If
			Next i
			If Mode > 0 Then Mode = Mode - 1
		End If
		ReDim Preserve TempList(Mode) As String
	ElseIf GetOption(5) = "1" Then		'Pascal Unicode 字串类型
		ReDim TempList(0) As String
		TempList(0) = "12"
	ElseIf GetOption(7) = "1" Then		'Pascal Ansi 字串类型
		ReDim TempList(0) As String
		TempList(0) = "8"
	ElseIf GetOption(6) = "1" Then		'Pascal Wide 字串类型
		ReDim TempList(0) As String
		TempList(0) = "4"
	ElseIf GetOption(8) = "1" Then		'Pascal Short 字串类型
		ReDim TempList(0) As String
		TempList(0) = "1"
	ElseIf GetOption(9) = "1" Then		'Android 字串类型
		ReDim TempList(7) As String
		For i = 0 To 6
			TempList(i) = CStr(i + 2)
		Next i
	ElseIf GetOption(41) = "1" Then		'.NET 字串类型
		ReDim TempList(3) As String
		For i = 0 To 3
			TempList(i) = CStr(i + 1)
		Next i
	End If
	GetStrTypeLength = TempList
End Function


'计算不同字串类型的前置字节长度，返回其更改差额
'WriteType = 0 初始化，否则获取翻译字串与原始字串的字串类型长度差值和翻译字串的字串类型长度
Private Function StrTypeLength(strData As STRING_PROPERTIE,TypeList() As STRING_TYPE,Optional FN As Variant, _
		Optional ByVal Mode As Long,Optional ByVal WriteType As Integer) As Long
	With strData
		StrTypeLength = .Trans.StrTypeLength
		If WriteType < 1 Then
			.Source.MoveLength = 0
			.Trans.MoveLength = 0
			.GetLengthState = 0
		End If
		Select Case .StrType
		Case Is < -4	'Android 字串类型
			If WriteType < 1 Then
				.Source.StrTypeLength = -(.StrType + 3)
				.Trans.StrTypeLength = -(.StrType + 3)
			ElseIf .GetLengthState = 0 Then
				.Source.StrTypeLength = -(.StrType + 3)
				.Source.MoveLength = MoveLength(strData,.Trans.lCharLength,.Trans.lHexLength,False)
				.Trans.StrTypeLength = .Source.StrTypeLength + .Source.MoveLength
				.GetLengthState = 1
			Else
				.Source.MoveLength = MoveLength(strData,.Trans.lCharLength,.Trans.lHexLength,False)
				.Trans.StrTypeLength = .Source.StrTypeLength + .Source.MoveLength
			End If
		Case Is < 0		'.NET 字串类型
			If WriteType < 1 Then
				.Source.StrTypeLength = -.StrType
				.Trans.StrTypeLength = -.StrType
			ElseIf .GetLengthState = 0 Then
				.Source.StrTypeLength = -.StrType
				.Source.MoveLength = MoveLength(strData,.Trans.lCharLength,.Trans.lHexLength,False)
				.Trans.StrTypeLength = .Source.StrTypeLength + .Source.MoveLength
				.GetLengthState = 1
			Else
				.Source.MoveLength = MoveLength(strData,.Trans.lCharLength,.Trans.lHexLength,False)
				.Trans.StrTypeLength = .Source.StrTypeLength + .Source.MoveLength
			End If
		Case 0			'默认字串类型
			If WriteType < 1 Then
				.Source.StrTypeLength = 0
				.Trans.StrTypeLength = 0
			ElseIf .GetLengthState = 0 Then
				.Source.StrTypeLength = 0
				.Trans.StrTypeLength = 0
				.Source.MoveLength = 0
				.GetLengthState = 1
			End If
		Case 1			'Pascal Unicode 字串类型
			If WriteType < 1 Then
				.Source.StrTypeLength = 12
				.Trans.StrTypeLength = 12
			ElseIf .GetLengthState = 0 Then
				.Source.StrTypeLength = 12
				.Trans.StrTypeLength = 12
				.Source.MoveLength = 0
				.GetLengthState = 1
			End If
		Case 2			'Pascal Wide 字串类型
			If WriteType < 1 Then
				.Source.StrTypeLength = 4
				.Trans.StrTypeLength = 4
			ElseIf .GetLengthState = 0 Then
				.Source.StrTypeLength = 4
				.Trans.StrTypeLength = 4
				.Source.MoveLength = 0
				.GetLengthState = 1
			End If
		Case 3			'Pascal Ansi 字串类型
			If WriteType < 1 Then
				.Source.StrTypeLength = 8
				.Trans.StrTypeLength = 8
			ElseIf .GetLengthState = 0 Then
				.Source.StrTypeLength = 8
				.Trans.StrTypeLength = 8
				.Source.MoveLength = 0
				.GetLengthState = 1
			End If
		Case 4			'Pascal Short 字串类型
			If WriteType < 1 Then
				.Source.StrTypeLength = 1
				.Trans.StrTypeLength = 1
			ElseIf .GetLengthState = 0 Then
				.Source.StrTypeLength = 1
				.Trans.StrTypeLength = 1
				.Source.MoveLength = 0
				.GetLengthState = 1
			End If
		Case Is > 4		'自定义字串类型
			If TypeList(.StrType - 5).CodeLoc = 0 Then
				If WriteType < 1 Then
					.Source.StrTypeLength = TypeList(.StrType - 5).FristCodePos
					.Trans.StrTypeLength = TypeList(.StrType - 5).FristCodePos
					.GetLengthState = 0
				ElseIf .GetLengthState = 0 Then
					.Source.StrTypeLength = GetCustomStrTypeLengthRegExp(FN,strData,TypeList(.StrType - 5),Mode)
					.Source.MoveLength = MoveLength(strData,.Trans.lCharLength,.Trans.lHexLength,False)
					.Trans.StrTypeLength = .Source.StrTypeLength + .Source.MoveLength
					.GetLengthState = 1
				Else
					.Source.MoveLength = MoveLength(strData,.Trans.lCharLength,.Trans.lHexLength,False)
					.Trans.StrTypeLength = .Source.StrTypeLength + .Source.MoveLength
				End If
			Else
				If WriteType < 1 Then
					.Source.StrTypeLength = 0
					.Trans.StrTypeLength = 0
				ElseIf .GetLengthState = 0 Then
					.Source.StrTypeLength = 0
					.Trans.StrTypeLength = 0
					.Source.MoveLength = 0
					.GetLengthState = 1
				End If
			End If
		End Select
		StrTypeLength = .Trans.StrTypeLength - StrTypeLength
	End With
End Function


'计算字串类型 CorSigCompress 压缩长度的移位值
'Mode = False 计算翻译字串与原始字串的字串类型长度差值，否则计算实际写入与翻译字串的字串类型长度差值
Private Function MoveLength(strData As STRING_PROPERTIE,ByVal trnCharLength As Long,ByVal trnHexLength As Long,ByVal Mode As Boolean) As Long
	With strData
	If Mode = False Then
		Select Case .StrType
		Case Is < -4	'Android 字串类型
			MoveLength = CorSigCompressLength(trnCharLength) + CorSigCompressLength(trnHexLength) - .Source.StrTypeLength
		Case Is < 0		'.NET 字串类型
			MoveLength = CorSigCompressLength(trnHexLength + .EndByteLength) - .Source.StrTypeLength
		Case Is > 4		'自定义字串类型
			If .TagType > 1 Then Exit Function
			Select Case .LengthModeID
			Case 5
				MoveLength = CorSigCompressLength(trnHexLength) - CorSigCompressLength(.Source.lHexLength)
			Case 6
				MoveLength = CorSigCompressLength(trnCharLength) - CorSigCompressLength(.Source.lCharLength)
			Case 7, 8
				MoveLength = CorSigCompressLength(trnHexLength) + CorSigCompressLength(trnCharLength) - _
							CorSigCompressLength(.Source.lHexLength) - CorSigCompressLength(.Source.lCharLength)
			Case 9
				MoveLength = CorSigCompressLength(trnHexLength + trnCharLength) - _
							CorSigCompressLength(.Source.lHexLength + .Source.lCharLength)
			End Select
		End Select
	Else
		Select Case .StrType
		Case Is < -4	'Android 字串类型
			MoveLength = CorSigCompressLength(trnCharLength) + CorSigCompressLength(trnHexLength) - .Trans.StrTypeLength
		Case Is < 0		'.NET 字串类型
			MoveLength = CorSigCompressLength(trnHexLength + .EndByteLength) - .Trans.StrTypeLength
		Case Is > 4		'自定义字串类型
			If .TagType > 1 Then Exit Function
			Select Case .LengthModeID
			Case 5
				MoveLength = CorSigCompressLength(trnHexLength) - CorSigCompressLength(.Trans.lHexLength)
			Case 6
				MoveLength = CorSigCompressLength(trnCharLength) - CorSigCompressLength(.Trans.lCharLength)
			Case 7, 8
				MoveLength = CorSigCompressLength(trnHexLength) + CorSigCompressLength(trnCharLength) - _
							CorSigCompressLength(.Trans.lHexLength) - CorSigCompressLength(.Trans.lCharLength)
			Case 9
				MoveLength = CorSigCompressLength(trnHexLength + trnCharLength) - _
							CorSigCompressLength(.Trans.lHexLength + .Trans.lCharLength)
			End Select
		End Select
	End If
	End With
End Function


'求字串类型的最小移动值
'Mode = True 按字符截短超长字串长度
Private Function MinMoveLength(strData As STRING_PROPERTIE,textStr As String,trnLength As Long,ByVal trnMaxLength As Long) As Long
	Dim i As Long,j As Long,k As Long,x As Long,trnLengthBak As Long,Temp As String,TempBak As String
	Temp = textStr: TempBak = textStr
	With strData
		MinMoveLength = .Trans.MoveLength
		j = trnLength: trnLengthBak = trnLength
		i = trnMaxLength - .EndByteLength - .Trans.iNullByteLength
		Do
			'避免写入半个双字节字符
			If i < j Then
				j = IsDBCSLeadPos(Temp,.Trans.CodePage,i,True)
			End If
			k = MoveLength(strData,Len(Temp),j,True)
			If k = 0 Then
				textStr = Temp: trnLength = j: MinMoveLength = k
				Exit Do
			End If
			If j <= x Then Exit Do
			x = j
			i = trnMaxLength - .EndByteLength - .Trans.iNullByteLength - k
			If i >= j Then
				textStr = Temp: trnLength = j: MinMoveLength = k
			End If
			Temp = TempBak: j = trnLengthBak
		Loop
	End With
End Function


'计算字串类型的显示值
Private Function StrTypeValue(StrType As Integer) As Integer
	Select Case StrType
	Case Is < -4	'Android 字串类型
		StrTypeValue = 7
	Case Is < 0		'.NET 字串类型
		StrTypeValue = 6
	Case Is < 5
		StrTypeValue = StrType + 1
	Case Is > 4
		StrTypeValue = StrType + 3
	End Select
End Function


'计算不同字串类型的后随字节长度
Private Function EndByteLength(ByVal StrType As Integer,TypeList() As STRING_TYPE) As Integer
	Select Case StrType
	Case Is < -4	'Android 字串类型
		EndByteLength = 0
	Case Is < 0		'.NET 字串类型
		EndByteLength = 1
	Case Is > 4		'自定义字串类型
		If TypeList(StrType - 5).CodeLoc = 0 Then
			EndByteLength = TypeList(StrType - 5).EndCodeLength
		End If
	End Select
End Function


'获取自定义字符串标识符类型
Private Function TagType(ByVal StrType As Integer,TypeList() As STRING_TYPE) As Integer
	Select Case StrType
	Case Is > 4
		If TypeList(StrType - 5).CodeLoc = 0 Then
			TagType = 1
		Else
			TagType = 2
		End If
	Case Is > 0, Is < 0
		TagType = 1
	End Select
End Function


'计算不同代码页所需的后置空字节长度
Private Function NullByteLength(strData As STRING_PROPERTIE,ByVal Mode As Boolean) As Integer
	With strData
		Select Case .StrType
		Case Is < -4	'Android 字串类型
			NullByteLength = 1
		Case Is < 0		'.NET 字串类型
			NullByteLength = 0
		Case Else
			If .Source.lMaxAddress > .Source.lEndAddress Then
				Select Case IIf(Mode = False,.Source.CodePage,.Trans.CodePage)
				Case CP_UNICODELITTLE, CP_UNICODEBIG
					NullByteLength = 2
				Case CP_UTF32LE, CP_UTF32BE, CP_UTF_32LE, CP_UTF_32BE
					NullByteLength = 4
				Case Else
					NullByteLength = 1
				End Select
			End If
		End Select
	End With
End Function


'计算实际空格对齐的字节数
Private Function FillLength(strData As STRING_PROPERTIE,ByVal NoEscTextStr As String) As Integer
	With strData
		If .Trans.lHexLength <> .Source.lHexLength Then Exit Function
		Select Case .FillLength
		Case Is > 0
			FillLength = StrHexLength(Space$(.Trans.lCharLength - Len(RTrim$(NoEscTextStr))),.Trans.CodePage,0)
			If FillLength <> .FillLength Then FillLength = 0
		Case Is < 0
			FillLength = -StrHexLength(Space$(.Trans.lCharLength - Len(LTrim$(NoEscTextStr))),.Trans.CodePage,0)
			If FillLength <> .FillLength Then FillLength = 0
		End Select
	End With
End Function


'计算超长字符及需要移位的字串(引用代码已更改的)
'MoveType = 0 不需要移位和修改所有引用，原字串位置直接覆盖，多余字节可被其他字串覆盖
'MoveType = 1 需要移位和修改所有引用，原字串位置可被其他字串覆盖
'MoveType = 2 需要移位和修改部分引用，原字串保留不可被其他字串覆盖
'MoveType = 3 已经被标记为移位的字串（地址和所有引用已被修改）
'MoveType = 4 已部分移位不再需要移位，原字串保留不可被其他字串覆盖
'MoveType = 5 无引用或不能移位的字串，但可利用相邻的后一个翻译字串移位留下的空位，后一个字串必须设置为强制移位
'MoveString 返回值: 0 不需要移位，1 = 全部移位成功，> 1 = 移位失败数，-1 全部失败
'                 	第一个项目为有引用字串的移位结果，第二个项目为无引用字串的移位结果
'fType = 0 搜索空余字节并移位，否则只搜索空余字节
Private Function MoveString(trnFile As FILE_PROPERTIE,DataList() As STRING_PROPERTIE,ByVal fType As Long, _
				ByVal Mode As Long,Optional ByVal ShowMsg As Long) As POINTAPI
	Dim i As Long,n As Long,m As Long,j As Long,k As Long,Max As Long,MoveType As Integer
	Dim Msg As PROGRESS_MSG,File As FILE_PROPERTIE,FN As FILE_IMAGE
	Dim orgMaxPosDic As Object,trnMaxPosDic As Object,SectionDic As Object
	'非 PE 文件和无字串时直接退出
	If trnFile.Magic = "" Then Exit Function
	If ParentStrNum < 1 Then Exit Function
	'不需要移位时直接退出 (获取空余地址除外)
	If Selected(8) = "0" And fType = 0 Then Exit Function
	n = IIf(StrToLong(Selected(4) & Selected(5)) > 0,2,StrToLong(Selected(6)) Or StrToLong(Selected(7)))
	'准备完成进度显示
	Msg.hWnd = ShowMsg
	If ShowMsg > 0 Then
		Msg.Massage = GetTextBoxString(ShowMsg) & " "
	ElseIf ShowMsg < 0 Then
		ReDim TempList(PSL.OutputWnd(0).LineCount - 1) As String
		For i = 1 To PSL.OutputWnd(0).LineCount
			TempList(i - 1) = PSL.OutputWnd(0).Text(i)
		Next i
		Msg.Massage = StrListJoin(TempList,vbCrLf) & " "
	End If
	Max = UBound(DataList)
	Msg.Total = Max + 1
	If fType = 0 And n > 0 Then Msg.Total = Msg.Total * 2
	'搜索需要移位字串和可用空余地址
	Set orgMaxPosDic = CreateObject("Scripting.Dictionary")
	Set trnMaxPosDic = CreateObject("Scripting.Dictionary")
	Set SectionDic = CreateObject("Scripting.Dictionary")
	If UBound(FreeByteList) < ParentStrNum - 1 Then
		ReDim Preserve FreeByteList(ParentStrNum - 1) As FREE_BTYE_SPACE
	End If
	ReDim OverByteList(Max) As FREE_BTYE_SPACE
	j = -1
	For i = 0 To Max
		With DataList(i)
			'排除拆分形成的子串，确保空余地址数据都是父串
			If .SplitState > -1 Then
				j = j + 1
				FreeByteList(j).inSectionID = .Source.inSectionID
				FreeByteList(j).inSubSecID = .Source.inSubSecID
				FreeByteList(j).lNumber = .ID
				FreeByteList(j).Address = 0
				FreeByteList(j).MaxAddress = 0
				FreeByteList(j).Length = 0
				FreeByteList(j).MoveType = .ID
			End If
			'跳过不可移位的字串
			If .Moveable = 3 Then GoTo NextNo
			If .Moveable > 0 Then GoTo NextPos
			If .WriteType < 1 And .MoveMode <> 1 Then GoTo NextPos
			'If .MoveMode > 3 Then GoTo NextPos
			'If .SplitState > 0 Then GoTo NextPos
			'重置移位类型为节尾原有空位、节尾扩展空位、最后节扩展空位和新增节的字串
			If fType = 0 Then
				If n > 0 And .MoveType > 2 Then
					ResetStrVal(trnFile,DataList,FreeByteList,i,n - 1)
				End If
			End If
			'计算字串移位类型
			MoveType = 0
			If .Source.lReferenceNum > 0 And .SplitState < 1 And .MoveMode < 4 Then
				If .Trans.lReferenceNum = .Source.lReferenceNum Then
					If CheckStrVal(DataList(i),3,0) = True Then MoveType = 1 Else MoveType = 3
				ElseIf .Trans.lReferenceNum <> 0 Then
					If CheckStrVal(DataList(i),3,0) = True Then MoveType = 2 Else MoveType = 4
				ElseIf CheckStrVal(DataList(i),3,0) = True Then
					If CheckStrVal(DataList(i),4,0) = False Then MoveType = 1
				End If
			ElseIf .MoveMode = 5 Then
				If .SplitState > -1 Then
					If CheckStrVal(DataList(i),4,0) = False Then
						k = i + DataList(i).SplitState + 1
						If DataList(k).Source.lReferenceNum > 0 Then
							If .Source.lMaxAddress + 1 = DataList(k).Source.lStartAddress - DataList(k).Source.StrTypeLength Then
								MoveType = 5
							End If
						End If
					End If
				End If
			End If
			'获取字串的空余字节数据和需要移位数据
			Select Case MoveType
			Case 0
				'计算未移位留下的空字节
				If .SplitState = 0 Then
					If IIf(.OverLengthWrite = 0,.Source.lMaxHexLength,.Source.lHexLength) - .Trans.lHexLength > FreeByteMinLength Then
						FreeByteList(j).Address = .Trans.lStartAddress + .Trans.lHexLength + .EndByteLength + .Trans.iNullByteLength + 1
						FreeByteList(j).MaxAddress = GetMaxAddress(DataList(i),False)
						FreeByteList(j).Length = FreeByteList(j).MaxAddress - FreeByteList(j).Address + 1
						'FreeByteList(j).inSectionID = .Source.inSectionID
						'FreeByteList(j).lNumber = .ID
						FreeByteList(j).MoveType = .ScapeIDBeMoved
					End If
				End If
			Case 1
				If .SplitState < 1 Then
					'计算需要完全移位的字串
					OverByteList(i).Length = GetEvenPos(.Trans.lHexLength + .Trans.StrTypeLength + .EndByteLength + .Trans.iNullByteLength + 1)
					'OverByteList(i).Address = .Trans.lStartAddress
					'OverByteList(i).MaxAddress = .Trans.lMaxAddress
					OverByteList(i).inSectionID = .Trans.inSectionID
					OverByteList(i).inSubSecID = .Trans.inSubSecID
					OverByteList(i).lNumber = j
					OverByteList(i).MoveType = -1
					MoveString.x = MoveString.x + 1
					m = m + 1
				End If
				'计算可能被完全移位后的空字节并设置不可用，以免重复排序
				If .SplitState = 0 Then
					FreeByteList(j).Address = .Source.lStartAddress - .Source.StrTypeLength
					FreeByteList(j).MaxAddress = GetMaxAddress(DataList(i),False)
					FreeByteList(j).Length = FreeByteList(j).MaxAddress - FreeByteList(j).Address + 1
					'FreeByteList(j).inSectionID = .Source.inSectionID
					'FreeByteList(j).lNumber = .ID
					FreeByteList(j).MoveType = IIf(.ScapeIDBeMoved = -1,.ID,.ScapeIDBeMoved)
				End If
			Case 2
				'计算需要部分移位的字串，原字串保留
				If .SplitState < 1 Then
					OverByteList(i).Length = GetEvenPos(.Trans.lHexLength + .Trans.StrTypeLength + .EndByteLength + .Trans.iNullByteLength + 1)
					'OverByteList(i).Address = .Trans.lStartAddress
					'OverByteList(i).MaxAddress = .Trans.lMaxAddress
					OverByteList(i).inSectionID = .Trans.inSectionID
					OverByteList(i).inSubSecID = .Trans.inSubSecID
					OverByteList(i).lNumber = j
					OverByteList(i).MoveType = -2
					MoveString.x = MoveString.x + 1
				End If
			Case 3
				'计算完全移位后留下的空字节
				If .SplitState = 0 Then
					FreeByteList(j).Address = .Source.lStartAddress - .Source.StrTypeLength
					FreeByteList(j).MaxAddress = GetMaxAddress(DataList(i),False)
					FreeByteList(j).Length = FreeByteList(j).MaxAddress - FreeByteList(j).Address + 1
					'FreeByteList(j).inSectionID = .Source.inSectionID
					'FreeByteList(j).lNumber = .ID
					FreeByteList(j).MoveType = .ScapeIDBeMoved
				End If
			Case 5
				'计算需要全部移位的字串
				OverByteList(i).Length = .Trans.lHexLength + .Trans.StrTypeLength + .EndByteLength + .Trans.iNullByteLength + 1
				OverByteList(i).Address = .Trans.lStartAddress
				OverByteList(i).MaxAddress = .Trans.lMaxAddress
				OverByteList(i).inSectionID = .Trans.inSectionID
				OverByteList(i).inSubSecID = .Trans.inSubSecID
				OverByteList(i).lNumber = j
				OverByteList(i).MoveType = 7	'该值为负时移位，移位成功后，该数值会变成 1-6
				MoveString.y = MoveString.y + 1
			End Select
			'为提取非字串空余字节作准备
			NextPos:
			If Selected(3) = "1" Or fType = 1 Then
				'获取字串所在的节编号
				If Not SectionDic.Exists(.Source.inSectionID) Then
					SectionDic.Add(.Source.inSectionID,"")
					Msg.Total = Msg.Total + trnFile.SecList(.Source.inSectionID).lSizeOfRawData
				End If
				'记录原始字串、翻译的最大地址所对应的索引
				If Not orgMaxPosDic.Exists(.Source.lMaxAddress) Then
					orgMaxPosDic.Add(.Source.lMaxAddress,i)
				End If
				If Not trnMaxPosDic.Exists(.Trans.lMaxAddress) Then
					trnMaxPosDic.Add(.Trans.lMaxAddress,i)
				End If
			End If
			NextNo:
		End With
		'输出进度消息
		If ShowMsg > 0 Then
			SetTextBoxString ShowMsg,Msg.Massage & Format$((i + Msg.Passed) / Msg.Total,"#%")
		ElseIf ShowMsg < 0 Then
			PSL.OutputWnd(0).Clear
			PSL.Output Msg.Massage & Format$((i + Msg.Passed) / Msg.Total,"#%")
		End If
	Next i
	If (fType + MoveString.x + MoveString.y) = 0 Then GoTo ExitFunction
	Msg.Passed = Msg.Passed + i
	'转换选定文件节列表并提取未被提取空字节的文件节
	If Selected(3) = "1" Or fType = 1 Then
		If SectionDic.Count > 0 Then
			'打开翻译文件
			Mode = LoadFile(trnFile.FilePath,FN,0,0,0,Mode)
			If Mode < -1 Then GoTo ExitFunction
			'转换选定文件节列表并提取未被提取空字节的文件节
			For i = 0 To SectionDic.Count - 1
				n = SectionDic.Keys(i)
				If GetFreeByteSecList(n) <> "" Then
					Msg.Total = Msg.Total - trnFile.SecList(n).lSizeOfRawData
				Else
					j = GetFreeByteListRegExp(trnFile,FN,n,orgMaxPosDic,trnMaxPosDic,DataList,Msg,Mode)
					If j > 0 Then GetFreeByteSecList(n) = trnFile.SecList(n).sName
					Msg.Passed = Msg.Passed + trnFile.SecList(n).lSizeOfRawData
				End If
			Next i
			'关闭翻译文件
			If UnLoadFile(FN,0,Mode) = False Then GoTo ExitFunction
			If j < 0 Then GoTo ExitFunction
		End If
	End If
	If fType = 1 Then GoTo ExitFunction
	'移位字串
	If MoveString.x + MoveString.y = 0 Then GoTo ExitFunction
	'定义使用的文件
	File = trnFile
	n = 0
	If MoveString.x > 0 Then
		If Selected(6) = "1" Then
			n = MoveToLastSecEnd(File,DataList,OverByteList,FreeByteList,Msg,Mode)
			MoveString.x = IIf(n = 0,-1,MoveString.x - n + 1)
		ElseIf Selected(7) = "1" Then
			If InStr(trnFile.Magic,"NotPE") = 0 Then
				n = MoveToNewSec(File,DataList,OverByteList,FreeByteList,Msg,Mode)
			Else
				n = MoveToLastSecEnd(File,DataList,OverByteList,FreeByteList,Msg,Mode)
			End If
			MoveString.x = IIf(n = 0,-1,MoveString.x - n + 1)
		Else
			For i = 1 To Len(Selected(11))
				j = 0
				Select Case StrToLong(Mid$(Selected(11),i,1))
				Case 1
					If Selected(2) = "1" And MoveString.x > 0 Then
						j = MoveToFreeSpace(trnFile,DataList,OverByteList,FreeByteList,m,Msg,1)
					End If
				Case 2
					If Selected(3) = "1" And MoveString.x > 0 Then
						j = MoveToFreeSpace(trnFile,DataList,OverByteList,FreeByteList,m,Msg,2)
					End If
				Case 3
					If Selected(4) = "1" And MoveString.x > 0 Then
						j = MoveToSecEnd(trnFile,DataList,OverByteList,FreeByteList,m,Msg)
					End If
				Case 4
					If Selected(5) = "1" And MoveString.x > 0 Then
						j = MoveToAddSecEnd(File,DataList,OverByteList,FreeByteList,m,Msg,Mode)
					End If
				End Select
				MoveString.x = MoveString.x - j
				n = n + j
			Next i
			MoveString.x = IIf(n = 0,-1,IIf(MoveString.x = 0,1,MoveString.x + 1))
		End If
	End If
	If MoveString.y > 0 Then
		n = AddLengthToStrFreeSpace(File,DataList,OverByteList,FreeByteList,Msg)
		MoveString.y = IIf(n = 0,-1,MoveString.y - n + 1)
	End If
	'退出函数
	ExitFunction:
	Set orgMaxPosDic = Nothing
	Set trnMaxPosDic = Nothing
	Set SectionDic = Nothing
	If ShowMsg > 0 Then
		SetTextBoxString ShowMsg, Msg.Massage & "100%"
	ElseIf ShowMsg < 0 Then
		PSL.OutputWnd(0).Clear
		PSL.Output Msg.Massage & "100%"
	End If
	If StrToLong(Selected(26)) = 1 Then Beep
End Function


'移位到新增节
Private Function MoveToNewSec(trnFile As FILE_PROPERTIE,DataList() As STRING_PROPERTIE,OverByteList() As FREE_BTYE_SPACE, _
		ByteList() As FREE_BTYE_SPACE,Msg As PROGRESS_MSG,ByVal Mode As Long) As Long
	Dim i As Long,StratPos As Long,TempByte As FREE_BTYE_SPACE,Temp As String
	TempByte.Length = 5000
	If AddSection(trnFile,TempByte,0,Mode) < 1 Then Exit Function
	StratPos = TempByte.Address + 16
	For i = 0 To UBound(DataList)
		With OverByteList(i)
			If .MoveType < 0 Then
				'再次扩展空间
				If StratPos + .Length > TempByte.MaxAddress Then
					TempByte.Length = (StratPos + .Length - TempByte.Address) * 2
					If AddSection(trnFile,TempByte,0,Mode) < 1 Then Exit For
				End If
				'标记未被占用的完全移位后留下的空字节为未占用
				If .MoveType = -1 Then
					If ByteList(.lNumber).MoveType = DataList(i).ID Then
						ByteList(.lNumber).MoveType = -1
					End If
				End If
				'记录完全移位的地址，最大地址和长度按可用空位的原值
				.Address = GetEvenPos(StratPos + DataList(i).Trans.StrTypeLength)
				.MaxAddress = .Address + .Length - DataList(i).Trans.StrTypeLength - 1
				'.Length = .MaxAddress - .Address + 1 + DataList(i).Trans.StrTypeLength
				.inSectionID = TempByte.inSectionID
				.inSubSecID = TempByte.inSubSecID
				.lNumber = -.Address
				'标记已完全移位字串的移位类型为新增节空位
				.MoveType = 6
				'下一条字串的写入位置
				StratPos = .MaxAddress + 1
				'移位成功计数并合并找到的空字节位置到 DataList 中
				MoveToNewSec = MoveToNewSec + 1
				Call MergerMoveData(trnFile,DataList,OverByteList,ByteList,i)
				If Msg.hWnd > 0 Then
					SetTextBoxString Msg.hWnd,Msg.Massage & Format$((i + Msg.Passed) / Msg.Total,"#%")
				ElseIf Msg.hWnd < 0 Then
					PSL.OutputWnd(0).Clear
					PSL.Output Msg.Massage & Format$((i + Msg.Passed) / Msg.Total,"#%")
				End If
			End If
		End With
	Next i
	Msg.Passed = Msg.Passed + i
End Function


'移位到最后节的扩展空间
Private Function MoveToLastSecEnd(trnFile As FILE_PROPERTIE,DataList() As STRING_PROPERTIE,OverByteList() As FREE_BTYE_SPACE, _
		ByteList() As FREE_BTYE_SPACE,Msg As PROGRESS_MSG,ByVal Mode As Long) As Long
	Dim i As Long,StratPos As Long
	ReDim TempByteList(0) As FREE_BTYE_SPACE
	TempByteList(0).inSectionID = trnFile.MaxSecID
	TempByteList(0).Length = 5000
	If AddSectionSize(trnFile,TempByteList,0,Mode) < 1 Then Exit Function
	StratPos = TempByteList(0).Address + 16
	For i = 0 To UBound(DataList)
		With OverByteList(i)
			If .MoveType < 0 Then
				'再次扩展空间
				If StratPos + .Length > TempByteList(0).MaxAddress Then
					TempByteList(0).Length = (StratPos + .Length - TempByteList(0).Address) * 2
					If AddSectionSize(trnFile,TempByteList,0,Mode) < 1 Then Exit For
				End If
				'标记未被占用的完全移位后留下的空字节为未占用
				If .MoveType = -1 Then
					If ByteList(.lNumber).MoveType = DataList(i).ID Then
						ByteList(.lNumber).MoveType = -1
					End If
				End If
				'记录完全移位的地址，最大地址和长度按可用空位的原值
				.Address = GetEvenPos(StratPos + DataList(i).Trans.StrTypeLength)
				.MaxAddress = .Address + .Length - DataList(i).Trans.StrTypeLength - 1
				'.Length = .MaxAddress - .Address + 1 + DataList(i).Trans.StrTypeLength
				.inSectionID = TempByteList(0).inSectionID
				.inSubSecID = TempByteList(0).inSubSecID
				.lNumber = TempByteList(0).lNumber
				'标记已完全移位字串的移位类型为最后节扩展空位
				.MoveType = 5
				'下一条字串的写入位置
				StratPos = .MaxAddress + 1
				'移位成功计数并合并找到的空字节位置到 DataList 中
				MoveToLastSecEnd = MoveToLastSecEnd + 1
				Call MergerMoveData(trnFile,DataList,OverByteList,ByteList,i)
				If Msg.hWnd > 0 Then
					SetTextBoxString Msg.hWnd,Msg.Massage & Format$((i + Msg.Passed) / Msg.Total,"#%")
				ElseIf Msg.hWnd < 0 Then
					PSL.OutputWnd(0).Clear
					PSL.Output Msg.Massage & Format$((i + Msg.Passed) / Msg.Total,"#%")
				End If
			End If
		End With
	Next i
	Msg.Passed = Msg.Passed + i
End Function


'移位到字串所在节尾的扩展空间
Private Function MoveToAddSecEnd(trnFile As FILE_PROPERTIE,DataList() As STRING_PROPERTIE,OverByteList() As FREE_BTYE_SPACE, _
		ByteList() As FREE_BTYE_SPACE,FullMoveNum As Long,Msg As PROGRESS_MSG,ByVal Mode As Long) As Long
	Dim i As Long,j As Long,k As Long,Dic As Object
	'获取节索引值及其所属字串索引列表
	Set Dic = CreateObject("Scripting.Dictionary")
	ReDim FreeByte(trnFile.MaxSecIndex - 1) As FREE_BTYE_SPACE
	k = -1
	For i = 0 To UBound(DataList)
		With OverByteList(i)
			If .inSectionID <> trnFile.MaxSecIndex Then
				If Not Dic.Exists(.inSectionID) Then
					k = k + 1
					Dic.Add(.inSectionID,k)
					Dic.Add(-.inSectionID - 1,0)
					ReDim FreeByte(k).IndexList(UBound(DataList)) 'As Long
					FreeByte(k).inSectionID = .inSectionID
					FreeByte(k).IndexList(0) = i
				Else
					j = Dic.Item(-.inSectionID - 1)
					Dic.Item(-.inSectionID - 1) = j + 1
					FreeByte(Dic.Item(.inSectionID)).IndexList(j + 1) = i
				End If
			End If
		End With
	Next i
	If k = -1 Then
		Set Dic = Nothing
		Exit Function
	End If
	ReDim Preserve FreeByte(k) As FREE_BTYE_SPACE
	For i = 0 To k
		ReDim Preserve FreeByte(i).IndexList(Dic.Item(-FreeByte(i).inSectionID - 1)) 'As FREE_BTYE_SPACE
	Next i
	Set Dic = Nothing
	'按照其他段不移位的情况下分段获取移位字串的地址
	For j = 0 To UBound(FreeByte)
		ReDim TempByteList(0) As FREE_BTYE_SPACE
		TempByteList(0).inSectionID = FreeByte(j).inSectionID
		If AddSectionSize(trnFile,TempByteList,0,Mode) > 0 Then
			TempByteList(0).Address = TempByteList(0).Address + 16
			For k = 0 To UBound(FreeByte(j).IndexList)
				i = FreeByte(j).IndexList(k)
				With OverByteList(i)
					If .MoveType < 0 Then
						If TempByteList(0).Address + .Length < TempByteList(0).MaxAddress Then
							'标记未被占用的完全移位后留下的空字节为未占用
							If .MoveType = -1 Then
								FullMoveNum = FullMoveNum - 1
								If ByteList(.lNumber).MoveType = DataList(i).ID Then
									ByteList(.lNumber).MoveType = -1
								End If
							End If
							'记录完全移位的地址，最大地址和长度按可用空位的原值
							.Address = GetEvenPos(TempByteList(0).Address + DataList(i).Trans.StrTypeLength)
							.MaxAddress = .Address + .Length - DataList(i).Trans.StrTypeLength - 1
							'.Length = .MaxAddress - .Address + 1 + DataList(i).Trans.StrTypeLength
							.inSectionID = TempByteList(0).inSectionID
							.inSubSecID = TempByteList(0).inSubSecID
							.lNumber = TempByteList(0).lNumber
							'标记已完全移位字串的移位类型为扩展节后空位
							.MoveType = 4
							'下一条字串的写入位置
							TempByteList(0).Address = .MaxAddress + 1
							'移位成功计数并合并找到的空字节位置到 DataList 中
							MoveToAddSecEnd = MoveToAddSecEnd + 1
							Call MergerMoveData(trnFile,DataList,OverByteList,ByteList,i)
						Else
							DataList(i).WriteType = WriteType(trnFile,DataList(i),WriteSet)
						End If
					End If
				End With
				If Msg.hWnd > 0 Then
					SetTextBoxString Msg.hWnd,Msg.Massage & Format$((i + Msg.Passed) / Msg.Total,"#%")
				ElseIf Msg.hWnd < 0 Then
					PSL.OutputWnd(0).Clear
					PSL.Output Msg.Massage & Format$((i + Msg.Passed) / Msg.Total,"#%")
				End If
			Next k
		End If
	Next j
End Function


'移位到字串所在节尾的原有空间
Private Function MoveToSecEnd(trnFile As FILE_PROPERTIE,DataList() As STRING_PROPERTIE,OverByteList() As FREE_BTYE_SPACE, _
		ByteList() As FREE_BTYE_SPACE,FullMoveNum As Long,Msg As PROGRESS_MSG) As Long
	Dim i As Long,j As Long,x As Long,Dic As Object
	'查找可用空字节数据列表，以加快匹配速度
	x = UBound(ByteList)
	If x <= ParentStrNum - 1 Then Exit Function
	Set Dic = CreateObject("Scripting.Dictionary")
	ReDim TempByteList(trnFile.MaxSecIndex - 1) As FREE_BTYE_SPACE
	x = IIf(x > ParentStrNum + trnFile.MaxSecIndex - 1,ParentStrNum + trnFile.MaxSecIndex - 1,x)
	For i = ParentStrNum - 1 To x
		If ByteList(i).MoveType = -2 Then
			TempByteList(j) = ByteList(i)
			If Not Dic.Exists(ByteList(i).inSectionID) Then
				Dic.Add(ByteList(i).inSectionID,j)
			End If
			j = j + 1
		End If
	Next i
	If j = 0 Then
		 Set Dic = Nothing
		 Exit Function
	End If
	ReDim Preserve TempByteList(j - 1) As FREE_BTYE_SPACE
	'找出最适合翻译长度的可用空字节位置
	For i = 0 To UBound(DataList)
		With OverByteList(i)
			If .MoveType < 0 Then
				x = -1
				'找出最适合翻译长度的可用空字节位置
				If Dic.Exists(.inSectionID) Then
					j = Dic.Item(.inSectionID)
					If TempByteList(j).Address + .Length < TempByteList(j).MaxAddress Then
						x = j
					End If
				End If
				If x > -1 Then
					'标记未被占用的完全移位后留下的空字节为未占用
					If .MoveType = -1 Then
						FullMoveNum = FullMoveNum - 1
						If ByteList(.lNumber).MoveType = DataList(i).ID Then
							ByteList(.lNumber).MoveType = -1
						End If
					End If
					'记录完全移位的地址，最大地址和长度按可用空位的原值
					.Address = GetEvenPos(TempByteList(x).Address + DataList(i).Trans.StrTypeLength)
					.MaxAddress = .Address + .Length - DataList(i).Trans.StrTypeLength - 1
					'.Length = .MaxAddress - .Address + 1 + DataList(i).Trans.StrTypeLength
					.inSectionID = TempByteList(x).inSectionID
					.inSubSecID = TempByteList(x).inSubSecID
					.lNumber = TempByteList(x).lNumber
					'标记已完全移位字串的移位类型为节后原有空位
					.MoveType = 3
					'下一条字串的写入位置
					TempByteList(x).Address = .MaxAddress + 1
					'移位成功计数并合并找到的空字节位置到 DataList 中
					MoveToSecEnd = MoveToSecEnd + 1
					Call MergerMoveData(trnFile,DataList,OverByteList,ByteList,i)
				Else
					DataList(i).WriteType = WriteType(trnFile,DataList(i),WriteSet)
				End If
			End If
		End With
		If Msg.hWnd > 0 Then
			SetTextBoxString Msg.hWnd,Msg.Massage & Format$((i + Msg.Passed) / Msg.Total,"#%")
		ElseIf Msg.hWnd < 0 Then
			PSL.OutputWnd(0).Clear
			PSL.Output Msg.Massage & Format$((i + Msg.Passed) / Msg.Total,"#%")
		End If
	Next i
	Msg.Passed = Msg.Passed + i
	Set Dic = Nothing
End Function


'移位到字串和非字串空位
'Mode = 0 合并查找字串和非字串空位
'Mode = 1 字串空位
'Mode > 1 非字串空位
Private Function MoveToFreeSpace(trnFile As FILE_PROPERTIE,DataList() As STRING_PROPERTIE,OverByteList() As FREE_BTYE_SPACE, _
		ByteList() As FREE_BTYE_SPACE,FullMoveNum As Long,Msg As PROGRESS_MSG,ByVal Mode As Long) As Long
	Dim i As Long,j As Long,k As Long,n As Long,x As Long,LoopNum As Long
	Dim TempByteList() As FREE_BTYE_SPACE,Dic As Object
	'获取可用空字节数据列表
	If Mode = 0 Then
		TempByteList = ByteList
	ElseIf Mode = 1 Then
		TempByteList = ByteList
		ReDim Preserve TempByteList(ParentStrNum - 1) As FREE_BTYE_SPACE
	Else
		k = UBound(ByteList)
		If k <= ParentStrNum - 1 Then Exit Function
		ReDim TempByteList(k - ParentStrNum) As FREE_BTYE_SPACE
		CopyMemory TempByteList(0),ByteList(ParentStrNum),(k - ParentStrNum + 1) * Len(ByteList(0))
	End If
	'按空字节长度从大到小排序
	k = UBound(TempByteList)
	If k > 0 Then
		Call SortFreeByteByLength(TempByteList,0,k,True)
	End If
	'获取最大空余字节最小长度
	If Mode <> 1 Then
		x = StrToLong(Selected(9)) + 2
		For i = 0 To UBound(OrgStrTypeList)
			With OrgStrTypeList(i)
				If .CodeLoc = 0 Then
					If .FristCodePos > x Then x = .FristCodePos
				End If
			End With
		Next i
		If x < FreeByteMinLength Then x = FreeByteMinLength + 1
	End If
	'准备空余字节数据列表的索引号字典，并找出符合最小长度的索引号
	Set Dic = CreateObject("Scripting.Dictionary")
	For i = 0 To UBound(TempByteList)
		With TempByteList(i)
			If .lNumber < -1 Then
				If .Length < x Then .MoveType = -3
			ElseIf .lNumber > -1 Then
				If Not Dic.Exists(.lNumber) Then
					Dic.Add(.lNumber,i)
				End If
			End If
		End With
	Next i
	'找出最适合翻译长度的可用空字节位置
	LoopNum = StrToLong(Selected(18))
	Do
		Msg.Total = Msg.Total + UBound(DataList)
		For i = 0 To UBound(DataList)
			With OverByteList(i)
				If .MoveType < 0 And .Length <= TempByteList(0).Length Then
					x = -1
					'找出最适合翻译长度的可用空字节位置
					For j = 0 To k
						If TempByteList(j).MoveType = -1 Then
							If TempByteList(j).inSectionID = .inSectionID Then
								If TempByteList(j).Length > .Length Then
									x = j
								Else
									Exit For
								End If
							End If
						End If
					Next j
					If x > -1 Then
						'标记未被占用的完全移位后留下的空字节为未占用
						If .MoveType = -1 Then
							FullMoveNum = FullMoveNum - 1
							If ByteList(.lNumber).MoveType = DataList(i).ID Then
								ByteList(.lNumber).MoveType = -1
								If Dic.Exists(DataList(i).ID) Then
									TempByteList(Dic.Item(DataList(i).ID)).MoveType = -1
								End If
							End If
						End If
						'标记已完全移位字串的移位类型，标记空字节为已被占用，以免再被使用
						TempByteList(x).MoveType = DataList(i).ID
						If TempByteList(x).lNumber > -1 Then
							'标记已完全移位字串的移位类型为字串空位
							.MoveType = 1
							ByteList(FreeByteDic.Item(TempByteList(x).lNumber)).MoveType = DataList(i).ID
						Else
							'标记已完全移位字串的移位类型为非字串空位
							.MoveType = 2
							ByteList(-TempByteList(x).lNumber).MoveType = DataList(i).ID
						End If
						'记录完全移位的地址，最大地址和长度按可用空位的原值
						.Address = GetEvenPos(TempByteList(x).Address + DataList(i).Trans.StrTypeLength)
						.MaxAddress = TempByteList(x).MaxAddress
						'.Length = .MaxAddress - .Address + 1 + DataList(i).Trans.StrTypeLength
						.inSectionID = TempByteList(x).inSectionID
						.inSubSecID = TempByteList(x).inSubSecID
						.lNumber = TempByteList(x).lNumber
						'移位成功计数并合并找到的空字节位置到 DataList 中
						MoveToFreeSpace = MoveToFreeSpace + 1
						Call MergerMoveData(trnFile,DataList,OverByteList,ByteList,i)
					Else
						DataList(i).WriteType = WriteType(trnFile,DataList(i),WriteSet)
					End If
				End If
			End With
			If Msg.hWnd > 0 Then
				SetTextBoxString Msg.hWnd,Msg.Massage & Format$((i + Msg.Passed) / Msg.Total,"#%")
			ElseIf Msg.hWnd < 0 Then
				PSL.OutputWnd(0).Clear
				PSL.Output Msg.Massage & Format$((i + Msg.Passed) / Msg.Total,"#%")
			End If
		Next i
		n = n + 1
		Msg.Passed = Msg.Passed + i
	Loop Until FullMoveNum = 0 Or n >= LoopNum
	Set Dic = Nothing
End Function


'扩展无引用字串到字串空位
Private Function AddLengthToStrFreeSpace(trnFile As FILE_PROPERTIE,DataList() As STRING_PROPERTIE,OverByteList() As FREE_BTYE_SPACE, _
		ByteList() As FREE_BTYE_SPACE,Msg As PROGRESS_MSG) As Long
	Dim i As Long,x As Long
	'找出最适合翻译长度的可用空字节位置
	Msg.Total = Msg.Total + UBound(DataList)
	For i = 0 To UBound(DataList) - 1
		With OverByteList(i)
			If .MoveType = 7 Then
				x = .lNumber + 1
				If ByteList(x).MoveType = -1 Then
					If ByteList(x).Length + .MaxAddress - .Address + 1 > .Length Then
						'标记已超长写入字串的扩展类型，标记空字节为已被占用，以免再被使用
						ByteList(x).MoveType = DataList(i).ID
						'标记已完全移位字串的移位类型为字串空位
						.MoveType = 1
						'记录完全移位的地址，最大地址和长度按可用空位的原值
						.MaxAddress = ByteList(x).MaxAddress
						'.Length = .MaxAddress - .Address + 1 + DataList(i).Trans.StrTypeLength
						.inSectionID = ByteList(x).inSectionID
						.inSubSecID = ByteList(x).inSubSecID
						.lNumber = ByteList(x).lNumber
						'移位成功计数并合并找到的空字节位置到 DataList 中
						AddLengthToStrFreeSpace = AddLengthToStrFreeSpace + 1
						Call MergerMoveData(trnFile,DataList,OverByteList,ByteList,i)
					Else
						DataList(i).WriteType = WriteType(trnFile,DataList(i),WriteSet)
					End If
				Else
					DataList(i).WriteType = WriteType(trnFile,DataList(i),WriteSet)
				End If
			End If
		End With
		If Msg.hWnd > 0 Then
			SetTextBoxString Msg.hWnd,Msg.Massage & Format$((i + Msg.Passed) / Msg.Total,"#%")
		ElseIf Msg.hWnd < 0 Then
			PSL.OutputWnd(0).Clear
			PSL.Output Msg.Massage & Format$((i + Msg.Passed) / Msg.Total,"#%")
		End If
	Next i
	Msg.Passed = Msg.Passed + i
End Function


'合并找到的空字节位置到 DataList 中
Private Sub MergerMoveData(trnFile As FILE_PROPERTIE,DataList() As STRING_PROPERTIE,OverList() As FREE_BTYE_SPACE, _
			ByteList() As FREE_BTYE_SPACE,ByVal Index As Long)
	Dim i As Long
	With DataList(Index)
		.Trans.MoveLength = 0
		.Trans.lStartAddress = OverList(Index).Address
		.Trans.lEndAddress = OverList(Index).Address + .Trans.lHexLength - 1
		.Trans.lMaxAddress = OverList(Index).MaxAddress
		'.Trans.lHexLength = OverList(Index).Length - 2
		.Trans.lMaxHexLength = .Trans.lMaxAddress - .Trans.lStartAddress + 1 - .EndByteLength - .Trans.iNullByteLength
		.Trans.inSectionID = OverList(Index).inSectionID
		.Trans.inSubSecID = OverList(Index).inSubSecID
		.ScapeIDForMove = OverList(Index).lNumber
		.MoveType = OverList(Index).MoveType
		'修改引用列表
		If .Source.lReferenceNum > 0 Then
			'更改全部移位的引用列表，部分移位的保持不变
			If .Trans.lReferenceNum = 0 And .MoveMode < 3 Then
				.Trans.Reference = .Source.Reference
				.Trans.lReferenceNum = .Source.lReferenceNum
			End If
			'获取更改后的引用代码
			Call GetVARefList(trnFile,"",.Trans,OrgStrTypeList,.TagType,.Moveable,"",1,0,0)
		End If
		'获取字串写入类型
		.WriteType = WriteType(trnFile,DataList(Index),WriteSet)
		'获取字串的移位模式
		.MoveMode = MoveMode(trnFile,DataList(Index))
	End With
	'修改占用的未被移位字串的最大位置值，并标记被占用的ID号
	i = DataList(Index).ScapeIDForMove
	If i > -1 Then
		i = StrIDIndexDic.Item(i)
		If i <> Index Then
			With DataList(i)
				If .ScapeIDForMove = -1 Then
					.Trans.lMaxAddress = DataList(Index).Trans.lStartAddress - DataList(Index).Trans.StrTypeLength - 1
					.Trans.lMaxHexLength = .Trans.lMaxAddress - .Trans.lStartAddress + 1 - .EndByteLength - .Trans.iNullByteLength
				End If
				.ScapeIDBeMoved = DataList(Index).ID
			End With
		End If
	End If
	'修改原被占用的字串和空间为当前字串的开始地址和最大可写长度
	i = DataList(Index).ScapeIDBeMoved
	If i > -1 Then
		i = StrIDIndexDic.Item(i)
		With DataList(i)
			If .Trans.lReferenceNum <> 0 Then
				.Trans.MoveLength = 0
				.Trans.lStartAddress = DataList(Index).Source.lStartAddress - DataList(Index).Source.StrTypeLength + .Trans.StrTypeLength
				.Trans.lEndAddress = .Trans.lStartAddress + .Trans.lHexLength - 1
				.Trans.lMaxAddress = GetMaxAddress(DataList(Index),False)
				.Trans.lMaxHexLength = .Trans.lMaxAddress - .Trans.lStartAddress + 1 - .EndByteLength - .Trans.iNullByteLength
				.Trans.inSectionID = DataList(Index).Source.inSectionID
				Call GetVARefList(trnFile,"",.Trans,OrgStrTypeList,.TagType,.Moveable,"",1,0,0)
			End If
		End With
		With DataList(Index)
			i = FreeByteDic.Item(.ID)
			ByteList(i).Address = .Source.lStartAddress - .Source.StrTypeLength
			ByteList(i).MaxAddress = GetMaxAddress(DataList(Index),False)
			ByteList(i).Length = ByteList(i).MaxAddress - ByteList(i).Address + 1
		End With
	End If
End Sub


'获取可用的空字节空间列表
Private Function GetFreeByteListRegExp(trnFile As FILE_PROPERTIE,FN As FILE_IMAGE,ByVal SecID As Long,oDic As Object,tDic As Object, _
		DataList() As STRING_PROPERTIE,Msg As PROGRESS_MSG,ByVal Mode As Long) As Long
	Dim i As Long,j As Long,n As Long,e As Long,m As Long,k As Long,x As Long
	Dim RSize As Long,ROffset As Long,SkipVal As Long,Max As Long,Stemp As Boolean,Matches As Object
	Dim ByteList() As FREE_BTYE_SPACE,Dic As Object
	Dim MinVal As Long,MaxVal As Long,SubSecID As Long
	If InStr(trnFile.Magic,"MAC") = 0 Then SubSecID = -1

	'Name(节名) + VSize(虚拟大小) + VOffset(虚拟地址) + RSize(物理大小) + ROffset(物理地址)
	ROffset = trnFile.SecList(SecID).lPointerToRawData
	RSize = ROffset + trnFile.SecList(SecID).lSizeOfRawData - 1

	'获取最大空余字节最小长度
	x = StrToLong(Selected(9)) + 2
	For i = 0 To UBound(OrgStrTypeList)
		With OrgStrTypeList(i)
			If .CodeLoc = 0 Then
				If .FristCodePos > x Then x = .FristCodePos
			End If
		End With
	Next i
	If x < FreeByteMinLength Then x = FreeByteMinLength + 1

	Set Dic = CreateObject("Scripting.Dictionary")
	CopyDic FreeByteDic,Dic
	ByteList = FreeByteList
	n = UBound(ByteList)
	k = n
	Max = n + IIf((RSize - ROffset + 1) < 1000,10,(RSize - ROffset + 1) \ 100)
	ReDim Preserve ByteList(Max) As FREE_BTYE_SPACE
	RegExp.Global = True
	RegExp.IgnoreCase = False
	RegExp.Pattern = "\x00{" & CStr$(x \ 2) & ",}"

	'显示主窗口的取消操作按钮和禁止主窗口的 Esc 键响应退出主窗口
	Call ShowButton(StopHwnd,VK_ESCAPE,True)
	i = ROffset
	SkipVal = ROffset - 1
	Do While i < RSize
		'排除各种文件头数据区段
		If i <= SkipVal Then i = SkipVal + 1
		If i > SkipVal Then
			m = SkipHeader(trnFile,i,SkipVal,1)
			If m = 0 Or m = 1 Then Exit Do
			If i > SkipVal Or SkipVal > RSize Then SkipVal = RSize + 1
			If i > RSize Then Exit Do
		End If
		Set Matches = RegExp.Execute(GetBytes(FN,SkipVal - i,i,Mode))
		If Matches.Count > 0 Then
			For j = 0 To Matches.Count - 1
				e = i + Matches(j).FirstIndex * 2
				m = e + Matches(j).Length * 2 - 1
				'获取字串的最大位置
				m = getNotNullByte(FN,m + 1,RSize,Mode) - 1
				'避开 Delphi 窗体代码
				If trnFile.LangType = DELPHI_FILE_SIGNATURE And m + 6 < RSize Then
					If GetLong(FN,m + 1,Mode) = &HFFFFFFFF Then
						If m - 4 > e Then m = m - 4
					End If
				End If
				If m - e + 1 >= x Then		'搜索大于 x 个字节的空字节
					If oDic.Exists(m) Then GoTo NextNo
					If trnFile.LangType = DELPHI_FILE_SIGNATURE Then
						If oDic.Exists(m + 4) Then GoTo NextNo
					End If
					'避开已被提取的空字节
					'- 1 避开以空字节开始的双字节字符的开始地址和前一个字串的最大地址相同)
					If Dic.Exists(m - 1) Then GoTo NextNo
					'添加空余地址字典项，记录空字节位置及大小
					n = n + 1
					If n >= Max Then
						Max = Max * 2
						ReDim Preserve ByteList(Max) As FREE_BTYE_SPACE
					End If
					With ByteList(n)
						.Address = e + 2	'隔开2个字节
						.MaxAddress = m
						.Length = .MaxAddress - .Address + 1
						.inSectionID = SecID
						.inSubSecID = -1
						If SubSecID > -1 Then
							If .Address < MinVal Or .Address > MaxVal Then
								SubSecID = SkipSubSection(trnFile.SecList(SecID),.Address,MinVal,MaxVal)
							End If
							.inSubSecID = SubSecID
						End If
						.lNumber = -n
						'检查是否已被占用
						If tDic.Exists(m) Then
							e = tDic.Item(m)
							DataList(e).ScapeIDForMove = -n
							DataList(e).MoveType = 2
							.MoveType = DataList(e).ID
						Else
							.MoveType = -1	'可用的非字串空位，参与空位管理
						End If
					End With
					Dic.Add(m - 1,-n)
					NextNo:
				End If
				If Msg.hWnd > 0 Then
					SetTextBoxString Msg.hWnd,Msg.Massage & Format$((m - ROffset + Msg.Passed) / Msg.Total,"#%")
				ElseIf Msg.hWnd < 0 Then
					PSL.OutputWnd(0).Clear
					PSL.Output Msg.Massage & Format$((m - ROffset + Msg.Passed) / Msg.Total,"#%")
				End If
				'DoEvents '转让控制权，允许操作系统处理其他事件
				If StopProcess(StopHwnd,VK_ESCAPE) = True Then
					GetFreeByteListRegExp = -1
					GoTo ExitFunction
				End If
			Next j
		End If
	Loop
	ReDim Preserve ByteList(n) As FREE_BTYE_SPACE
	FreeByteList = ByteList: Set FreeByteDic = Dic
	If n > k Then GetFreeByteListRegExp = n - k
	ExitFunction:
	Set Dic = Nothing
	'隐藏主窗口中的取消操作按钮，启用 Esc 键的退出响应
	Call ShowButton(StopHwnd,VK_ESCAPE,False)
End Function


'添加未提取但已经被占用的非字串空字节空间列表
Private Function AddFreeByteListRegExp(trnFile As FILE_PROPERTIE,FN As FILE_IMAGE,ByteList() As FREE_BTYE_SPACE, _
		DataList() As STRING_PROPERTIE,Index() As Long,ByVal Mode As Long) As Boolean
	Dim i As Long,j As Long,n As Long,k As Long,Length As Long,Matches As Object
	n = UBound(ByteList): k = n
	ReDim Preserve ByteList(n + UBound(Index) + 1) As FREE_BTYE_SPACE
	RegExp.Global = True
	RegExp.IgnoreCase = False
	RegExp.Pattern = "\x00"
	For i = 0 To UBound(Index)
		j = Index(i)
		If j > -1 Then
			With DataList(j).Trans
				If SkipHeader(trnFile,.lStartAddress,0,0) > -1 Then
					If FreeByteDic.Exists(.lMaxAddress - 1) Then FreeByteDic.Remove(.lMaxAddress - 1)
					ResetStrVal(trnFile,DataList,ByteList,j,1)
				Else
					Length = .lMaxAddress - .lStartAddress + 1 + .StrTypeLength
					Set Matches = RegExp.Execute(ByteToString(GetBytes(FN,Length,.lStartAddress - .StrTypeLength,Mode),CP_ISOLATIN1))
					If Matches.Count = Length Then
						n = n + 1
						ByteList(n).Address = .lStartAddress - .StrTypeLength
						ByteList(n).MaxAddress = .lMaxAddress
						ByteList(n).Length = Length
						ByteList(n).inSectionID = .inSectionID
						ByteList(n).inSubSecID = .inSubSecID
						ByteList(n).lNumber = -n
						ByteList(n).MoveType = DataList(j).ID	'非字串空位，参与空位管理
						DataList(j).ScapeIDForMove = -n
						FreeByteDic.Item(.lMaxAddress - 1) = -n
					Else
						If FreeByteDic.Exists(.lMaxAddress - 1) Then FreeByteDic.Remove(.lMaxAddress - 1)
						ResetStrVal(trnFile,DataList,ByteList,j,1)
					End If
				End If
			End With
		Else
			ResetStrVal(trnFile,DataList,ByteList,-j,1)
		End If
	Next i
	If n > k Then AddFreeByteListRegExp = True
	ReDim Preserve ByteList(n) As FREE_BTYE_SPACE
End Function


'获取节后可用的空字节空间
Private Function GetSecEndFreeBytes(trnFile As FILE_PROPERTIE,FN As FILE_IMAGE,ByVal SecID As Long,oDic As Object, _
		ByteList() As FREE_BTYE_SPACE,ByVal Index As Long,ByVal Mode As Long) As Boolean
	Dim i As Long,RSize As Long,ROffset As Long,SkipVal As Long
	Dim MinVal As Long,MaxVal As Long,SubSecID As Long
	If InStr(trnFile.Magic,"MAC") = 0 Then SubSecID = -1
	'Name(节名) + VSize(虚拟大小) + VOffset(虚拟地址) + RSize(物理大小) + ROffset(物理地址)
	ROffset = trnFile.SecList(SecID).lPointerToRawData
	RSize = ROffset + trnFile.SecList(SecID).lSizeOfRawData - 1
	If oDic.Exists(RSize) = True Then Exit Function
	SkipVal = ROffset
	If SkipHeader(trnFile,RSize,SkipVal,2) > -1 Then Exit Function
	If SkipVal = RSize Then Exit Function
	i = RSize
	Do While i > ROffset
		If i = SkipVal Or GetByte(FN,i,Mode) > 0 Then
			If RSize - i - 3 > FreeByteMinLength Then
				'- 1 避开以空字节开始的双字节字符的开始地址和前一个字串的最大地址相同)
				If Not FreeByteDic.Exists(RSize - 1) Then
					With ByteList(Index)
						.Address = i + 4
						.MaxAddress = RSize
						.Length = .MaxAddress - .Address + 1
						.inSectionID = SecID
						.inSubSecID = -1
						If SubSecID > -1 Then
							If .Address < MinVal Or .Address > MaxVal Then
								SubSecID = SkipSubSection(trnFile.SecList(SecID),.Address,MinVal,MaxVal)
							End If
							.inSubSecID = SubSecID
						End If
						.lNumber = -Index
						.MoveType = -2	'节尾空位，不参与空位管理
					End With
					FreeByteDic.Add(RSize - 1,-Index)
					GetSecEndFreeBytes = True
				End If
			End If
			Exit Do
		End If
		i = i - 1
	Loop
End Function


'获取节后可用的空字节空间
Private Function GetSecEndFreeBytesRegExp(trnFile As FILE_PROPERTIE,FN As FILE_IMAGE,ByVal SecID As Long,oDic As Object, _
		ByteList() As FREE_BTYE_SPACE,ByVal Index As Long,ByVal Mode As Long) As Boolean
	Dim i As Long,RSize As Long,ROffset As Long,SkipVal As Long,Matches As Object
	Dim MinVal As Long,MaxVal As Long,SubSecID As Long
	If InStr(trnFile.Magic,"MAC") = 0 Then SubSecID = -1
	'Name(节名) + VSize(虚拟大小) + VOffset(虚拟地址) + RSize(物理大小) + ROffset(物理地址)
	ROffset = trnFile.SecList(SecID).lPointerToRawData
	RSize = ROffset + trnFile.SecList(SecID).lSizeOfRawData - 1
	If oDic.Exists(RSize) = True Then Exit Function
	SkipVal = ROffset
	If SkipHeader(trnFile,RSize,SkipVal,2) > -1 Then Exit Function
	If SkipVal = RSize Then Exit Function
	ROffset = RSize: i = RSize
	With RegExp
		.Global = True
		.IgnoreCase = False
		.Pattern = "\x00{" & FreeByteMinLength & ",}$"
		Do
			i = IIf(i - 512 > SkipVal,i - 512,SkipVal)
			Set Matches = .Execute(ByteToString(GetBytes(FN,RSize - i + 1,i,Mode),CP_ISOLATIN1))
			If Matches.Count = 0 Then Exit Do
			If i = SkipVal Or Matches(Matches.Count - 1).FirstIndex > 0 Then
				ROffset = i + Matches(Matches.Count - 1).FirstIndex
				If ROffset + Matches(Matches.Count - 1).Length - 1 = RSize Then Exit Do
				Exit Function
			End If
		Loop Until i <= SkipVal
	End With
	If RSize - ROffset - 3 > FreeByteMinLength Then
		'- 1 避开以空字节开始的双字节字符的开始地址和前一个字串的最大地址相同)
		If Not FreeByteDic.Exists(RSize - 1) Then
			With ByteList(Index)
				.Address = ROffset + IIf(i = SkipVal,4,3)
				.MaxAddress = RSize
				.Length = .MaxAddress - .Address + 1
				.inSectionID = SecID
				.inSubSecID = -1
				If SubSecID > -1 Then
					If .Address < MinVal Or .Address > MaxVal Then
						SubSecID = SkipSubSection(trnFile.SecList(SecID),.Address,MinVal,MaxVal)
					End If
					.inSubSecID = SubSecID
				End If
				.lNumber = -Index
				.MoveType = -2	'节尾空位，不参与空位管理
			End With
			FreeByteDic.Add(RSize - 1,-Index)
			GetSecEndFreeBytesRegExp = True
		End If
	End If
End Function


'查找 .NET 字串引用地址列表
'fType = 0 查找来源的引用列表和引用代码
'fType = 1 查找翻译的引用列表和引用代码，如果 RefAdds 为空，则按照原来引用地址计算引用代码
'fType = 2 查找翻译的引用列表和引用代码，如果 RefAdds 为空，则初始化，清空引用列表
'fType > 2 初始化，清空翻译引用列表和引用代码
Private Function GetNETVARefList(File As FILE_PROPERTIE,FN As Variant,strData As STRING_SUB_PROPERTIE,ByVal StrTypeLength As Integer, _
				ByVal RefAdds As String,ByVal fType As Long,ByVal Mode As Long,Optional ByVal ShowMsg As Long) As Long
	Dim i As Long,j As Long,m As Long,n As Long
	Dim Msg As String,TempList() As String
	On Error GoTo ExitFunction
	If File.Magic = "" Then GoTo ExitFunction
	If fType > 2 Then GoTo ExitFunction
	If ShowMsg > 0 Then
		Msg = GetTextBoxString(ShowMsg) & " "
	ElseIf ShowMsg < 0 Then
		ReDim TempList(PSL.OutputWnd(0).LineCount - 1) As String
		For i = 1 To PSL.OutputWnd(0).LineCount
			TempList(i - 1) = PSL.OutputWnd(0).Text(i)
		Next i
		Msg = StrListJoin(TempList,vbCrLf) & " "
	End If
	With strData
		'按原来翻译开始地址的引用代码获取新地址的引用代码列表
		If fType < 0 Then
			'If RefAdds <> "" Then Call getRefList(strData,ReSplit(RefAdds,RefJoinStr),TempList,True)
			If .lReferenceNum = 0 Then GoTo ExitFunction
			j = File.StreamList(File.USStreamID).lPointerToRawData
			.Reference(0).sCode = ReverseHexCode(Hex$(.lStartAddress - j - StrTypeLength),6) & "70"
			For i = 0 To .lReferenceNum - 1
				.Reference(i).sCode = .Reference(0).sCode
			Next i
			.GetRefState = 1
			Exit Function
		End If
		If fType = 0 Then
			'获取过引用的退出程序
			If .GetRefState > 0 Then Exit Function
			.lReferenceNum = 0
			ReDim strData.Reference(0) 'As REFERENCE_PROPERTIE
			j = File.StreamList(File.USStreamID).lPointerToRawData
			.Reference(0).sCode = ReverseHexCode(Hex$(.lStartAddress - j - StrTypeLength),6) & "70"
			i = File.SecList(File.MinSecID).lPointerToRawData
			If RefAdds = "" Then
				j = File.StreamList(File.USStreamID).lPointerToRawData
				RefAdds = ByteToString(GetBytes(FN,j - i + 1,i,Mode),CP_ISOLATIN1)
			End If
			TempList = GetVAListRegExp(RefAdds,"\x72" & HexStr2RegExpPattern(.Reference(0).sCode,1),i)
			If CheckArray(TempList) = True Then
				.lReferenceNum = UBound(TempList) + 1
				ReDim Preserve strData.Reference(.lReferenceNum - 1) 'As REFERENCE_PROPERTIE
				For i = 0 To .lReferenceNum - 1
					.Reference(i).lAddress = CLng(TempList(i)) + 1
					.Reference(i).sCode = .Reference(0).sCode
					If .Reference(i).lAddress < n Or .Reference(i).lAddress > m Then
						j = SkipSection(File,.Reference(i).lAddress,n,m)
					End If
					.Reference(i).inSecID = j
					If ShowMsg > 0 Then
						SetTextBoxString ShowMsg,Msg & Format$(i / .lReferenceNum,"#%")
					ElseIf ShowMsg < 0 Then
						PSL.OutputWnd(0).Clear
						PSL.Output Msg & Format$(i / .lReferenceNum,"#%")
					End If
				Next i
			End If
			.GetRefState = 1
		ElseIf RefAdds <> "" Or (.lReferenceNum > 0 And fType < 2) Then
			If RefAdds <> "" Then Call GetRefList(strData,ReSplit(RefAdds,RefJoinStr),TempList,True)
			If .lReferenceNum > 0 Then
				j = File.StreamList(File.USStreamID).lPointerToRawData
				.Reference(0).sCode = ReverseHexCode(Hex$(.lStartAddress - j - StrTypeLength),6) & "70"
				For i = 0 To .lReferenceNum - 1
					.Reference(i).sCode = .Reference(0).sCode
					If ShowMsg > 0 Then
						SetTextBoxString ShowMsg,Msg & Format$(i / .lReferenceNum,"#%")
					ElseIf ShowMsg < 0 Then
						PSL.OutputWnd(0).Clear
						PSL.Output Msg & Format$(i / .lReferenceNum,"#%")
					End If
				Next i
			End If
			.GetRefState = 1
		Else
			GoTo ExitFunction
		End If
	End With
	GetNETVARefList = strData.lReferenceNum
	If ShowMsg > 0 Then
		SetTextBoxString ShowMsg,Msg & "100%"
	ElseIf ShowMsg < 0 Then
		PSL.OutputWnd(0).Clear
		PSL.Output Msg & "100%"
	End If
	Exit Function
	'退出函数
	ExitFunction:
	ReDim Preserve strData.Reference(0) 'As REFERENCE_PROPERTIE
	strData.lReferenceNum = 0
	strData.GetRefState = 0
	If ShowMsg > 0 Then
		SetTextBoxString ShowMsg,Msg & "100%"
	ElseIf ShowMsg < 0 Then
		PSL.OutputWnd(0).Clear
		PSL.Output Msg & "100%"
	End If
End Function


'查找引用代码和引用列表
'fType < 0 按现有的引用地址列表，查找翻译的引用代码列表，fType 为原来的翻译开始地址
'fType = 0 查找来源的引用列表和引用代码
'fType = 1 查找翻译的引用列表和引用代码，如果 RefAdds 为空，则按照原来引用地址计算引用代码
'fType = 2 查找翻译的引用列表和引用代码，如果 RefAdds 为空，则初始化，清空引用列表
'fType > 2 初始化，清空翻译引用列表和引用代码
'虚拟地址(VA) = StartPos + ImageBase + VRK
Private Function GetVARefList(File As FILE_PROPERTIE,FN As Variant,strData As STRING_SUB_PROPERTIE,TypeList() As STRING_TYPE,ByVal TagType As Integer, _
				ByVal Moveable As Integer,ByVal RefAdds As String,ByVal fType As Long,ByVal Mode As Long,Optional ByVal ShowMsg As Long) As Long
	Dim i As Long,j As Long,k As Long,m As Long,n As Long
	Dim RVA As Long,VRK As Long,MaxPos As Long,RSize As Long,SkipVal As Long
	Dim Msg As String,TempList() As String,Temp As String
	On Error GoTo ExitFunction
	If fType > 2 Then GoTo ExitFunction
	If Moveable = 2 Then
		GetVARefList = GetNETVARefList(File,FN,strData,strData.StrTypeLength,RefAdds,fType,Mode,ShowMsg)
		Exit Function
	End If
	If Moveable > 0 Then GoTo ExitFunction
	With strData
	If fType > -1 Then
		If .inSectionID < 0 Then .inSectionID = SkipSection(File,.lStartAddress,0,0)
		If .inSectionID < 0 Then GoTo ExitFunction
		If File.SecList(.inSectionID).SubSecs > 0 Then
			If .inSubSecID < 0 Then .inSubSecID = SkipSubSection(File.SecList(.inSectionID),.lStartAddress,0,0)
		End If
		If ShowMsg > 0 Then
			Msg = GetTextBoxString(ShowMsg) & " "
		ElseIf ShowMsg < 0 Then
			ReDim TempList(PSL.OutputWnd(0).LineCount - 1) As String
			For i = 1 To PSL.OutputWnd(0).LineCount
				TempList(i - 1) = PSL.OutputWnd(0).Text(i)
			Next i
			Msg = StrListJoin(TempList,vbCrLf) & " "
		End If
		If fType > 0 Then RefAdds = Trim$(RefAdds)
	End If
	Select Case File.Magic
	Case "PE64","NET64","MAC64","NotPE64"
		'按原来翻译开始地址的引用代码获取新地址的引用代码列表
		If fType < 0 Then
			'If RefAdds <> "" Then Call getRefList(strData,ReSplit(RefAdds,RefJoinStr),TempList,True)
			If .lReferenceNum = 0 Then GoTo ExitFunction
			i = .Reference(0).inSecID
			If InStr(File.Magic,"NotPE") = 0 Then
				VRK = File.SecList(i).lVirtualAddress - File.SecList(i).lPointerToRawData
				RVA = Val("&H" & ReverseHexCode(.Reference(0).sCode,8)) + .Reference(0).lAddress + VRK + 4
				RVA = RVA + fType + .lStartAddress
				For i = 0 To .lReferenceNum - 1
					j = .Reference(i).inSecID
					VRK = File.SecList(j).lVirtualAddress - File.SecList(j).lPointerToRawData
					.Reference(i).sCode = ReverseHexCode(Hex$(RVA - (.Reference(i).lAddress + VRK + 4)),8)
					'.Reference(i).sCode = Byte2Hex(Val2Bytes(RVA - (.Reference(i).lAddress + VRK + 4),4),0,3)
				Next i
			Else
				If UseRefTypeList(0).ByteOrder = 0 Then
					RVA = Val("&H" & ReverseHexCode(.Reference(0).sCode,UseRefTypeList(0).ByteLength * 2)) + .Reference(0).lAddress
					RVA = RVA + fType + .lStartAddress
					For i = 0 To .lReferenceNum - 1
						.Reference(0).sCode = ReverseHexCode(Hex$(RVA - .Reference(i).lAddress),UseRefTypeList(0).ByteLength * 2)
					Next i
				Else
					RVA = Val("&H" & .Reference(0).sCode) + .Reference(0).lAddress
					RVA = RVA + fType + .lStartAddress
					For i = 0 To .lReferenceNum - 1
						.Reference(0).sCode = ValToStr(RVA - .Reference(i).lAddress,-UseRefTypeList(0).ByteLength * 2,True)
					Next i
				End If
			End If
			.GetRefState = 1
			Exit Function
		End If
		If .inSectionID > File.MaxSecIndex - 1 Then GoTo ExitFunction
		'获取字串的虚拟地址
		With File.SecList(.inSectionID)
			If strData.lStartAddress >= .lPointerToRawData And strData.lStartAddress < .lPointerToRawData + .lSizeOfRawData Then
				RVA = strData.lStartAddress + .lVirtualAddress - .lPointerToRawData
			Else
				GoTo ExitFunction
			End If
		End With
		If fType = 0 Then
			'获取过引用的退出程序
			If .GetRefState > 0 Then Exit Function
			If SkipHeader(File,strData.lStartAddress,0,0) > -1 Then GoTo ExitFunction
			.lReferenceNum = 0
			ReDim strData.Reference(0) 'As REFERENCE_PROPERTIE
			If InStr(File.Magic,"NotPE") = 0 Then
				MaxPos = strData.lStartAddress - 4
				For j = 0 To IIf(.inSectionID = 0,0,.inSectionID - 1)
					With File.SecList(j)
						i = .lPointerToRawData
						RSize = i + .lSizeOfRawData - 4
						VRK = RVA - (.lVirtualAddress - .lPointerToRawData) - 4
					End With
					If RSize > MaxPos Then RSize = MaxPos
					SkipVal = i - 1
					Do While i < RSize
						'排除某些数据目录区段和 .NET 文件数据区段
						If i > SkipVal Then
							k = i: m = SkipHeader(File,k,SkipVal,1)
							If m = 2 Or m = 4 Or m = 5 Or m > 15 Then i = k
							If i > SkipVal Or SkipVal > RSize Then SkipVal = RSize + 1
							If i > RSize Then Exit Do
						End If
						i = i + GetVAListPE64(FN,strData,n,j,VRK,i,SkipVal,Mode) + 1
						If ShowMsg > 0 Then
							SetTextBoxString ShowMsg,Msg & Format$(i / MaxPos,"#%")
						ElseIf ShowMsg < 0 Then
							PSL.OutputWnd(0).Clear
							PSL.Output Msg & Format$(i / MaxPos,"#%")
						End If
					Loop
				Next j
			Else
				MaxPos = strData.lStartAddress
				With File.SecList(0)
					i = .lPointerToRawData
					RSize = i + .lSizeOfRawData
					VRK = RVA - (.lVirtualAddress - .lPointerToRawData)
				End With
				If RSize > MaxPos Then RSize = MaxPos
				SkipVal = i - 1
				Do While i < RSize
					i = i + GetVAListNotPE64(FN,strData,n,0,VRK,i,SkipVal,Mode) + 1
					If ShowMsg > 0 Then
						SetTextBoxString ShowMsg,Msg & Format$(i / MaxPos,"#%")
					ElseIf ShowMsg < 0 Then
						PSL.OutputWnd(0).Clear
						PSL.Output Msg & Format$(i / MaxPos,"#%")
					End If
				Loop
			End If
			If .lReferenceNum > 0 Then
				ReDim Preserve strData.Reference(.lReferenceNum - 1) 'As REFERENCE_PROPERTIE
				If TagType > 1 Then Call GetCustomStrTypeRegExp(FN,strData,TypeList,Mode,-1)
			End If
			.GetRefState = 1
		ElseIf RefAdds <> "" Or (.lReferenceNum > 0 And fType < 2) Then
			If RefAdds <> "" Then Call GetRefList(strData,ReSplit(RefAdds,RefJoinStr),TempList,True)
			If .lReferenceNum > 0 Then
				If InStr(File.Magic,"NotPE") = 0 Then
					For i = 0 To .lReferenceNum - 1
						j = .Reference(i).inSecID
						VRK = File.SecList(j).lVirtualAddress - File.SecList(j).lPointerToRawData
						.Reference(i).sCode = ReverseHexCode(Hex$(RVA - (.Reference(i).lAddress + VRK + 4)),8)
						'.Reference(i).sCode = Byte2Hex(Val2Bytes(RVA - (.Reference(i).lAddress + VRK + 4),4),0,3)
						If ShowMsg > 0 Then
							SetTextBoxString ShowMsg,Msg & Format$(i / .lReferenceNum,"#%")
						ElseIf ShowMsg < 0 Then
							PSL.OutputWnd(0).Clear
							PSL.Output Msg & Format$(i / .lReferenceNum,"#%")
						End If
					Next i
				ElseIf UseRefTypeList(0).ByteOrder = 0 Then
					For i = 0 To .lReferenceNum - 1
						Temp = Replace(Replace(Replace(UseRefTypeList(0).Algorithm,"{strstartaddress}",CStr(RVA)), _
								"{refstartaddress}",CStr(.Reference(i).lAddress)),"{strtypelength}",CStr(.StrTypeLength))
						.Reference(i).sCode = ReverseHexCode(Hex$(Eval(Temp)),UseRefTypeList(0).ByteLength * 2)
						If ShowMsg > 0 Then
							SetTextBoxString ShowMsg,Msg & Format$(i / .lReferenceNum,"#%")
						ElseIf ShowMsg < 0 Then
							PSL.OutputWnd(0).Clear
							PSL.Output Msg & Format$(i / .lReferenceNum,"#%")
						End If
					Next i
				Else
					For i = 0 To .lReferenceNum - 1
						Temp = Replace(Replace(Replace(UseRefTypeList(0).Algorithm,"{strstartaddress}",CStr(RVA)), _
								"{refstartaddress}",CStr(.Reference(i).lAddress)),"{strtypelength}",CStr(.StrTypeLength))
						.Reference(i).sCode = ValToStr(Eval(Temp),-UseRefTypeList(0).ByteLength * 2,True)
						If ShowMsg > 0 Then
							SetTextBoxString ShowMsg,Msg & Format$(i / .lReferenceNum,"#%")
						ElseIf ShowMsg < 0 Then
							PSL.OutputWnd(0).Clear
							PSL.Output Msg & Format$(i / .lReferenceNum,"#%")
						End If
					Next i
				End If
				.GetRefState = 1
			End If
		Else
			GoTo ExitFunction
		End If
	Case Else
		'按原来翻译开始地址的引用代码获取新地址的引用代码列表
		If fType < 0 Then
			'If RefAdds <> "" Then Call getRefList(strData,ReSplit(RefAdds,RefJoinStr),TempList,True)
			If .lReferenceNum = 0 Then GoTo ExitFunction
			If InStr(File.Magic,"NotPE") = 0 Then
				VRK = Val("&H" & ReverseHexCode(.Reference(0).sCode,8)) + fType
				.Reference(0).sCode = ReverseHexCode(Hex$(.lStartAddress + VRK),8)
				'.Reference(0).sCode = Byte2Hex(Val2Bytes(.lStartAddress + VRK,4),0,3)
			Else
				Temp = Replace(Replace(UseRefTypeList(0).Algorithm,"{strstartaddress}",CStr(.lStartAddress)), _
						"{strtypelength}",CStr(.StrTypeLength))
				If UseRefTypeList(0).ByteOrder = 0 Then
					VRK = Val("&H" & ReverseHexCode(.Reference(0).sCode,UseRefTypeList(0).ByteLength * 2)) + fType
					.Reference(0).sCode = ReverseHexCode(Hex$(Eval(Temp) + VRK),UseRefTypeList(0).ByteLength * 2)
				Else
					VRK = Val("&H" & .Reference(0).sCode) + fType
					.Reference(0).sCode = ValToStr(Eval(Temp) + VRK,-UseRefTypeList(0).ByteLength * 2,True)
				End If
			End If
			For i = 0 To .lReferenceNum - 1
				.Reference(i).sCode = .Reference(0).sCode
			Next i
			.GetRefState = 1
			Exit Function
		End If
		If .inSectionID > File.MaxSecIndex - 1 Then GoTo ExitFunction
		'获取字串的虚拟地址
		If File.SecList(.inSectionID).SubSecs > 0 Then
			With File.SecList(.inSectionID).SubSecList(.inSubSecID)
				If strData.lStartAddress >= .lPointerToRawData And strData.lStartAddress < .lPointerToRawData + .lSizeOfRawData Then
					VRK = .lVirtualAddress - .lPointerToRawData + File.ImageBase
				Else
					GoTo ExitFunction
				End If
			End With
		Else
			With File.SecList(.inSectionID)
				If strData.lStartAddress >= .lPointerToRawData And strData.lStartAddress < .lPointerToRawData + .lSizeOfRawData Then
					VRK = .lVirtualAddress - .lPointerToRawData + File.ImageBase
				Else
					GoTo ExitFunction
				End If
			End With
		End If
		'获取引用地址及引用代码列表
		If fType = 0 Then
			'获取过引用的退出程序
			If .GetRefState > 0 Then Exit Function
			If SkipHeader(File,strData.lStartAddress,0,0) > -1 Then GoTo ExitFunction
			With File
				SkipVal = .SecList(.MinSecID).lPointerToRawData
				If RefAdds = "" Then
					If .DataDirs > 0 Then
						If .DataDirectory(2).lPointerToRawData > 0 Then
							If SkipSection(File,.DataDirectory(2).lPointerToRawData,0,0) > -1 Then
								RSize = .DataDirectory(2).lPointerToRawData - 1
							Else
								RSize = .SecList(.MaxSecID).lPointerToRawData + .SecList(.MaxSecID).lSizeOfRawData - 1
							End If
						Else
							RSize = .SecList(.MaxSecID).lPointerToRawData + .SecList(.MaxSecID).lSizeOfRawData - 1
						End If
					Else
						RSize = .SecList(.MaxSecID).lPointerToRawData + .SecList(.MaxSecID).lSizeOfRawData - 1
					End If
					RefAdds = ByteToString(GetBytes(FN,RSize - SkipVal + 1,SkipVal,Mode),CP_ISOLATIN1)
				End If
			End With
			.lReferenceNum = 0
			ReDim strData.Reference(0) 'As REFERENCE_PROPERTIE
			If InStr(File.Magic,"NotPE") = 0 Then
				.Reference(0).sCode = ReverseHexCode(Hex$(.lStartAddress + VRK),8)
				TempList = GetVAListRegExp(RefAdds,HexStr2RegExpPattern(.Reference(0).sCode,1),SkipVal)
			Else
				Temp = Replace(Replace(UseRefTypeList(0).Algorithm,"{strstartaddress}",CStr(.lStartAddress)), _
						"{strtypelength}",CStr(.StrTypeLength))
				If UseRefTypeList(0).ByteOrder = 0 Then
					.Reference(0).sCode = ReverseHexCode(Hex$(Eval(Temp)),UseRefTypeList(0).ByteLength * 2)
				Else
					.Reference(0).sCode = ValToStr(Eval(Temp),-UseRefTypeList(0).ByteLength * 2,True)
				End If
				TempList = GetVAListRegExp(RefAdds,UseRefTypeList(0).PrefixByte & HexStr2RegExpPattern(.Reference(0).sCode,1),SkipVal)
			End If
			If CheckArray(TempList) = True Then
				.lReferenceNum = UBound(TempList) + 1
				ReDim Preserve strData.Reference(.lReferenceNum - 1) 'As REFERENCE_PROPERTIE
				m = 0: n = 0
				For i = 0 To .lReferenceNum - 1
					.Reference(i).lAddress = CLng(TempList(i)) + UseRefTypeList(0).PrefixLength
					.Reference(i).sCode = .Reference(0).sCode
					If .Reference(i).lAddress < n Or .Reference(i).lAddress > m Then
						k = SkipSection(File,.Reference(i).lAddress,n,m)
					End If
					.Reference(i).inSecID = k
					If ShowMsg > 0 Then
						SetTextBoxString ShowMsg,Msg & Format$(i / .lReferenceNum,"#%")
					ElseIf ShowMsg < 0 Then
						PSL.OutputWnd(0).Clear
						PSL.Output Msg & Format$(i / .lReferenceNum,"#%")
					End If
				Next i
				If TagType > 1 Then Call GetCustomStrTypeRegExp(FN,strData,TypeList,Mode,-1)
			End If
			.GetRefState = 1
		ElseIf RefAdds <> "" Or (.lReferenceNum > 0 And fType < 2) Then
			If RefAdds <> "" Then Call GetRefList(strData,ReSplit(RefAdds,RefJoinStr),TempList,True)
			If .lReferenceNum > 0 Then
				If InStr(File.Magic,"NotPE") = 0 Then
					.Reference(0).sCode = ReverseHexCode(Hex$(.lStartAddress + VRK),8)
					'.Reference(0).sCode = Byte2Hex(Val2Bytes(.lStartAddress + VRK,4),0,3)
				Else
					Temp = Replace(Replace(UseRefTypeList(0).Algorithm,"{strstartaddress}",CStr(.lStartAddress)), _
							"{strtypelength}",CStr(.StrTypeLength))
					If UseRefTypeList(0).ByteOrder = 0 Then
						.Reference(0).sCode = ReverseHexCode(Hex$(Eval(Temp)),UseRefTypeList(0).ByteLength * 2)
					Else
						.Reference(0).sCode = ValToStr(Eval(Temp),-UseRefTypeList(0).ByteLength * 2,True)
					End If
				End If
				For i = 0 To .lReferenceNum - 1
					.Reference(i).sCode = .Reference(0).sCode
					If ShowMsg > 0 Then
						SetTextBoxString ShowMsg,Msg & Format$(i / .lReferenceNum,"#%")
					ElseIf ShowMsg < 0 Then
						PSL.OutputWnd(0).Clear
						PSL.Output Msg & Format$(i / .lReferenceNum,"#%")
					End If
				Next i
				.GetRefState = 1
			End If
		Else
			GoTo ExitFunction
		End If
	End Select
	GetVARefList = .lReferenceNum
	End With
	If ShowMsg > 0 Then
		SetTextBoxString ShowMsg,Msg & "100%"
	ElseIf ShowMsg < 0 Then
		PSL.OutputWnd(0).Clear
		PSL.Output Msg & "100%"
	End If
	Exit Function
	'退出函数
	ExitFunction:
	ReDim strData.Reference(0) 'As REFERENCE_PROPERTIE
	strData.lReferenceNum = 0
	strData.GetRefState = 0
	If ShowMsg > 0 Then
		SetTextBoxString ShowMsg,Msg & "100%"
	ElseIf ShowMsg < 0 Then
		PSL.OutputWnd(0).Clear
		PSL.Output Msg & "100%"
	End If
End Function


'批量查找引用代码和引用列表
'fType = 0 查找来源的引用列表和引用代码
'fType = 1 查找翻译的引用列表和引用代码，如果 RefAdds 为空，则按照原来引用地址计算引用代码
'fType = 2 查找翻译的引用列表和引用代码，如果 RefAdds 为空，则初始化，清空引用列表
'fType = 3 查找来源和翻译的引用列表和引用代码，如果 RefAdds 为空，则初始化翻译引用列表
'fType = 4 查找来源的引用列表和引用代码，但不获取跟随引用地址的自定义字串类型，并初始化翻译的引用列表和引用代码
'fType > 4 初始化，清空翻译引用列表和引用代码
'虚拟地址(VA) = StartPos + ImageBase + VRK
Private Function GetVARefListBatch(File As FILE_PROPERTIE,FN As Variant,DataList() As STRING_PROPERTIE,TypeList() As STRING_TYPE,IDList() As Long, _
	RefAddList() As String,ByVal fType As Long,ByVal Mode As Long,Optional ByVal ShowMsg As Long,Optional ByVal Stopable As Boolean) As Long
	Dim i As Long,j As Long,k As Long,m As Long,n As Long
	Dim RVA As Long,VRK As Long,MaxPos As Long,RSize As Long,SkipVal As Long
	Dim Max As Long,MinVal As Long,MaxVal As Long
	Dim Msg As PROGRESS_MSG,TempList() As String,Stemp As Boolean,Temp As String
	ReDim DataListBak(0) As STRING_PROPERTIE
	DataListBak = DataList
	On Error GoTo ExitFunction
	If File.Magic = "" Then GoTo ExitFunction
	If fType > 4 Then GoTo ExitFunction
	Stemp = CheckArrEmpty(IDList)
	If Stemp = True Then Max = UBound(IDList) Else Max = UBound(DataListBak)
	If ShowMsg > 0 Then
		Msg.Massage = GetTextBoxString(ShowMsg) & " "
	ElseIf ShowMsg < 0 Then
		ReDim TempList(PSL.OutputWnd(0).LineCount - 1) As String
		For i = 1 To PSL.OutputWnd(0).LineCount
			TempList(i - 1) = PSL.OutputWnd(0).Text(i)
		Next i
		Msg.Massage = StrListJoin(TempList,vbCrLf) & " "
	End If
	'查找来源的引用列表和引用代码
	If fType = 0 Or fType > 2 Then
		With File
			If InStr(.Magic,"32") Then
				MinVal = .SecList(.MinSecID).lPointerToRawData
				If .DataDirs > 0 Then
					If .DataDirectory(2).lPointerToRawData > 0 Then
						If SkipSection(File,.DataDirectory(2).lPointerToRawData,0,0) > -1 Then
							RSize = .DataDirectory(2).lPointerToRawData - 1
						Else
							RSize = .SecList(.MaxSecID).lPointerToRawData + .SecList(.MaxSecID).lSizeOfRawData - 1
						End If
					Else
						RSize = .SecList(.MaxSecID).lPointerToRawData + .SecList(.MaxSecID).lSizeOfRawData - 1
					End If
				Else
					RSize = .SecList(.MaxSecID).lPointerToRawData + .SecList(.MaxSecID).lSizeOfRawData - 1
				End If
				Temp = ByteToString(GetBytes(FN,RSize - MinVal + 1,MinVal,Mode),CP_ISOLATIN1)
			End If
		End With
		If Max < 5 Then
			Msg.Total = IIf(fType > 2,Max * 2,Max) + 1
			For i = 0 To Max
				j = IIf(Stemp = True,IDList(i),i)
				With DataListBak(j)
					'过滤已获取过引用的字串
					If .Source.GetRefState = 0 Then
						If .Moveable = 2 Then
							If GetNETVARefList(File,FN,.Source,.Source.StrTypeLength,Temp,0,Mode,0) > 0 Then
								GetVARefListBatch = GetVARefListBatch + 1
							End If
						ElseIf .Moveable > 0 Then
							.Source.lReferenceNum = 0
							.Source.GetRefState = 1
							ReDim DataListBak(j).Source.Reference(0) 'As REFERENCE_PROPERTIE
						ElseIf GetVARefList(File,FN,.Source,TypeList,IIf(fType = 4,0,.TagType),.Moveable,Temp,0,Mode,0) > 0 Then
							GetVARefListBatch = GetVARefListBatch + 1
						Else
							.Source.lReferenceNum = 0
							.Source.GetRefState = 1
							ReDim DataListBak(j).Source.Reference(0) 'As REFERENCE_PROPERTIE
						End If
					End If
				End With
				If ShowMsg > 0 Then
					SetTextBoxString ShowMsg,Msg.Massage & Format$(i / Msg.Total,"#%")
				ElseIf ShowMsg < 0 Then
					PSL.OutputWnd(0).Clear
					PSL.Output Msg.Massage & Format$(i / Msg.Total,"#%")
				End If
			Next i
			Msg.Passed = i
		Else
			If Stopable = True Then
				'显示主窗口的取消操作按钮和禁止主窗口的 Esc 键响应退出主窗口
				Call ShowButton(StopHwnd,VK_ESCAPE,True)
			End If
			Select Case File.Magic
			Case "PE64","NET64","MAC64"
				'初始化字串的虚拟地址
				Dim Dic As Object,pDic As Object,aDic As Object
				ReDim RefMaxList(Max) As Long,intList(Max) As Long
				ReDim MinList(File.MaxSecIndex) As Long,MaxList(File.MaxSecIndex) As Long
				ReDim aDicList(File.MaxSecIndex) As Object
				Set Dic = CreateObject("Scripting.Dictionary")
				Set pDic = CreateObject("Scripting.Dictionary")
				Set aDic = CreateObject("Scripting.Dictionary")
				m = -1
				For i = 0 To Max
					j = IIf(Stemp = True,IDList(i),i)
					With DataListBak(j)
						'过滤已获取过引用的字串
						If .Source.GetRefState = 0 Then
							If .Moveable = 2 Then
								If GetNETVARefList(File,FN,.Source,.Source.StrTypeLength,Temp,0,Mode,0) > 0 Then
									GetVARefListBatch = GetVARefListBatch + 1
								End If
							ElseIf .Moveable > 0 Then
								.Source.lReferenceNum = 0
								.Source.GetRefState = 1
								ReDim DataListBak(j).Source.Reference(0) 'As REFERENCE_PROPERTIE
							Else
								.Source.lReferenceNum = 0
								.Source.GetRefState = 1
								ReDim DataListBak(j).Source.Reference(0) 'As REFERENCE_PROPERTIE
								If Not Dic.Exists(.Source.inSectionID) Then
									Dic.Add(.Source.inSectionID,"")
									m = m + 1
									MinList(m) = .Source.lStartAddress
									MaxList(m) = .Source.lStartAddress
								Else
									If .Source.lStartAddress < MinList(m) Then MinList(m) = .Source.lStartAddress
									If .Source.lStartAddress > MaxList(m) Then MaxList(m) = .Source.lStartAddress
								End If
								If Not aDic.Exists(.Source.lStartAddress) Then
									aDic.Add(.Source.lStartAddress,CStr$(k))
								Else
									aDic.Item(.Source.lStartAddress) = aDic.Item(.Source.lStartAddress) & JoinStr & CStr$(k)
								End If
								intList(k) = j
								k = k + 1
								If .Source.lStartAddress > MaxPos Then MaxPos = .Source.lStartAddress
							End If
						End If
					End With
					'DoEvents '转让控制权，允许操作系统处理其他事件
					If Stopable = True Then
						If StopProcess(StopHwnd,VK_ESCAPE) = True Then
							GetVARefListBatch = -2
							GoTo ExitFunction
						End If
					End If
				Next i
				Msg.Total = IIf(fType > 2,MaxPos + Max,MaxPos) + 1
				n = 0
				If k > 0 Then
					ReDim Preserve MinList(m) As Long,MaxList(m) As Long,intList(k - 1) As Long,aDicList(m) As Object
					For k = 0 To Dic.Count - 1
						With File.SecList(Dic.Keys(k))
							RSize = .lPointerToRawData + .lSizeOfRawData - 1
							RVA = .lVirtualAddress - .lPointerToRawData
						End With
						If RSize > MaxList(k) Then RSize = MaxList(k) + 1
						For j = 0 To IIf(Dic.Keys(k) = 0,0,Dic.Keys(k) - 1)
							With File.SecList(j)
								MinVal = .lPointerToRawData
								MaxVal = MinVal + .lSizeOfRawData - 1
								VRK = RVA - (.lVirtualAddress - .lPointerToRawData) - 4
							End With
							If MaxVal > RSize - 4 Then MaxVal = RSize - 4
							SkipVal = MinVal - 1
							'排除各种文件头数据区段
							Do While MinVal < MaxVal
								If MinVal > SkipVal Then
									i = MinVal: m = SkipHeader(File,i,SkipVal,1)
									If m = 2 Or m = 4 Or m = 5 Or m > 15 Then MinVal = i
									If MinVal > SkipVal Or SkipVal > MaxVal Then SkipVal = MaxVal + 1
									If MinVal > MaxVal Then Exit Do
								End If
								Temp = ByteToString(GetBytes(FN,SkipVal - MinVal,MinVal,Mode),CP_ISOLATIN1)
								i = IIf(j < Dic.Keys(k),MinList(k) - SkipVal,0) + 4
								pDic.RemoveAll
								Do While i < RSize - MinVal + 1
									m = GetVAListPE64Batch(FN,DataListBak,intList,RefMaxList,pDic,aDic, _
										i,Temp,VRK,j,MinList(k),RSize,MinVal,Mode,Stopable)
									If m < -1 Then
										GetVARefListBatch = -2
										Exit Function
									End If
									i = i + m + 1
									If MinVal + i > n Then
										n = MinVal + i
										If ShowMsg > 0 Then
											SetTextBoxString ShowMsg,Msg.Massage & Format$(n / Msg.Total,"#%")
										ElseIf ShowMsg < 0 Then
											PSL.OutputWnd(0).Clear
											PSL.Output Msg.Massage & Format$(n / Msg.Total,"#%")
										End If
									End If
									'DoEvents '转让控制权，允许操作系统处理其他事件
									If Stopable = True Then
										If StopProcess(StopHwnd,VK_ESCAPE) = True Then
											GetVARefListBatch = -2
											GoTo ExitFunction
										End If
									End If
								Loop
								MinVal = SkipVal + 1
							Loop
						Next j
					Next k
					Erase RefMaxList,MinList,MaxList,aDicList
					Set Dic = Nothing: Set pDic = Nothing: Set aDic = Nothing
					For i = 0 To UBound(intList)
						j = intList(i)
						With DataListBak(j).Source
							If .lReferenceNum > 0 Then
								ReDim Preserve DataListBak(j).Source.Reference(.lReferenceNum - 1) 'As REFERENCE_PROPERTIE
								If .lReferenceNum > 1 Then
										'清除引用地址重复的引用
									.lReferenceNum = ClearRefArray(.Reference) + 1
									'按引用地址从小到大排序
									Call SortRefArrayByAddress(.Reference,0,.lReferenceNum - 1,False)
								End If
								GetVARefListBatch = GetVARefListBatch + 1
								If fType <> 4 Then
									If DataListBak(j).TagType > 1 Then
										Call GetCustomStrTypeRegExp(FN,DataListBak(j).Source,TypeList,Mode,-1)
									End If
								End If
							End If
						End With
						'DoEvents '转让控制权，允许操作系统处理其他事件
						If Stopable = True Then
							If StopProcess(StopHwnd,VK_ESCAPE) = True Then
								GetVARefListBatch = -2
								GoTo ExitFunction
							End If
						End If
					Next i
				End If
				Msg.Passed = MaxPos
			Case Else
				Msg.Total = IIf(fType > 2,Max * 2,Max) + 1
				For i = 0 To Max
					j = IIf(Stemp = True,IDList(i),i)
					With DataListBak(j)
						'过滤已获取过引用的字串
						If .Source.GetRefState = 0 Then
							If .Moveable = 2 Then
								If GetNETVARefList(File,FN,.Source,.Source.StrTypeLength,Temp,0,Mode,0) > 0 Then
									GetVARefListBatch = GetVARefListBatch + 1
								End If
							ElseIf .Moveable > 0 Then
								.Source.lReferenceNum = 0
								.Source.GetRefState = 1
								ReDim DataListBak(j).Source.Reference(0) 'As REFERENCE_PROPERTIE
							ElseIf GetVARefList(File,FN,.Source,TypeList,IIf(fType = 4,0,.TagType),.Moveable,Temp,0,Mode,0) > 0 Then
								GetVARefListBatch = GetVARefListBatch + 1
							Else
								.Source.lReferenceNum = 0
								.Source.GetRefState = 1
								ReDim DataListBak(j).Source.Reference(0) 'As REFERENCE_PROPERTIE
							End If
						End If
					End With
					If ShowMsg > 0 Then
						SetTextBoxString ShowMsg,Msg.Massage & Format$(i / Msg.Total,"#%")
					ElseIf ShowMsg < 0 Then
						PSL.OutputWnd(0).Clear
						PSL.Output Msg.Massage & Format$(i / Msg.Total,"#%")
					End If
					'DoEvents '转让控制权，允许操作系统处理其他事件
					If Stopable = True Then
						If StopProcess(StopHwnd,VK_ESCAPE) = True Then
							GetVARefListBatch = -2
							GoTo ExitFunction
						End If
					End If
				Next i
				Msg.Passed = i
			End Select
			If Stopable = True Then
				'隐藏主窗口中的取消操作按钮，启用 Esc 键的退出响应
				Call ShowButton(StopHwnd,VK_ESCAPE,False)
			End If
		End If
	End If
	'查找翻译的引用列表和引用代码
	If fType > 0 Then
		Msg.Total = IIf(fType > 2,Msg.Total,Max + 1)
		If fType = 3 Then fType = 2
		For i = 0 To Max
			j = IIf(Stemp = True,IDList(i),i)
			With DataListBak(j)
				If .Moveable > 0 And .Moveable <> 2 Then
					If .Trans.GetRefState = 0 Then
						ReDim DataListBak(j).Trans.Reference(0) 'As REFERENCE_PROPERTIE
						.Trans.lReferenceNum = 0
						.Trans.GetRefState = 1
					End If
				ElseIf fType = 1 Then
					j = IIf(.MoveType < 4,fType,-(.Trans.lStartAddress - .Trans.MoveLength))
					GetVARefList(File,"",.Trans,TypeList,.TagType,.Moveable,RefAddList(i),j,Mode,0)
					'批量提取时，翻译地址已被还原为完整写入时的地址，故置零
					.Trans.MoveLength = 0
				ElseIf RefAddList(i) = "" Then
					GetVARefList(File,"",.Trans,TypeList,.TagType,.Moveable,"",fType,Mode,0)
				Else
					.Trans.Reference = .Source.Reference
					.Trans.lReferenceNum = .Source.lReferenceNum
					'获取翻译的引用代码列表(获取类型必须为 2)
					GetVARefList(File,"",.Trans,TypeList,.TagType,.Moveable,RefAddList(i),fType,Mode,0)
					'获取子字串的来源引用列表
					If .SplitState < 0 Then
						Call GetRefList(.Source,ReSplit(RefAddList(i),RefJoinStr),RefAddList,True)
					End If
				End If
			End With
			If ShowMsg > 0 Then
				SetTextBoxString ShowMsg,Msg.Massage & Format$((i + Msg.Passed) / Msg.Total,"#%")
			ElseIf ShowMsg < 0 Then
				PSL.OutputWnd(0).Clear
				PSL.Output Msg.Massage & Format$((i + Msg.Passed) / Msg.Total,"#%")
			End If
		Next i
	End If
	If ShowMsg > 0 Then
		SetTextBoxString ShowMsg,Msg.Massage & "100%"
	ElseIf ShowMsg < 0 Then
		PSL.OutputWnd(0).Clear
		PSL.Output Msg.Massage & "100%"
	End If
	DataList = DataListBak
	Exit Function
	ExitFunction:
	Erase aDicList
	Set Dic = Nothing: Set pDic = Nothing: Set aDic = Nothing
	If Stopable = True Then
		'隐藏主窗口中的取消操作按钮，启用 Esc 键的退出响应
		Call ShowButton(StopHwnd,VK_ESCAPE,False)
	End If
End Function


'获取 NotPE64 原始字串的引用地址和代码
'返回 GetVAListNotPE64 = 步进长度
Private Function GetVAListNotPE64(FN As Variant,strData As STRING_SUB_PROPERTIE,RefMaxNum As Long,ByVal SecID As Long, _
				ByVal VRK As Long,ByVal StartPos As Long,ByVal RSize As Long,ByVal Mode As Long) As Long
	Dim i As Long,Temp As String,Bytes() As Byte
	With strData
		'i = (VRK - StartPos) And &HFF	'后3个字节查找，速度较慢
		'i = Val("&H" & Right$("0000" & Hex$(VRK - StartPos),4))	'后2个字节查找，速度较快
		i = (VRK - StartPos) And 65535	'后2个字节查找，速度较快，这里的 65535 不能替换成 &HFFFF，因为 &HFFFF 返回为 -1
		If i > RSize - StartPos Then i = RSize - StartPos
		If i > .lStartAddress - StartPos Then i = .lStartAddress - StartPos
		RSize = UseRefTypeList(0).PrefixLength
		If i > 0 Then
			GetVAListNotPE64 = i
			'正则表达式查找，速度较快，后3个字节查找时，开始地址为 StartPos + 1，否则为 StartPos + 2
			ReDim TempList(0) As String
			If UseRefTypeList(0).ByteOrder = 0 Then
				Temp = HexStr2RegExpPattern(Right$(ReverseHexCode(Hex$(VRK - StartPos),UseRefTypeList(0).ByteLength * 2),UseRefTypeList(0).ByteLength),1)
				Temp = UseRefTypeList(0).PrefixByte & "[\x00-\xFF]{" & UseRefTypeList(0).ByteLength \ 2 & "}" & Temp
			Else
				Temp = HexStr2RegExpPattern(Left$(ValToStr(VRK - StartPos,-UseRefTypeList(0).ByteLength * 2,True),UseRefTypeList(0).ByteLength),1)
				Temp = UseRefTypeList(0).PrefixByte & Temp
			End If
			TempList = GetVAListRegExp(ByteToString(GetBytes(FN,i + 4,StartPos - RSize,Mode),CP_ISOLATIN1),Temp,StartPos - RSize)
			'字节数组查找，速度较慢，后3个字节查找时，开始地址为 StartPos + 1，否则为 StartPos + 2
			'TempList = GetVAList(FN.ImageByte,Val2BytesRev(VRK - StartPos,4,2),StartPos + 2,StartPos + 2 + GetVAListPE64)
			If CheckArray(TempList) = False Then Exit Function
			For i = 0 To UBound(TempList)
				StartPos = CLng(TempList(i)) + RSize
				If VRK > StartPos Then
					'获取虚拟地址(即引用代码值)，并判断其是否正确
					Temp = Replace(Replace(Replace(UseRefTypeList(0).Algorithm,"{strstartaddress}",CStr(VRK)), _
							"{refstartaddress}",CStr(StartPos)),"{strtypelength}",CStr(.StrTypeLength))
					Bytes = Val2Bytes(Eval(Temp),UseRefTypeList(0).ByteLength,-UseRefTypeList(0).ByteOrder)
					If Bytes = GetBytes(FN,UseRefTypeList(0).ByteLength,StartPos,Mode) Then
						If .lReferenceNum > RefMaxNum Then
							RefMaxNum = .lReferenceNum + 20
							ReDim Preserve strData.Reference(RefMaxNum) 'As REFERENCE_PROPERTIE
						End If
						'保存找到的引用地址及引用代码
						.Reference(.lReferenceNum).lAddress = StartPos
						.Reference(.lReferenceNum).sCode = Byte2Hex(GetBytes(FN,UseRefTypeList(0).ByteLength,StartPos,Mode),0,UseRefTypeList(0).ByteLength - 1)
						.Reference(.lReferenceNum).inSecID = SecID
						.lReferenceNum = .lReferenceNum + 1
					End If
				End If
			Next i
		ElseIf VRK > StartPos Then
			'获取虚拟地址(即引用代码值)，并判断其是否正确
			If UseRefTypeList(0).PrefixByte <> "" Then
				TempList = GetVAListRegExp(ByteToString(GetBytes(FN,5,StartPos - RSize,Mode),CP_ISOLATIN1),UseRefTypeList(0).PrefixByte,StartPos - RSize)
				If CheckArray(TempList) = False Then Exit Function
			End If
			Temp = Replace(Replace(Replace(UseRefTypeList(0).Algorithm,"{strstartaddress}",CStr(VRK)), _
					"{refstartaddress}",CStr(StartPos)),"{strtypelength}",CStr(.StrTypeLength))
			Bytes = Val2Bytes(Eval(Temp),UseRefTypeList(0).ByteLength,-UseRefTypeList(0).ByteOrder)
			If Bytes = GetBytes(FN,UseRefTypeList(0).ByteLength,StartPos,Mode) Then
				GetVAListNotPE64 = 3
				If .lReferenceNum > RefMaxNum Then
					RefMaxNum = .lReferenceNum + 20
					ReDim Preserve strData.Reference(RefMaxNum) 'As REFERENCE_PROPERTIE
				End If
				'保存找到的引用地址及引用代码
				.Reference(.lReferenceNum).lAddress = StartPos
				.Reference(.lReferenceNum).sCode = Byte2Hex(GetBytes(FN,UseRefTypeList(0).ByteLength,StartPos,Mode),0,UseRefTypeList(0).ByteLength - 1)
				.Reference(.lReferenceNum).inSecID = SecID
				.lReferenceNum = .lReferenceNum + 1
			End If
		End If
	End With
End Function


'获取 PE64 原始字串的引用地址和代码
'返回 GetVAListPE64 = 步进长度
Private Function GetVAListPE64(FN As Variant,strData As STRING_SUB_PROPERTIE,RefMaxNum As Long,ByVal SecID As Long, _
				ByVal VRK As Long,ByVal StartPos As Long,ByVal RSize As Long,ByVal Mode As Long) As Long
	Dim i As Long,Temp As String
	With strData
		'i = (VRK - StartPos) And &HFF	'后3个字节查找，速度较慢
		'i = Val("&H" & Right$("0000" & Hex$(VRK - StartPos),4))	'后2个字节查找，速度较快
		i = (VRK - StartPos) And 65535	'后2个字节查找，速度较快，这里的 65535 不能替换成 &HFFFF，因为 &HFFFF 返回为 -1
		If i > RSize - StartPos Then i = RSize - StartPos
		If i > .lStartAddress - StartPos - 4 Then i = .lStartAddress - StartPos - 4
		If i > 0 Then
			GetVAListPE64 = i
			'正则表达式查找，速度较快，后3个字节查找时，开始地址为 StartPos + 1，否则为 StartPos + 2
			ReDim TempList(0) As String
			Temp = RefFrontChar & HexStr2RegExpPattern(Right$(ReverseHexCode(Hex$(VRK - StartPos),8),4),1)
			TempList = GetVAListRegExp(ByteToString(GetBytes(FN,i + 4,StartPos - 3,Mode),CP_ISOLATIN1),Temp,StartPos - 3)
			'字节数组查找，速度较慢，后3个字节查找时，开始地址为 StartPos + 1，否则为 StartPos + 2
			'TempList = GetVAList(FN.ImageByte,Val2BytesRev(VRK - StartPos,4,2),StartPos + 2,StartPos + 2 + GetVAListPE64)
			If CheckArray(TempList) = False Then Exit Function
			For i = 0 To UBound(TempList)
				StartPos = CLng(TempList(i)) + 3	'前3个为引用的特征码，所以往后3个字节
				If VRK > StartPos Then
					'获取虚拟地址(即引用代码值)，并判断其是否正确
					RSize = GetLong(FN,StartPos,Mode)
					If RSize > 0 And RSize = VRK - StartPos Then
						If .lReferenceNum > RefMaxNum Then
							RefMaxNum = .lReferenceNum + 20
							ReDim Preserve strData.Reference(RefMaxNum) 'As REFERENCE_PROPERTIE
						End If
						'保存找到的引用地址及引用代码
						.Reference(.lReferenceNum).lAddress = StartPos
						.Reference(.lReferenceNum).sCode = Byte2Hex(GetBytes(FN,4,StartPos,Mode),0,3)
						.Reference(.lReferenceNum).inSecID = SecID
						.lReferenceNum = .lReferenceNum + 1
					End If
				End If
			Next i
		ElseIf VRK > StartPos Then
			'获取虚拟地址(即引用代码值)，并判断其是否正确
			TempList = GetVAListRegExp(ByteToString(GetBytes(FN,5,StartPos - 3,Mode),CP_ISOLATIN1),RefFrontChar,StartPos - 3)
			If CheckArray(TempList) = False Then Exit Function
			RSize = GetLong(FN,StartPos,Mode)
			If RSize > 0 And RSize = VRK - StartPos Then
				GetVAListPE64 = 3
				If .lReferenceNum > RefMaxNum Then
					RefMaxNum = .lReferenceNum + 20
					ReDim Preserve strData.Reference(RefMaxNum) 'As REFERENCE_PROPERTIE
				End If
				'保存找到的引用地址及引用代码
				.Reference(.lReferenceNum).lAddress = StartPos
				.Reference(.lReferenceNum).sCode = Byte2Hex(GetBytes(FN,4,StartPos,Mode),0,3)
				.Reference(.lReferenceNum).inSecID = SecID
				.lReferenceNum = .lReferenceNum + 1
			End If
		End If
	End With
End Function


'批量获取 PE64 原始字串的引用地址和代码
'返回 GetVAListPE64Batch = 步进长度
Private Function GetVAListPE64Batch(FN As Variant,DataList() As STRING_PROPERTIE,IDList() As Long,RefMaxList() As Long, _
		pDic As Object,ByVal AddDic As Object,ByVal Index As Long,ByVal StrText As String,ByVal VRK As Long, _
		ByVal SecID As Long,ByVal ROffset As Long,ByVal RSize As Long,ByVal StartPos As Long,ByVal Mode As Long,ByVal StopAble As Boolean) As Long
	Dim i As Long,j As Long,k As Long,Temp As String
	'i = &HFF - ((Index + VRK) And &HFF)		'后3个字节查找，速度较慢
	'i = 65535 - Val("&H" & Right$("0000" & Hex$(Index + VRK),4))	'后2个字节查找，速度较快
	i = 65535 - ((Index + VRK) And 65535)	'后2个字节查找，速度较快，这里的 65535 不能替换成 &HFFFF，因为 &HFFFF 返回为 -1
	If i > RSize - StartPos + 1 - Index Then i = RSize - StartPos + 1 - Index
	If i <= 0 Then Exit Function
	GetVAListPE64Batch = i
	Temp = Right$(ReverseHexCode(Hex$(Index + VRK),8),4)
	If pDic.Exists(Temp) Then Exit Function
	pDic.Add(Temp,"")
	ReDim TempList(0) As String,TempArray(0) As String
	TempList = GetVAListRegExp(StrText,RefFrontChar & HexStr2RegExpPattern(Temp,1),StartPos)
	If CheckArray(TempList) = False Then Exit Function
	For i = 0 To UBound(TempList)
		StartPos = CLng(TempList(i)) + 3
		'获取可能的虚拟地址(即引用代码)
		j = GetLong(FN,StartPos,Mode)
		If j > 0 And j > VRK Then
			'获取虚拟地址对应的可能的字串地址
			j = CheckLongPlus(j,StartPos - VRK)
			If j > StartPos Then
				'判断可能的字串地址是否符合范围
				If j >= ROffset And j <= RSize Then
					'判断地址是否和某个字串的地址相同
					If AddDic.Exists(j) Then
						TempArray = ReSplit(AddDic.Item(j),JoinStr)
						For k = 0 To UBound(TempArray)
							j = CLng(TempArray(k))
							Index = IDList(j)
							With DataList(Index).Source
								If .lReferenceNum > RefMaxList(j) Then
									RefMaxList(j) = .lReferenceNum + 20
									ReDim Preserve DataList(Index).Source.Reference(RefMaxList(j)) 'As REFERENCE_PROPERTIE
								End If
								.Reference(.lReferenceNum).lAddress = StartPos
								.Reference(.lReferenceNum).sCode = Byte2Hex(GetBytes(FN,4,StartPos,Mode),0,3)
								.Reference(.lReferenceNum).inSecID = SecID
								.lReferenceNum = .lReferenceNum + 1
							End With
						Next k
					End If
				End If
			End If
		End If
		'DoEvents '转让控制权，允许操作系统处理其他事件
		If StopAble = True Then
			If StopProcess(StopHwnd,VK_ESCAPE) = True Then
				GetVAListPE64Batch = -2
				Exit Function
			End If
		End If
	Next i
End Function


'获取在字节数组中找到的匹配数组的列表(VB方式)
'注意：StartPos、EndPos 均为以 0 开始的地址
Private Function GetVAList(Bytes() As Byte,Find() As Byte,Optional ByVal StartPos As Long,Optional ByVal EndPos As Long) As String()
	Dim i As Long,j As Long,k As Long,m As Long,n As Long,Length As Long,TempByte() As Byte
	Length = UBound(Find) + 1
	TempByte = Find
	k = -1
	For i = 0 To Length - 1
		If Find(i) <> 0 Then
			If i <> 0 Then
				ReDim TempByte(Length - i - 1) As Byte
				CopyMemory TempByte(0), Find(i), Length - i
			End If
			k = i
			Exit For
		End If
	Next i
	If k = -1 Then
		If EndPos <= StartPos Then Exit Function
		ReDim TempByte(EndPos - StartPos) As Byte
		CopyMemory TempByte(0), Bytes(StartPos), EndPos - StartPos + 1
		GetVAList = GetVAListRegExp(ByteToString(TempByte,CP_ISOLATIN1),"\x00{" & CStr$(Length) & ",}",StartPos)
		Exit Function
	End If
	m = 50
	ReDim TempList(m) As String
	i = InStrB(StartPos + k + 1,Bytes,TempByte)
	Do While i > 0
		If k > 0 Then
			For j = i - k - 1 To i - 2
				If Bytes(j) <> 0 Then GoTo NextNum
			Next j
			i = i - k
		End If
		If EndPos > 0 Then
			If i + Length - 2 > EndPos Then Exit Do
		End If
		If n > m Then
			m = m * 2
			ReDim Preserve TempList(m) As String
		End If
		TempList(n) = CStr(i - 1)    '注意 InStrB 函数找到第一个数就返回"1"
		n = n + 1
		NextNum:
		i = InStrB(i + Length,Bytes,TempByte)
	Loop
	If n > 0 Then n = n - 1
	ReDim Preserve TempList(n) As String
	GetVAList = TempList
End Function


'比较二个 STRING_PROPERTIE 数组的部分是否相同，不相同返回 True
Private Function DataCompByID(Data As STRING_PROPERTIE,oArray() As STRING_PROPERTIE,Dic As Object,Optional ByVal Mode As Long) As Boolean
	Dim i As Long
	If Not Dic Is Nothing Then
		If Dic.Exists(Data.ID) Then
			i = Dic.Item(Data.ID)
			If DataComp(Data,oArray(i),Mode) = True Then DataCompByID = True
		End If
	Else
		For i = LBound(oArray) To UBound(oArray)
			If oArray(i).ID = Data.ID Then
				If DataComp(Data,oArray(i),Mode) = True Then
					DataCompByID = True
					Exit For
				End If
			End If
		Next i
	End If
End Function


'比较二个 STRING_PROPERTIE 数组是否相同，不相同返回 True
Private Function DataComps(uArray() As STRING_PROPERTIE,oArray() As STRING_PROPERTIE,Optional Dic As Object,Optional ByVal Mode As Long) As Boolean
	Dim i As Long
	If Mode < 8 Or Mode > 28 Then
		If UBound(uArray) <> UBound(oArray) Then
			DataComps = True
			Exit Function
		ElseIf CheckDataArray(uArray) = False And CheckDataArray(oArray) = False Then
			Exit Function
		End If
	End If
	If Not Dic Is Nothing Then
		For i = LBound(oArray) To UBound(oArray)
			If Dic.Exists(oArray(i).ID) Then
				If DataComp(uArray(Dic.Item(oArray(i).ID)),oArray(i),Mode) = True Then
					DataComps = True
					Exit For
				End If
			ElseIf Mode < 8 Or Mode > 28 Then
				If oArray(i).SplitState > -1 Then
					DataComps = True
					Exit For
				End If
			End If
		Next i
	Else
		Set Dic = CreateObject("Scripting.Dictionary")
		For i = LBound(uArray) To UBound(uArray)
			If Not Dic.Exists(uArray(i).ID) Then
				Dic.Add(uArray(i).ID,i)
			End If
		Next i
		For i = LBound(oArray) To UBound(oArray)
			If Dic.Exists(oArray(i).ID) Then
				If DataComp(uArray(Dic.Item(oArray(i).ID)),oArray(i),Mode) = True Then
					DataComps = True
					Exit For
				End If
			ElseIf Mode < 8 Or Mode > 28 Then
				If oArray(i).SplitState > -1 Then
					DataComps = True
					Exit For
				End If
			End If
		Next i
	End If
End Function


'比较 STRING_PROPERTIE 单项数组是否相同，不相同返回 True
'Mode = 0 所有数组项目
'Mode = 1 仅来源数组项目
'Mode = 2 仅翻译数组项目
'Mode = 3 仅需要保存为来源 HCS 文件的数组项目
'Mode = 4 仅需要保存为翻译 HCS 文件的数组项目
'Mode = 5,9 仅来源和翻译字符串
'Mode = 6 仅来源字符串
'Mode = 7 仅翻译字符串
'Mode = 8 仅父翻译字符串
'Mode = 10 仅来源字串和翻译字串代码页
'Mode = 11 仅来源字串和翻译字串地址
'Mode = 12 仅来源字串和翻译字串字节长度
'Mode = 13 仅来源字串和翻译字串字符长度
'Mode = 14 仅来源字串和翻译字串引用地址
'Mode = 15 仅来源字串和翻译字串引用代码
'Mode = 16 仅字串类型
'Mode = 17 仅来源字串和翻译字串类型长度
'Mode = 18 仅字串标识符类型
'Mode = 19 仅字串写入类型
'Mode = 20 仅字串写入状态
'Mode = 21 仅字串拆分状态
'Mode = 22 仅字串锁定状态
'Mode = 23 仅字串空格补齐状态
'Mode = 24 仅字串移位类型
'Mode = 25 仅字串移位模式
'Mode = 26 仅字串占用空间
'Mode = 27 仅字串被占用空间
'Mode = 28 仅是否允许超长写入
'Mode = 29 更新过程是否被删除(iError = 1)或忽略过(iError = 2)
'Mode = 30 仅来源字符串和更新过程是否被删除(iError = 1)或忽略过(iError = 2)
Private Function DataComp(uData As STRING_PROPERTIE,oData As STRING_PROPERTIE,Optional ByVal Mode As Long) As Boolean
	DataComp = True
	With oData
	Select Case Mode
	Case 0
		If .iError <> uData.iError Then Exit Function
		If .StrType <> uData.StrType Then Exit Function
		If .TagType <> uData.TagType Then Exit Function
		If .MoveType <> uData.MoveType Then Exit Function
		If .MoveMode <> uData.MoveMode Then Exit Function
		If .WriteType <> uData.WriteType Then Exit Function
		If .SplitState <> uData.SplitState Then Exit Function
		If .FillLength <> uData.FillLength Then Exit Function
		If .OverLengthWrite <> uData.OverLengthWrite Then Exit Function
		If .Source.CodePage <> uData.Source.CodePage Then Exit Function
		If .Source.lStartAddress <> uData.Source.lStartAddress Then Exit Function
		If .Source.lEndAddress <> uData.Source.lEndAddress Then Exit Function
		If .Source.lMaxAddress <> uData.Source.lMaxAddress Then Exit Function
		If .Source.lHexLength <> uData.Source.lHexLength Then Exit Function
		If .Source.lCharLength <> uData.Source.lCharLength Then Exit Function
		If .Source.lMaxHexLength <> uData.Source.lMaxHexLength Then Exit Function
		If .Source.inSectionID <> uData.Source.inSectionID Then Exit Function
		'If .Source.StrTypeLength <> uData.Source.StrTypeLength Then Exit Function
		If .Source.GetRefState <> uData.Source.GetRefState Then Exit Function
		If .Source.lReferenceNum <> uData.Source.lReferenceNum Then Exit Function
		If .Source.sString <> uData.Source.sString Then Exit Function
		If ArrayComp(RefList2StrList(.Source,0),RefList2StrList(uData.Source,0)) = True Then Exit Function
		If ArrayComp(RefList2StrList(.Source,1),RefList2StrList(uData.Source,1)) = True Then Exit Function
		If .Trans.CodePage <> uData.Trans.CodePage Then Exit Function
		If .Trans.lStartAddress <> uData.Trans.lStartAddress Then Exit Function
		If .Trans.lEndAddress <> uData.Trans.lEndAddress Then Exit Function
		If .Trans.lMaxAddress <> uData.Trans.lMaxAddress Then Exit Function
		If .Trans.lHexLength <> uData.Trans.lHexLength Then Exit Function
		If .Trans.lCharLength <> uData.Trans.lCharLength Then Exit Function
		If .Trans.lMaxHexLength <> uData.Trans.lMaxHexLength Then Exit Function
		If .Trans.inSectionID <> uData.Trans.inSectionID Then Exit Function
		'If .Trans.StrTypeLength <> uData.Trans.StrTypeLength Then Exit Function
		If .Trans.GetRefState <> uData.Trans.GetRefState Then Exit Function
		If .Trans.lReferenceNum <> uData.Trans.lReferenceNum Then Exit Function
		If .Trans.sString <> uData.Trans.sString Then Exit Function
		If ArrayComp(RefList2StrList(.Trans,0),RefList2StrList(uData.Trans,0)) = True Then Exit Function
		If ArrayComp(RefList2StrList(.Trans,1),RefList2StrList(uData.Trans,1)) = True Then Exit Function
	Case 1
		If .iError <> uData.iError Then Exit Function
		If .StrType <> uData.StrType Then Exit Function
		If .TagType <> uData.TagType Then Exit Function
		'If .WriteType <> uData.WriteType Then Exit Function
		If .Source.CodePage <> uData.Source.CodePage Then Exit Function
		If .Source.lStartAddress <> uData.Source.lStartAddress Then Exit Function
		If .Source.lEndAddress <> uData.Source.lEndAddress Then Exit Function
		If .Source.lMaxAddress <> uData.Source.lMaxAddress Then Exit Function
		If .Source.lHexLength <> uData.Source.lHexLength Then Exit Function
		If .Source.lCharLength <> uData.Source.lCharLength Then Exit Function
		If .Source.lMaxHexLength <> uData.Source.lMaxHexLength Then Exit Function
		If .Source.inSectionID <> uData.Source.inSectionID Then Exit Function
		'If .Source.StrTypeLength <> uData.Source.StrTypeLength Then Exit Function
		If .Source.GetRefState <> uData.Source.GetRefState Then Exit Function
		If .Source.iNullByteLength <> uData.Source.iNullByteLength Then Exit Function
		If .Source.lReferenceNum <> uData.Source.lReferenceNum Then Exit Function
		If .Source.sString <> uData.Source.sString Then Exit Function
		If ArrayComp(RefList2StrList(.Source,0),RefList2StrList(uData.Source,0)) = True Then Exit Function
		If ArrayComp(RefList2StrList(.Source,1),RefList2StrList(uData.Source,1)) = True Then Exit Function
	Case 2
		'If .StrType <> uData.StrType Then Exit Function
		If .MoveType <> uData.MoveType Then Exit Function
		If .MoveMode <> uData.MoveMode Then Exit Function
		If .WriteType <> uData.WriteType Then Exit Function
		If .SplitState <> uData.SplitState Then Exit Function
		If .FillLength <> uData.FillLength Then Exit Function
		If .OverLengthWrite <> uData.OverLengthWrite Then Exit Function
		If .Trans.CodePage <> uData.Trans.CodePage Then Exit Function
		If .Trans.lStartAddress <> uData.Trans.lStartAddress Then Exit Function
		If .Trans.lEndAddress <> uData.Trans.lEndAddress Then Exit Function
		If .Trans.lMaxAddress <> uData.Trans.lMaxAddress Then Exit Function
		If .Trans.lHexLength <> uData.Trans.lHexLength Then Exit Function
		If .Trans.lCharLength <> uData.Trans.lCharLength Then Exit Function
		If .Trans.lMaxHexLength <> uData.Trans.lMaxHexLength Then Exit Function
		If .Trans.inSectionID <> uData.Trans.inSectionID Then Exit Function
		'If .Trans.StrTypeLength <> uData.Trans.StrTypeLength Then Exit Function
		If .Trans.GetRefState <> uData.Trans.GetRefState Then Exit Function
		If .Trans.iNullByteLength <> uData.Trans.iNullByteLength Then Exit Function
		If .Trans.lReferenceNum <> uData.Trans.lReferenceNum Then Exit Function
		If .Trans.sString <> uData.Trans.sString Then Exit Function
		If ArrayComp(RefList2StrList(.Trans,0),RefList2StrList(uData.Trans,0)) = True Then Exit Function
		If ArrayComp(RefList2StrList(.Trans,1),RefList2StrList(uData.Trans,1)) = True Then Exit Function
	Case 3
		If .iError <> uData.iError Then Exit Function
		If .StrType <> uData.StrType Then Exit Function
		If .Source.CodePage <> uData.Source.CodePage Then Exit Function
		If .Source.lStartAddress <> uData.Source.lStartAddress Then Exit Function
		If .Source.sString <> uData.Source.sString Then Exit Function
	Case 4
		'If .StrType <> uData.StrType Then Exit Function
		If .MoveType <> uData.MoveType Then Exit Function
		If .MoveMode <> uData.MoveMode Then Exit Function
		If .WriteType <> uData.WriteType Then Exit Function
		If .SplitState <> uData.SplitState Then Exit Function
		'If .FillLength <> uData.FillLength Then Exit Function
		If .OverLengthWrite <> uData.OverLengthWrite Then Exit Function
		If .Trans.CodePage <> uData.Trans.CodePage Then Exit Function
		If .Trans.lStartAddress <> uData.Trans.lStartAddress Then Exit Function
		If .Trans.lMaxAddress <> uData.Trans.lMaxAddress Then Exit Function
		If .Trans.lReferenceNum <> uData.Trans.lReferenceNum Then Exit Function
		If .Trans.sString <> uData.Trans.sString Then Exit Function
		If ArrayComp(RefList2StrList(.Trans,0),RefList2StrList(uData.Trans,0)) = True Then Exit Function
	Case 5, 9
		If .Source.sString <> uData.Source.sString Then Exit Function
		If .Trans.sString <> uData.Trans.sString Then Exit Function
	Case 6
		If .Source.sString <> uData.Source.sString Then Exit Function
	Case 7
		If .Trans.sString <> uData.Trans.sString Then Exit Function
	Case 8
		If .SplitState > -1 And uData.SplitState > -1 Then
			If .Trans.sString <> uData.Trans.sString Then Exit Function
		End If
	Case 10
		If .Source.CodePage <> uData.Source.CodePage Then Exit Function
		If .Trans.CodePage <> uData.Trans.CodePage Then Exit Function
	Case 11
		If .Source.lStartAddress <> uData.Source.lStartAddress Then Exit Function
		If .Source.lEndAddress <> uData.Source.lEndAddress Then Exit Function
		If .Source.lMaxAddress <> uData.Source.lMaxAddress Then Exit Function
		If .Trans.lStartAddress <> uData.Trans.lStartAddress Then Exit Function
		If .Trans.lEndAddress <> uData.Trans.lEndAddress Then Exit Function
		If .Trans.lMaxAddress <> uData.Trans.lMaxAddress Then Exit Function
	Case 12
		If .Source.lHexLength <> uData.Source.lHexLength Then Exit Function
		If .Trans.lHexLength <> uData.Trans.lHexLength Then Exit Function
	Case 13
		If .Source.lCharLength <> uData.Source.lCharLength Then Exit Function
		If .Trans.lCharLength <> uData.Trans.lCharLength Then Exit Function
	Case 14
		If .Source.lReferenceNum <> uData.Source.lReferenceNum Then Exit Function
		If .Trans.lReferenceNum <> uData.Trans.lReferenceNum Then Exit Function
		If ArrayComp(RefList2StrList(.Source,0),RefList2StrList(uData.Source,0)) = True Then Exit Function
		If ArrayComp(RefList2StrList(.Trans,0),RefList2StrList(uData.Trans,0)) = True Then Exit Function
	Case 15
		If .Source.lReferenceNum <> uData.Source.lReferenceNum Then Exit Function
		If .Trans.lReferenceNum <> uData.Trans.lReferenceNum Then Exit Function
		If ArrayComp(RefList2StrList(.Source,1),RefList2StrList(uData.Source,1)) = True Then Exit Function
		If ArrayComp(RefList2StrList(.Trans,1),RefList2StrList(uData.Trans,1)) = True Then Exit Function
	Case 16
		If .StrType <> uData.StrType Then Exit Function
		If ArrayComp(RefList2StrList(.Source,2),RefList2StrList(uData.Source,2)) = True Then Exit Function
	Case 17
		If .Source.StrTypeLength <> uData.Source.StrTypeLength Then Exit Function
		If .Trans.StrTypeLength <> uData.Trans.StrTypeLength Then Exit Function
	Case 18
		If .TagType <> uData.TagType Then Exit Function
	Case 19
		If .WriteType <> uData.WriteType Then Exit Function
	Case 20
		If .WriteState <> uData.WriteState Then Exit Function
	Case 21
		If .SplitState <> uData.SplitState Then Exit Function
	Case 22
		If .LockState <> uData.LockState Then Exit Function
	Case 23
		If .FillLength <> uData.FillLength Then Exit Function
	Case 24
		If .MoveType <> uData.MoveType Then Exit Function
	Case 25
		If .MoveMode <> uData.MoveMode Then Exit Function
	Case 26
		If .ScapeIDForMove <> uData.ScapeIDForMove Then Exit Function
	Case 27
		If .ScapeIDBeMoved <> uData.ScapeIDBeMoved Then Exit Function
	Case 28
		If .OverLengthWrite <> uData.OverLengthWrite Then Exit Function
	Case 29
		If .iError <> uData.iError Then Exit Function
	Case 30
		If .iError <> uData.iError Then Exit Function
		If .Source.sString <> uData.Source.sString Then Exit Function
	End Select
	End With
	DataComp = False
End Function


'插入数据到数组，并修改字串编号
Private Sub InsertDataArray(Dic As Object,DataList() As STRING_PROPERTIE,Data As STRING_PROPERTIE,ByVal insPos As Long)
	Dim i As Long,j As Long
	i = LBound(DataList)
	j = UBound(DataList)
	If j = i And DataList(i).Trans.sString = "" Then
		DataList(i) = Data
		If Dic.Exists(Data.ID) Then
			Dic.Item(Data.ID) = i
		Else
			Dic.Add(Data.ID,i)
		End If
	Else
		ReDim Preserve DataList(j + 1) As STRING_PROPERTIE
		If insPos <= j Then
			For i = j + 1 To insPos + 1 Step -1
				DataList(i) = DataList(i - 1)
				Dic.Item(DataList(i).ID) = i
			Next i
		End If
		DataList(insPos) = Data
		If Dic.Exists(Data.ID) Then
			Dic.Item(Data.ID) = insPos
		Else
			Dic.Add(Data.ID,insPos)
		End If
	End If
End Sub


'插入数据到数组，并修改字串编号
Private Sub InsertDataArrays(Dic As Object,DataList() As STRING_PROPERTIE,Data() As STRING_PROPERTIE,ByVal insPos As Long)
	Dim i As Long,j As Long,k As Long
	k = LBound(DataList)
	j = UBound(DataList)
	If j = k And DataList(k).Trans.sString = "" Then
		DataList = Data
		For i = 0 To UBound(Data)
			If Dic.Exists(Data(i).ID) Then
				Dic.Item(Data(i).ID) = i
			Else
				Dic.Add(Data(i).ID,i)
			End If
		Next i
	Else
		k = UBound(Data) + 1
		ReDim Preserve DataList(j + k) As STRING_PROPERTIE
		If insPos <= j Then
			For i = j + k To insPos + k Step -1
				DataList(i) = DataList(i - k)
				Dic.Item(DataList(i).ID) = i
			Next i
		End If
		For i = 0 To k - 1
			DataList(insPos) = Data(i)
			If Dic.Exists(Data(i).ID) Then
				Dic.Item(Data(i).ID) = insPos
			Else
				Dic.Add(Data(i).ID,insPos)
			End If
			insPos = insPos + 1
		Next i
	End If
End Sub


'按 IntList 列表找出二个数据数组中的字串编号相同或不相同的索引列表
'Mode = False 获取二个数据数组中的字串编号相同的索引列表，二个索引列表没有对应关系
'Mode = True 获取二个数据数组中的字串编号不相同的索引列表，二个索引列表没有对应关系
Private Function GetIndexList(Dic As Object,SrcList() As STRING_PROPERTIE,intList() As Long,Optional ByVal Mode As Boolean) As Boolean
	Dim i As Long,n As Long,tempDic As Object
	If Mode = False Then
		For i = LBound(intList) To UBound(intList)
			If Dic.Exists(SrcList(intList(i)).ID) Then
				intList(n) = Dic.Item(SrcList(intList(i)).ID)
				n = n + 1
			End If
		Next i
	Else
		Set tempDic = CreateObject("Scripting.Dictionary")
		For i = LBound(intList) To UBound(intList)
			If Not tempDic.Exists(SrcList(intList(i)).ID) Then
				tempDic.Add(SrcList(intList(i)).ID,intList(i))
			End If
		Next i
		ReDim intList(Dic.Count - 1) As Long
		For i = 0 To Dic.Count -1
			If Not tempDic.Exists(Dic.Keys(i)) Then
				intList(n) = Dic.Items(i)
				n = n + 1
			End If
		Next i
		Set tempDic = Nothing
	End If
	If n > 0 Then
		ReDim Preserve intList(n - 1) As Long
		GetIndexList = True
	Else
		ReDim intList(0) As Long
	End If
End Function


'按 IntList 列表找出二个字串数组中的字串相同或不相同的索引列表
'Mode = False 获取二个字串数组中的字串相同的索引列表，二个索引列表没有对应关系
'Mode = True 获取二个字串数组中的字串不相同的索引列表，二个索引列表没有对应关系
Private Function GetStrIndexList(Dic As Object,SrcList() As String,intList() As Long,Optional ByVal Mode As Boolean) As Boolean
	Dim i As Long,n As Long,tempDic As Object
	If Mode = False Then
		For i = LBound(intList) To UBound(intList)
			If Dic.Exists(SrcList(intList(i))) Then
				intList(n) = Dic.Item(SrcList(intList(i)))
				n = n + 1
			End If
		Next i
	Else
		Set tempDic = CreateObject("Scripting.Dictionary")
		For i = LBound(intList) To UBound(intList)
			If Not tempDic.Exists(SrcList(intList(i))) Then
				tempDic.Add(SrcList(intList(i)),intList(i))
			End If
		Next i
		ReDim intList(Dic.Count - 1) As Long
		For i = 0 To Dic.Count -1
			If Not tempDic.Exists(Dic.Keys(i)) Then
				intList(n) = Dic.Items(i)
				n = n + 1
			End If
		Next i
		Set tempDic = Nothing
	End If
	If n > 0 Then
		ReDim Preserve intList(n - 1) As Long
		GetStrIndexList = True
	Else
		ReDim intList(0) As Long
	End If
End Function


'找出二个字串数组中的字串相同或不相同的索引列表
'Mode = False 获取二个字串数组中的字串相同的索引列表，二个索引列表没有对应关系
'Mode = True 获取二个字串数组中的字串不相同的索引列表，二个索引列表没有对应关系
Private Function GetChangeIndexList(AllList() As String,UseList() As String,Optional ByVal Mode As Boolean) As Integer()
	Dim i As Long,n As Long,Dic As Object
	Set Dic = CreateObject("Scripting.Dictionary")
	For i = LBound(AllList) To UBound(AllList)
		If Not Dic.Exists(AllList(i)) Then
			Dic.Add(AllList(i),"")
		End If
	Next i
	ReDim Indexs(UBound(UseList)) As Integer
	If Mode = False Then
		For i = LBound(UseList) To UBound(UseList)
			If Dic.Exists(UseList(i)) Then
				Indexs(n) = i
				n = n + 1
			End If
		Next i
	Else
		For i = LBound(UseList) To UBound(UseList)
			If Not Dic.Exists(UseList(i)) Then
				Indexs(n) = i
				n = n + 1
			End If
		Next i
	End If
	If n > 0 Then n = n - 1
	ReDim Preserve Indexs(n) As Integer
	GetChangeIndexList = Indexs
	Set Dic = Nothing
End Function


'添加将被覆盖的其他字串索引号
Private Function AddIndexList(DataList() As STRING_PROPERTIE,SrcIntList() As Long,TrgIntList() As Long) As Long
	Dim i As Long,j As Long,n As Long,m As Long,Dic As Object
	Set Dic = CreateObject("Scripting.Dictionary")
	For i = LBound(SrcIntList) To UBound(SrcIntList)
		If Not Dic.Exists(SrcIntList(i)) Then
			Dic.Add(SrcIntList(i),"")
		End If
	Next i
	n = UBound(SrcIntList)
	TrgIntList = SrcIntList
	For i = LBound(SrcIntList) To UBound(SrcIntList)
		j = SrcIntList(i)
		Do
			j = DataList(j).ScapeIDForMove
			If j > -1 Then
				j = StrIDIndexDic.Item(j)
				If Not Dic.Exists(j) Then
					Dic.Add(j,"")
					n = n + 1
					If n > m Then
						m = n * 10
						ReDim Preserve TrgIntList(m) As Long
					End If
					TrgIntList(n) = j
				End If
			End If
		Loop Until j < 0
	Next i
	Set Dic = Nothing
	If n > UBound(SrcIntList) Then
		ReDim Preserve TrgIntList(n) As Long
		Call SortNumArray(TrgIntList,UBound(SrcIntList),n,False)
		AddIndexList = n - UBound(SrcIntList)
	End If
End Function


'根据节和子节的索引号获取节和子节的名称(用于显示)
Private Function GetSectionName(File As FILE_PROPERTIE,ByVal SecID As Integer,Optional ByVal SubSecID As Integer = -1) As String
	If SecID = -1 Then
		Select Case File.Magic
		Case "PE32","PE64","NET32","NET64"
			GetSectionName = NewPESecName
		Case "MAC32","MAC64"
			GetSectionName = NewMacSecName
		End Select
		Exit Function
	End If
	If SubSecID = -1 Then
		GetSectionName = File.SecList(SecID).sName
		Exit Function
	End If
	If File.SecList(SecID).SubSecs = 0 Then
		GetSectionName = File.SecList(SecID).sName
	Else
		GetSectionName = File.SecList(SecID).sName & "-" & File.SecList(SecID).SubSecList(SubSecID).sName
	End If
End Function


'根据引用地址列表获取引用代码列表(用于显示)
'Mode = False '来源引用代码列表，否则，目标引用代码列表
'fType 返回第一个选定的引用代码值
Private Function GetRefCodeList(strData As STRING_PROPERTIE,ByVal Mode As Boolean,Optional fType As Long) As String()
	Dim i As Long,Dic As Object
	With strData
		If .Source.lReferenceNum = 0 Then
			ReDim TempArray(0) As String
			GetRefCodeList = TempArray
		ElseIf Mode = False Then
			GetRefCodeList = RefList2StrList(.Source,1)
			Exit Function
		ElseIf .Trans.lReferenceNum = 0 Then
			GetRefCodeList = RefList2StrList(.Source,1)
		ElseIf .Trans.lReferenceNum = .Source.lReferenceNum Then
			GetRefCodeList = RefList2StrList(.Trans,1)
		Else
			Set Dic = CreateObject("Scripting.Dictionary")
			For i = 0 To .Trans.lReferenceNum - 1
				If Not Dic.Exists(.Trans.Reference(i).lAddress) Then
					Dic.Add(.Trans.Reference(i).lAddress,.Trans.Reference(i).sCode)
				End If
			Next i
			ReDim TempArray(.Source.lReferenceNum - 1) As String
			fType = -1
			For i = 0 To .Source.lReferenceNum - 1
				If Dic.Exists(.Source.Reference(i).lAddress) Then
					TempArray(i) = Dic.Item(.Source.Reference(i).lAddress)
					If fType = -1 Then fType = i
				Else
					TempArray(i) = .Source.Reference(i).sCode
				End If
			Next i
			If fType = -1 Then fType = 0
			Set Dic = Nothing
			GetRefCodeList = TempArray
		End If
	End With
End Function


'根据翻译引用地址列表获取来源引用列表(用于字串拆分)
'Mode = False '修改引用地址列表，否则，获取引用地址和代码列表
Private Sub GetRefList(strData As STRING_SUB_PROPERTIE,RefAddList() As String,RefVAList() As String,ByVal Mode As Boolean)
	Dim i As Long,n As Long,Dic As Object
	With strData
		If .lReferenceNum = 0 Then
			ReDim RefList(0) As REFERENCE_PROPERTIE
			ReDim AddList(0) As String,VAList(0) As String
		Else
			n = UBound(RefAddList)
			ReDim RefList(n) As REFERENCE_PROPERTIE
			ReDim AddList(n) As String,VAList(n) As String
			Set Dic = CreateObject("Scripting.Dictionary")
			For i = 0 To .lReferenceNum - 1
				If Not Dic.Exists(.Reference(i).lAddress) Then
					Dic.Add(CStr(.Reference(i).lAddress),i)
				End If
			Next i
			n = 0
			For i = 0 To UBound(RefAddList)
				If Dic.Exists(RefAddList(i)) Then
					RefList(n) = .Reference(Dic.Item(RefAddList(i)))
					AddList(n) = CStr(RefList(n).lAddress)
					VAList(n) = RefList(n).sCode
					n = n + 1
				End If
			Next i
			Set Dic = Nothing
			If n > 0 Then
				ReDim Preserve RefList(n - 1) As REFERENCE_PROPERTIE
				ReDim Preserve AddList(n - 1) As String,VAList(n - 1) As String
			Else
				ReDim RefList(0) As REFERENCE_PROPERTIE
				ReDim AddList(0) As String,VAList(0) As String
			End If
		End If
		If Mode = False Then
			RefAddList = AddList
			RefVAList = VAList
		Else
			.Reference = RefList
			.lReferenceNum = n
			.GetRefState = IIf(n = 0,0,1)
		End If
	End With
End Sub


'引用地址或代码列表转字符串数组(用于字串拆分)
'Mode = 0 '引用地址列表转字符串数组
'Mode = 1 '引用代码列表转字符串数组
'Mode = 2 '跟随引用地址的字串类型列表转字符串数组
'Mode > 2 '引用所在区段 ID 转字符串数组
Private Function RefList2StrList(strData As STRING_SUB_PROPERTIE,ByVal Mode As Integer,Optional ByVal MoveVal As Integer) As String()
	Dim i As Long
	With strData
		If .lReferenceNum = 0 Then
			ReDim TempList(0) As String
		Else
			ReDim TempList(.lReferenceNum - 1) As String
			Select Case Mode
			Case 0
				For i = 0 To .lReferenceNum - 1
					TempList(i) = CStr(.Reference(i).lAddress + MoveVal)
				Next i
			Case 1
				For i = 0 To .lReferenceNum - 1
					TempList(i) = .Reference(i).sCode
				Next i
			Case 2
				For i = 0 To .lReferenceNum - 1
					TempList(i) = CStr(.Reference(i).StrType)
				Next i
			Case Else
				For i = 0 To .lReferenceNum - 1
					TempList(i) = CStr(.Reference(i).inSecID)
				Next i
			End Select
		End If
		RefList2StrList = TempList
	End With
End Function


'按数组值快速排序数字数组
'Mode = False 从小到大排序，否则从大到小排序，l = 数组的左边界，r = 数组的右边界.
Private Sub SortNumArray(ByRef MyArray As Variant,ByVal l As Long,ByVal r As Long,ByVal Mode As Boolean)
	Dim i As Long, j As Long, TmpX As Variant, TmpA As Variant
	i = l: j = r: TmpX = CLng(MyArray((l + r) \ 2))
	While (i <= j)
		If Mode = False Then
			While (CLng(MyArray(i)) < TmpX And i < r)
				i = i + 1
			Wend
			While (TmpX < CLng(MyArray(j)) And j > l)
				j = j - 1
			Wend
		Else
			While (CLng(MyArray(i)) > TmpX And i < r)
				i = i + 1
			Wend
			While (TmpX > CLng(MyArray(j)) And j > l)
				j = j - 1
			Wend
		End If
		If (i <= j) Then
			TmpA = MyArray(i)
			MyArray(i) = MyArray(j)
			MyArray(j) = TmpA
			i = i + 1: j = j - 1
		End If
	Wend
	If (l < j) Then Call SortNumArray(MyArray, l, j, Mode)
	If (i < r) Then Call SortNumArray(MyArray, i, r, Mode)
End Sub


'按字串的开始地址快速排序字串数据数组
'Mode = False 从小到大排序，否则从大到小排序，l = 数组的左边界，r = 数组的右边界
Private Sub SortStrArrayByAddress(MyArray() As STRING_PROPERTIE,ByVal l As Long,ByVal r As Long,ByVal Mode As Boolean)
	Dim i As Long, j As Long, TmpX As Long, TmpA As STRING_PROPERTIE
	i = l: j = r: TmpX = MyArray((l + r) \ 2).Source.lStartAddress
	While (i <= j)
		If Mode = False Then
			While (MyArray(i).Source.lStartAddress < TmpX And i < r)
				i = i + 1
			Wend
			While (TmpX < MyArray(j).Source.lStartAddress And j > l)
				j = j - 1
			Wend
		Else
			While (MyArray(i).Source.lStartAddress > TmpX And i < r)
				i = i + 1
			Wend
			While (TmpX > MyArray(j).Source.lStartAddress And j > l)
				j = j - 1
			Wend
		End If
		If (i <= j) Then
			TmpA = MyArray(i)
			MyArray(i) = MyArray(j)
			MyArray(j) = TmpA
			i = i + 1: j = j - 1
		End If
	Wend
	If (l < j) Then Call SortStrArrayByAddress(MyArray, l, j, Mode)
	If (i < r) Then Call SortStrArrayByAddress(MyArray, i, r, Mode)
End Sub


'按字串的开始地址快速排序字串数组及字串数据数组和字典
'Mode = False 从小到大排序，否则从大到小排序，l = 数组的左边界，r = 数组的右边界
Private Sub SortStrArraysByAddress(Dic As Object,MyArray() As STRING_PROPERTIE,ByVal l As Long,ByVal r As Long,ByVal Mode As Boolean)
	Dim i As Long, j As Long, TmpX As Long, TmpA As STRING_PROPERTIE
	i = l: j = r: TmpX = MyArray((l + r) \ 2).Source.lStartAddress
	While (i <= j)
		If Mode = False Then
			While (MyArray(i).Source.lStartAddress < TmpX And i < r)
				i = i + 1
			Wend
			While (TmpX < MyArray(j).Source.lStartAddress And j > l)
				j = j - 1
			Wend
		Else
			While (MyArray(i).Source.lStartAddress > TmpX And i < r)
				i = i + 1
			Wend
			While (TmpX > MyArray(j).Source.lStartAddress And j > l)
				j = j - 1
			Wend
		End If
		If (i <= j) Then
			Dic.Item(MyArray(i).ID) = j
			Dic.Item(MyArray(j).ID) = i
			TmpA = MyArray(i)
			MyArray(i) = MyArray(j)
			MyArray(j) = TmpA
			i = i + 1: j = j - 1
		End If
	Wend
	If (l < j) Then Call SortStrArraysByAddress(Dic, MyArray, l, j, Mode)
	If (i < r) Then Call SortStrArraysByAddress(Dic, MyArray, i, r, Mode)
End Sub


'按字串的ID快速排序字串数组及字串数据数组和字典
'Mode = False 从小到大排序，否则从大到小排序，l = 数组的左边界，r = 数组的右边界
Private Sub SortStrArraysByID(Dic As Object,MyArray() As STRING_PROPERTIE,ByVal l As Long,ByVal r As Long,ByVal Mode As Boolean)
	Dim i As Long, j As Long, TmpX As Long, TmpA As STRING_PROPERTIE
	i = l: j = r: TmpX = MyArray((l + r) \ 2).ID
	While (i <= j)
		If Mode = False Then
			While (MyArray(i).ID < TmpX And i < r)
				i = i + 1
			Wend
			While (TmpX < MyArray(j).ID And j > l)
				j = j - 1
			Wend
		Else
			While (MyArray(i).ID > TmpX And i < r)
				i = i + 1
			Wend
			While (TmpX > MyArray(j).ID And j > l)
				j = j - 1
			Wend
		End If
		If (i <= j) Then
			Dic.Item(MyArray(i).ID) = j
			Dic.Item(MyArray(j).ID) = i
			TmpA = MyArray(i)
			MyArray(i) = MyArray(j)
			MyArray(j) = TmpA
			i = i + 1: j = j - 1
		End If
	Wend
	If (l < j) Then Call SortStrArraysByID(Dic, MyArray, l, j, Mode)
	If (i < r) Then Call SortStrArraysByID(Dic, MyArray, i, r, Mode)
End Sub


'按代码页值快速排序语言数组
'Mode = False 从小到大排序，否则从大到小排序，l = 数组的左边界，r = 数组的右边界
Private Sub SortLangArrayByCP(MyArray() As LANG_PROPERTIE,ByVal l As Long,ByVal r As Long,ByVal Mode As Boolean)
	Dim i As Long, j As Long, TmpX As Long, TmpA As LANG_PROPERTIE
	i = l: j = r: TmpX = MyArray((l + r) \ 2).CodePage
	While (i <= j)
		If Mode = False Then
			While (MyArray(i).CodePage < TmpX And i < r)
				i = i + 1
			Wend
			While (TmpX < MyArray(j).CodePage And j > l)
				j = j - 1
			Wend
		Else
			While (MyArray(i).CodePage > TmpX And i < r)
				i = i + 1
			Wend
			While (TmpX > MyArray(j).CodePage And j > l)
				j = j - 1
			Wend
		End If
		If (i <= j) Then
			TmpA = MyArray(i)
			MyArray(i) = MyArray(j)
			MyArray(j) = TmpA
			i = i + 1: j = j - 1
		End If
	Wend
	If (l < j) Then Call SortLangArrayByCP(MyArray, l, j, Mode)
	If (i < r) Then Call SortLangArrayByCP(MyArray, i, r, Mode)
End Sub


'按代码页值快速排序语言数组和名称列表
'Mode = False 从小到大排序，否则从大到小排序，l = 数组的左边界，r = 数组的右边界
Private Sub SortLangArraysByCP(Dic As Object,MyArray() As LANG_PROPERTIE,ByVal l As Long,ByVal r As Long,ByVal Mode As Boolean)
	Dim i As Long, j As Long, TmpX As Long, TmpA As LANG_PROPERTIE, TmpB As String
	i = l: j = r: TmpX = MyArray((l + r) \ 2).CodePage
	While (i <= j)
		If Mode = False Then
			While (MyArray(i).CodePage < TmpX And i < r)
				i = i + 1
			Wend
			While (TmpX < MyArray(j).CodePage And j > l)
				j = j - 1
			Wend
		Else
			While (MyArray(i).CodePage > TmpX And i < r)
				i = i + 1
			Wend
			While (TmpX > MyArray(j).CodePage And j > l)
				j = j - 1
			Wend
		End If
		If (i <= j) Then
			Dic.Item(MyArray(i).CodePage) = j
			Dic.Item(MyArray(j).CodePage) = i
			TmpA = MyArray(i)
			MyArray(i) = MyArray(j)
			MyArray(j) = TmpA
			i = i + 1: j = j - 1
		End If
	Wend
	If (l < j) Then Call SortLangArraysByCP(Dic, MyArray, l, j, Mode)
	If (i < r) Then Call SortLangArraysByCP(Dic, MyArray, i, r, Mode)
End Sub


'按语言ID快速排序语言数组
'Mode = False 从小到大排序，否则从大到小排序，l = 数组的左边界，r = 数组的右边界
Private Sub SortLangArraysByLngID(Dic As Object,MyArray() As LANG_PROPERTIE,ByVal l As Long,ByVal r As Long,ByVal Mode As Boolean)
	Dim i As Long, j As Long, TmpX As Long, TmpA As LANG_PROPERTIE
	i = l: j = r: TmpX = MyArray((l + r) \ 2).LangID
	While (i <= j)
		If Mode = False Then
			While (MyArray(i).LangID < TmpX And i < r)
				i = i + 1
			Wend
			While (TmpX < MyArray(j).LangID And j > l)
				j = j - 1
			Wend
		Else
			While (MyArray(i).LangID > TmpX And i < r)
				i = i + 1
			Wend
			While (TmpX > MyArray(j).LangID And j > l)
				j = j - 1
			Wend
		End If
		If (i <= j) Then
			Dic.Item(MyArray(i).LangID) = j
			Dic.Item(MyArray(j).LangID) = i
			TmpA = MyArray(i)
			MyArray(i) = MyArray(j)
			MyArray(j) = TmpA
			i = i + 1: j = j - 1
		End If
	Wend
	If (l < j) Then Call SortLangArraysByLngID(Dic, MyArray, l, j, Mode)
	If (i < r) Then Call SortLangArraysByLngID(Dic, MyArray, i, r, Mode)
End Sub


'按语言ID快速排序语言数组
'Mode = False 从小到大排序，否则从大到小排序，l = 数组的左边界，r = 数组的右边界
Public Sub SortLangArraysByLngName(Dic As Object,MyArray() As LANG_PROPERTIE,ByVal l As Long,ByVal r As Long,ByVal Mode As Boolean)
	Dim i As Long, j As Long, TmpX As String, TmpA As LANG_PROPERTIE
	i = l: j = r: TmpX = MyArray((l + r) \ 2).LangName
	While (i <= j)
		If Mode = False Then
			While (StrComp(MyArray(i).LangName, TmpX, 1) = -1) And (i < r)
				i = i + 1
			Wend
			While (StrComp(TmpX, MyArray(j).LangName, 1) = -1) And (j > l)
				j = j - 1
			Wend
		Else
			While (StrComp(MyArray(i).LangName, TmpX, 1) = 1) And (i < r)
				i = i + 1
			Wend
			While (StrComp(TmpX, MyArray(j).LangName, 1) = 1) And (j > l)
				j = j - 1
			Wend
		End If
		If (i <= j) Then
			Dic.Item(MyArray(i).LangID) = j
			Dic.Item(MyArray(j).LangID) = i
			TmpA = MyArray(i)
			MyArray(i) = MyArray(j)
			MyArray(j) = TmpA
			i = i + 1: j = j - 1
		End If
	Wend
	If (l < j) Then Call SortLangArraysByLngName(Dic, MyArray, l, j, Mode)
	If (i < r) Then Call SortLangArraysByLngName(Dic, MyArray, i, r, Mode)
End Sub


'按引用地址快速排序引用数据数组
'Mode = False 从小到大排序，否则从大到小排序，l = 数组的左边界，r = 数组的右边界
Private Sub SortRefArrayByAddress(MyArray() As REFERENCE_PROPERTIE,ByVal l As Long,ByVal r As Long,ByVal Mode As Boolean)
	Dim i As Long, j As Long, TmpX As Long, TmpA As REFERENCE_PROPERTIE
	i = l: j = r: TmpX = MyArray((l + r) \ 2).lAddress
	While (i <= j)
		If Mode = False Then
			While (MyArray(i).lAddress < TmpX And i < r)
				i = i + 1
			Wend
			While (TmpX < MyArray(j).lAddress And j > l)
				j = j - 1
			Wend
		Else
			While (MyArray(i).lAddress > TmpX And i < r)
				i = i + 1
			Wend
			While (TmpX > MyArray(j).lAddress And j > l)
				j = j - 1
			Wend
		End If
		If (i <= j) Then
			TmpA = MyArray(i)
			MyArray(i) = MyArray(j)
			MyArray(j) = TmpA
			i = i + 1: j = j - 1
		End If
	Wend
	If (l < j) Then Call SortRefArrayByAddress(MyArray, l, j, Mode)
	If (i < r) Then Call SortRefArrayByAddress(MyArray, i, r, Mode)
End Sub


'过滤器设置对话框
Private Function FilterSet(ByVal Mode As Long,ByVal fType As Long) As Boolean
	Dim MsgList() As String
	If getMsgList(UIDataList,MsgList,"FilterSet",1) = False Then Exit Function
	Begin Dialog UserDialog 860,574,MsgList(0),.FilterSetDlgFunc ' %GRID:10,7,1,1
		TextBox 0,0,0,21,.SuppValueBox
		GroupBox 10,0,840,532,"",.GroupBox
		Text 30,14,130,14,MsgList(1),.ItemText
		Text 670,14,70,14,MsgList(2),.IgnoreItemText,2
		Text 720,14,70,14,MsgList(3),.ShowItemText,2
		Text 770,14,70,14,MsgList(4),.NotShowItemText,2
		OptionGroup .FilterModeGroup
			OptionButton 190,14,220,14,MsgList(5),.FilterModeButton1
			OptionButton 420,14,220,14,MsgList(6),.FilterModeButton2

		Text 30,38,130,14,MsgList(8),.inSectionText
		TextBox 160,35,480,21,.inSectionTextBox
		TextBox 160,35,480,21,.inSectionValBox
		PushButton 640,35,30,21,MsgList(7),.inSectionButton
		OptionGroup .inSectionGroup
			OptionButton 700,35,50,21,"",.inSectionButton1
			OptionButton 750,35,50,21,"",.inSectionButton2
			OptionButton 800,35,40,21,"",.inSectionButton3

		Text 30,59,130,14,MsgList(9),.WriteTypeText
		TextBox 160,56,480,21,.WriteTypeTextBox
		TextBox 160,56,480,21,.WriteTypeValBox
		PushButton 640,56,30,21,MsgList(7),.WriteTypeButton
		OptionGroup .WriteTypeGroup
			OptionButton 700,56,50,21,"",.WriteTypeButton1
			OptionButton 750,56,50,21,"",.WriteTypeButton2
			OptionButton 800,56,40,21,"",.WriteTypeButton3

		Text 30,80,130,14,MsgList(10),.OverLengthText
		TextBox 160,77,480,21,.OverLengthTextBox
		TextBox 160,77,480,21,.OverLengthValBox
		PushButton 640,77,30,21,MsgList(7),.OverLengthButton
		OptionGroup .OverLengthGroup
			OptionButton 700,77,50,21,"",.OverLengthButton1
			OptionButton 750,77,50,21,"",.OverLengthButton2
			OptionButton 800,77,40,21,"",.OverLengthButton3

		Text 30,101,130,14,MsgList(11),.SplitStateText
		TextBox 160,98,480,21,.SplitStateTextBox
		TextBox 160,98,480,21,.SplitStateValBox
		PushButton 640,98,30,21,MsgList(7),.SplitStateButton
		OptionGroup .SplitStateGroup
			OptionButton 700,98,50,21,"",.SplitStateButton1
			OptionButton 750,98,50,21,"",.SplitStateButton2
			OptionButton 800,98,40,21,"",.SplitStateButton3

		Text 30,122,120,14,MsgList(12),.LangText
		TextBox 160,119,480,21,.LangTextBox
		TextBox 160,119,480,21,.LangValBox
		PushButton 640,119,30,21,MsgList(7),.LangButton
		OptionGroup .LangGroup
			OptionButton 700,119,50,21,"",.LangButton1
			OptionButton 750,119,50,21,"",.LangButton2
			OptionButton 800,119,40,21,"",.LangButton3

		Text 30,143,120,14,MsgList(13),.SrcCPText
		TextBox 160,140,480,21,.SrcCPTextBox
		TextBox 160,140,480,21,.SrcCPValBox
		PushButton 640,140,30,21,MsgList(7),.SrcCPButton
		OptionGroup .SrcCPGroup
			OptionButton 700,140,50,21,"",.SrcCPButton1
			OptionButton 750,140,50,21,"",.SrcCPButton2
			OptionButton 800,140,40,21,"",.SrcCPButton3

		Text 30,164,120,14,MsgList(14),.TrnCPText
		TextBox 160,161,480,21,.TrnCPTextBox
		TextBox 160,161,480,21,.TrnCPValBox
		PushButton 640,161,30,21,MsgList(7),.TrnCPButton
		OptionGroup .TrnCPGroup
			OptionButton 700,161,50,21,"",.TrnCPButton1
			OptionButton 750,161,50,21,"",.TrnCPButton2
			OptionButton 800,161,40,21,"",.TrnCPButton3

		Text 30,185,130,14,MsgList(15),.PredefTypeText
		TextBox 160,182,480,21,.PredefTypeTextBox
		TextBox 160,182,480,21,.PredefTypeValBox
		PushButton 640,182,30,21,MsgList(7),.PredefTypeButton
		OptionGroup .PredefTypeGroup
			OptionButton 700,182,50,21,"",.PredefTypeButton1
			OptionButton 750,182,50,21,"",.PredefTypeButton2
			OptionButton 800,182,40,21,"",.PredefTypeButton3

		Text 30,207,130,14,MsgList(16),.CustomTypeText
		TextBox 160,203,480,21,.CustomTypeTextBox
		TextBox 160,203,480,21,.CustomTypeValBox
		PushButton 640,203,30,21,MsgList(7),.CustomTypeButton
		OptionGroup .CustomTypeGroup
			OptionButton 700,203,50,21,"",.CustomTypeButton1
			OptionButton 750,203,50,21,"",.CustomTypeButton2
			OptionButton 800,203,40,21,"",.CustomTypeButton3

		Text 30,227,130,14,MsgList(17),.MoveModeText
		TextBox 160,224,480,21,.MoveModeTextBox
		TextBox 160,224,480,21,.MoveModeValBox
		PushButton 640,224,30,21,MsgList(7),.MoveModeButton
		OptionGroup .MoveModeGroup
			OptionButton 700,224,50,21,"",.MoveModeButton1
			OptionButton 750,224,50,21,"",.MoveModeButton2
			OptionButton 800,224,40,21,"",.MoveModeButton3

		Text 30,248,130,14,MsgList(18),.MoveTypeText
		TextBox 160,245,480,21,.MoveTypeTextBox
		TextBox 160,245,480,21,.MoveTypeValBox
		PushButton 640,245,30,21,MsgList(7),.MoveTypeButton
		OptionGroup .MoveTypeGroup
			OptionButton 700,245,50,21,"",.MoveTypeButton1
			OptionButton 750,245,50,21,"",.MoveTypeButton2
			OptionButton 800,245,40,21,"",.MoveTypeButton3

		Text 30,269,130,14,MsgList(19),.WriteStateText
		TextBox 160,266,480,21,.WriteStateTextBox
		TextBox 160,266,480,21,.WriteStateValBox
		PushButton 640,266,30,21,MsgList(7),.WriteStateButton
		OptionGroup .WriteStateGroup
			OptionButton 700,266,50,21,"",.WriteStateButton1
			OptionButton 750,266,50,21,"",.WriteStateButton2
			OptionButton 800,266,40,21,"",.WriteStateButton3

		Text 30,290,130,14,MsgList(20),.StrTypeLengthText
		TextBox 160,287,480,21,.StrTypeLengthTextBox
		TextBox 160,287,480,21,.StrTypeLengthValBox
		PushButton 640,287,30,21,MsgList(7),.StrTypeLengthButton
		OptionGroup .StrTypeLengthGroup
			OptionButton 700,287,50,21,"",.StrTypeLengthButton1
			OptionButton 750,287,50,21,"",.StrTypeLengthButton2
			OptionButton 800,287,40,21,"",.StrTypeLengthButton3

		Text 30,311,130,14,MsgList(21),.RefText
		TextBox 160,308,480,21,.RefTextBox
		TextBox 160,308,480,21,.RefValBox
		PushButton 640,308,30,21,MsgList(7),.RefButton
		OptionGroup .RefGroup
			OptionButton 700,308,50,21,"",.RefButton1
			OptionButton 750,308,50,21,"",.RefButton2
			OptionButton 800,308,40,21,"",.RefButton3

		Text 30,332,130,14,MsgList(22),.FillSpaceText
		TextBox 160,329,480,21,.FillSpaceTextBox
		TextBox 160,329,480,21,.FillSpaceValBox
		PushButton 640,329,30,21,MsgList(7),.FillSpaceButton
		OptionGroup .FillSpaceGroup
			OptionButton 700,329,50,21,"",.FillSpaceButton1
			OptionButton 750,329,50,21,"",.FillSpaceButton2
			OptionButton 800,329,40,21,"",.FillSpaceButton3

		Text 30,353,130,14,MsgList(23),.DataChangeText
		TextBox 160,350,480,21,.DataChangeTextBox
		TextBox 160,350,480,21,.DataChangeValBox
		PushButton 640,350,30,21,MsgList(7),.DataChangeButton
		OptionGroup .DataChangeGroup
			OptionButton 700,350,50,21,"",.DataChangeButton1
			OptionButton 750,350,50,21,"",.DataChangeButton2
			OptionButton 800,350,40,21,"",.DataChangeButton3

		Text 30,374,610,14,MsgList(24),.FilterStrText
		CheckBox 370,375,210,14,MsgList(25),.FilterStrAccKeyCheckBox
		PushButton 640,371,30,21,MsgList(7),.FilterStrButton
		OptionGroup .FilterStrGroup
			OptionButton 700,371,50,21,"",.FilterStrButton1
			OptionButton 750,371,50,21,"",.FilterStrButton2
			OptionButton 800,371,40,21,"",.FilterStrButton3

		Text 30,395,610,14,MsgList(26),.LockStateText
		OptionGroup .LockStateGroup
			OptionButton 700,392,50,21,"",.LockStateButton1
			OptionButton 750,392,50,21,"",.LockStateButton2
			OptionButton 800,392,40,21,"",.LockStateButton3

		Text 30,416,610,14,IIf(fType = 1,MsgList(27),MsgList(28)),.NewStrText
		OptionGroup .NewStrGroup
			OptionButton 700,413,50,21,"",.NewStrButton1
			OptionButton 750,413,50,21,"",.NewStrButton2
			OptionButton 800,413,40,21,"",.NewStrButton3

		Text 30,437,610,14,MsgList(29),.iErrorText
		OptionGroup .iErrorGroup
			OptionButton 700,434,50,21,"",.iErrorButton1
			OptionButton 750,434,50,21,"",.iErrorButton2
			OptionButton 800,434,40,21,"",.iErrorButton3

		Text 30,458,610,14,MsgList(30),.OverWriteText
		OptionGroup .OverWriteGroup
			OptionButton 700,455,50,21,"",.OverWriteButton1
			OptionButton 750,455,50,21,"",.OverWriteButton2
			OptionButton 800,455,40,21,"",.OverWriteButton3

		Text 30,479,610,14,MsgList(31),.CommentText
		OptionGroup .CommentGroup
			OptionButton 700,476,50,21,"",.CommentButton1
			OptionButton 750,476,50,21,"",.CommentButton2
			OptionButton 800,476,40,21,"",.CommentButton3

		Text 30,500,130,14,MsgList(32),.CustomText
		DropListBox 160,497,310,21,MsgList(),.CustomBox,1
		TextBox 160,497,310,21,.CustomBoxBak
		CheckBox 550,497,120,21,MsgList(25),.CustomAccKeyCheckBox
		PushButton 470,497,30,21,MsgList(33),.RegExpTipButton
		PushButton 500,497,30,21,MsgList(7),.FavoriteButton
		OptionGroup .CustomGroup
			OptionButton 700,497,50,21,"",.CustomButton1
			OptionButton 750,497,50,21,"",.CustomButton2
			OptionButton 800,497,40,21,"",.CustomButton3

		PushButton 10,546,90,21,MsgList(54),.HelpButton
		PushButton 120,546,90,21,MsgList(34),.ReverseButton
		PushButton 230,546,90,21,MsgList(35),.ReposButton
		PushButton 340,546,90,21,MsgList(36),.ResetButton
		CheckBox 490,546,80,21,"",.ModeCheckBox
		CheckBox 480,546,80,21,"",.TypeCheckBox
		OKButton 650,546,90,21,.OKButton
		CancelButton 760,546,90,21,.CancelButton
	End Dialog
	Dim dlg As UserDialog
	dlg.ModeCheckBox = Mode
	dlg.TypeCheckBox = fType
	If Dialog(dlg) = 0 Then Exit Function
	FilterSet = True
End Function


'过滤器设置对话框函数
Private Function FilterSetDlgFunc(DlgItem$, Action%, SuppValue&) As Boolean
	Dim i As Long,j As Long,n As Long,k As Long,Dic As Object
	Dim MsgList() As String,TempArray() As String,TempList() As String
	Select Case Action%
	Case 1 ' 对话框窗口初始化
		If getMsgList(UIDataList,MsgList,"FilterSet",1) = False Then Exit Function
		DlgText "SuppValueBox",CStr$(SuppValue)
		DlgVisible "SuppValueBox",False
		DlgVisible "ModeCheckBox",False
		DlgVisible "TypeCheckBox",False
		DlgVisible "CustomBoxBak",False
		If DlgValue("TypeCheckBox") = 1 Then
			DlgEnable "CommentGroup",False
			DlgValue "CommentGroup",0
		End If
		GetHistory(TempList,"Filters","FilterShowSetDlg")
		DlgListBoxArray "CustomBox",TempList()
		DlgText "CustomBoxBak",TempList(0)

		If CheckArray(FilterStrSet) = True Then
			DlgValue "FilterModeGroup",StrToLong(FilterStrSet(0))
			DlgValue "inSectionGroup",StrToLong(ReSplit(FilterStrSet(1),ItemJoinStr)(0))
			DlgText "inSectionValBox",ReSplit(FilterStrSet(1),ItemJoinStr,2)(1)
			DlgValue "WriteTypeGroup",StrToLong(ReSplit(FilterStrSet(2),ItemJoinStr)(0))
			DlgText "WriteTypeValBox",ReSplit(FilterStrSet(2),ItemJoinStr,2)(1)
			DlgValue "OverLengthGroup",StrToLong(ReSplit(FilterStrSet(3),ItemJoinStr)(0))
			DlgText "OverLengthValBox",ReSplit(FilterStrSet(3),ItemJoinStr,2)(1)
			DlgValue "SplitStateGroup",StrToLong(ReSplit(FilterStrSet(4),ItemJoinStr)(0))
			DlgText "SplitStateValBox",ReSplit(FilterStrSet(4),ItemJoinStr,2)(1)
			DlgValue "LangGroup",StrToLong(ReSplit(FilterStrSet(5),ItemJoinStr)(0))
			DlgText "LangValBox",ReSplit(FilterStrSet(5),ItemJoinStr,2)(1)
			DlgValue "SrcCPGroup",StrToLong(ReSplit(FilterStrSet(6),ItemJoinStr)(0))
			DlgText "SrcCPValBox",ReSplit(FilterStrSet(6),ItemJoinStr,2)(1)
			DlgValue "TrnCPGroup",StrToLong(ReSplit(FilterStrSet(7),ItemJoinStr)(0))
			DlgText "TrnCPValBox",ReSplit(FilterStrSet(7),ItemJoinStr,2)(1)
			DlgValue "PredefTypeGroup",StrToLong(ReSplit(FilterStrSet(8),ItemJoinStr)(0))
			DlgText "PredefTypeValBox",ReSplit(FilterStrSet(8),ItemJoinStr,2)(1)
			DlgValue "CustomTypeGroup",StrToLong(ReSplit(FilterStrSet(9),ItemJoinStr)(0))
			DlgText "CustomTypeValBox",ReSplit(FilterStrSet(9),ItemJoinStr,2)(1)
			DlgValue "MoveModeGroup",StrToLong(ReSplit(FilterStrSet(10),ItemJoinStr)(0))
			DlgText "MoveModeValBox",ReSplit(FilterStrSet(10),ItemJoinStr,2)(1)
			DlgValue "MoveTypeGroup",StrToLong(ReSplit(FilterStrSet(11),ItemJoinStr)(0))
			DlgText "MoveTypeValBox",ReSplit(FilterStrSet(11),ItemJoinStr,2)(1)
			DlgValue "WriteStateGroup",StrToLong(ReSplit(FilterStrSet(12),ItemJoinStr)(0))
			DlgText "WriteStateValBox",ReSplit(FilterStrSet(12),ItemJoinStr,2)(1)
			DlgValue "StrTypeLengthGroup",StrToLong(ReSplit(FilterStrSet(13),ItemJoinStr)(0))
			DlgText "StrTypeLengthValBox",ReSplit(FilterStrSet(13),ItemJoinStr,2)(1)
			DlgValue "RefGroup",StrToLong(ReSplit(FilterStrSet(14),ItemJoinStr)(0))
			DlgText "RefValBox",ReSplit(FilterStrSet(14),ItemJoinStr,2)(1)
			DlgValue "FillSpaceGroup",StrToLong(ReSplit(FilterStrSet(15),ItemJoinStr)(0))
			DlgText "FillSpaceValBox",ReSplit(FilterStrSet(15),ItemJoinStr,2)(1)
			DlgValue "DataChangeGroup",StrToLong(ReSplit(FilterStrSet(16),ItemJoinStr)(0))
			DlgText "DataChangeValBox",ReSplit(FilterStrSet(16),ItemJoinStr,2)(1)
			DlgValue "FilterStrGroup",StrToLong(ReSplit(FilterStrSet(17),ItemJoinStr)(0))
			DlgValue "FilterStrAccKeyCheckBox",StrToLong(ReSplit(FilterStrSet(17),ItemJoinStr)(1))
			DlgValue "LockStateGroup",StrToLong(FilterStrSet(18))
			DlgValue "NewStrGroup",StrToLong(FilterStrSet(19))
			DlgValue "iErrorGroup",StrToLong(FilterStrSet(20))
			DlgValue "OverWriteGroup",StrToLong(FilterStrSet(21))
			DlgValue "CommentGroup",StrToLong(FilterStrSet(22))
			DlgValue "CustomGroup",StrToLong(ReSplit(FilterStrSet(23),ItemJoinStr)(0))
			DlgValue "CustomAccKeyCheckBox",StrToLong(ReSplit(FilterStrSet(23),ItemJoinStr)(1))
			DlgText "CustomBox",ReSplit(FilterStrSet(23),ItemJoinStr,3)(2)
		End If

		If DlgText("inSectionValBox") = "" Then
			TempArray = getSectionList(SourceFile.SecList,2)
			TempList = getSectionList(SourceFile.SecList,10)
			DlgText "inSectionTextBox",StrListJoin(TempArray,ItemJoinStr)
			DlgText "inSectionValBox",StrListJoin(TempList,ItemJoinStr)
		Else
			TempArray = getSectionList(SourceFile.SecList,2)
			TempList = getSectionList(SourceFile.SecList,10)
			Set Dic = CreateObject("Scripting.Dictionary")
			For i = 0 To UBound(TempList)
				If Not Dic.Exists(TempList(i)) Then
					Dic.Add(TempList(i),TempArray(i))
				End If
			Next i
			TempArray = ReSplit(DlgText("inSectionValBox"),ItemJoinStr)
			n = 0
			For i = 0 To UBound(TempArray)
				If Dic.Exists(TempArray(i)) Then
					TempArray(n) = Dic.Item(TempArray(i))
					n = n + 1
				End If
			Next i
			If n > 0 Then
				ReDim Preserve TempArray(n - 1) As String
			Else
				ReDim TempArray(0) As String
			End If
			DlgText "inSectionTextBox",StrListJoin(TempArray,ItemJoinStr)
			Set Dic = Nothing
		End If

		If DlgText("LangValBox") = "" Then
			TempList = GetLangStrList(AllLangList,1)
			TempArray = GetLangStrList(AllLangList,0)
			n = UBound(TempList)
			ReDim Preserve TempList(n + 2) As String,TempArray(n + 2) As String
			'添加原列表中没有的英语代码页
			TempList(n + 1) = CStr$(1033)
			TempArray(n + 1) = UniLangList(LangIDIndexDic.Item(1033)).LangName
			'添加原列表中没有的目标代码页
			If TargetFile.hcsFile.FilePath <> SourceFile.hcsFile.FilePath Then
				TempList(n + 2) = CStr$(trn.Language.LangID)
				TempArray(n + 2) = UniLangList(LangIDIndexDic.Item(trn.Language.LangID)).LangName
			End If
			TempList = ClearTextArray(TempList,True)
			TempArray = ClearTextArray(TempArray,True)
			DlgText "LangValBox",StrListJoin(TempList,ItemJoinStr)
			DlgText "LangTextBox",StrListJoin(TempArray,ItemJoinStr)
		Else
			TempArray = ReSplit(DlgText("LangValBox"),ItemJoinStr)
			For i = 0 To UBound(TempArray)
				TempArray(i) = UniLangList(LangIDIndexDic.Item(StrToLong(TempArray(i)))).LangName
			Next i
			DlgText "LangTextBox",StrListJoin(TempArray,ItemJoinStr)
		End If

		If DlgText("SrcCPValBox") = "" Then
			TempList = GetLangStrList(AllLangList,7,True)
			TempArray = GetLangStrList(AllLangList,8,True)
			DlgText "SrcCPValBox",StrListJoin(TempList,ItemJoinStr)
			DlgText "SrcCPTextBox",StrListJoin(TempArray,ItemJoinStr)
		Else
			TempList = GetLangStrList(AllLangList,7,True)
			TempArray = GetLangStrList(AllLangList,8,True)
			Set Dic = CreateObject("Scripting.Dictionary")
			For i = 0 To UBound(TempList)
				If Not Dic.Exists(TempList(i)) Then
					Dic.Add(TempList(i),TempArray(i))
				End If
			Next i
			TempArray = ReSplit(DlgText("SrcCPValBox"),ItemJoinStr)
			n = 0
			For i = 0 To UBound(TempArray)
				If Dic.Exists(TempArray(i)) Then
					TempArray(n) = Dic.Item(TempArray(i))
					n = n + 1
				End If
			Next i
			If n > 0 Then
				ReDim Preserve TempArray(n - 1) As String
			Else
				ReDim TempArray(0) As String
			End If
			DlgText "SrcCPTextBox",StrListJoin(TempArray,ItemJoinStr)
			Set Dic = Nothing
		End If

		If DlgText("TrnCPValBox") = "" Then
			TempList = GetLangStrList(AllLangList,7,True)
			TempArray = GetLangStrList(AllLangList,8,True)
			DlgText "TrnCPValBox",StrListJoin(TempList,ItemJoinStr)
			DlgText "TrnCPTextBox",StrListJoin(TempArray,ItemJoinStr)
		Else
			TempList = GetLangStrList(AllLangList,7,True)
			TempArray = GetLangStrList(AllLangList,8,True)
			Set Dic = CreateObject("Scripting.Dictionary")
			For i = 0 To UBound(TempList)
				If Not Dic.Exists(TempList(i)) Then
					Dic.Add(TempList(i),TempArray(i))
				End If
			Next i
			TempArray = ReSplit(DlgText("TrnCPValBox"),ItemJoinStr)
			n = 0
			For i = 0 To UBound(TempArray)
				If Dic.Exists(TempArray(i)) Then
					TempArray(n) = Dic.Item(TempArray(i))
					n = n + 1
				End If
			Next i
			If n > 0 Then
				ReDim Preserve TempArray(n - 1) As String
			Else
				ReDim TempArray(0) As String
			End If
			DlgText "TrnCPTextBox",StrListJoin(TempArray,ItemJoinStr)
			Set Dic = Nothing
		End If

		If CheckStrTypeArray(OrgStrTypeList) = False Then
			DlgEnable "CustomTypeButton",False
		Else
			Set Dic = CreateObject("Scripting.Dictionary")
			n = UBound(OrgStrTypeList)
			ReDim TempList(n) As String
			For i = 0 To n
				TempList(i) = StrTypeToString(OrgStrTypeList,i)
				If Not Dic.Exists(TempList(i)) Then
					Dic.Add(TempList(i),OrgStrTypeList(i).sName)
				End If
			Next i
			n = UBound(UseStrTypeList)
			ReDim TempList(n) As String
			For i = 0 To n
				TempList(i) = StrTypeToString(UseStrTypeList,i)
				If Not Dic.Exists(TempList(i)) Then
					Dic.Add(TempList(i),UseStrTypeList(i).sName)
				End If
			Next i
			n = Dic.Count - 1
			If DlgText("CustomTypeValBox") = "" Then
				ReDim TempList(n) As String,TempArray(n) As String
				For i = 0 To n
					TempList(i) = CStr$(5 + i)
					TempArray(i) = Dic.Items(i)
				Next i
				DlgText "CustomTypeValBox",StrListJoin(TempList,ItemJoinStr)
				DlgText "CustomTypeTextBox",StrListJoin(TempArray,ItemJoinStr)
			Else
				TempArray = ReSplit(DlgText("CustomTypeValBox"),ItemJoinStr)
				For i = 0 To UBound(TempArray)
					j = StrToLong(TempArray(i)) - 5
					If j > -1 And j <= n Then
						TempArray(k) = Dic.Items(j)
						k = k + 1
					End If
				Next i
				If k > 0 Then
					ReDim Preserve TempArray(k - 1) As String
				Else
					ReDim TempArray(0) As String
				End If
				DlgText "CustomTypeTextBox",StrListJoin(TempArray,ItemJoinStr)
			End If
			Set Dic = Nothing
		End If

		If DlgValue("ModeCheckBox") > 0 Then MsgList(38) = MsgList(37)
		n = 0
		For i = 0 To DlgCount() - 1
			DlgItem$ = DlgName(i)
			If InStr(DlgItem$,"TextBox") Then
				DlgEnable DlgItem$,False
			ElseIf InStr(DlgItem$,"ValBox") Then
				DlgVisible DlgItem$,False
				Select Case DlgItem$
				Case "PredefTypeValBox"
					If DlgText(DlgItem$) = "" Then
						DlgText DlgItem$,"0;1;2;3;4;5;6"
						DlgText Replace$(DlgItem$,"ValBox","TextBox"),MsgList(41)
					Else
						TempArray = ReSplit(DlgText(DlgItem$),ItemJoinStr)
						For j = 0 To UBound(TempArray)
							TempArray(j) = ReSplit(MsgList(41),ItemJoinStr)(StrToLong(TempArray(j)))
						Next j
						DlgText Replace$(DlgItem$,"ValBox","TextBox"),StrListJoin(TempArray,ItemJoinStr)
					End If
				Case "DataChangeValBox"
					If DlgText(DlgItem$) = "" Then
						DlgText DlgItem$,"0;1;2;3;4;5;6;7;8;9;10;11;12;13;14;15;16;17;18;19;20"
						DlgText Replace$(DlgItem$,"ValBox","TextBox"),MsgList(48)
					Else
						TempArray = ReSplit(DlgText(DlgItem$),ItemJoinStr)
						For j = 0 To UBound(TempArray)
							TempArray(j) = ReSplit(MsgList(48),ItemJoinStr)(StrToLong(TempArray(j)))
						Next j
						DlgText Replace$(DlgItem$,"ValBox","TextBox"),StrListJoin(TempArray,ItemJoinStr)
					End If
				Case "WriteTypeValBox","OverLengthValBox","SplitStateValBox","MoveModeValBox", _
					"MoveTypeValBox","WriteStateValBox","StrTypeLengthValBox","RefValBox","FillSpaceValBox"
					Select Case DlgItem$
					Case "WriteTypeValBox"
						TempArray = ReSplit(MsgList(38),ItemJoinStr)
					Case "OverLengthValBox"
						TempArray = ReSplit(MsgList(39),ItemJoinStr)
					Case "SplitStateValBox"
						TempArray = ReSplit(MsgList(40),ItemJoinStr)
					Case "MoveModeValBox"
						TempArray = ReSplit(MsgList(42),ItemJoinStr)
					Case "MoveTypeValBox"
						TempArray = ReSplit(MsgList(43),ItemJoinStr)
					Case "WriteStateValBox"
						TempArray = ReSplit(MsgList(44),ItemJoinStr)
					Case "StrTypeLengthValBox"
						TempArray = ReSplit(MsgList(45),ItemJoinStr)
					Case "RefValBox"
						TempArray = ReSplit(MsgList(46),ItemJoinStr)
					Case "FillSpaceValBox"
						TempArray = ReSplit(MsgList(47),ItemJoinStr)
					End Select
					If DlgText(DlgItem$) = "" Then
						DlgText Replace$(DlgItem$,"ValBox","TextBox"),StrListJoin(TempArray,ItemJoinStr)
						If DlgValue("ModeCheckBox") > 0 Then
							TempArray = ReSplit("012345678;0123;012;012345;0123456;012345;012;01;012",ItemJoinStr)
						Else
							TempArray = ReSplit("01234567;0123;012;012345;0123456;012345;012;01;012",ItemJoinStr)
						End If
						DlgText DlgItem$,TempArray(n)
					Else
						For j = 1 To Len(DlgText(DlgItem$))
							TempArray(j - 1) = TempArray(StrToLong(Mid$(DlgText(DlgItem$),j,1)))
						Next j
						ReDim Preserve TempArray(j - 2) As String
						DlgText Replace$(DlgItem$,"ValBox","TextBox"),StrListJoin(TempArray,ItemJoinStr)
					End If
					n = n + 1
				End Select
			ElseIf DlgItem$ = "CustomBox" Then
				If DlgText("CustomBox") = "" Then
					DlgText "CustomBox",IIf(DlgText("CustomBoxBak") = "",MsgList(52),DlgText("CustomBoxBak"))
				End If
				DlgText "CustomBoxBak",MsgList(52)
			End If
		Next i
		'设置当前对话框字体
		If CheckFont(LFList(0)) = True Then
			j = CreateFont(0,LFList(0))
			If j = 0 Then Exit Function
			For i = 0 To DlgCount() - 1
				SendMessageLNG(GetDlgItem(SuppValue,DlgControlId(DlgName(i))),WM_SETFONT,j,0)
			Next i
		End If
	Case 2 ' 数值更改或者按下按钮时
		FilterSetDlgFunc = True ' 防止按下按钮时关闭对话框窗口
		Select Case DlgItem$
		Case "CancelButton"
			FilterSetDlgFunc = False
			Exit Function
		Case "OKButton"
			If DlgValue("CustomGroup") > 0 Then
				If getMsgList(UIDataList,MsgList,"FilterSet",1) = False Then Exit Function
				If DlgText("CustomBox") = "" Then
					MsgBox MsgList(50),vbOkOnly+vbInformation,MsgList(49)
					Exit Function
				End If
				Select Case FilterStr("CheckRegExp",DlgText("CustomBox"),GetFindMode(DlgText("CustomBox")))
				Case -2
					MsgBox MsgList(53),vbOkOnly+vbInformation,MsgList(49)
					Exit Function
				Case -3
					MsgBox MsgList(51),vbOkOnly+vbInformation,MsgList(49)
					Exit Function
				End Select
			End If
			FilterStrSet(0) = CStr$(DlgValue("FilterModeGroup"))
			FilterStrSet(1) = CStr$(DlgValue("inSectionGroup")) & ItemJoinStr & DlgText("inSectionValBox")
			FilterStrSet(2) = CStr$(DlgValue("WriteTypeGroup")) & ItemJoinStr & DlgText("WriteTypeValBox")
			FilterStrSet(3) = CStr$(DlgValue("OverLengthGroup")) & ItemJoinStr & DlgText("OverLengthValBox")
			FilterStrSet(4) = CStr$(DlgValue("SplitStateGroup")) & ItemJoinStr & DlgText("SplitStateValBox")
			FilterStrSet(5) = CStr$(DlgValue("LangGroup")) & ItemJoinStr & DlgText("LangValBox")
			FilterStrSet(6) = CStr$(DlgValue("SrcCPGroup")) & ItemJoinStr & DlgText("SrcCPValBox")
			FilterStrSet(7) = CStr$(DlgValue("TrnCPGroup")) & ItemJoinStr & DlgText("TrnCPValBox")
			FilterStrSet(8) = CStr$(DlgValue("PredefTypeGroup")) & ItemJoinStr & DlgText("PredefTypeValBox")
			FilterStrSet(9) = CStr$(DlgValue("CustomTypeGroup")) & ItemJoinStr & DlgText("CustomTypeValBox")
			FilterStrSet(10) = CStr$(DlgValue("MoveModeGroup")) & ItemJoinStr & DlgText("MoveModeValBox")
			FilterStrSet(11) = CStr$(DlgValue("MoveTypeGroup")) & ItemJoinStr & DlgText("MoveTypeValBox")
			FilterStrSet(12) = CStr$(DlgValue("WriteStateGroup")) & ItemJoinStr & DlgText("WriteStateValBox")
			FilterStrSet(13) = CStr$(DlgValue("StrTypeLengthGroup")) & ItemJoinStr & DlgText("StrTypeLengthValBox")
			FilterStrSet(14) = CStr$(DlgValue("RefGroup")) & ItemJoinStr & DlgText("RefValBox")
			FilterStrSet(15) = CStr$(DlgValue("FillSpaceGroup")) & ItemJoinStr & DlgText("FillSpaceValBox")
			FilterStrSet(16) = CStr$(DlgValue("DataChangeGroup")) & ItemJoinStr & DlgText("DataChangeValBox")
			FilterStrSet(17) = CStr$(DlgValue("FilterStrGroup")) & ItemJoinStr & CStr$(DlgValue("FilterStrAccKeyCheckBox"))
			FilterStrSet(18) = CStr$(DlgValue("LockStateGroup"))
			FilterStrSet(19) = CStr$(DlgValue("NewStrGroup"))
			FilterStrSet(20) = CStr$(DlgValue("iErrorGroup"))
			FilterStrSet(21) = CStr$(DlgValue("OverWriteGroup"))
			FilterStrSet(22) = CStr$(DlgValue("CommentGroup"))
			If DlgText("CustomBox") = DlgText("CustomBoxBak") Then
				FilterStrSet(23) = CStr$(DlgValue("CustomGroup")) & ItemJoinStr & CStr$(DlgValue("CustomAccKeyCheckBox")) & ItemJoinStr
			Else
				FilterStrSet(23) = CStr$(DlgValue("CustomGroup")) & ItemJoinStr & CStr$(DlgValue("CustomAccKeyCheckBox")) & ItemJoinStr & DlgText("CustomBox")
				'添加查找内容
				If DlgText("CustomBox") <> "" And DlgValue("CustomGroup") > 0 Then
					GetHistory(TempList,"Filters","FilterShowSetDlg")
					If InsertArray(TempList,DlgText("CustomBox"),0,True) = True Then
						WriteHistory(TempList,"Filters","FilterShowSetDlg")
					End If
				End If
			End If
			FilterSetDlgFunc = False
			Exit Function
		Case "HelpButton"
			If StrToLong(Selected(30)) = 1 Then
				If DlgValue("TypeCheckBox") = 1 Then
					If OpenCHM(CLng(DlgText("SuppValueBox")),1009,Selected(0),OSLanguage,UIFileList) = True Then Exit Function
				Else
					If OpenCHM(CLng(DlgText("SuppValueBox")),1010,Selected(0),OSLanguage,UIFileList) = True Then Exit Function
				End If
			End If
			Call Help("FilterSetHelp")
		Case "FilterStrButton"
			If EditFilter(ExtractSet,0) = True Then
				ExtractSetBak(34) = ExtractSet(34)
				ExtractSetBak(35) = ExtractSet(35)
				ExtractSetBak(39) = ExtractSet(39)
				WriteSettings("FilterStrDic")
			End If
			TempList = ReSplit(ReadBinaryFile(ExtractSet(35),CP_UNICODELITTLE,True),vbNullChar)
			StrList2StrDic(FilterStrDic,TempList,DlgValue("FilterStrAccKeyCheckBox"),1)
		Case "FilterStrAccKeyCheckBox"
			TempList = ReSplit(ReadBinaryFile(ExtractSet(35),CP_UNICODELITTLE,True),vbNullChar)
			StrList2StrDic(FilterStrDic,TempList,DlgValue("FilterStrAccKeyCheckBox"),1)
		Case "ReverseButton"
			For i = 0 To DlgCount() - 1
				If DlgType(i) = "OptionGroup" Then
					n = DlgValue(DlgName(i))
					If DlgName(i) <> "FilterModeGroup" Then
						DlgValue DlgName(i),IIf(n = 0,1,IIf(n = 1,2,0))
					End If
				End If
			Next i
		Case "ResetButton"
			For i = 0 To DlgCount() - 1
				If DlgType(i) = "OptionGroup" Then
					n = IIf(DlgName(i) = "FilterModeGroup",0,n + 1)
					If FilterStrSet(n) = "" Then
						DlgValue DlgName(i),0
					Else
						DlgValue DlgName(i),StrToLong(ReSplit(FilterStrSet(n),ItemJoinStr)(0))
					End If
				End If
			Next i
		Case "ReposButton"
			For i = 0 To DlgCount() - 1
				If DlgType(i) = "OptionGroup" Then DlgValue DlgName(i),0
			Next i
		Case "inSectionButton"
			If getMsgList(UIDataList,MsgList,"FilterSet",1) = False Then Exit Function
			TempArray = ReSplit(DlgText("inSectionTextBox"),ItemJoinStr)
			TempList = getSectionList(SourceFile.SecList,2)
			Do
				If EditList(TempList,TempArray) = False Then Exit Function
				If CheckArray(TempArray) = True Then Exit Do
				MsgBox MsgList(50),vbOkOnly+vbInformation,MsgList(49)
			Loop
			DlgText "inSectionTextBox",StrListJoin(TempArray,ItemJoinStr)
			Set Dic = CreateObject("Scripting.Dictionary")
			For i = 0 To UBound(TempList)
				If Not Dic.Exists(TempList(i)) Then
					Dic.Add(TempList(i),i)
				End If
			Next i
			TempList = getSectionList(SourceFile.SecList,10)
			For i = 0 To UBound(TempArray)
				If Dic.Exists(TempArray(i)) Then
					TempArray(n) = TempList(Dic.Item(TempArray(i)))
					n = n + 1
				End If
			Next i
			If n > 0 Then n = n - 1
			ReDim Preserve TempArray(n) As String
			DlgText "inSectionValBox",StrListJoin(TempArray,ItemJoinStr)
			Set Dic = Nothing
		Case "LangButton"
			If getMsgList(UIDataList,MsgList,"FilterSet",1) = False Then Exit Function
			TempList = GetLangStrList(AllLangList,0)
			n = UBound(TempList)
			ReDim Preserve TempList(UBound(TempList) + 2) As String
			'添加原列表中没有的英语代码页
			TempList(n + 1) = UniLangList(LangIDIndexDic.Item(1033)).LangName
			'添加原列表中没有的目标代码页
			If TargetFile.hcsFile.FilePath <> SourceFile.hcsFile.FilePath Then
				TempList(n + 2) = UniLangList(LangIDIndexDic.Item(trn.Language.LangID)).LangName
			End If
			TempList = ClearTextArray(TempList,True)
			TempArray = ReSplit(DlgText("LangTextBox"),ItemJoinStr)
			Do
				If EditList(TempList,TempArray) = False Then Exit Function
				If CheckArray(TempArray) = True Then Exit Do
				MsgBox MsgList(50),vbOkOnly+vbInformation,MsgList(49)
			Loop
			DlgText "LangTextBox",StrListJoin(TempArray,ItemJoinStr)
			Set Dic = CreateObject("Scripting.Dictionary")
			For i = 0 To UBound(UniLangList)
				If Not Dic.Exists(UniLangList(i).LangName) Then
					Dic.Add(UniLangList(i).LangName,UniLangList(i).LangID)
				End If
			Next i
			n = 0
			For i = 0 To UBound(TempArray)
				If Dic.Exists(TempArray(i)) Then
					TempArray(n) = CStr$(Dic.Item(TempArray(i)))
					n = n + 1
				End If
			Next i
			If n > 0 Then n = n - 1
			ReDim Preserve TempArray(n) As String
			DlgText "LangValBox",StrListJoin(TempArray,ItemJoinStr)
			Set Dic = Nothing
		Case "SrcCPButton"
			If getMsgList(UIDataList,MsgList,"FilterSet",1) = False Then Exit Function
			TempList = GetLangStrList(AllLangList,8,True)
			TempArray = ReSplit(DlgText("SrcCPTextBox"),ItemJoinStr)
			Do
				If EditList(TempList,TempArray) = False Then Exit Function
				If CheckArray(TempArray) = True Then Exit Do
				MsgBox MsgList(50),vbOkOnly+vbInformation,MsgList(49)
			Loop
			DlgText "SrcCPTextBox",StrListJoin(TempArray,ItemJoinStr)
			Set Dic = CreateObject("Scripting.Dictionary")
			For i = 0 To UBound(TempList)
				If Not Dic.Exists(TempList(i)) Then
					Dic.Add(TempList(i),i)
				End If
			Next i
			TempList = GetLangStrList(AllLangList,7,True)
			For i = 0 To UBound(TempArray)
				If Dic.Exists(TempArray(i)) Then
					TempArray(n) = TempList(Dic.Item(TempArray(i)))
					n = n + 1
				End If
			Next i
			If n > 0 Then n = n - 1
			ReDim Preserve TempArray(n) As String
			DlgText "SrcCPValBox",StrListJoin(TempArray,ItemJoinStr)
			Set Dic = Nothing
		Case "TrnCPButton"
			If getMsgList(UIDataList,MsgList,"FilterSet",1) = False Then Exit Function
			TempList = GetLangStrList(AllLangList,8,True)
			TempArray = ReSplit(DlgText("TrnCPTextBox"),ItemJoinStr)
			Do
				If EditList(TempList,TempArray) = False Then Exit Function
				If CheckArray(TempArray) = True Then Exit Do
				MsgBox MsgList(50),vbOkOnly+vbInformation,MsgList(49)
			Loop
			DlgText "TrnCPTextBox",StrListJoin(TempArray,ItemJoinStr)
			Set Dic = CreateObject("Scripting.Dictionary")
			For i = 0 To UBound(TempList)
				If Not Dic.Exists(TempList(i)) Then
					Dic.Add(TempList(i),i)
				End If
			Next i
			TempList = GetLangStrList(AllLangList,7,True)
			For i = 0 To UBound(TempArray)
				If Dic.Exists(TempArray(i)) Then
					TempArray(n) = TempList(Dic.Item(TempArray(i)))
					n = n + 1
				End If
			Next i
			If n > 0 Then n = n - 1
			ReDim Preserve TempArray(n) As String
			DlgText "TrnCPValBox",StrListJoin(TempArray,ItemJoinStr)
			Set Dic = Nothing
		Case "CustomTypeButton"
			If getMsgList(UIDataList,MsgList,"FilterSet",1) = False Then Exit Function
			Set Dic = CreateObject("Scripting.Dictionary")
			n = UBound(OrgStrTypeList)
			ReDim TempList(n) As String
			For i = 0 To n
				TempList(i) = StrTypeToString(OrgStrTypeList,i)
				If Not Dic.Exists(TempList(i)) Then
					Dic.Add(TempList(i),OrgStrTypeList(i).sName)
				End If
			Next i
			n = UBound(UseStrTypeList)
			ReDim TempList(n) As String
			For i = 0 To n
				TempList(i) = StrTypeToString(UseStrTypeList,i)
				If Not Dic.Exists(TempList(i)) Then
					Dic.Add(TempList(i),UseStrTypeList(i).sName)
				End If
			Next i
			n = Dic.Count - 1
			ReDim TempList(n) As String
			For i = 0 To n
				TempList(i) = Dic.Items(i)
				If Not Dic.Exists(Dic.Items(i)) Then
					Dic.Key(Dic.Keys(i)) = Dic.Items(i)
					Dic.Item(Dic.Items(i)) = i
				End If
			Next i
			TempArray = ReSplit(DlgText("CustomTypeTextBox"),ItemJoinStr)
			Do
				If EditList(TempList,TempArray) = False Then
					Set Dic = Nothing
					Exit Function
				End If
				If CheckArray(TempArray) = True Then Exit Do
				MsgBox MsgList(50),vbOkOnly+vbInformation,MsgList(49)
			Loop
			DlgText "CustomTypeTextBox",StrListJoin(TempArray,ItemJoinStr)
			n = 0
			For i = 0 To UBound(TempArray)
				If Dic.Exists(TempArray(i)) Then
					TempArray(n) = CStr$(5 + Dic.Item(TempArray(i)))
					n = n + 1
				End If
			Next i
			If n > 0 Then n = n - 1
			ReDim Preserve TempArray(n) As String
			DlgText "CustomTypeValBox",StrListJoin(TempArray,ItemJoinStr)
			Set Dic = Nothing
		Case "WriteTypeButton","OverLengthButton","SplitStateButton","PredefTypeButton","MoveModeButton", _
			"MoveTypeButton","WriteStateButton","StrTypeLengthButton","RefButton","FillSpaceButton","DataChangeButton"
			If getMsgList(UIDataList,MsgList,"FilterSet",1) = False Then Exit Function
			If DlgValue("ModeCheckBox") > 0 Then MsgList(38) = MsgList(37)
			Select Case DlgItem$
			Case "WriteTypeButton"
				TempList = ReSplit(MsgList(38),ItemJoinStr)
			Case "OverLengthButton"
				TempList = ReSplit(MsgList(39),ItemJoinStr)
			Case "SplitStateButton"
				TempList = ReSplit(MsgList(40),ItemJoinStr)
			Case "PredefTypeButton"
				TempList = ReSplit(MsgList(41),ItemJoinStr)
			Case "MoveModeButton"
				TempList = ReSplit(MsgList(42),ItemJoinStr)
			Case "MoveTypeButton"
				TempList = ReSplit(MsgList(43),ItemJoinStr)
			Case "WriteStateButton"
				TempList = ReSplit(MsgList(44),ItemJoinStr)
			Case "StrTypeLengthButton"
				TempList = ReSplit(MsgList(45),ItemJoinStr)
			Case "RefButton"
				TempList = ReSplit(MsgList(46),ItemJoinStr)
			Case "FillSpaceButton"
				TempList = ReSplit(MsgList(47),ItemJoinStr)
			Case "DataChangeButton"
				TempList = ReSplit(MsgList(48),ItemJoinStr)
			End Select
			TempArray = ReSplit(DlgText(Replace$(DlgItem$,"Button","TextBox")),ItemJoinStr)
			Do
				If EditList(TempList,TempArray) = False Then Exit Function
				If CheckArray(TempArray) = True Then Exit Do
				MsgBox MsgList(50),vbOkOnly+vbInformation,MsgList(49)
			Loop
			DlgText Replace$(DlgItem$,"Button","TextBox"),StrListJoin(TempArray,ItemJoinStr)
			Set Dic = CreateObject("Scripting.Dictionary")
			For i = 0 To UBound(TempList)
				If Not Dic.Exists(TempList(i)) Then
					Dic.Add(TempList(i),i)
				End If
			Next i
			For i = 0 To UBound(TempArray)
				If Dic.Exists(TempArray(i)) Then
					TempArray(n) = CStr$(Dic.Item(TempArray(i)))
					n = n + 1
				End If
			Next i
			If n > 0 Then n = n - 1
			ReDim Preserve TempArray(n) As String
			Select Case DlgItem$
			Case "PredefTypeButton","DataChangeButton"
				DlgText Replace$(DlgItem$,"Button","ValBox"),StrListJoin(TempArray,ItemJoinStr)
			Case Else
				DlgText Replace$(DlgItem$,"Button","ValBox"),StrListJoin(TempArray,"")
			End Select
			Set Dic = Nothing
		Case "PredefTypeGroup"
			i = DlgValue("PredefTypeGroup")
			If i = 0 Then Exit Function
			If DlgValue("CustomTypeGroup") <> i Then DlgValue "CustomTypeGroup",0
		Case "CustomTypeGroup"
			i = DlgValue("CustomTypeGroup")
			If i = 0 Then Exit Function
			If DlgValue("PredefTypeGroup") <> i Then DlgValue "PredefTypeGroup",0
		Case "RegExpTipButton"
			If getMsgList(UIDataList,MsgList,"RegExpRuleTip",1) = False Then Exit Function
			i = ShowPopupMenu(MsgList,vbPopupUseRightButton)
			If i < 0 Then Exit Function
			If i = UBound(MsgList) Then
				If StrToLong(Selected(30)) = 1 Then
					If OpenCHM(CLng(DlgText("SuppValueBox")),1022,Selected(0),OSLanguage,UIFileList) = True Then Exit Function
				End If
				Call Help("RegExpRuleHelp")
				Exit Function
			End If
			If DlgText("CustomBox") = "" Then
				DlgText "CustomBox",Mid$(MsgList(i),InStrRev(MsgList(i),vbTab) + 1)
			Else
				DlgFocus("CustomBox")  '设置焦点到文本框
				DlgText "CustomBox",InsertStr(GetFocus(),DlgText("CustomBox"), _
						Mid$(MsgList(i),InStrRev(MsgList(i),vbTab) + 1))
			End If
		Case "FavoriteButton"
			If getMsgList(UIDataList,MsgList,"EditFavority",1) = False Then Exit Function
			TempList = ReSplit(MsgList(25),ItemJoinStr)
			If UBound(TempList) < 7 Then Exit Function
			TempList(2) = ""
			TempList(4) = TempList(4) & " - " & NoVowelsRegExp
			TempList(5) = TempList(5) & " - " & FilePathRegExp
			TempList(6) = TempList(6) & " - " & RegKeyRegExp
			TempList(7) = TempList(7) & " - " & WebSiteRegExp
			GetHistory(TempList,"Favorites","FilterShowSetDlg"," - ")
			n = 4
			For i = 4 To UBound(TempList)
				If CheckStrRegExp(TempList(i),"^\(\(.+?\)\)\|\(\(.+?\)\)$",0,5) = False Then
					TempList(n) = TempList(i)
					n = n + 1
				End If
			Next i
			If n > 0 Then n = n - 1
			ReDim Preserve TempList(n) As String
			i = ShowPopupMenu(TempList,vbPopupUseRightButton)
			Select Case i
			Case Is < 0
				Exit Function
			Case 0
				If DlgText("CustomBox") = "" Then
					MsgBox MsgList(26),vbOkOnly+vbInformation,MsgList(19)
					Exit Function
				End If
				Select Case GetFindMode(DlgText("CustomBox"))
				Case 1
					If FilterStr("CheckRegExp",DlgText("CustomBox"),1) = -2 Then
						MsgBox MsgList(32),vbOkOnly+vbInformation,MsgList(19)
						Exit Function
					End If
				Case 2
					If CheckRegExp(RegExp,DlgText("CustomBox")) = False Then
						MsgBox MsgList(27),vbOkOnly+vbInformation,MsgList(19)
						Exit Function
					End If
					If CheckStrRegExp(DlgText("CustomBox"),"^\(\(.+?\)\)\|\(\(.+?\)\)$",0,5) Then
						MsgBox MsgList(29),vbOkOnly+vbInformation,MsgList(19)
						Exit Function
					End If
					For i = 4 To UBound(TempList)
						If InStr(TempList(i)," - ") Then
							If ReSplit(TempList(i)," - ",2)(1) = DlgText("CustomBox") Then
								MsgBox MsgList(28),vbOkOnly+vbInformation,MsgList(19)
								Exit Function
							End If
						End If
					Next i
				End Select
				GetHistory(TempList,"Favorites","FilterShowSetDlg")
				For i = 0 To UBound(TempList)
					If InStr(TempList(i)," - ") Then
						If ReSplit(TempList(i)," - ",2)(1) = DlgText("CustomBox") Then
							MsgBox MsgList(28),vbOkOnly+vbInformation,MsgList(19)
							Exit Function
						End If
					End If
				Next i
				ReDim TempArray(0) As String
				Do
					TempArray(0) = Trim$(InputBox(MsgList(15),MsgList(14),TempArray(0)))
					If TempArray(0) = "" Then Exit Function
					If InStr(TempArray(0)," - ") = 0 Then Exit Do
					MsgBox MsgList(20),vbOkOnly+vbInformation,MsgList(19)
				Loop
				i = IIf(CheckArray(TempList) = False,0,UBound(TempList) + 1)
				If InsertArray(TempList,TempArray(0) & " - " & DlgText("CustomBox"),i,True) = True Then
					WriteHistory(TempList,"Favorites","FilterShowSetDlg",True)
				End If
			Case 1
				GetHistory(TempList,"Favorites","FilterShowSetDlg")
				If EditFavority(TempList,3) = True Then
					WriteHistory(TempList,"Favorites","FilterShowSetDlg",True)
				End If
			Case 3
				Set Dic = CreateObject("Scripting.Dictionary")
				If CheckStrRegExp(DlgText("CustomBox"),"^\(\(.+?\)\)\|\(\(.+?\)\)$",0,5) Then
					TempArray = ReSplit(DlgText("CustomBox"),"))|((",-1)
					i = UBound(TempArray)
					TempArray(0) = Mid$(TempArray(0),3)
					TempArray(i) = Left$(TempArray(i),Len(TempArray(i)) - 2)
				Else
					ReDim TempArray(0) As String
					TempArray(0) = DlgText("CustomBox")
				End If
				For i = 0 To UBound(TempArray)
					If Not Dic.Exists(TempArray(i)) Then Dic.Add(TempArray(i),i)
				Next i
				ReDim TempArray(UBound(TempList)) As String
				n = 0
				For i = 4 To UBound(TempList)
					MsgList = ReSplit(TempList(i)," - ",2)
					If Dic.Exists(MsgList(1)) Then
						TempArray(n) = MsgList(0)
						n = n + 1
					End If
					If Not Dic.Exists(MsgList(0)) Then Dic.Add(MsgList(0),MsgList(1))
					TempList(i - 4) = MsgList(0)
				Next i
				If n > 0 Then n = n - 1
				ReDim Preserve TempArray(n) As String,TempList(i - 5) As String
				If EditList(TempList,TempArray) = False Then
					Set Dic = Nothing
					Exit Function
				End If
				For i = 0 To UBound(TempArray)
					If Dic.Exists(TempArray(i)) Then TempArray(i) = Dic.Item(TempArray(i))
				Next i
				Set Dic = Nothing
				If i = 1 Then
					DlgText "CustomBox",TempArray(0)
				Else
					DlgText "CustomBox","((" & StrListJoin(TempArray,"))|((") & "))"
				End If
			Case Is > 3
				TempList = ReSplit(TempList(i)," - ",2)
				If UBound(TempList) > 0 Then DlgText "CustomBox",TempList(1)
			End Select
			Exit Function
		End Select
	Case 3 ' 文本框或者组合框文本被更改
		If DlgItem$ = "CustomBox" Then
			If DlgValue("CustomGroup") = 0 Then Exit Function
			If DlgText("CustomBox") = DlgText("CustomBoxBak") Then Exit Function
			If DlgText("CustomBox") = "" Then
				If getMsgList(UIDataList,MsgList,"FilterSet",1) = False Then Exit Function
				MsgBox MsgList(50),vbOkOnly+vbInformation,MsgList(49)
				Exit Function
			End If
			Select Case FilterStr("CheckRegExp",DlgText("CustomBox"),GetFindMode(DlgText("CustomBox")))
			Case -2
				If getMsgList(UIDataList,MsgList,"FilterSet",1) = False Then Exit Function
				MsgBox MsgList(53),vbOkOnly+vbInformation,MsgList(49)
			Case -3
				If getMsgList(UIDataList,MsgList,"FilterSet",1) = False Then Exit Function
				MsgBox MsgList(51),vbOkOnly+vbInformation,MsgList(49)
			End Select
		End If
	Case 6 ' 函数快捷键
		Select Case SuppValue
		Case 1
			If StrToLong(Selected(30)) = 1 Then
				If DlgValue("TypeCheckBox") = 1 Then
					If OpenCHM(CLng(DlgText("SuppValueBox")),1009,Selected(0),OSLanguage,UIFileList) = True Then Exit Function
				Else
					If OpenCHM(CLng(DlgText("SuppValueBox")),1010,Selected(0),OSLanguage,UIFileList) = True Then Exit Function
				End If
			End If
			Call Help("FilterSetHelp")
		Case 2
			If getMsgList(UIDataList,MsgList,"RegExpRuleTip",1) = False Then Exit Function
			i = ShowPopupMenu(MsgList,vbPopupUseRightButton)
			If i < 0 Then Exit Function
			If i = UBound(MsgList) Then
				If StrToLong(Selected(30)) = 1 Then
					If OpenCHM(CLng(DlgText("SuppValueBox")),1022,Selected(0),OSLanguage,UIFileList) = True Then Exit Function
				End If
				Call Help("RegExpRuleHelp")
				Exit Function
			End If
			If DlgText("CustomBox") = "" Then
				DlgText "CustomBox",Mid$(MsgList(i),InStrRev(MsgList(i),vbTab) + 1)
			Else
				DlgFocus("CustomBox")  '设置焦点到文本框
				DlgText "CustomBox",InsertStr(GetFocus(),DlgText("CustomBox"), _
						Mid$(MsgList(i),InStrRev(MsgList(i),vbTab) + 1))
			End If
		End Select
	End Select
End Function


'编辑收藏夹对话框
Public Function EditFavority(FavorityList() As String,ByVal Mode As Long) As Boolean
	Dim MsgList() As String
	If getMsgList(UIDataList,MsgList,"EditFavority",1) = False Then Exit Function
	AllStrList = FavorityList: UseStrList = FavorityList
	Begin Dialog UserDialog 560,259,MsgList(0),.EditFavorityDlgFunc ' %GRID:10,7,1,1
		TextBox 0,0,30,21,.SuppValueBox
		TextBox 0,0,30,21,.ModeTextBox
		TextBox 0,0,30,21,.CheckTextBox
		Text 20,4,400,14,MsgList(1),.ItemText
		ListBox 20,21,400,112,FavorityList(),.FavorityList,1
		Text 20,138,400,14,MsgList(2),.NameText
		TextBox 20,154,400,21,.NameTextBox
		Text 20,179,400,14,IIf(Mode = 0,MsgList(3),IIf(Mode = 1,MsgList(4),IIf(Mode = 2,MsgList(5),MsgList(6)))),.ContentText
		TextBox 20,196,400,49,.ContentTextBox,1
		PushButton 440,224,100,21,MsgList(7),.RegExpTipButton
		PushButton 440,21,100,21,MsgList(8),.AddButton
		PushButton 440,42,100,21,MsgList(9),.DelButton
		PushButton 440,70,100,21,MsgList(10),.UpButton
		PushButton 440,91,100,21,MsgList(11),.DownButton
		PushButton 440,119,100,21,MsgList(12),.CleanButton
		PushButton 440,140,100,21,MsgList(13),.ResetButton
		OKButton 440,168,100,21,.OKButton
		CancelButton 440,189,100,21,.CancelButton
	End Dialog
	Dim dlg As UserDialog
	dlg.ModeTextBox = CStr$(Mode)
	If Dialog(dlg) = 0 Then Exit Function
	If ArrayComp(UseStrList,AllStrList) = True Then
		EditFavority = True
		FavorityList = UseStrList
	End If
	Erase UseStrList,AllStrList
End Function


'编辑收藏夹对话框函数
Private Function EditFavorityDlgFunc(DlgItem$, Action%, SuppValue&) As Boolean
	Dim i As Long,j As Long,Temp As String,MsgList() As String
	Select Case Action%
	Case 1 ' 对话框窗口初始化
		DlgText "SuppValueBox",CStr$(SuppValue)
		DlgVisible "ModeTextBox",False
		DlgVisible "CheckTextBox",False
		DlgVisible "SuppValueBox",False
		If StrToLong(DlgText("ModeTextBox")) < 2 Then DlgEnable "RegExpTipButton",False
		If getMsgList(UIDataList,MsgList,"EditFavority",1) = False Then Exit Function
		If UBound(UseStrList) = 0 Then
			DlgEnable "UpButton",False
			DlgEnable "DownButton",False
		Else
			Select Case DlgValue("FavorityList")
			Case Is < 0
				DlgEnable "DelButton",False
				DlgEnable "UpButton",False
				DlgEnable "DownButton",False
			Case 0
				DlgEnable "UpButton",False
			Case DlgListBoxArray("FavorityList") - 1
				DlgEnable "DownButton",False
			End Select
		End If
		If DlgListBoxArray("FavorityList") = 0 Then
			DlgEnable "NameTextBox",False
			DlgEnable "ContentTextBox",False
			DlgEnable "RegExpTipButton",False
			DlgEnable "DelButton",False
			DlgEnable "CleanButton",False
			DlgText "ItemText",Replace$(MsgList(1),"%s","0")
		Else
			DlgText "NameTextBox",ReSplit(UseStrList(0)," - ",2)(0)
			If InStr(UseStrList(i)," - ") Then
				DlgText "ContentTextBox",ReSplit(UseStrList(0)," - ",2)(1)
			Else
				DlgText "ContentTextBox",""
			End If
			DlgText "ItemText",Replace$(MsgList(1),"%s",CStr$(UBound(UseStrList) + 1))
		End If
		DlgEnable "ResetButton",False
		DlgText "CheckTextBox","0"
		'设置当前对话框字体
		If CheckFont(LFList(0)) = True Then
			j = CreateFont(0,LFList(0))
			If j = 0 Then Exit Function
			For i = 0 To DlgCount() - 1
				SendMessageLNG(GetDlgItem(SuppValue,DlgControlId(DlgName(i))),WM_SETFONT,j,0)
			Next i
		End If
	Case 2 ' 数值更改或者按下了按钮
	 	EditFavorityDlgFunc = True	' 防止按下按钮关闭对话框窗口
		Select Case DlgItem$
		Case "CancelButton"
			EditFavorityDlgFunc = False
			Exit Function
		Case "OKButton"
			If CheckArray(UseStrList) = True Then
				For i = 0 To UBound(UseStrList)
					If InStr(UseStrList(i)," - ") Then
						Temp = ReSplit(UseStrList(i)," - ",2)(1)
						If Temp = "" Then
							If getMsgList(UIDataList,MsgList,"EditFavority",1) = False Then Exit Function
							Temp = Replace$(Replace$(MsgList(24),"%s",ReSplit(UseStrList(i)," - ",2)(0)),"%d",MsgList(33))
							MsgBox Temp,vbOkOnly+vbInformation,MsgList(19)
							Exit Function
						End If
						Select Case FilterStr("CheckRegExp",Temp,GetFindMode(Temp))
						Case -2
							If getMsgList(UIDataList,MsgList,"EditFavority",1) = False Then Exit Function
							Temp = Replace$(Replace$(MsgList(24),"%s",ReSplit(UseStrList(i)," - ",2)(0)),"%d",MsgList(31))
							MsgBox Temp,vbOkOnly+vbInformation,MsgList(19)
							Exit Function
						Case -3
							If getMsgList(UIDataList,MsgList,"EditFavority",1) = False Then Exit Function
							Temp = Replace$(Replace$(MsgList(24),"%s",ReSplit(UseStrList(i)," - ",2)(0)),"%d",MsgList(23))
							MsgBox Temp,vbOkOnly+vbInformation,MsgList(19)
							Exit Function
						End Select
					End If
				Next i
			End If
			EditFavorityDlgFunc = False
			Exit Function
		Case "AddButton"
			If getMsgList(UIDataList,MsgList,"EditFavority",1) = False Then Exit Function
			If DlgListBoxArray("FavorityList") > 0 Then
				i = UBound(UseStrList) + 1
			End If
			Do
				Temp = Trim$(InputBox(MsgList(15),MsgList(14),Temp))
				If Temp = "" Then Exit Function
				If InStr(Temp," - ") = 0 Then Exit Do
				MsgBox MsgList(20),vbOkOnly+vbInformation,MsgList(19)
			Loop
			InsertArray(UseStrList,Temp & " - ",i,True)
			DlgListBoxArray "FavorityList",UseStrList()
			DlgValue "FavorityList",i
			DlgEnable "CleanButton",True
			DlgText "ItemText",Replace$(MsgList(1),"%s",CStr$(UBound(UseStrList) + 1))
			DlgItem$ = "FavorityList"
		Case "DelButton"
			i = DlgValue("FavorityList")
			If i < 0 Then Exit Function
			If getMsgList(UIDataList,MsgList,"EditFavority",1) = False Then Exit Function
			If MsgBox(MsgList(17),vbYesNo+vbInformation,MsgList(16)) = vbNo Then Exit Function
			Call DelArray(UseStrList,i)
			If i > 0 And i = UBound(UseStrList) + 1 Then i = i - 1
			DlgListBoxArray "FavorityList",UseStrList()
			DlgValue "FavorityList",i
			If DlgValue("FavorityList") < 0 Then
				DlgEnable "CleanButton",False
				DlgText "ItemText",Replace$(MsgList(1),"%s","0")
			Else
				DlgEnable "CleanButton",True
				DlgText "ItemText",Replace$(MsgList(1),"%s",CStr$(UBound(UseStrList) + 1))
			End If
			DlgItem$ = "FavorityList"
		Case "UpButton"
			i = DlgValue("FavorityList")
			If i = 0 Then Exit Function
			Temp = UseStrList(i)
			UseStrList(i) = UseStrList(i - 1)
			UseStrList(i - 1) = Temp
			DlgListBoxArray "FavorityList",UseStrList()
			DlgValue "FavorityList",i - 1
		Case "DownButton"
			i = DlgValue("FavorityList")
			If i = UBound(UseStrList) Then Exit Function
			Temp = UseStrList(i)
			UseStrList(i) = UseStrList(i + 1)
			UseStrList(i + 1) = Temp
			DlgListBoxArray "FavorityList",UseStrList()
			DlgValue "FavorityList",i + 1
		Case "ResetButton"
			If getMsgList(UIDataList,MsgList,"EditFavority",1) = False Then Exit Function
			UseStrList = AllStrList
			DlgListBoxArray "FavorityList",UseStrList()
			DlgValue "FavorityList",0
			If DlgValue("FavorityList") < 0 Then
				DlgEnable "NameTextBox",False
				DlgEnable "ContentTextBox",False
				DlgEnable "CleanButton",False
				DlgText "ItemText",Replace$(MsgList(1),"%s","0")
			Else
				DlgEnable "NameTextBox",True
				DlgEnable "ContentTextBox",True
				DlgEnable "CleanButton",True
				DlgText "ItemText",Replace$(MsgList(1),"%s",CStr$(UBound(UseStrList) + 1))
			End If
			DlgItem$ = "FavorityList"
		Case "CleanButton"
			If getMsgList(UIDataList,MsgList,"EditFavority",1) = False Then Exit Function
			If MsgBox(MsgList(18),vbYesNo+vbInformation,MsgList(16)) = vbNo Then Exit Function
			ReDim UseStrList(0) As String
			DlgListBoxArray "FavorityList",UseStrList()
			DlgValue "FavorityList",0
			DlgEnable "CleanButton",False
			DlgEnable "ResetButton",True
			DlgText "ItemText",Replace$(MsgList(1),"%s","0")
			DlgItem$ = "FavorityList"
		Case "RegExpTipButton"
			If getMsgList(UIDataList,MsgList,"RegExpRuleTip",1) = False Then Exit Function
			i = ShowPopupMenu(MsgList,vbPopupUseRightButton)
			If i < 0 Then Exit Function
			If i = UBound(MsgList) Then
				If StrToLong(Selected(30)) = 1 Then
					If OpenCHM(CLng(DlgText("SuppValueBox")),1022,Selected(0),OSLanguage,UIFileList) = True Then Exit Function
				End If
				Call Help("RegExpRuleHelp")
				Exit Function
			End If
			DlgText "ContentTextBox",DlgText("ContentTextBox") & Mid$(MsgList(i),InStrRev(MsgList(i),vbTab) + 1)
			Exit Function
		End Select
		If DlgItem$ = "FavorityList" Then
			i = DlgValue("FavorityList")
			If i < 0 Then
				DlgText "NameTextBox",""
				DlgText "ContentTextBox",""
			Else
				DlgText "NameTextBox",ReSplit(UseStrList(i)," - ",2)(0)
				If InStr(UseStrList(i)," - ") Then
					DlgText "ContentTextBox",ReSplit(UseStrList(i)," - ",2)(1)
				Else
					DlgText "ContentTextBox",""
				End If
			End If
		End If
		If DlgValue("FavorityList") < 0 Then
			DlgEnable "NameTextBox",False
			DlgEnable "ContentTextBox",False
			DlgEnable "RegExpTipButton",False
			DlgEnable "DelButton",False
			DlgEnable "UpButton",False
			DlgEnable "DownButton",False
		Else
			DlgEnable "NameTextBox",True
			DlgEnable "ContentTextBox",True
			DlgEnable "RegExpTipButton",True
			DlgEnable "DelButton",True
			If UBound(UseStrList) = 0 Then
				DlgEnable "UpButton",False
				DlgEnable "DownButton",False
			Else
				Select Case DlgValue("FavorityList")
				Case 0
					DlgEnable "UpButton",False
					DlgEnable "DownButton",True
				Case DlgListBoxArray("FavorityList") - 1
					DlgEnable "UpButton",True
					DlgEnable "DownButton",False
				Case Else
					DlgEnable "UpButton",True
					DlgEnable "DownButton",True
				End Select
			End If
		End If
		DlgText "CheckTextBox",CStr$(IIf(DlgValue("FavorityList") < 0,0,DlgValue("FavorityList")))
		DlgEnable "ResetButton",ArrayComp(UseStrList,AllStrList)
	Case 3 ' 文本框或者组合框文本被更改
		Select Case DlgItem$
		Case "NameTextBox"
			If DlgEnable("NameTextBox") = False Then Exit Function
			If DlgText("NameTextBox") = "" Then Exit Function
			If DlgText("CheckTextBox") = "" Then
				i = DlgValue("FavorityList")
			Else
				i = StrToLong(DlgText("CheckTextBox"))
			End If
			If i < 0 Then Exit Function
			If ReSplit(UseStrList(i)," - ",2)(0) = DlgText("NameTextBox") Then Exit Function
			If InStr(DlgText("NameTextBox")," - ") Then
				If getMsgList(UIDataList,MsgList,"EditFavority",1) = False Then Exit Function
				MsgBox MsgList(20),vbOkOnly+vbInformation,MsgList(19)
				Exit Function
			End If
			UseStrList(i) = DlgText("NameTextBox") & " - " & DlgText("ContentTextBox")
			DlgListBoxArray "FavorityList",UseStrList()
			DlgValue "FavorityList",i
			DlgEnable "ResetButton",ArrayComp(UseStrList,AllStrList)
		Case "ContentTextBox"
			If DlgEnable("ContentTextBox") = False Then Exit Function
			If DlgText("ContentTextBox") = "" Then
				If getMsgList(UIDataList,MsgList,"EditFavority",1) = False Then Exit Function
				MsgBox MsgList(21),vbOkOnly+vbInformation,MsgList(19)
				Exit Function
			End If
			If DlgText("CheckTextBox") = "" Then
				i = DlgValue("FavorityList")
			Else
				i = StrToLong(DlgText("CheckTextBox"))
			End If
			If i < 0 Then Exit Function
			DlgText "ContentTextBox",ReConvert(DlgText("ContentTextBox"),3)
			If InStr(DlgText("ContentTextBox"),"\\") Then
				DlgText "ContentTextBox",Replace$(DlgText("ContentTextBox"),"\\","\")
			End If
			If InStr(UseStrList(i)," - ") Then
				If ReSplit(UseStrList(i)," - ",2)(1) = DlgText("ContentTextBox") Then Exit Function
			End If
			For j = 0 To UBound(UseStrList)
				If InStr(UseStrList(j)," - ") Then
					If ReSplit(UseStrList(j)," - ",2)(1) = DlgText("ContentTextBox") Then
						If getMsgList(UIDataList,MsgList,"EditFavority",1) = False Then Exit Function
						MsgBox MsgList(22),vbOkOnly+vbInformation,MsgList(19)
						Exit Function
					End If
				End If
			Next j
			Select Case FilterStr("CheckRegExp",DlgText("ContentTextBox"),GetFindMode(DlgText("ContentTextBox")))
			Case -2
				If getMsgList(UIDataList,MsgList,"EditFavority",1) = False Then Exit Function
				MsgBox MsgList(31),vbOkOnly+vbInformation,MsgList(19)
			Case -3
				If getMsgList(UIDataList,MsgList,"EditFavority",1) = False Then Exit Function
				MsgBox MsgList(23),vbOkOnly+vbInformation,MsgList(19)
			End Select
			UseStrList(i) = DlgText("NameTextBox") & " - " & DlgText("ContentTextBox")
			DlgListBoxArray "FavorityList",UseStrList()
			DlgValue "FavorityList",i
			DlgEnable "ResetButton",ArrayComp(UseStrList,AllStrList)
		End Select
	End Select
End Function


'编辑保留或过滤字串列表
'Mode = 0 编辑过滤字串列表，否则编辑保留字串列表
Public Function EditFilter(OptionSet() As String,Optional ByVal Mode As Long) As Boolean
	Dim MsgList() As String
	If getMsgList(UIDataList,MsgList,"EditFilter",1) = False Then Exit Function
	Begin Dialog UserDialog 660,553,IIf(Mode = 0,MsgList(0),MsgList(1)),.EditFilterDlgFunc ' %GRID:10,7,1,1
		CheckBox 10,7,80,14,"",.ModeCheckBox
		PushButton 10,7,80,21,"",.TempButton '为默认热点，以免双击列表框都添加文件
		TextBox 10,7,80,14,.SuppValueBox
		DropListBox 10,7,360,21,AllStrList(),.FileList
		PushButton 380,7,90,21,MsgList(2),.AddFileButton
		PushButton 470,7,90,21,MsgList(3),.ChangeFileButton
		PushButton 560,7,90,21,MsgList(4),.DelFileButton
		PushButton 610,35,30,21,MsgList(5),.FileLocPushButton
		TextBox 30,35,580,21,.FileLocTextBox
		TextBox 30,35,580,21,.FileLocTextBoxBak
		OptionGroup .FileLocOption
			OptionButton 30,63,620,14,"",.UseMacroLocFileBox
			OptionButton 30,63,620,14,"",.UsePrjLocFileBox
			OptionButton 30,63,620,14,"",.CustomLocFileBox
		CheckBox 30,63,620,14,MsgList(7),.AutoSelectBox
		Text 10,87,140,14,MsgList(8),.Text
		DropListBox 160,84,330,21,MsgList(),.FindTextBox,1
		MultiListBox 10,112,510,343,UseStrList(),.UseStrList,1
		TextBox 10,462,510,84,.StrTextBox,1
		PushButton 530,84,120,21,MsgList(9),.FindButton
		PushButton 530,105,120,21,MsgList(10),.FilterShowButton
		PushButton 530,126,120,21,MsgList(11),.AllShowButton
		PushButton 490,84,30,21,MsgList(12),.RegExpTipButton
		PushButton 530,154,120,21,MsgList(13),.AddButton
		PushButton 530,175,120,21,MsgList(14),.DelButton
		PushButton 530,196,120,21,MsgList(15),.CopyButton
		PushButton 530,217,120,21,MsgList(16),.AllSelectButton
		PushButton 530,245,120,21,MsgList(17),.CleanButton
		PushButton 530,266,120,21,MsgList(18),.ResetButton
		PushButton 530,287,120,21,MsgList(19),.DefaultButton
		PushButton 530,308,120,21,MsgList(20),.ReadFileButton
		PushButton 530,336,120,21,MsgList(21),.ImportButton
		PushButton 530,357,120,21,MsgList(22),.ExportButton
		Text 530,462,120,14,MsgList(23),.OptionText
		CheckBox 530,479,120,14,MsgList(24),.MatchCaseBox
		CheckBox 530,497,120,14,MsgList(25),.IgnoreCheckBox
		Text 530,515,120,14,MsgList(26),.IndexNumText
		Text 530,532,120,14,MsgList(27),.TotalNumText
		PushButton 530,427,120,21,MsgList(30),.HelpButton
		OKButton 530,385,120,21,.OKButton
		CancelButton 530,406,120,21,.CancelButton
	End Dialog
	Dim dlg As UserDialog
	dlg.ModeCheckBox = Mode
	If Mode = 0 Then
		dlg.AutoSelectBox = StrToLong(OptionSet(34))
		dlg.FileLocOption = StrToLong(OptionSet(39))
	Else
		dlg.AutoSelectBox = StrToLong(OptionSet(36))
		dlg.FileLocOption = StrToLong(OptionSet(40))
	End If
	Select Case dlg.FileLocOption
	Case 0
		dlg.FileLocTextBox = MacroLoc & "\Data"
	Case 1
		dlg.FileLocTextBox = PSL.ActiveProject.Location
	Case Else
		If Mode = 0 Then
			dlg.FileLocTextBox = Left$(ExtractSet(35),InStrRev(ExtractSet(35),"\") - 1)
		Else
			dlg.FileLocTextBox = Left$(ExtractSet(37),InStrRev(ExtractSet(37),"\") - 1)
		End If
		dlg.FileLocTextBoxBak = dlg.FileLocTextBox
	End Select
	If Dialog(dlg) <> 0 Then
		If Mode = 0 Then
			If OptionSet(34) <> CStr(dlg.AutoSelectBox) Then
				EditFilter = True
			ElseIf OptionSet(39) <> CStr(dlg.FileLocOption) Then
				EditFilter = True
			ElseIf OptionSet(35) <> ExtractSet(38) Then
				EditFilter = True
			End If
			OptionSet(34) = CStr(dlg.AutoSelectBox)
			OptionSet(35) = ExtractSet(38)
			OptionSet(39) = CStr(dlg.FileLocOption)
		Else
			If OptionSet(36) <> CStr(dlg.AutoSelectBox) Then
				EditFilter = True
			ElseIf OptionSet(40) <> CStr(dlg.FileLocOption) Then
				EditFilter = True
			ElseIf OptionSet(37) <> ExtractSet(38) Then
				EditFilter = True
			End If
			OptionSet(36) = CStr(dlg.AutoSelectBox)
			OptionSet(37) = ExtractSet(38)
			OptionSet(40) = CStr(dlg.FileLocOption)
		End If
	End If
	ExtractSet(38) = "": ExtractSetBak(38) = ""
End Function


'编辑列表对话框函数
Private Function EditFilterDlgFunc(DlgItem$, Action%, SuppValue&) As Boolean
	Dim i As Long,j As Long,IDList() As Long,intList() As Long
	Dim MsgList() As String,TempList() As String,Temp As String
	Dim Dic As Object,FindStr As String

	Select Case Action%
	Case 1 ' 对话框窗口初始化
		DlgText "SuppValueBox",CStr(SuppValue&)
		DlgVisible "ModeCheckBox",False
		DlgVisible "TempButton",False
		DlgVisible "SuppValueBox",False
		DlgVisible "FileLocOption",False
		DlgVisible "FileLocTextBoxBak",False
		DlgEnable "AllShowButton",False
		DlgEnable "FileLocOption",False
		DlgEnable "FileLocTextBox",False
		GetHistory(TempList,"FindStrings","EditFilterDlg")
		DlgListBoxArray "FindTextBox",TempList()
		DlgText "FindTextBox",TempList(0)
		If SourceFile.FilePath = "" Then
			DlgValue "FileLocOption",0
			DlgValue "AutoSelectBox",0
		End If
		If DlgValue("AutoSelectBox") = 1 Then
			If InStr(SourceFile.FileName,".") > 1 Then
				FindStr = LCase$(Left$(SourceFile.FileName,InStrRev(SourceFile.FileName,".") - 1)) & ".*"
			Else
				FindStr = LCase$(SourceFile.FileName) & ".*"
			End If
		End If
		ReDim FileList(0) As FILE_LIST
		If DlgValue("ModeCheckBox") = 0 Then
			DlgEnable "DefaultButton",False
			ExtractSet(38) = ExtractSet(35)
			Select Case DlgValue("FileLocOption")
			Case 0
				TempList = GetFiles(FileList,MacroLoc & "\Data\",FilterFile,"*.sfl",True)
				Temp = MacroLoc & "\Data\" & SourceFile.FileName & ".sfl"
			Case 1
				TempList = GetFiles(FileList,PSL.ActiveProject.Location & "\","","*.sfl")
				Temp = PSL.ActiveProject.Location & "\" & SourceFile.FileName & ".sfl"
			Case Else
				TempList = GetFiles(FileList,DlgText("FileLocTextBox") & "\","","*.sfl")
				Temp = DlgText("FileLocTextBox") & "\" & SourceFile.FileName & ".sfl"
			End Select
			If Dir$(Temp) = "" Then
				If CheckArray(TempList) = False Then j = 0 Else j = UBound(TempList) + 1
				ReDim Preserve TempList(j) As String,FileList(j) As FILE_LIST
				TempList(j) = SourceFile.FileName & ".sfl"
				FileList(j).FilePath = Temp
			End If
			If DlgValue("AutoSelectBox") = 1 Then
				For i = 0 To UBound(TempList)
					If (LCase$(TempList(i)) Like FindStr) Then
						ExtractSet(38) = FileList(i).FilePath
						Exit For
					End If
				Next i
			End If
			AllStrList = ReSplit(ReadBinaryFile(ExtractSet(38),CP_UNICODELITTLE,True),vbNullChar)
			StrList2StrDic(FilterStrDic,AllStrList,0,2)
		Else
			ExtractSet(38) = ExtractSet(37)
			Select Case DlgValue("FileLocOption")
			Case 0
				TempList = GetFiles(FileList,MacroLoc & "\Data\",ReserveFile,"*.srl",True)
				Temp = MacroLoc & "\Data\" & SourceFile.FileName & ".srl"
			Case 1
				TempList = GetFiles(FileList,PSL.ActiveProject.Location & "\","","*.srl")
				Temp = PSL.ActiveProject.Location & "\" & SourceFile.FileName & ".srl"
			Case Else
				TempList = GetFiles(FileList,DlgText("FileLocTextBox") & "\","","*.srl")
				Temp = DlgText("FileLocTextBox") & "\" & SourceFile.FileName & ".srl"
			End Select
			If Dir$(Temp) = "" Then
				If CheckArray(TempList) = False Then j = 0 Else j = UBound(TempList) + 1
				ReDim Preserve TempList(j) As String,FileList(j) As FILE_LIST
				TempList(j) = SourceFile.FileName & ".srl"
				FileList(j).FilePath = Temp
			End If
			If DlgValue("AutoSelectBox") = 1 Then
				For i = 0 To UBound(TempList)
					If (LCase$(TempList(i)) Like FindStr) Then
						ExtractSet(38) = FileList(i).FilePath
						Exit For
					End If
				Next i
			End If
			If Dir$(ExtractSet(38)) <> "" Then
				AllStrList = ReSplit(ReadBinaryFile(ExtractSet(38),CP_UNICODELITTLE,True),vbNullChar)
			Else
				AllStrList = ReSplit(ExcludeStr,ItemJoinStr)
			End If
			StrList2StrDic(ReserveStrDic,AllStrList,0,2)
		End If
		ExtractSetBak(38) = ExtractSet(38)
		UseStrList = AllStrList: UseStrListBak = AllStrList
		DlgListBoxArray "FileList",TempList()
		DlgText "FileList",Mid$(ExtractSet(38),InStrRev(ExtractSet(38),"\") + 1)
		DlgListBoxArray "UseStrList",UseStrList()
		DlgValue "UseStrList",Array(0)
		If CheckArray(AllStrList) = False Then
			DlgText "IndexNumText",Replace$(DlgText("IndexNumText"),"%n","0")
			DlgText "TotalNumText",Replace$(Replace$(DlgText("TotalNumText"),"%s","0"),"%d","0")
			'DlgEnable "FilterShowButton",False
			DlgEnable "DelButton",False
			DlgEnable "CopyButton",False
			DlgEnable "AllSelectButton",False
			DlgEnable "CleanButton",False
			DlgEnable "ExportButton",False
		Else
			DlgText "StrTextBox",UseStrList(0)
			DlgText "IndexNumText",Replace$(DlgText("IndexNumText"),"%n","0")
			DlgText "TotalNumText",Replace$(Replace$(DlgText("TotalNumText"),"%d","1"),"%s",CStr(UBound(AllStrList) + 1))
		End If
		If InStr(ExtractSet(38),FilterFile) Or InStr(ExtractSet(38),ReserveFile) Then
			DlgEnable "ChangeFileButton",False
			DlgEnable "DelFileButton",False
		End If
		DlgEnable "ResetButton",False
		'设置当前对话框字体
		If CheckFont(LFList(0)) = True Then
			j = CreateFont(0,LFList(0))
			If j = 0 Then Exit Function
			For i = 0 To DlgCount() - 1
				SendMessageLNG(GetDlgItem(SuppValue,DlgControlId(DlgName(i))),WM_SETFONT,j,0)
			Next i
		End If
	Case 2 ' 数值更改或者按下按钮时
		EditFilterDlgFunc = True ' 防止按下按钮时关闭对话框窗口
		Select Case DlgItem$
		Case "HelpButton"
			If StrToLong(Selected(30)) = 1 Then
				If OpenCHM(CLng(DlgText("SuppValueBox")),1015,Selected(0),OSLanguage,UIFileList) = True Then Exit Function
			End If
			Call Help("FilterReserveHelp")
			Exit Function
		Case "OKButton"
			EditFilterDlgFunc = False
			'检查数据是否已经改变，已改变时先保存当前的文件
			If ArrayComp(AllStrList,UseStrListBak) = True Then
				Temp = StrListJoin(AllStrList,vbNullChar)
				WriteBinaryFile ExtractSet(38),CP_UNICODELITTLE,IIf(Temp = "","",Temp & vbNullChar),True
			End If
			If DlgValue("AutoSelectBox") = 0 Then Exit Function
			'自动选择时检查当前的文件是否和自动选择的一致
			If DlgValue("ModeCheckBox") = 0 Then
				Select Case DlgValue("FileLocOption")
				Case 0
					ExtractSet(38) = MacroLoc & "\Data\" & SourceFile.FileName & ".sfl"
				Case 1
					ExtractSet(38) = PSL.ActiveProject.Location & "\" & SourceFile.FileName & ".sfl"
				Case Else
					ExtractSet(38) = DlgText("FileLocTextBox") & "\" & SourceFile.FileName & ".sfl"
				End Select
			Else
				Select Case DlgValue("FileLocOption")
				Case 0
					ExtractSet(38) = MacroLoc & "\Data\" & SourceFile.FileName & ".srl"
				Case 1
					ExtractSet(38) = PSL.ActiveProject.Location & "\" & SourceFile.FileName & ".srl"
				Case Else
					ExtractSet(38) = DlgText("FileLocTextBox") & "\" & SourceFile.FileName & ".srl"
				End	Select
			End If
			Erase AllStrList,UseStrList,UseStrListBak
			Exit Function
		Case "RegExpTipButton"
			If getMsgList(UIDataList,MsgList,"RegExpRuleTip",1) = False Then Exit Function
			i = ShowPopupMenu(MsgList,vbPopupUseRightButton)
			If i < 0 Then Exit Function
			If i = UBound(MsgList) Then
				If StrToLong(Selected(30)) = 1 Then
					If OpenCHM(CLng(DlgText("SuppValueBox")),1022,Selected(0),OSLanguage,UIFileList) = True Then Exit Function
				End If
				Call Help("RegExpRuleHelp")
				Exit Function
			End If
			If DlgText("FindTextBox") = "" Then
				DlgText "FindTextBox",Mid$(MsgList(i),InStrRev(MsgList(i),vbTab) + 1)
			Else
				DlgFocus("FindTextBox")  '设置焦点到文本框
				DlgText "FindTextBox",InsertStr(GetFocus(),DlgText("FindTextBox"), _
						Mid$(MsgList(i),InStrRev(MsgList(i),vbTab) + 1))
			End If
			Exit Function
		Case "CopyButton"
			intList = GetListBoxIndexs(GetDlgItem(CLng(DlgText("SuppValueBox")),DlgControlId("UseStrList")))
			If CheckArrEmpty(intList) = False Then Exit Function
			ReDim TempList(UBound(intList)) As String
			For i = 0 To UBound(intList)
				TempList(i) = UseStrList(intList(i))
			Next i
			Clipboard StrListJoin(TempList,TextJoinStr)
			Exit Function
		End Select

		If getMsgList(UIDataList,MsgList,"EditFilter",1) = False Then
			EditFilterDlgFunc = True ' 防止按下按钮时关闭对话框窗口
			Exit Function
		End If

		Select Case DlgItem$
		Case "CancelButton"
			EditFilterDlgFunc = False
			If ArrayComp(AllStrList,UseStrListBak) = False Then	Exit Function
			Select Case MsgBox(MsgList(52),vbYesNoCancel+vbInformation,MsgList(32))
			Case vbCancel
				EditFilterDlgFunc = True
				Exit Function
			Case vbYes
				Temp = StrListJoin(AllStrList,vbNullChar)
				WriteBinaryFile ExtractSet(38),CP_UNICODELITTLE,IIf(Temp = "","",Temp & vbNullChar),True
			End Select
			Erase AllStrList,UseStrList,UseStrListBak
			Exit Function
		Case "FileList"
			Select Case DlgValue("FileLocOption")
			Case 0
				Temp = MacroLoc & "\Data\" & DlgText("FileList")
			Case 1
				Temp = PSL.ActiveProject.Location & "\" & DlgText("FileList")
			Case Else
				Temp = DlgText("FileLocTextBox") & "\" & DlgText("FileList")
			End Select
			If Temp = ExtractSet(38) Then Exit Function
			'检查数据是否已经改变，已改变时先保存当前的文件
			If ArrayComp(AllStrList,UseStrListBak) = True Then
				Select Case MsgBox(MsgList(52),vbYesNoCancel+vbInformation,MsgList(32))
				Case vbCancel
					DlgText "FileList",Mid$(ExtractSet(38),InStrRev(ExtractSet(38),"\") + 1)
					Exit Function
				Case vbYes
					FindStr = StrListJoin(AllStrList,vbNullChar)
					WriteBinaryFile ExtractSet(38),CP_UNICODELITTLE,IIf(FindStr = "","",FindStr & vbNullChar),True
				End Select
			End If
			ExtractSet(38) = Temp
			If DlgValue("ModeCheckBox") = 0 Then
				AllStrList = ReSplit(ReadBinaryFile(ExtractSet(38),CP_UNICODELITTLE,True),vbNullChar)
				StrList2StrDic(FilterStrDic,AllStrList,0,2)
			Else
				If Dir$(ExtractSet(38)) <> "" Then
					AllStrList = ReSplit(ReadBinaryFile(ExtractSet(38),CP_UNICODELITTLE,True),vbNullChar)
				Else
					AllStrList = ReSplit(ExcludeStr,ItemJoinStr)
				End If
				StrList2StrDic(ReserveStrDic,AllStrList,0,2)
			End If
			UseStrList = AllStrList: UseStrListBak = AllStrList
			DlgListBoxArray "UseStrList",UseStrList()
			DlgValue "UseStrList",Array(0)
			DlgEnable "AllShowButton",False
			If InStr(ExtractSet(38),FilterFile) Or InStr(ExtractSet(38),ReserveFile) Then
				DlgEnable "ChangeFileButton",False
				DlgEnable "DelFileButton",False
			Else
				DlgEnable "ChangeFileButton",True
				DlgEnable "DelFileButton",True
			End If
			DlgItem$ = "UseStrList"
		Case "AutoSelectBox", "FileLocOption", "FileLocPushButton"
			Select Case DlgItem$
			Case "AutoSelectBox"
				If DlgValue("AutoSelectBox") = 0 Then Exit Function
			Case "FileLocPushButton"
				ReDim TempList(3) As String
				TempList(0) = MsgList(6)
				TempList(1) = MsgList(28)
				If DlgText("FileLocTextBoxBak") = "" Then
					TempList(3) = MsgList(29)
				ElseIf Dir$(DlgText("FileLocTextBoxBak"),vbDirectory) = "" Then
					TempList(3) = MsgList(29)
				ElseIf DlgText("FileLocTextBoxBak") = MacroLoc & "\Data" Then
					TempList(3) = MsgList(29)
				ElseIf DlgText("FileLocTextBoxBak") = PSL.ActiveProject.Location Then
					TempList(3) = MsgList(29)
				Else
					TempList(2) = DlgText("FileLocTextBoxBak")
					TempList(3) = MsgList(29)
				End If
				i = ShowPopupMenu(TempList,vbPopupUseRightButton)
				If i < 0 Then Exit Function
				Select Case i
				Case 0
					If DlgText("FileLocTextBox") = MacroLoc & "\Data" Then Exit Function
					DlgText "FileLocTextBox",MacroLoc & "\Data"
				Case 1
					If DlgText("FileLocTextBox") = PSL.ActiveProject.Location Then Exit Function
					DlgText "FileLocTextBox",PSL.ActiveProject.Location
				Case 2
					If DlgText("FileLocTextBox") = DlgText("FileLocTextBoxBak") Then Exit Function
					DlgText "FileLocTextBox",DlgText("FileLocTextBoxBak")
				Case Else
					If BrowseForFolder(Temp,MsgList(62)) = False Then Exit Function
					If DlgText("FileLocTextBox") = Temp Then Exit Function
					DlgText "FileLocTextBox",Temp
					DlgText "FileLocTextBoxBak",Temp
					i = 2
				End Select
				DlgValue "FileLocOption",i
			End Select
			If DlgValue("ModeCheckBox") = 0 Then
				Select Case DlgValue("FileLocOption")
				Case 0
					Temp = MacroLoc & "\Data\" & SourceFile.FileName & ".sfl"
					TempList = GetFiles(FileList,MacroLoc & "\Data\",FilterFile,"*.sfl",True)
				Case 1
					Temp = PSL.ActiveProject.Location & "\" & SourceFile.FileName & ".sfl"
					TempList = GetFiles(FileList,PSL.ActiveProject.Location & "\","","*.sfl")
				Case Else
					Temp = DlgText("FileLocTextBox") & "\" & SourceFile.FileName & ".sfl"
					TempList = GetFiles(FileList,DlgText("FileLocTextBox") & "\","","*.sfl")
				End Select
				If Dir$(Temp) = "" Then
					If CheckArray(TempList) = False Then j = 0 Else j = UBound(TempList) + 1
					ReDim Preserve TempList(j) As String,FileList(j) As FILE_LIST
					TempList(j) = SourceFile.FileName & ".sfl"
					FileList(j).FilePath = Temp
				End If
			Else
				Select Case DlgValue("FileLocOption")
				Case 0
					Temp = MacroLoc & "\Data\" & SourceFile.FileName & ".srl"
					TempList = GetFiles(FileList,MacroLoc & "\Data\",ReserveFile,"*.srl",True)
				Case 1
					Temp = PSL.ActiveProject.Location & "\" & SourceFile.FileName & ".srl"
					TempList = GetFiles(FileList,PSL.ActiveProject.Location & "\","","*.srl")
				Case Else
					Temp = DlgText("FileLocTextBox") & "\" & SourceFile.FileName & ".srl"
					TempList = GetFiles(FileList,DlgText("FileLocTextBox") & "\","","*.srl")
				End	Select
				If Dir$(Temp) = "" Then
					If CheckArray(TempList) = False Then j = 0 Else j = UBound(TempList) + 1
					ReDim Preserve TempList(j) As String,FileList(j) As FILE_LIST
					TempList(j) = SourceFile.FileName & ".srl"
					FileList(j).FilePath = Temp
				End If
			End If
			DlgListBoxArray "FileList",TempList()
			If DlgValue("AutoSelectBox") = 0 Then
				FindStr = LCase$(Left$(ExtractSetBak(38),InStrRev(ExtractSetBak(38),".") + 1)) & ".*"
			Else
				If InStr(SourceFile.FileName,".") > 1 Then
					FindStr = LCase$(Left$(SourceFile.FileName,InStrRev(SourceFile.FileName,".") - 1)) & ".*"
				Else
					FindStr = LCase$(SourceFile.FileName) & ".*"
				End If
			End If
			For i = 0 To UBound(TempList)
				If LCase$(TempList(i)) Like FindStr Then
					Temp = FileList(i).FilePath
					Exit For
				End If
			Next i
			If Temp = ExtractSet(38) Then
				DlgText "FileList",Mid$(ExtractSet(38),InStrRev(ExtractSet(38),"\") + 1)
				Exit Function
			End If
			'检查数据是否已经改变，已改变时先保存当前的文件
			If ArrayComp(AllStrList,UseStrListBak) = True Then
				If MsgBox(MsgList(52),vbYesNo+vbInformation,MsgList(32)) = vbYes Then
					FindStr = StrListJoin(AllStrList,vbNullChar)
					WriteBinaryFile ExtractSet(38),CP_UNICODELITTLE,IIf(FindStr = "","",FindStr & vbNullChar),True
				End If
			End If
			DlgText "FileList",Mid$(Temp,InStrRev(Temp,"\") + 1)
			ExtractSet(38) = Temp
			If DlgValue("ModeCheckBox") = 0 Then
				AllStrList = ReSplit(ReadBinaryFile(ExtractSet(38),CP_UNICODELITTLE,True),vbNullChar)
				StrList2StrDic(FilterStrDic,AllStrList,0,2)
			Else
				If Dir$(ExtractSet(38)) <> "" Then
					AllStrList = ReSplit(ReadBinaryFile(ExtractSet(38),CP_UNICODELITTLE,True),vbNullChar)
				Else
					AllStrList = ReSplit(ExcludeStr,ItemJoinStr)
				End If
				StrList2StrDic(ReserveStrDic,AllStrList,0,2)
			End If
			UseStrList = AllStrList: UseStrListBak = AllStrList
			DlgListBoxArray "UseStrList",UseStrList()
			DlgValue "UseStrList",Array(0)
			DlgEnable "AllShowButton",False
			If InStr(ExtractSet(38),FilterFile) Or InStr(ExtractSet(38),ReserveFile) Then
				DlgEnable "ChangeFileButton",False
				DlgEnable "DelFileButton",False
			Else
				DlgEnable "ChangeFileButton",True
				DlgEnable "DelFileButton",True
			End If
			DlgItem$ = "UseStrList"
		Case "AddFileButton"
			If ArrayComp(AllStrList,UseStrListBak) = True Then
				Select Case MsgBox(MsgList(52),vbYesNoCancel+vbInformation,MsgList(32))
				Case vbCancel
					Exit Function
				Case vbYes
					Temp = StrListJoin(AllStrList,vbNullChar)
					WriteBinaryFile ExtractSet(38),CP_UNICODELITTLE,IIf(Temp = "","",Temp & vbNullChar),True
				End Select
			End If
			If DlgValue("ModeCheckBox") = 0 Then
				Select Case DlgValue("FileLocOption")
				Case 0
					Temp = MacroLoc & "\Data\" & SourceFile.FileName & ".sfl"
					TempList = GetFiles(FileList,MacroLoc & "\Data\",FilterFile,"*.sfl",True)
				Case 1
					Temp = PSL.ActiveProject.Location & "\" & SourceFile.FileName & ".sfl"
					TempList = GetFiles(FileList,PSL.ActiveProject.Location & "\","","*.sfl")
				Case Else
					Temp = DlgText("FileLocTextBox") & "\" & SourceFile.FileName & ".sfl"
					TempList = GetFiles(FileList,DlgText("FileLocTextBox") & "\","","*.sfl")
				End Select
				If Dir$(Temp) = "" Then
					If CheckArray(TempList) = False Then j = 0 Else j = UBound(TempList) + 1
					ReDim Preserve TempList(j) As String
					TempList(j) = SourceFile.FileName & ".sfl"
				End If
				Temp = SourceFile.FileName & ".sfl"
			Else
				Select Case DlgValue("FileLocOption")
				Case 0
					Temp = MacroLoc & "\Data\" & SourceFile.FileName & ".srl"
					TempList = GetFiles(FileList,MacroLoc & "\Data\",ReserveFile,"*.srl",True)
				Case 1
					Temp = PSL.ActiveProject.Location & "\" & SourceFile.FileName & ".srl"
					TempList = GetFiles(FileList,PSL.ActiveProject.Location & "\","","*.srl")
				Case Else
					Temp = DlgText("FileLocTextBox") & "\" & SourceFile.FileName & ".srl"
					TempList = GetFiles(FileList,DlgText("FileLocTextBox") & "\","","*.srl")
				End	Select
				If Dir$(Temp) = "" Then
					If CheckArray(TempList) = False Then j = 0 Else j = UBound(TempList) + 1
					ReDim Preserve TempList(j) As String
					TempList(j) = SourceFile.FileName & ".srl"
				End If
				Temp = SourceFile.FileName & ".srl"
			End If
			Do
				Temp = AddSet(TempList,Temp)
				If Temp = "" Then Exit Function
				If CheckStrRegExp(Temp,"[\\/:*?""<>|]",0,2) = False Then Exit Do
				MsgBox MsgList(57),vbOkOnly+vbInformation,MsgList(31)
			Loop
			If DlgValue("ModeCheckBox") = 0 Then
				If InStr(LCase$(Temp),".sfl") = 0 Then Temp = Temp & ".sfl"
			Else
				If InStr(LCase$(Temp),".srl") = 0 Then Temp = Temp & ".srl"
			End If
			i = UBound(TempList) + 1
			ReDim Preserve TempList(i) As String
			TempList(i) = Temp
			DlgListBoxArray "FileList",TempList()
			DlgValue "FileList",i
			If DlgValue("ModeCheckBox") = 0 Then
				FilterStrDic.RemoveAll
			Else
				ReserveStrDic.RemoveAll
			End If
			Select Case DlgValue("FileLocOption")
			Case 0
				ExtractSet(38) = MacroLoc & "\Data\" & Temp
			Case 1
				ExtractSet(38) = PSL.ActiveProject.Location & "\" & Temp
			Case Else
				ExtractSet(38) = DlgText("FileLocTextBox") & "\" & Temp
			End Select
			ReDim AllStrList(0) As String
			UseStrList = AllStrList: UseStrListBak = UseStrList
			DlgListBoxArray "UseStrList",UseStrList()
			DlgValue "UseStrList",Array(0)
			DlgEnable "AllShowButton",False
			DlgEnable "ChangeFileButton",True
			DlgEnable "DelFileButton",True
			DlgEnable "ResetButton",False
			WriteBinaryFile ExtractSet(38),CP_UNICODELITTLE,StrListJoin(AllStrList,vbNullChar) & vbNullChar,True
			DlgItem$ = "UseStrList"
		Case "ChangeFileButton"
			i = DlgValue("FileList")
			If i < 0 Then Exit Function
			Select Case DlgValue("FileLocOption")
			Case 0
				If Dir$(MacroLoc & "\Data\" & DlgText("FileList")) = "" Then
					MsgBox Replace$(MsgList(53),"%s",MacroLoc & "\Data\" & DlgText("FileList")),vbOkOnly+vbInformation,MsgList(31)
					Exit Function
				End If
			Case 1
				If Dir$(PSL.ActiveProject.Location & "\" & DlgText("FileList")) = "" Then
					MsgBox Replace$(MsgList(53),"%s",PSL.ActiveProject.Location & "\" & DlgText("FileList")),vbOkOnly+vbInformation,MsgList(31)
					Exit Function
				End If
			Case Else
				If Dir$(DlgText("FileLocTextBox") & "\" & DlgText("FileList")) = "" Then
					MsgBox Replace$(MsgList(53),"%s",DlgText("FileLocTextBox") & "\" & DlgText("FileList")),vbOkOnly+vbInformation,MsgList(31)
					Exit Function
				End If
			End Select
			If DlgValue("ModeCheckBox") = 0 Then
				Select Case DlgValue("FileLocOption")
				Case 0
					Temp = MacroLoc & "\Data\" & SourceFile.FileName & ".sfl"
					TempList = GetFiles(FileList,MacroLoc & "\Data\",FilterFile,"*.sfl",True)
				Case 1
					Temp = PSL.ActiveProject.Location & "\" & SourceFile.FileName & ".sfl"
					TempList = GetFiles(FileList,PSL.ActiveProject.Location & "\","","*.sfl")
				Case Else
					Temp = DlgText("FileLocTextBox") & "\" & SourceFile.FileName & ".sfl"
					TempList = GetFiles(FileList,DlgText("FileLocTextBox") & "\","","*.sfl")
				End Select
				If Dir$(Temp) = "" Then
					If CheckArray(TempList) = False Then j = 0 Else j = UBound(TempList) + 1
					ReDim Preserve TempList(j) As String
					TempList(j) = SourceFile.FileName & ".sfl"
				End If
			Else
				Select Case DlgValue("FileLocOption")
				Case 0
					Temp = MacroLoc & "\Data\" & SourceFile.FileName & ".srl"
					TempList = GetFiles(FileList,MacroLoc & "\Data\",ReserveFile,"*.srl",True)
				Case 1
					Temp = PSL.ActiveProject.Location & "\" & SourceFile.FileName & ".srl"
					TempList = GetFiles(FileList,PSL.ActiveProject.Location & "\","","*.srl")
				Case Else
					Temp = DlgText("FileLocTextBox") & "\" & SourceFile.FileName & ".srl"
					TempList = GetFiles(FileList,DlgText("FileLocTextBox") & "\","","*.srl")
				End	Select
				If Dir$(Temp) = "" Then
					If CheckArray(TempList) = False Then j = 0 Else j = UBound(TempList) + 1
					ReDim Preserve TempList(j) As String
					TempList(j) = SourceFile.FileName & ".srl"
				End If
			End If
			Do
				Temp = EditSet(TempList,i)
				If Temp = "" Then Exit Function
				If CheckStrRegExp(Temp,"[\\/:*?""<>|]",0,2) = False Then Exit Do
				MsgBox MsgList(57),vbOkOnly+vbInformation,MsgList(31)
			Loop
			If Dir$(FileList(i).FilePath) <> "" Then Name FileList(i).FilePath As ExtractSet(38)
			TempList(i) = Temp
			Select Case DlgValue("FileLocOption")
			Case 0
				ExtractSet(38) = MacroLoc & "\Data\" & Temp
			Case 1
				ExtractSet(38) = PSL.ActiveProject.Location & "\" & Temp
			Case Else
				ExtractSet(38) = DlgText("FileLocTextBox") & "\" & Temp
			End Select
			DlgListBoxArray "FileList",TempList()
			DlgValue "FileList",i
			Exit Function
		Case "DelFileButton"
			i = DlgValue("FileList")
			If i < 0 Then Exit Function
			Select Case DlgValue("FileLocOption")
			Case 0
				If Dir$(MacroLoc & "\Data\" & DlgText("FileList")) = "" Then
					MsgBox Replace$(MsgList(54),"%s",MacroLoc & "\Data\" & DlgText("FileList")),vbOkOnly+vbInformation,MsgList(31)
					Exit Function
				End If
				If MsgBox(MsgList(55),vbYesNo+vbInformation,MsgList(32)) = vbNo Then Exit Function
				Kill MacroLoc & "\Data\" & DlgText("FileList")
			Case 1
				If Dir$(PSL.ActiveProject.Location & "\" & DlgText("FileList")) = "" Then
					MsgBox Replace$(MsgList(54),"%s",PSL.ActiveProject.Location & "\" & DlgText("FileList")),vbOkOnly+vbInformation,MsgList(31)
					Exit Function
				End If
				If MsgBox(MsgList(55),vbYesNo+vbInformation,MsgList(32)) = vbNo Then Exit Function
				Kill PSL.ActiveProject.Location & "\" & DlgText("FileList")
			Case Else
				If Dir$(DlgText("FileLocTextBox") & "\" & DlgText("FileList")) = "" Then
					MsgBox Replace$(MsgList(54),"%s",DlgText("FileLocTextBox") & "\" & DlgText("FileList")),vbOkOnly+vbInformation,MsgList(31)
					Exit Function
				End If
				If MsgBox(MsgList(55),vbYesNo+vbInformation,MsgList(32)) = vbNo Then Exit Function
				Kill DlgText("FileLocTextBox") & "\" & DlgText("FileList")
			End Select
			If DlgValue("ModeCheckBox") = 0 Then
				Select Case DlgValue("FileLocOption")
				Case 0
					Temp = MacroLoc & "\Data\" & SourceFile.FileName & ".sfl"
					TempList = GetFiles(FileList,MacroLoc & "\Data\",FilterFile,"*.sfl",True)
				Case 1
					Temp = PSL.ActiveProject.Location & "\" & SourceFile.FileName & ".sfl"
					TempList = GetFiles(FileList,PSL.ActiveProject.Location & "\","","*.sfl")
				Case Else
					Temp = DlgText("FileLocTextBox") & "\" & SourceFile.FileName & ".sfl"
					TempList = GetFiles(FileList,DlgText("FileLocTextBox") & "\","","*.sfl")
				End Select
				If Dir$(Temp) = "" Then
					If CheckArray(TempList) = False Then j = 0 Else j = UBound(TempList) + 1
					ReDim Preserve TempList(j) As String
					TempList(j) = SourceFile.FileName & ".sfl"
				End If
			Else
				Select Case DlgValue("FileLocOption")
				Case 0
					Temp = MacroLoc & "\Data\" & SourceFile.FileName & ".srl"
					TempList = GetFiles(FileList,MacroLoc & "\Data\",ReserveFile,"*.srl",True)
				Case 1
					Temp = PSL.ActiveProject.Location & "\" & SourceFile.FileName & ".srl"
					TempList = GetFiles(FileList,PSL.ActiveProject.Location & "\","","*.srl")
				Case Else
					Temp = DlgText("FileLocTextBox") & "\" & SourceFile.FileName & ".srl"
					TempList = GetFiles(FileList,DlgText("FileLocTextBox") & "\","","*.srl")
				End	Select
				If Dir$(Temp) = "" Then
					If CheckArray(TempList) = False Then j = 0 Else j = UBound(TempList) + 1
					ReDim Preserve TempList(j) As String
					TempList(j) = SourceFile.FileName & ".srl"
				End If
			End If
			DlgListBoxArray "FileList",TempList()
			j = UBound(TempList)
			DlgValue "FileList",IIf(i > j,j,i)
			Select Case DlgValue("FileLocOption")
			Case 0
				ExtractSet(38) = MacroLoc & "\Data\" & DlgText("FileList")
			Case 1
				ExtractSet(38) = PSL.ActiveProject.Location & "\" & DlgText("FileList")
			Case Else
				ExtractSet(38) = DlgText("FileLocTextBox") & "\" & DlgText("FileList")
			End Select
			If DlgValue("ModeCheckBox") = 0 Then
				AllStrList = ReSplit(ReadBinaryFile(ExtractSet(38),CP_UNICODELITTLE,True),vbNullChar)
				StrList2StrDic(FilterStrDic,AllStrList,0,2)
			Else
				If Dir$(ExtractSet(38)) <> "" Then
					AllStrList = ReSplit(ReadBinaryFile(ExtractSet(38),CP_UNICODELITTLE,True),vbNullChar)
				Else
					AllStrList = ReSplit(ExcludeStr,ItemJoinStr)
				End If
				StrList2StrDic(ReserveStrDic,AllStrList,0,2)
			End If
			UseStrList = AllStrList: UseStrListBak = AllStrList
			DlgListBoxArray "UseStrList",UseStrList()
			DlgValue "UseStrList",Array(0)
			DlgEnable "AllShowButton",False
			DlgEnable "ResetButton",False
			If InStr(ExtractSet(38),FilterFile) Or InStr(ExtractSet(38),ReserveFile) Then
				DlgEnable "ChangeFileButton",False
				DlgEnable "DelFileButton",False
			Else
				DlgEnable "ChangeFileButton",True
				DlgEnable "DelFileButton",True
			End If
			DlgItem$ = "UseStrList"
		Case "FindButton", "FilterShowButton"
			If DlgText("FindTextBox") = "" Then
				MsgBox MsgList(33),vbOkOnly+vbInformation,MsgList(31)
				Exit Function
			End If
			'添加查找字串
			GetHistory(TempList,"FindStrings","EditFilterDlg")
			If InsertArray(TempList,DlgText("FindTextBox"),0,True) = True Then
				WriteHistory(TempList,"FindStrings","EditFilterDlg")
				DlgListBoxArray "FindTextBox",TempList()
				DlgText "FindTextBox",TempList(0)
			End If
			'检查是不是通配符
			FindStr = DlgText("FindTextBox")
			If DlgValue("IgnoreCheckBox") = 1 Then FindStr = DelAccKey(FindStr)
			j = GetFindMode(FindStr)
			Select Case j
			Case 0
				If (FindStr Like "*\[*?#[]*") = True Then
					TempList = ReSplit("*,?,#,[",",",-1)
					For i = 0 To UBound(TempList)
						FindStr = Replace$(FindStr,"\" & TempList(i),TempList(i))
					Next i
				End If
				If DlgValue("MatchCaseBox") = 0 Then FindStr = LCase$(FindStr)
			Case 1
				If FilterStr("CheckRegExp",FindStr,1) = -2 Then
					MsgBox MsgList(59),vbOkOnly+vbInformation,MsgList(31)
					Exit Function
				End If
				If DlgValue("MatchCaseBox") = 0 Then FindStr = LCase$(FindStr)
				FindStr = "*" & FindStr & "*"
			Case 2
				If CheckRegExp(RegExp,FindStr) = False Then
					MsgBox MsgList(51),vbOkOnly+vbInformation,MsgList(31)
					Exit Function
				End If
			End Select
			intList = GetListBoxIndexs(GetDlgItem(CLng(DlgText("SuppValueBox")),DlgControlId("UseStrList")))
			If CheckArrEmpty(intList) = False Then ReDim intList(0) As Long
			If DlgItem$ = "FindButton" Then
				If CheckArray(UseStrList) = False Then
					MsgBox MsgList(34),vbOkOnly+vbInformation,MsgList(31)
					Exit Function
				End If
				TempList = UseStrList
				i = IIf(intList(0) < UBound(TempList),intList(0) + 1,0)
			Else
				Set Dic = CreateObject("Scripting.Dictionary")
				For i = 0 To UBound(intList)
					If Not Dic.Exists(UseStrList(intList(i))) Then
						Dic.Add(UseStrList(intList(i)),intList(i))
					End If
				Next i
				TempList = AllStrList
				ReDim UseStrList(UBound(TempList)) As String
				ReDim intList(UBound(TempList)) As Long
				i = 0
			End If
			ReDim IDList(3) As Long
			IDList(1) = UBound(TempList)
			IDList(0) = -1
			Do
				Temp = TempList(i)
				If j < 2 Then
					If DlgValue("MatchCaseBox") = 0 Then Temp = LCase$(Temp)
				End If
				If DlgValue("IgnoreCheckBox") = 1 Then Temp = DelAccKey(Temp)
				Select Case j
				Case 0
					If InStr(Temp,FindStr) Then
						IDList(0) = IDList(0) + 1
						If DlgItem$ = "FindButton" Then Exit Do
						UseStrList(IDList(0)) = TempList(i)
						If Dic.Exists(TempList(i)) Then
							intList(IDList(3)) = IDList(0)
							IDList(3) = IDList(3) + 1
						End If
					End If
				Case 1
					If Temp Like FindStr Then
						IDList(0) = IDList(0) + 1
						If DlgItem$ = "FindButton" Then Exit Do
						UseStrList(IDList(0)) = TempList(i)
						If Dic.Exists(TempList(i)) Then
							intList(IDList(3)) = IDList(0)
							IDList(3) = IDList(3) + 1
						End If
					End If
				Case 2
					RegExp.Global = False
					RegExp.IgnoreCase = IIf(DlgValue("MatchCaseBox") = 0,True,False)
					RegExp.Pattern = FindStr
					If RegExp.Test(Temp) Then
						IDList(0) = IDList(0) + 1
						If DlgItem$ = "FindButton" Then Exit Do
						UseStrList(IDList(0)) = TempList(i)
						If Dic.Exists(TempList(i)) Then
							intList(IDList(3)) = IDList(0)
							IDList(3) = IDList(3) + 1
						End If
					End If
				End Select
				If DlgItem$ = "FindButton" Then
					i = IIf(i < IDList(1),i + 1,0)
					IDList(2) = IDList(2) + 1
					If IDList(2) > IDList(1) Then Exit Do
				Else
					i = i + 1
					If i > IDList(1) Then Exit Do
				End If
			Loop
			Set Dic = Nothing
			If DlgItem$ = "FindButton" Then
				If IDList(0) = -1 Then
					MsgBox MsgList(35),vbOkOnly+vbInformation,MsgList(31)
					Exit Function
				ElseIf i = intList(0) Then
					MsgBox Replace$(MsgList(36),"%s",UseStrList(i)),vbOkOnly+vbInformation,MsgList(31)
					Exit Function
				End If
				SetListBoxItems(GetDlgItem(CLng(DlgText("SuppValueBox")),DlgControlId("UseStrList")),i)
			ElseIf IDList(0) <> i - 1 Then
				If IDList(0) = -1 Then IDList(0) = 0
				If IDList(3) > 0 Then IDList(3) = IDList(3) - 1
				ReDim Preserve UseStrList(IDList(0)) As String
				ReDim Preserve intList(IDList(3)) As Long
				DlgListBoxArray "UseStrList",UseStrList()
				SetListBoxItems(GetDlgItem(CLng(DlgText("SuppValueBox")),DlgControlId("UseStrList")),intList)
				DlgEnable "AllShowButton",True
			Else
				MsgBox MsgList(58),vbOkOnly+vbInformation,MsgList(31)
				Exit Function
			End If
			DlgItem$ = "UseStrList"
		Case "AllShowButton"
			intList = GetListBoxIndexs(GetDlgItem(CLng(DlgText("SuppValueBox")),DlgControlId("UseStrList")))
			If CheckArrEmpty(intList) = False Then
				ReDim intList(0) As Long
			ElseIf DlgValue("ModeCheckBox") = 0 Then
				If GetStrIndexList(FilterStrDic,UseStrList,intList,False) = False Then
					ReDim intList(0) As Long
				End If
			ElseIf GetStrIndexList(ReserveStrDic,UseStrList,intList,False) = False Then
				ReDim intList(0) As Long
			End If
			UseStrList = AllStrList
			DlgListBoxArray "UseStrList",UseStrList()
			SetListBoxItems(GetDlgItem(CLng(DlgText("SuppValueBox")),DlgControlId("UseStrList")),intList)
			DlgEnable "AllShowButton",False
			DlgItem$ = "UseStrList"
		Case "AddButton"
			If Trim$(DlgText("FindTextBox")) = "" Then
				MsgBox MsgList(33),vbOkOnly+vbInformation,MsgList(31)
				Exit Function
			End If
			'检查是不是通配符
			Select Case GetFindMode(DlgText("FindTextBox"))
			Case 1
				If MsgBox(MsgList(37),vbYesNo+vbInformation,MsgList(32)) = vbNo Then
					Exit Function
				End If
			Case 2
				If MsgBox(MsgList(38),vbYesNo+vbInformation,MsgList(32)) = vbNo Then
					Exit Function
				End If
			End Select
			If CheckArray(AllStrList) = True Then
				i = UBound(AllStrList) + 1
			End If
			Temp = Trim$(DlgText("FindTextBox"))
			If DlgValue("ModeCheckBox") = 0 Then
				If FilterStrDic.Exists(Temp) Then
					MsgBox MsgList(39),vbOkOnly+vbInformation,MsgList(31)
					Exit Function
				End If
				FilterStrDic.Add(Temp,i)
			Else
				If ReserveStrDic.Exists(Temp) Then
					MsgBox MsgList(39),vbOkOnly+vbInformation,MsgList(31)
					Exit Function
				End If
				ReserveStrDic.Add(Temp,i)
			End If
			ReDim Preserve AllStrList(i) As String
			AllStrList(i) = Temp
			i = 0
			If CheckArray(UseStrList) = True Then i = UBound(UseStrList) + 1
			ReDim Preserve UseStrList(i) As String,IDList(0) As Long
			UseStrList(i) = Temp
			IDList(0) = GetDlgItem(CLng(DlgText("SuppValueBox")),DlgControlId("UseStrList"))
			'设置水平滚动条的长度以查看最长列表项的全部字符串
			j = GetStrPixels(IDList(0),Temp)
			If j > SendMessageLNG(IDList(0), LB_GETHORIZONTALEXTENT, 0&, 0&) Then
				SendMessageLNG(IDList(0), LB_SETHORIZONTALEXTENT, j, 0&)
			End If
			AddListBoxItems(IDList(0),Temp,i)
			SetListBoxItems(IDList(0),i)
			DlgEnable "ResetButton",ArrayComp(AllStrList,UseStrListBak)
			DlgItem$ = "UseStrList"
		Case "DelButton", "CleanButton"
			If DlgItem$ = "DelButton" Then
				If MsgBox(MsgList(40),vbYesNo+vbInformation,MsgList(32)) = vbNo Then
					Exit Function
				End If
			Else
				SetListBoxItems(GetDlgItem(CLng(DlgText("SuppValueBox")),DlgControlId("UseStrList")),-1)
				i = 0
			End If
			intList = GetListBoxIndexs(GetDlgItem(CLng(DlgText("SuppValueBox")),DlgControlId("UseStrList")))
			If CheckArrEmpty(intList) = False Then Exit Function
			j = UBound(AllStrList)
			If UBound(intList) > UBound(AllStrList) Then ReDim Preserve intList(j) As Long
			IDList = intList
			If DlgValue("ModeCheckBox") = 0 Then
				If DlgEnable("AllShowButton") = True Then
					If GetStrIndexList(FilterStrDic,UseStrList,IDList,False) = False Then
						Exit Function
					End If
				End If
				Call DelArrays(FilterStrDic,AllStrList,IDList,False)
			Else
				If DlgEnable("AllShowButton") = True Then
					If GetStrIndexList(ReserveStrDic,UseStrList,IDList,False) = False Then
						Exit Function
					End If
				End If
				Call DelArrays(ReserveStrDic,AllStrList,IDList,False)
			End If
			If DlgItem$ = "CleanButton" Or UBound(intList) = UBound(UseStrList) Then
				ReDim UseStrList(0) As String
				j = GetDlgItem(CLng(DlgText("SuppValueBox")),DlgControlId("UseStrList"))
				DelListBoxItems(j,-2)
			Else
				Call DelArray(UseStrList,intList)
				j = UBound(UseStrList) - UBound(intList)
				i = IIf(intList(0) < 0,0,IIf(intList(0) > j,j,intList(0)))
				If UBound(intList) > 500 Then
					DlgListBoxArray "UseStrList",UseStrList()
					DlgValue "UseStrList",Array(i)
				Else
					j = GetDlgItem(CLng(DlgText("SuppValueBox")),DlgControlId("UseStrList"))
					DelListBoxItems(j,intList)
					SetListBoxItems(j,i)
				End If
			End If
			DlgEnable "ResetButton",ArrayComp(AllStrList,UseStrListBak)
			DlgItem$ = "UseStrList"
		Case "AllSelectButton"
			SetListBoxItems(GetDlgItem(CLng(DlgText("SuppValueBox")),DlgControlId("UseStrList")),-1)
			DlgItem$ = "UseStrList"
		Case "ResetButton", "DefaultButton", "ReadFileButton"
			Select Case DlgItem$
			Case "ResetButton"
				AllStrList = UseStrListBak: UseStrList = AllStrList: UseStrListBak = UseStrList
			Case "DefaultButton"
				AllStrList = ReSplit(ExcludeStr,ItemJoinStr): UseStrList = AllStrList
			Case "ReadFileButton"
				TempList = ReSplit(ReadBinaryFile(ExtractSet(38),CP_UNICODELITTLE,True),vbNullChar)
				If CheckArray(TempList) = False Then
					MsgBox MsgList(41),vbOkOnly+vbInformation,MsgList(31)
					Exit Function
				End If
				j = UBound(TempList)
				If TempList(j) = "" Then ReDim Preserve TempList(j - 1) As String
				AllStrList = TempList: UseStrList = AllStrList: UseStrListBak = UseStrList
			End Select
			If DlgValue("ModeCheckBox") = 0 Then
				StrList2StrDic(FilterStrDic,AllStrList,0,2)
			Else
				StrList2StrDic(ReserveStrDic,AllStrList,0,2)
			End If
			DlgListBoxArray "UseStrList",UseStrList()
			DlgValue "UseStrList",Array(0)
			DlgEnable "AllShowButton",False
			DlgEnable "ResetButton",False
			DlgItem$ = "UseStrList"
		Case "ImportButton"
			MsgList(44) = IIf(DlgValue("ModeCheckBox") = 0,MsgList(44),MsgList(45))
			If PSL.SelectFile(Temp,True,MsgList(44),MsgList(42)) = False Then Exit Function
			Select Case Mid$(Temp,InStrRev(Temp,"."))
			Case ".txt"
				TempList = ReSplit(ReadTextFile(Temp,"unicodeFFFE"),TextJoinStr)
			Case ".sfl", "srl"
				TempList = ReSplit(ReadBinaryFile(Temp,CP_UNICODELITTLE,True),vbNullChar)
			Case Else
				MsgBox MsgList(47),vbOkOnly+vbInformation,MsgList(31)
				Exit Function
			End Select
			If CheckArray(TempList) = False Then
				MsgBox MsgList(46),vbOkOnly+vbInformation,MsgList(31)
				Exit Function
			End If
			If Mid$(Temp,InStrRev(Temp,".")) = ".txt" Then
				If DlgValue("ModeCheckBox") = 0 Then
					If InStr(TempList(0),"FilterList export file for PSLHardCodedString") = 0 Then
						MsgBox MsgList(48),vbOkOnly+vbInformation,MsgList(31)
						Exit Function
					End If
				Else
					If InStr(TempList(0),"ReserveList export file for PSLHardCodedString") = 0 Then
						MsgBox MsgList(48),vbOkOnly+vbInformation,MsgList(31)
						Exit Function
					End If
				End If
			End If
			ReDim IDList(6) As Long
			IDList(4) = GetDlgItem(CLng(DlgText("SuppValueBox")),DlgControlId("UseStrList"))
			If CheckArray(AllStrList) = True Then
				IDList(0) = UBound(AllStrList) + 1
			End If
			If CheckArray(UseStrList) = True Then
				IDList(1) = UBound(UseStrList) + 1
			End If
			IDList(2) = UBound(TempList)
			ReDim intList(IDList(2)) As Long
			ReDim Preserve AllStrList(IDList(0) + IDList(2)) As String
			ReDim Preserve UseStrList(IDList(1) + IDList(2)) As String
			If DlgValue("ModeCheckBox") = 0 Then
				For i = 1 To IDList(2)
					TempList(i) = Trim$(TempList(i))
					If TempList(i) <> "" Then
						If Not FilterStrDic.Exists(TempList(i)) Then
							FilterStrDic.Add(TempList(i),IDList(0))
							AllStrList(IDList(0)) = TempList(i)
							UseStrList(IDList(1)) = TempList(i)
							AddListBoxItems(IDList(4),TempList(i),IDList(1))
							intList(IDList(3)) = IDList(1)
							IDList(0) = IDList(0) + 1
							IDList(1) = IDList(1) + 1
							IDList(3) = IDList(3) + 1
							If Len(TempList(i)) > IDList(5) Then
								IDList(5) = Len(TempList(i)): IDList(6) = i
							End If
						Else
							j = j + 1
						End If
					End If
				Next i
			Else
				For i = 1 To IDList(2)
					TempList(i) = Trim$(TempList(i))
					If TempList(i) <> "" Then
						If Not ReserveStrDic.Exists(TempList(i)) Then
							ReserveStrDic.Add(TempList(i),IDList(0))
							AllStrList(IDList(0)) = TempList(i)
							UseStrList(IDList(1)) = TempList(i)
							AddListBoxItems(IDList(4),TempList(i),IDList(1))
							intList(IDList(3)) = IDList(1)
							IDList(0) = IDList(0) + 1
							IDList(1) = IDList(1) + 1
							IDList(3) = IDList(3) + 1
							If Len(TempList(i)) > IDList(5) Then
								IDList(5) = Len(TempList(i)): IDList(6) = i
							End If
						Else
							j = j + 1
						End If
					End If
				Next i
			End If
			If IDList(0) > 0 Then IDList(0) = IDList(0) - 1
			If IDList(1) > 0 Then IDList(1) = IDList(1) - 1
			ReDim Preserve AllStrList(IDList(0)) As String,UseStrList(IDList(1)) As String
			MsgBox Replace$(Replace$(MsgList(49),"%s",CStr(IDList(3))),"%d",CStr(j)),vbOkOnly+vbInformation,MsgList(31)
			If IDList(3) = 0 Then Exit Function
			ReDim Preserve intList(IDList(3) - 1) As Long
			'设置水平滚动条的长度以查看最长列表项的全部字符串
			j = GetStrPixels(IDList(4),TempList(IDList(6)))
			If j > SendMessageLNG(IDList(4), LB_GETHORIZONTALEXTENT, 0&, 0&) Then
				SendMessageLNG(IDList(4), LB_SETHORIZONTALEXTENT, j, 0&)
			End If
			SetListBoxItems(IDList(4),intList)
			DlgEnable "ResetButton",ArrayComp(AllStrList,UseStrListBak)
			DlgItem$ = "UseStrList"
		Case "ExportButton"
			MsgList(60) = IIf(DlgValue("ModeCheckBox") = 0,MsgList(60),MsgList(61))
			If PSL.SelectFile(Temp,False,MsgList(60),MsgList(43)) = False Then Exit Function
			If InStr(LCase$(Temp),".txt") = 0 Then Temp = Temp & ".txt"
			If DlgValue("ModeCheckBox") = 0 Then
				MsgList(49) = ";FilterList export file for PSLHardCodedString" & TextJoinStr & TextJoinStr
			Else
				MsgList(49) = ";ReserveList export file for PSLHardCodedString" & TextJoinStr & TextJoinStr
			End If
			WriteBinaryFile(Temp,CP_UNICODELITTLE,MsgList(49) & StrListJoin(AllStrList,TextJoinStr))
			MsgBox Replace$(MsgList(50),"%s",CStr(UBound(AllStrList) + 1)),vbOkOnly+vbInformation,MsgList(31)
			Exit Function
		End Select

		If DlgItem$ = "UseStrList" Then
			If CheckArray(UseStrList) = False Then
				DlgText "StrTextBox",""
				DlgText "IndexNumText",Replace$(MsgList(26),"%n","0")
				DlgText "TotalNumText",Replace$(Replace$(MsgList(27),"%d","0"),"%s","0")
				'DlgEnable "FilterShowButton",False
				DlgEnable "DelButton",False
				DlgEnable "CopyButton",False
				DlgEnable "AllSelectButton",False
				DlgEnable "CleanButton",False
				DlgEnable "ExportButton",False
			Else
				i = GetDlgItem(CLng(DlgText("SuppValueBox")),DlgControlId("UseStrList"))
				IDList = GetListBoxIndexs(i)
				If CheckArrEmpty(IDList) = False Then Exit Function
				DlgText "StrTextBox",UseStrList(IDList(0))
				DlgText "IndexNumText",Replace$(MsgList(26),"%n",CStr(IDList(0)))
				DlgText "TotalNumText",Replace$(Replace$(MsgList(27),"%d",CStr(UBound(IDList) + 1)),"%s",CStr(UBound(UseStrList) + 1))
				'DlgEnable "FilterShowButton",True
				DlgEnable "DelButton",True
				DlgEnable "CopyButton",True
				DlgEnable "AllSelectButton",True
				DlgEnable "CleanButton",True
				DlgEnable "ExportButton",True
			End If
		End If
	Case 3 ' 文本框或者组合框文本被更改
		If DlgItem$ = "StrTextBox" Then
			intList = GetListBoxIndexs(GetDlgItem(CLng(DlgText("SuppValueBox")),DlgControlId("UseStrList")))
			If CheckArrEmpty(intList) = False Then Exit Function
			Temp = Trim$(DlgText("StrTextBox"))
			If Temp = "" Then Exit Function
			Temp = ReConvert(Convert(Temp))
			If UseStrList(intList(0)) = Temp Then Exit Function
			If getMsgList(UIDataList,MsgList,"EditFilter",1) = False Then Exit Function
			If DlgValue("ModeCheckBox") = 0 Then
				If FilterStrDic.Exists(Temp) Then
					MsgBox MsgList(56),vbOkOnly+vbInformation,MsgList(31)
					Exit Function
				End If
			Else
				If ReserveStrDic.Exists(Temp) Then
					MsgBox MsgList(56),vbOkOnly+vbInformation,MsgList(31)
					Exit Function
				End If
			End If
			IDList = intList
			ReDim Preserve IDList(0) As Long
			If DlgValue("ModeCheckBox") = 0 Then
				If DlgEnable("AllShowButton") = True Then
					If GetStrIndexList(FilterStrDic,UseStrList,IDList,False) = False Then
						Exit Function
					End If
				End If
				If Not FilterStrDic.Exists(AllStrList(IDList(0))) Then Exit Function
				FilterStrDic.Key(AllStrList(IDList(0))) = Temp
			Else
				If DlgEnable("AllShowButton") = True Then
					If GetStrIndexList(ReserveStrDic,UseStrList,IDList,False) = False Then
						Exit Function
					End If
				End If
				If Not ReserveStrDic.Exists(AllStrList(IDList(0))) Then Exit Function
				ReserveStrDic.Key(AllStrList(IDList(0))) = Temp
			End If
			AllStrList(IDList(0)) = Temp
			UseStrList(intList(0)) = Temp
			j = GetDlgItem(CLng(DlgText("SuppValueBox")),DlgControlId("UseStrList"))
			ChangeListBoxItems(j,Temp,intList(0),intList(0))
			SetListBoxItems(j,intList(0))
			DlgEnable "ResetButton",ArrayComp(AllStrList,UseStrListBak)
		End If
	Case 6 ' 函数快捷键
		Select Case SuppValue
		Case 1	'帮助
			If StrToLong(Selected(30)) = 1 Then
				If OpenCHM(CLng(DlgText("SuppValueBox")),1015,Selected(0),OSLanguage,UIFileList) = True Then Exit Function
			End If
			Call Help("FilterReserveHelp")
			Exit Function
		Case 2	'弹出正则表达式专用字符选择菜单
			If getMsgList(UIDataList,MsgList,"RegExpRuleTip",1) = False Then Exit Function
			i = ShowPopupMenu(MsgList,vbPopupUseRightButton)
			If i < 0 Then Exit Function
			If i = UBound(MsgList) Then
				If StrToLong(Selected(30)) = 1 Then
					If OpenCHM(CLng(DlgText("SuppValueBox")),1022,Selected(0),OSLanguage,UIFileList) = True Then Exit Function
				End If
				Call Help("RegExpRuleHelp")
				Exit Function
			End If
			If DlgText("FindTextBox") = "" Then
				DlgText "FindTextBox",Mid$(MsgList(i),InStrRev(MsgList(i),vbTab) + 1)
			Else
				DlgFocus("FindTextBox")  '设置焦点到文本框
				DlgText "FindTextBox",InsertStr(GetFocus(),DlgText("FindTextBox"), _
						Mid$(MsgList(i),InStrRev(MsgList(i),vbTab) + 1))
			End If
			Exit Function
		Case 3 To 4	'查找或过滤
			If getMsgList(UIDataList,MsgList,"EditFilter",1) = False Then Exit Function
			If DlgText("FindTextBox") = "" Then
				MsgBox MsgList(33),vbOkOnly+vbInformation,MsgList(31)
				Exit Function
			End If
			'添加查找字串
			GetHistory(TempList,"FindStrings","EditFilterDlg")
			If InsertArray(TempList,DlgText("FindTextBox"),0,True) = True Then
				WriteHistory(TempList,"FindStrings","EditFilterDlg")
				DlgListBoxArray "FindTextBox",TempList()
				DlgText "FindTextBox",TempList(0)
			End If
			'检查是不是通配符
			FindStr = DlgText("FindTextBox")
			If DlgValue("IgnoreCheckBox") = 1 Then FindStr = DelAccKey(FindStr)
			j = GetFindMode(FindStr)
			Select Case j
			Case 0
				If (FindStr Like "*\[*?#[]*") = True Then
					TempList = ReSplit("*,?,#,[",",",-1)
					For i = 0 To UBound(TempList)
						FindStr = Replace$(FindStr,"\" & TempList(i),TempList(i))
					Next i
				End If
				If DlgValue("MatchCaseBox") = 0 Then FindStr = LCase$(FindStr)
			Case 1
				If FilterStr("CheckRegExp",FindStr,1) = -2 Then
					MsgBox MsgList(59),vbOkOnly+vbInformation,MsgList(31)
					Exit Function
				End If
				If DlgValue("MatchCaseBox") = 0 Then FindStr = LCase$(FindStr)
				FindStr = "*" & FindStr & "*"
			Case 2
				If CheckRegExp(RegExp,FindStr) = False Then
					MsgBox MsgList(51),vbOkOnly+vbInformation,MsgList(31)
					Exit Function
				End If
			End Select
			intList = GetListBoxIndexs(GetDlgItem(CLng(DlgText("SuppValueBox")),DlgControlId("UseStrList")))
			If CheckArrEmpty(intList) = False Then ReDim intList(0) As Long
			If SuppValue = 3 Then
				If CheckArray(UseStrList) = False Then
					MsgBox MsgList(34),vbOkOnly+vbInformation,MsgList(31)
					Exit Function
				End If
				TempList = UseStrList
				i = IIf(intList(0) < UBound(TempList),intList(0) + 1,0)
			Else
				Set Dic = CreateObject("Scripting.Dictionary")
				For i = 0 To UBound(intList)
					If Not Dic.Exists(UseStrList(intList(i))) Then
						Dic.Add(UseStrList(intList(i)),intList(i))
					End If
				Next i
				TempList = AllStrList
				ReDim UseStrList(UBound(TempList)) As String
				ReDim intList(UBound(TempList)) As Long
				i = 0
			End If
			ReDim IDList(3) As Long
			IDList(1) = UBound(TempList)
			IDList(0) = -1
			Do
				Temp = TempList(i)
				If j < 2 Then
					If DlgValue("MatchCaseBox") = 0 Then Temp = LCase$(Temp)
				End If
				If DlgValue("IgnoreCheckBox") = 1 Then Temp = DelAccKey(Temp)
				Select Case j
				Case 0
					If InStr(Temp,FindStr) Then
						IDList(0) = IDList(0) + 1
						If SuppValue = 3 Then Exit Do
						UseStrList(IDList(0)) = TempList(i)
						If Dic.Exists(TempList(i)) Then
							intList(IDList(3)) = IDList(0)
							IDList(3) = IDList(3) + 1
						End If
					End If
				Case 1
					If Temp Like FindStr Then
						IDList(0) = IDList(0) + 1
						If SuppValue = 3 Then Exit Do
						UseStrList(IDList(0)) = TempList(i)
						If Dic.Exists(TempList(i)) Then
							intList(IDList(3)) = IDList(0)
							IDList(3) = IDList(3) + 1
						End If
					End If
				Case 2
    				RegExp.Global = False
					RegExp.IgnoreCase = IIf(DlgValue("MatchCaseBox") = 0,True,False)
					RegExp.Pattern = FindStr
					If RegExp.Test(Temp) Then
						IDList(0) = IDList(0) + 1
						If SuppValue = 3 Then Exit Do
						UseStrList(IDList(0)) = TempList(i)
						If Dic.Exists(TempList(i)) Then
							intList(IDList(3)) = IDList(0)
							IDList(3) = IDList(3) + 1
						End If
					End If
				End Select
				If SuppValue = 3 Then
					i = IIf(i < IDList(1),i + 1,0)
					IDList(2) = IDList(2) + 1
					If IDList(2) > IDList(1) Then Exit Do
				Else
					i = i + 1
					If i > IDList(1) Then Exit Do
				End If
			Loop
			Set Dic = Nothing
			If SuppValue = 3 Then
				If IDList(0) = -1 Then
					MsgBox MsgList(35),vbOkOnly+vbInformation,MsgList(31)
					Exit Function
				ElseIf i = intList(0) Then
					MsgBox Replace$(MsgList(36),"%s",UseStrList(i)),vbOkOnly+vbInformation,MsgList(31)
					Exit Function
				End If
				SetListBoxItems(GetDlgItem(CLng(DlgText("SuppValueBox")),DlgControlId("UseStrList")),i)
			ElseIf IDList(0) <> i - 1 Then
				If IDList(0) = -1 Then IDList(0) = 0
				If IDList(3) > 0 Then IDList(3) = IDList(3) - 1
				ReDim Preserve UseStrList(IDList(0)) As String
				ReDim Preserve intList(IDList(3)) As Long
				DlgListBoxArray "UseStrList",UseStrList()
				SetListBoxItems(GetDlgItem(CLng(DlgText("SuppValueBox")),DlgControlId("UseStrList")),intList)
				DlgEnable "AllShowButton",True
			Else
				MsgBox MsgList(58),vbOkOnly+vbInformation,MsgList(31)
				Exit Function
			End If
			DlgItem$ = "UseStrList"
		Case 5	'全部显示
			If DlgEnable("AllShowButton") = False Then Exit Function
			If getMsgList(UIDataList,MsgList,"EditFilter",1) = False Then Exit Function
			intList = GetListBoxIndexs(GetDlgItem(CLng(DlgText("SuppValueBox")),DlgControlId("UseStrList")))
			If CheckArrEmpty(intList) = False Then
				ReDim intList(0) As Long
			ElseIf DlgValue("ModeCheckBox") = 0 Then
				If GetStrIndexList(FilterStrDic,UseStrList,intList,False) = False Then
					ReDim intList(0) As Long
				End If
			ElseIf GetStrIndexList(ReserveStrDic,UseStrList,intList,False) = False Then
				ReDim intList(0) As Long
			End If
			UseStrList = AllStrList
			DlgListBoxArray "UseStrList",UseStrList()
			SetListBoxItems(GetDlgItem(CLng(DlgText("SuppValueBox")),DlgControlId("UseStrList")),intList)
			DlgEnable "AllShowButton",False
			DlgItem$ = "UseStrList"
		Case 6	'文本形式编辑
			TempList = GetToolNameList(Tools,0)
			i = ShowPopupMenu(TempList,vbPopupUseRightButton)
			If i < 0 Then Exit Function
			Temp = SourceFile.FilePath & ".tmp"
			If WriteBinaryFile(Temp,CP_UNICODELITTLE,StrListJoin(AllStrList,TextJoinStr)) = False Then
				On Error Resume Next
				If Dir$(Temp) <> "" Then Kill Temp
				On Error GoTo 0
				Exit Function
			End If
			ReDim FileDataList(0) As String,TempArray(0) As String
			MsgList = AllStrList: TempArray = UseStrList
			FileDataList(0) = Temp & JoinStr & "unicodeFFFE"
			If OpenFile(Temp,FileDataList,i,True) = False Then
				On Error Resume Next
				If Dir$(Temp) <> "" Then Kill Temp
				On Error GoTo 0
				AllStrList = MsgList: UseStrList = TempArray
				Exit Function
			End If
			AllStrList = MsgList: UseStrList = TempArray
			TempList = ReSplit(ReadTextFile(Temp,"unicodeFFFE"),TextJoinStr)
			On Error Resume Next
			If Dir$(Temp) <> "" Then Kill Temp
			On Error GoTo 0
			If CheckArray(TempList) = False Then Exit Function
			If ArrayComp(AllStrList,TempList) = False Then Exit Function
			If getMsgList(UIDataList,MsgList,"EditFilter",1) = False Then Exit Function
			AllStrList = TempList
			If DlgValue("ModeCheckBox") = 0 Then
				StrList2StrDic(FilterStrDic,AllStrList,0,2)
			Else
				StrList2StrDic(ReserveStrDic,AllStrList,0,2)
			End If
			UseStrList = AllStrList
			DlgListBoxArray "UseStrList",UseStrList()
			DlgValue "UseStrList",Array(0)
			DlgEnable "AllShowButton",False
			DlgEnable "ResetButton",ArrayComp(AllStrList,UseStrListBak)
			DlgItem$ = "UseStrList"
		Case Else
			Exit Function
		End Select
		If DlgItem$ = "UseStrList" Then
			If CheckArray(UseStrList) = False Then
				DlgText "StrTextBox",""
				DlgText "IndexNumText",Replace$(MsgList(26),"%n","0")
				DlgText "TotalNumText",Replace$(Replace$(MsgList(27),"%d","0"),"%s","0")
				'DlgEnable "FilterShowButton",False
				DlgEnable "DelButton",False
				DlgEnable "CopyButton",False
				DlgEnable "AllSelectButton",False
				DlgEnable "CleanButton",False
				DlgEnable "ExportButton",False
			Else
				i = GetDlgItem(CLng(DlgText("SuppValueBox")),DlgControlId("UseStrList"))
				IDList = GetListBoxIndexs(i)
				If CheckArrEmpty(IDList) = False Then Exit Function
				DlgText "StrTextBox",UseStrList(IDList(0))
				DlgText "IndexNumText",Replace$(MsgList(26),"%n",CStr(IDList(0)))
				DlgText "TotalNumText",Replace$(Replace$(MsgList(27),"%d",CStr(UBound(IDList) + 1)),"%s",CStr(UBound(UseStrList) + 1))
				'DlgEnable "FilterShowButton",True
				DlgEnable "DelButton",True
				DlgEnable "CopyButton",True
				DlgEnable "AllSelectButton",True
				DlgEnable "CleanButton",True
				DlgEnable "ExportButton",True
			End If
		End If
	End Select
End Function


'编辑列表
'Mode = -2 显示删除、移动按钮
'Mode = -1 不显示拆分和合并字串选择框
'Mode = 0 显示拆分字串选择框
'Mode > 0 显示合并字串选择框
'StrID > -1 显示注释按钮
Private Function EditList(AllList() As String,UseList() As String,Optional Mode As Long = -1, _
				Optional ByVal strID As Long = -1,Optional QCheck As Long) As Boolean
	Dim MsgList() As String
	If getMsgList(UIDataList,MsgList,"EditList",1) = False Then Exit Function
	If CheckArray(AllList) = False Then ReDim AllList(0) As String
	If CheckArray(UseList) = False Then ReDim UseList(0) As String
	AllStrList = AllList: UseStrList = UseList: UseStrListBak = UseList
	Begin Dialog UserDialog 760,406,MsgList(0),.EditListDlgFunc ' %GRID:10,7,1,1
		Text 10,7,300,14,MsgList(1),.AppStrListText
		Text 450,7,300,14,MsgList(2),.UseStrListText
		MultiListBox 10,21,300,350,UseStrList(),.AppStrList
		MultiListBox 450,21,300,350,UseStrList(),.UseStrList
		PushButton 320,21,120,21,MsgList(3),.AddButton
		PushButton 320,42,120,21,MsgList(4),.AddAllButton
		PushButton 320,77,120,21,MsgList(5),.DelButton
		PushButton 320,98,120,21,MsgList(6),.DelAllButton
		PushButton 320,133,120,21,MsgList(7),.RevSelectButton
		PushButton 320,154,120,21,MsgList(8),.ExchangeSelectButton
		PushButton 320,175,120,21,MsgList(9),.ResetButton
		PushButton 320,210,120,21,MsgList(10),.LeftSelectButton
		PushButton 320,231,120,21,MsgList(11),.RightSelectButton
		PushButton 320,210,120,21,MsgList(12),.RemoveAppButton
		PushButton 320,231,120,21,MsgList(13),.RemoveUseButton
		PushButton 320,266,120,21,MsgList(14),.CopyAppButton
		PushButton 320,287,120,21,MsgList(15),.CopyUseButton
		PushButton 320,308,120,21,MsgList(16),.CopyAllButton
		PushButton 320,343,120,21,MsgList(17),.EditCommentButton
		CheckBox 10,378,200,21,MsgList(18),.sCheckBox
		CheckBox 10,378,200,21,MsgList(19),.mCheckBox
		CheckBox 210,378,200,21,MsgList(34),.qCheckBox
		CheckBox 10,378,200,21,"",.TypeCheckBox
		CheckBox 10,378,200,21,"",.RemoveCheckBox
		Text 10,378,200,21,CStr$(strID),.StringIDText
		OKButton IIf(Mode > -1,540,250),378,90,21,.OKButton
		CancelButton IIf(Mode > -1,660,420),378,90,21,.CancelButton
	End Dialog
	Dim dlg As UserDialog
	If Mode = 0 Then
		dlg.sCheckBox = 1
		dlg.TypeCheckBox = 1
	ElseIf Mode > 0 Then
		dlg.mCheckBox = 1
		dlg.qCheckBox = QCheck
		dlg.TypeCheckBox = 1
	End If
	If Dialog(dlg) = 0 Then
		Erase AllStrList,UseStrList,UseStrListBak
		Exit Function
	End If
	If Mode < 0 Then
		Mode = 0
	ElseIf Mode = 0 Then
		Mode = dlg.sCheckBox
		If Mode = 1 Then EditList = True
	ElseIf dlg.mCheckBox = 1 Then
		Mode = 2
		EditList = True
	Else
		Mode = -1
	End If
	If ArrayComp(UseList,UseStrList) = True Then
		AllList = AllStrList: UseList = UseStrList
		EditList = True
	End If
	QCheck = dlg.qCheckBox
	Erase AllStrList,UseStrList,UseStrListBak
End Function


'编辑列表对话框函数
Private Function EditListDlgFunc(DlgItem$, Action%, SuppValue&) As Boolean
	Dim i As Long,j As Long,n As Long,IDList() As Integer,AppStrList() As String,MsgList() As String
	Select Case Action%
	Case 1 ' 对话框窗口初始化
		If getMsgList(UIDataList,MsgList,"EditList",1) = False Then Exit Function
		DlgVisible "TypeCheckBox",False
		DlgVisible "RemoveAppButton",False
		DlgVisible "RemoveUseButton",False
		DlgVisible "RemoveCheckBox",False
		DlgVisible "StringIDText",False
		If StrToLong(DlgText("StringIDText")) < 0 Then
			DlgVisible "EditCommentButton",False
			DlgVisible "LeftSelectButton",False
			DlgVisible "RightSelectButton",False
		End If
		If DlgValue("TypeCheckBox") = 1 Then
			MsgList(1) = MsgList(20)
			MsgList(2) = MsgList(21)
		End If
		AppStrList = ChangeList(AllStrList,UseStrList)
		DlgListBoxArray "AppStrList",AppStrList()
		DlgValue "AppStrList",Array(0)
		DlgValue "UseStrList",Array(0)
		If DlgValue("sCheckBox") = 0 Then
			DlgVisible "sCheckBox",False
			If DlgValue("mCheckBox") = 0 Then DlgVisible "qCheckBox",False
		Else
			DlgValue "sCheckBox",0
			DlgValue "qCheckBox",0
			If UBound(AllStrList) = 0 Or CheckArray(UseStrList) = False Then
				DlgEnable "sCheckBox",False
				DlgEnable "qCheckBox",False
			End If
		End If
		If DlgValue("mCheckBox") = 0 Then
			DlgVisible "mCheckBox",False
			If DlgValue("sCheckBox") <> 0 Then DlgVisible "qCheckBox",False
		ElseIf DlgValue("TypeCheckBox") = 1 Then
			DlgValue "mCheckBox",0
		Else
			DlgValue "mCheckBox",0
		End If
		If DlgListBoxArray("AppStrList") = 0 Then
			DlgEnable "AddButton",False
			DlgEnable "AddAllButton",False
			DlgEnable "RemoveAppButton",False
			DlgEnable "LeftSelectButton",False
			DlgEnable "ExchangeSelectButton",False
		End If
		If DlgListBoxArray("UseStrList") = 0 Then
			DlgEnable "DelButton",False
			DlgEnable "DelAllButton",False
			DlgEnable "RemoveUseButton",False
			DlgEnable "RightSelectButton",False
			DlgEnable "ExchangeSelectButton",False
		End If
		If CheckArray(AllStrList) = False Then
			DlgEnable "CopyAppButton",False
			DlgEnable "CopyUseButton",False
			DlgEnable "CopyAllButton",False
		Else
			DlgEnable "CopyAppButton",CheckArray(AppStrList)
			DlgEnable "CopyUseButton",CheckArray(UseStrList)
		End If
		DlgEnable "ResetButton",False
		i = GetChangeIndexList(AppStrList,AllStrList)(0)
		If CheckArray(AppStrList) = False Then
			DlgText "AppStrListText",Replace$(Replace$(Replace$(MsgList(1),"%n", _
					CStr(i)),"%s",CStr(DlgListBoxArray("AppStrList"))),"%d","0")
		Else
			DlgText "AppStrListText",Replace$(Replace$(Replace$(MsgList(1),"%n", _
					CStr(i)),"%s",CStr(DlgListBoxArray("AppStrList"))),"%d","1")
		End If
		If CheckArray(UseStrList) = False Then
			i = GetChangeIndexList(UseStrList,AllStrList)(0)
			DlgText "UseStrListText",Replace$(Replace$(Replace$(MsgList(2),"%n", _
					CStr(i)),"%s",CStr(DlgListBoxArray("UseStrList"))),"%d","0")
		Else
			i = GetChangeIndexList(UseStrList,AllStrList)(0)
			DlgText "UseStrListText",Replace$(Replace$(Replace$(MsgList(2),"%n", _
					CStr(i)),"%s",CStr(DlgListBoxArray("UseStrList"))),"%d","1")
		End If
		'设置当前对话框字体
		If CheckFont(LFList(0)) = True Then
			j = CreateFont(0,LFList(0))
			If j = 0 Then Exit Function
			For i = 0 To DlgCount() - 1
				SendMessageLNG(GetDlgItem(SuppValue,DlgControlId(DlgName(i))),WM_SETFONT,j,0)
			Next i
		End If
	Case 2 ' 数值更改或者按下按钮时
		EditListDlgFunc = True ' 防止按下按钮时关闭对话框窗口
		Select Case DlgItem$
		Case "OKButton","CancelButton"
			EditListDlgFunc = False
			Exit Function
		Case "sCheckBox","mCheckBox","qCheckBox"
			Exit Function
		Case "CopyAppButton","CopyUseButton","CopyAllButton"
			If DlgItem$ = "CopyAppButton" Then
				AppStrList = ChangeList(AllStrList,UseStrList)
				Clipboard StrListJoin(AppStrList,TextJoinStr)
			ElseIf DlgItem$ = "CopyUseButton" Then
				Clipboard StrListJoin(UseStrList,TextJoinStr)
			Else
				Clipboard StrListJoin(AllStrList,TextJoinStr)
			End If
			Exit Function
		Case "AddButton","DelButton"
			If DlgItem$ = "AddButton" Then
				IDList = DlgValue("AppStrList")
				If CheckArrEmpty(IDList) = False Then Exit Function
				AppStrList = ChangeList(AllStrList,UseStrList)
				i = UBound(AppStrList)
				Call DelArray(AppStrList,IDList)
				MsgList = UseStrList
				UseStrList = ChangeList(AllStrList,AppStrList)
			Else
				IDList = DlgValue("UseStrList")
				If CheckArrEmpty(IDList) = False Then Exit Function
				MsgList = ChangeList(AllStrList,UseStrList)
				i = UBound(UseStrList)
				Call DelArray(UseStrList,IDList)
				AppStrList = ChangeList(AllStrList,UseStrList)
			End If
			If IDList(0) > 0 Then IDList(0) = IDList(0) - 1
			DlgListBoxArray "AppStrList",AppStrList()
			DlgListBoxArray "UseStrList",UseStrList()
			If DlgItem$ = "AddButton" Then
				DlgValue "AppStrList",Array(IDList(0))
				DlgValue "UseStrList",GetChangeIndexList(MsgList,UseStrList,True)
			Else
				DlgValue "AppStrList",GetChangeIndexList(MsgList,AppStrList,True)
				DlgValue "UseStrList",Array(IDList(0))
			End If
			DlgItem$ = "Button"
		Case "AddAllButton","DelAllButton","ResetButton","RevSelectButton"
			If DlgItem$ = "AddAllButton" Then
				ReDim AppStrList(0) As String
				UseStrList = AllStrList
			ElseIf DlgItem$ = "DelAllButton" Then
				ReDim UseStrList(0) As String
				AppStrList = AllStrList
			ElseIf DlgItem$ = "ResetButton" Then
				UseStrList = UseStrListBak
				AppStrList = ChangeList(AllStrList,UseStrList)
				DlgValue "RemoveCheckBox",0
			Else
				AppStrList = UseStrList
				UseStrList = ChangeList(AllStrList,UseStrList)
			End If
			DlgListBoxArray "AppStrList",AppStrList()
			DlgListBoxArray "UseStrList",UseStrList()
			DlgValue "AppStrList",Array(0)
			DlgValue "UseStrList",Array(0)
			DlgItem$ = "Button"
		Case "ExchangeSelectButton"
			ReDim TempList(0) As String
			AppStrList = ChangeList(AllStrList,UseStrList)
			MsgList = AppStrList
			TempList = UseStrList
			IDList = DlgValue("AppStrList")
			If CheckArrEmpty(IDList) = False Then Exit Function
			For i = 0 To UBound(IDList)
				AppStrList(j) = AppStrList(IDList(i))
				j = j + 1
			Next i
			IDList = DlgValue("UseStrList")
			If CheckArrEmpty(IDList) = False Then Exit Function
			Call DelArray(UseStrList,IDList)
			ReDim Preserve AppStrList(UBound(UseStrList) + j) As String
			For i = 0 To UBound(UseStrList)
				AppStrList(j + i) = UseStrList(i)
			Next i
			AppStrList = ChangeList(AllStrList,AppStrList)
			UseStrList = ChangeList(AllStrList,AppStrList)
			DlgListBoxArray "AppStrList",AppStrList()
			DlgValue "AppStrList",GetChangeIndexList(MsgList,AppStrList,True)
			IDList = DlgValue("UseStrList")
			DlgListBoxArray "UseStrList",UseStrList()
			DlgValue "UseStrList",GetChangeIndexList(TempList,UseStrList,True)
			DlgItem$ = "Button"
		Case "EditCommentButton"
			i = StrToLong(DlgText("StringIDText"))
			EditComment(AllStrDataList(i).Source.sString,i,UBound(AllStrDataList) + 1)
			Exit Function
		End Select
		If getMsgList(UIDataList,MsgList,"EditList",1) = False Then Exit Function
		Select Case DlgItem$
		Case "RemoveAppButton"
			If MsgBox(MsgList(23),vbYesNo+vbInformation,MsgList(22)) = vbNo Then Exit Function
			IDList = DlgValue("AppStrList")
			If CheckArrEmpty(IDList) = False Then Exit Function
			AppStrList = ChangeList(AllStrList,UseStrList)	'获取可用列表项目
			i = UBound(AppStrList)
			Call DelArray(AppStrList,IDList)	'删除被选定项目
			AppStrList = ChangeList(ChangeList(AllStrList,AppStrList),UseStrList)	'找出被删除的项目
			AllStrList = ChangeList(AllStrList,AppStrList)	'找出未被删除的项目
			AppStrList = ChangeList(AllStrList,UseStrList)	'再获取可用列表项目
			If IDList(0) > 0 Then IDList(0) = IDList(0) - 1
			DlgListBoxArray "AppStrList",AppStrList()
			DlgValue "AppStrList",Array(IDList(0))
			DlgValue "RemoveCheckBox",1
			DlgItem$ = "Button"
		Case "RemoveUseButton"
			If MsgBox(MsgList(23),vbYesNo+vbInformation,MsgList(22)) = vbNo Then Exit Function
			IDList = DlgValue("UseStrList")
			If CheckArrEmpty(IDList) = False Then Exit Function
			AppStrList = ChangeList(AllStrList,UseStrList)	'获取可用列表项目
			i = UBound(UseStrList)
			Call DelArray(UseStrList,IDList)	'删除被选定项目
			UseStrList = ChangeList(ChangeList(AllStrList,UseStrList),AppStrList)	'找出被删除的项目
			AllStrList = ChangeList(AllStrList,UseStrList)	'找出未被删除的项目
			UseStrList = ChangeList(AllStrList,AppStrList)	'再获取已用列表项目
			If IDList(0) > 0 Then IDList(0) = IDList(0) - 1
			DlgListBoxArray "UseStrList",UseStrList()
			DlgValue "UseStrList",Array(IDList(0))
			DlgValue "RemoveCheckBox",1
			DlgItem$ = "Button"
		Case "LeftSelectButton", "RightSelectButton"
			ReDim TempList(0) As String
			MsgList(25) = Replace$(Replace$(MsgList(25),"%1","0"),"%2",CStr$(UBound(AllStrList)))
			MsgList(0) = MsgList(26)
			Do
				MsgList(0) = Trim$(InputBox(MsgList(25),MsgList(24),MsgList(0)))
				If MsgList(0) = "" Or MsgList(0) = MsgList(26) Then Exit Function
				If CheckStrRegExp(MsgList(0),"[-,0-9]",0,1) = False Then
					MsgBox MsgList(28),vbOkOnly+vbInformation,MsgList(27)
				Else
					n = UBound(AllStrList)
					TempList = ReSplit(MsgList(0),",")
					For i = 0 To UBound(TempList)
						If InStr(TempList(i),"-") Then
							AppStrList = ReSplit(TempList(i),"-")
							If AppStrList(0) = "" Or AppStrList(1) = "" Then
								MsgBox Replace$(MsgList(29),"%s",AppStrList(0) & "-" & AppStrList(1)),vbOkOnly+vbInformation,MsgList(27)
								Exit For
							ElseIf StrToLong(AppStrList(0)) >= StrToLong(AppStrList(1)) Then
								MsgBox Replace$(MsgList(30),"%s",AppStrList(0) & "-" & AppStrList(1)),vbOkOnly+vbInformation,MsgList(27)
								Exit For
							ElseIf StrToLong(AppStrList(0)) > n Or StrToLong(AppStrList(1)) > n Then
								MsgBox Replace$(MsgList(31),"%s",AppStrList(0) & "-" & AppStrList(1)),vbOkOnly+vbInformation,MsgList(27)
								Exit For
							End If
						ElseIf StrToLong(TempList(i)) > n Then
							MsgBox Replace$(MsgList(31),"%s",TempList(i)),vbOkOnly+vbInformation,MsgList(27)
							Exit For
						End If
					Next i
					If i > UBound(TempList) Then
						Dim Dic As Object
						Set Dic = CreateObject("Scripting.Dictionary")
						If DlgItem$ = "LeftSelectButton" Then
							AppStrList = ChangeList(AllStrList,UseStrList)	'获取可用列表项目
						Else
							AppStrList = UseStrList
						End If
						For i = 0 To UBound(AppStrList)
							If Not Dic.Exists(AppStrList(i)) Then
								Dic.Add(AppStrList(i),i)
							End If
						Next i
						ReDim IDList(n) As Integer
						n = 0
						For i = 0 To UBound(TempList)
							If InStr(TempList(i),"-") Then
								AppStrList = ReSplit(TempList(i),"-")
								For j = StrToLong(AppStrList(0)) To StrToLong(AppStrList(1))
									If Dic.Exists(AllStrList(j)) Then
										IDList(n) = Dic.Item(AllStrList(j))
										n = n + 1
									End If
								Next j
							Else
								j = StrToLong(TempList(i))
								If Dic.Exists(AllStrList(j)) Then
									IDList(n) = Dic.Item(AllStrList(j))
									n = n + 1
								End If
							End If
						Next i
						Set Dic = Nothing
						If n > 0 Then
							ReDim Preserve IDList(n - 1) As Integer
							If DlgItem$ = "LeftSelectButton" Then
								DlgValue "AppStrList",IDList()
							Else
								DlgValue "UseStrList",IDList()
							End If
							DlgItem$ = "Button"
							Exit Do
						ElseIf DlgItem$ = "LeftSelectButton" Then
							MsgBox MsgList(32),vbOkOnly+vbInformation,MsgList(27)
						Else
							MsgBox MsgList(33),vbOkOnly+vbInformation,MsgList(27)
						End If
					End If
				End If
			Loop
		End Select
		If DlgItem$ = "AppStrList" Or DlgItem$ = "Button" Then
			If DlgValue("TypeCheckBox") = 1 Then MsgList(1) = MsgList(20)
			If DlgListBoxArray("AppStrList") = 0 Then
				DlgEnable "AddButton",False
				DlgEnable "AddAllButton",False
				DlgEnable "RemoveAppButton",False
				DlgEnable "LeftSelectButton",False
				DlgEnable "ExchangeSelectButton",False
				DlgText "AppStrListText",Replace$(Replace$(Replace$(MsgList(1),"%n","0"),"%s","0"),"%d","0")
			Else
				DlgEnable "AddButton",True
				DlgEnable "AddAllButton",True
				DlgEnable "RemoveAppButton",True
				DlgEnable "LeftSelectButton",True
				If DlgListBoxArray("UseStrList") > 0 Then DlgEnable "ExchangeSelectButton",True
				ReDim AppStrList(0) As String
				AppStrList(0) = DlgText("AppStrList")
				i = GetChangeIndexList(AppStrList,AllStrList)(0)
				IDList = DlgValue("AppStrList")
				DlgText "AppStrListText",Replace$(Replace$(Replace$(MsgList(1),"%n", _
						CStr(i)),"%s",CStr(DlgListBoxArray("AppStrList"))),"%d",CStr(UBound(IDList) + 1))
			End If
		End If
		If DlgItem$ = "UseStrList" Or DlgItem$ = "Button" Then
			If DlgValue("TypeCheckBox") = 1 Then MsgList(2) = MsgList(21)
			If DlgListBoxArray("UseStrList") = 0 Then
				DlgEnable "DelButton",False
				DlgEnable "DelAllButton",False
				DlgEnable "RemoveUseButton",False
				DlgEnable "RightSelectButton",False
				DlgEnable "ExchangeSelectButton",False
				DlgText "UseStrListText",Replace$(Replace$(Replace$(MsgList(2),"%n","0"),"%s","0"),"%d","0")
			Else
				DlgEnable "DelButton",True
				DlgEnable "DelAllButton",True
				DlgEnable "RemoveUseButton",True
				DlgEnable "RightSelectButton",True
				If DlgListBoxArray("AppStrList") > 0 Then DlgEnable "ExchangeSelectButton",True
				ReDim AppStrList(0) As String
				AppStrList(0) = DlgText("UseStrList")
				i = GetChangeIndexList(AppStrList,AllStrList)(0)
				IDList = DlgValue("UseStrList")
				DlgText "UseStrListText",Replace$(Replace$(Replace$(MsgList(2),"%n", _
						CStr(i)),"%s",CStr(DlgListBoxArray("UseStrList"))),"%d",CStr(UBound(IDList) + 1))
			End If
		End If
		If DlgItem$ = "Button" Then
			If DlgValue("RemoveCheckBox") = 0 Then
				DlgEnable "ResetButton",ArrayComp(UseStrList,UseStrListBak)
			Else
				DlgEnable "ResetButton",True
			End If
			If DlgVisible("sCheckBox") = True Then
				If UBound(AllStrList) > 0 And CheckArray(UseStrList) = True Then
					DlgEnable "sCheckBox",True
					DlgEnable "qCheckBox",True
				Else
					DlgEnable "sCheckBox",False
					DlgEnable "qCheckBox",False
					DlgValue "sCheckBox",0
					DlgValue "qCheckBox",0
				End If
			End If
			If CheckArray(AllStrList) = False Then
				DlgEnable "CopyAppButton",False
				DlgEnable "CopyUseButton",False
				DlgEnable "CopyAllButton",False
			ElseIf UBound(AllStrList) <> UBound(UseStrList) Then
				DlgEnable "CopyAllButton",True
				DlgEnable "CopyUseButton",True
				DlgEnable "CopyAppButton",True
			ElseIf CheckArray(UseStrList) = False Then
				DlgEnable "CopyAllButton",True
				DlgEnable "CopyAppButton",True
				DlgEnable "CopyUseButton",False
			Else
				DlgEnable "CopyAllButton",True
				DlgEnable "CopyAppButton",False
				DlgEnable "CopyUseButton",True
			End If
		End If
	End Select
End Function


'删除字串数据数组项目
Private Sub DelDataArray(Dic As Object,DataList() As STRING_PROPERTIE,ByVal IDList As Variant)
	Dim i As Long,n As Long
	If IsArray(IDList) Then
		If UBound(DataList) = UBound(IDList) Then
			Dic.RemoveAll
			ReDim DataList(0) As STRING_PROPERTIE
			Exit Sub
		End If
		ReDim Stemp(UBound(DataList)) As Long
		For i = LBound(IDList) To UBound(IDList)
			If IDList(i) > -1 Then Stemp(IDList(i)) = 1
		Next i
		n = IDList(LBound(IDList))
		For i = IDList(LBound(IDList)) To UBound(DataList)
			If Stemp(i) = 0 Then
				If DataList(i).Source.sString <> "" Then
					DataList(n) = DataList(i)
					If Dic.Exists(DataList(i).ID) Then
						Dic.Item(DataList(i).ID) = n
					Else
						Dic.Add(DataList(i).ID,n)
					End If
					n = n + 1
				ElseIf Dic.Exists(DataList(i).ID) Then
					Dic.Remove(DataList(i).ID)
				End If
			ElseIf Dic.Exists(DataList(i).ID) Then
				Dic.Remove(DataList(i).ID)
			End If
		Next i
	ElseIf IsNumeric(IDList) Then
		n = IDList
		If Dic.Exists(DataList(n).ID) Then Dic.Remove(DataList(n).ID)
		For i = IDList + 1 To UBound(DataList)
			If DataList(i).Source.sString <> "" Then
				DataList(n) = DataList(i)
				If Dic.Exists(DataList(i).ID) Then
					Dic.Item(DataList(i).ID) = n
				Else
					Dic.Add(DataList(i).ID,n)
				End If
				n = n + 1
			ElseIf Dic.Exists(DataList(i).ID) Then
				Dic.Remove(DataList(i).ID)
			End If
		Next i
	Else
		Exit Sub
	End If
	If n > 0 Then
		ReDim Preserve DataList(n - 1) As STRING_PROPERTIE
	Else
		ReDim DataList(0) As STRING_PROPERTIE
	End If
End Sub


'删除字串数据数组项目
Private Sub DelDataArrays(Dic As Object,DicBak As Object,DataList() As STRING_PROPERTIE,ByVal IDList As Variant)
	Dim i As Long,n As Long
	If IsArray(IDList) Then
		If UBound(DataList) = UBound(IDList) Then
			Dic.RemoveAll: DicBak.RemoveAll
			ReDim DataList(0) As STRING_PROPERTIE
			Exit Sub
		End If
		ReDim Stemp(UBound(DataList)) As Long
		For i = LBound(IDList) To UBound(IDList)
			If IDList(i) > -1 Then Stemp(IDList(i)) = 1
		Next i
		n = IDList(LBound(IDList))
		For i = IDList(LBound(IDList)) To UBound(DataList)
			If Stemp(i) = 0 Then
				If DataList(i).Source.sString <> "" Then
					DataList(n) = DataList(i)
					If Dic.Exists(DataList(i).ID) Then
						Dic.Item(DataList(i).ID) = n
					Else
						Dic.Add(DataList(i).ID,n)
					End If
					If DicBak.Exists(DataList(i).ID) Then
						DicBak.Item(DataList(i).ID) = n
					Else
						DicBak.Add(DataList(i).ID,n)
					End If
					n = n + 1
				Else
					If Dic.Exists(DataList(i).ID) Then Dic.Remove(DataList(i).ID)
					If DicBak.Exists(DataList(i).ID) Then DicBak.Remove(DataList(i).ID)
				End If
			Else
				If Dic.Exists(DataList(i).ID) Then Dic.Remove(DataList(i).ID)
				If DicBak.Exists(DataList(i).ID) Then DicBak.Remove(DataList(i).ID)
			End If
		Next i
	ElseIf IsNumeric(IDList) Then
		n = IDList
		If Dic.Exists(DataList(n).ID) Then Dic.Remove(DataList(n).ID)
		For i = IDList + 1 To UBound(DataList)
			If DataList(i).Source.sString <> "" Then
				DataList(n) = DataList(i)
				If Dic.Exists(DataList(i).ID) Then
					Dic.Item(DataList(i).ID) = n
				Else
					Dic.Add(DataList(i).ID,n)
				End If
				If DicBak.Exists(DataList(i).ID) Then
					DicBak.Item(DataList(i).ID) = n
				Else
					DicBak.Add(DataList(i).ID,n)
				End If
				n = n + 1
			Else
				If Dic.Exists(DataList(i).ID) Then Dic.Remove(DataList(i).ID)
				If DicBak.Exists(DataList(i).ID) Then DicBak.Remove(DataList(i).ID)
			End If
		Next i
	Else
		Exit Sub
	End If
	If n > 0 Then
		ReDim Preserve DataList(n - 1) As STRING_PROPERTIE
	Else
		ReDim DataList(0) As STRING_PROPERTIE
	End If
End Sub


'获取工具数据数组的工具名称列表
Public Function GetStrTypeNameList(DataList() As STRING_TYPE) As String()
	Dim i As Long
	ReDim TempList(UBound(DataList)) As String
	For i = 0 To UBound(DataList)
		TempList(i) = DataList(i).sName
	Next i
	GetStrTypeNameList = TempList
End Function


'删除自定义类型数组项目
Private Sub DelStrTypeArray(DataList() As STRING_TYPE,ByVal IDList As Variant)
	Dim i As Long,n As Long
	If IsArray(IDList) Then
		If UBound(DataList) = UBound(IDList) Then
			ReDim DataList(0) As STRING_TYPE
			Exit Sub
		End If
		ReDim Stemp(UBound(DataList)) As Long
		For i = LBound(IDList) To UBound(IDList)
			If IDList(i) > -1 Then Stemp(IDList(i)) = 1
		Next i
		n = IDList(LBound(IDList))
		For i = IDList(LBound(IDList)) To UBound(DataList)
			If Stemp(i) = 0 Then
				DataList(n) = DataList(i)
				n = n + 1
			End If
		Next i
	ElseIf IsNumeric(IDList) Then
		n = IDList
		For i = IDList + 1 To UBound(DataList)
			DataList(n) = DataList(i)
			n = n + 1
		Next i
	ElseIf IDList <> "" Then
		For i = LBound(DataList) To UBound(DataList)
			If DataList(i).sName <> IDList Then
				DataList(n) = DataList(i)
				n = n + 1
			End If
		Next i
	Else
		Exit Sub
	End If
	If n > 0 Then
		ReDim Preserve DataList(n - 1) As STRING_TYPE
	Else
		ReDim DataList(0) As STRING_TYPE
	End If
End Sub


'删除语言数据数组项目
Private Sub DelLangArray(DataList() As LANG_PROPERTIE,ByVal IDList As Variant)
	Dim i As Long,n As Long
	If IsArray(IDList) Then
		If UBound(DataList) = UBound(IDList) Then
			ReDim DataList(0) As LANG_PROPERTIE
			Exit Sub
		End If
		ReDim Stemp(UBound(DataList)) As Long
		For i = LBound(IDList) To UBound(IDList)
			If IDList(i) > -1 Then Stemp(IDList(i)) = 1
		Next i
		n = IDList(LBound(IDList))
		For i = IDList(LBound(IDList)) To UBound(DataList)
			If Stemp(i) = 0 Then
				DataList(n) = DataList(i)
				n = n + 1
			End If
		Next i
	ElseIf IsNumeric(IDList) Then
		n = IDList
		For i = IDList + 1 To UBound(DataList)
			DataList(n) = DataList(i)
			n = n + 1
		Next i
	ElseIf IDList <> "" Then
		For i = LBound(DataList) To UBound(DataList)
			If DataList(i).CPName <> IDList Then
				DataList(n) = DataList(i)
				n = n + 1
			End If
		Next i
	Else
		Exit Sub
	End If
	If n > 0 Then
		ReDim Preserve DataList(n - 1) As LANG_PROPERTIE
	Else
		ReDim DataList(0) As LANG_PROPERTIE
	End If
End Sub


'互换数组项目
'Mode = 0 找出不同的，否则找出相同的项目
Public Function ChangeList(AllList() As String,UseList() As String,Optional ByVal Mode As Long) As String()
	Dim i As Long,n As Long,Dic As Object
	If CheckArray(UseList) = False Then
		ChangeList = IIf(Mode = 0,AllList,UseList)
		Exit Function
	ElseIf CheckArray(AllList) = False Then
		ChangeList = IIf(Mode = 0,UseList,AllList)
		Exit Function
	End If
	ReDim TempList(UBound(AllList)) As String
	Set Dic = CreateObject("Scripting.Dictionary")
	For i = LBound(UseList) To UBound(UseList)
		If Not Dic.Exists(UseList(i)) Then
			Dic.Add(UseList(i),"")
		End If
	Next i
	If Mode = 0 Then
		For i = LBound(AllList) To UBound(AllList)
			If Not Dic.Exists(AllList(i)) Then
				TempList(n) = AllList(i)
				n = n + 1
			End If
		Next i
	Else
		For i = LBound(AllList) To UBound(AllList)
			If Dic.Exists(AllList(i)) Then
				TempList(n) = AllList(i)
				n = n + 1
			End If
		Next i
	End If
	Set Dic = Nothing
	If n > 0 Then n = n - 1
	ReDim Preserve TempList(n) As String
	ChangeList = TempList
End Function


'清理引用地址重复的引用数据，返回最大索引号
Private Function ClearRefArray(MyArray() As REFERENCE_PROPERTIE) As Long
	Dim i As Long,Dic As Object
	If UBound(MyArray) = 0 Then Exit Function
	Set Dic = CreateObject("Scripting.Dictionary")
	For i = LBound(MyArray) To UBound(MyArray)
		If Not Dic.Exists(MyArray(i).lAddress) Then
			Dic.Add(MyArray(i).lAddress,"")
			MyArray(ClearRefArray) = MyArray(i)
			ClearRefArray = ClearRefArray + 1
		End If
	Next i
	Set Dic = Nothing
	If ClearRefArray > 0 Then ClearRefArray = ClearRefArray - 1
	ReDim Preserve MyArray(ClearRefArray) 'As REFERENCE_PROPERTIE
End Function


'提取指定文件节中的字符串
'返回值 >0 获取的字串数，0 没有获取，-1 获取引用代码过程中中止 ，-2 获取字串过程中中止，-3 获取引用过程中中止
Private Function GetStrings(orgFile As FILE_PROPERTIE,ByVal ShowMsg As Long) As Long
	Dim i As Long,n As Long,k As Long,Mode As Long,MsgList() As String
	Dim LogFN As Variant,Dic As Object,Msg As PROGRESS_MSG
	Dim FN As FILE_IMAGE,TempList() As String,StartTime As Date
	If getMsgList(UIDataList,MsgList,"GetStrings",1) = False Then Exit Function
	Set Dic = CreateObject("Scripting.Dictionary")
	'转换提取区域类型
	If ExtractSet(49) = "0" Then
		'转换选定文件节列表的值为文件节列表的值
		With orgFile
			Select Case .Magic
			Case "PE32","PE64","NET32","NET64","NotPE32","NotPE64",""
				For i = 0 To UBound(UseSectionList)
					If Not Dic.Exists(UseSectionList(i)) Then
						Dic.Add(UseSectionList(i),"")
					End If
				Next i
				ReDim AddList(.MaxSecIndex * 4) As Long
				For i = 0 To .MaxSecIndex
					If Dic.Exists(.SecList(i).sName) Then
						Msg.Total = Msg.Total + .SecList(i).lSizeOfRawData
						AddList(n) = .SecList(i).lPointerToRawData
						AddList(n + 1) = AddList(n) + IIf(.SecList(i).lSizeOfRawData = 0,0,.SecList(i).lSizeOfRawData - 1)
						n = n + 2
					End If
				Next i
			Case Else
				For i = 0 To UBound(UseSubSecList)
					If Not Dic.Exists(UseSubSecList(i)) Then
						Dic.Add(UseSubSecList(i),"")
					End If
				Next i
				ReDim AddList(.MaxSecIndex * 100) As Long
				For i = 0 To .MaxSecIndex
					If .SecList(i).SubSecs > 0 Then
						For k = 0 To .SecList(i).SubSecs - 1
							If Dic.Exists(.SecList(i).sName & "-" & .SecList(i).SubSecList(k).sName) Then
								Msg.Total = Msg.Total + .SecList(i).SubSecList(k).lSizeOfRawData
								AddList(n) = .SecList(i).SubSecList(k).lPointerToRawData
								AddList(n + 1) = AddList(n) + IIf(.SecList(i).SubSecList(k).lSizeOfRawData = 0,0, _
												.SecList(i).SubSecList(k).lSizeOfRawData - 1)
								n = n + 2
							End If
						Next k
					ElseIf Dic.Exists(.SecList(i).sName) Then
						Msg.Total = Msg.Total + .SecList(i).lSizeOfRawData
						AddList(n) = .SecList(i).lPointerToRawData
						AddList(n + 1) = AddList(n) + IIf(.SecList(i).lSizeOfRawData = 0,0, _
										.SecList(i).lSizeOfRawData - 1)
						n = n + 2
					End If
				Next i
			End Select
		End With
		Dic.RemoveAll
		If n = 0 Then Exit Function
		n = n - 1
		ReDim Preserve AddList(n) As Long
	Else
		TempList = ReSplit(Replace$(ExtractSet(50),",","-"),"-")
		ReDim AddList(UBound(TempList)) As Long
		For i = 0 To UBound(TempList) - 1 Step 2
			AddList(n) = StrToLong(TempList(i))
			AddList(n + 1) = StrToLong(TempList(i + 1))
			Msg.Total = Msg.Total + AddList(n + 1) - AddList(n) + 1
			Do
				Call SkipSection(orgFile,AddList(n),0,k,1)
				If AddList(n + 1) <= k Then Exit Do
				AddList(n + 1) = k
				ReDim Preserve AddList(UBound(AddList) + 2) As Long
				n = n + 2
				AddList(n) = k + 1
				AddList(n + 1) = StrToLong(TempList(i + 1))
			Loop
			n = n + 2
		Next i
		If n = 0 Then Exit Function
		n = n - 1
		ReDim Preserve AddList(n) As Long
		Call SortNumArray(AddList,0,n,False)
	End If
	'初始化提取记录
	On Error GoTo ErrorHandle
	If ExtractSet(26) = "1" Or ExtractSet(51) = "1" Then
		If Dir$(orgFile.FilePath & ".log") <> "" Then Kill orgFile.FilePath & ".log"
		LogFN = FreeFile
		Open orgFile.FilePath & ".log" For Binary Access Write Lock Write As #LogFN
		WriteBinaryFile LogFN,CP_UNICODELITTLE,MsgList(3) & vbCrLf & vbCrLf
		WriteBinaryFile LogFN,CP_UNICODELITTLE,MsgList(4) & orgFile.FilePath & vbCrLf,True
		WriteBinaryFile LogFN,CP_UNICODELITTLE,MsgList(5) & orgFile.FileVersion & vbCrLf,True
		WriteBinaryFile LogFN,CP_UNICODELITTLE,MsgList(6) & orgFile.FileSize & vbCrLf,True
		WriteBinaryFile LogFN,CP_UNICODELITTLE,MsgList(7) & orgFile.DateLastModified & vbCrLf,True
		WriteBinaryFile LogFN,CP_UNICODELITTLE,MsgList(8) & StrListJoin(UseSectionList,", ") & vbCrLf,True
		WriteBinaryFile LogFN,CP_UNICODELITTLE,MsgList(9) & StrListJoin(GetLangStrList(UseLangList,0),", ") & vbCrLf,True
		WriteBinaryFile LogFN,CP_UNICODELITTLE,MsgList(14) & vbCrLf & MsgList(10) & Date & " " & Time & vbCrLf,True
		WriteBinaryFile LogFN,CP_UNICODELITTLE,MsgList(13) & vbCrLf & MsgList(12) & vbCrLf & MsgList(13) & vbCrLf,True
	End If
	On Error GoTo 0
	'打开文件
	Mode = LoadFile(orgFile.FilePath,FN,0,0,0,Mode)
	If Mode < -1 Then GoTo ExitFunction
	'获取过滤和保留字串列表字典
	If ExtractSet(21) = "1" Then
		TempList = ReSplit(ReadBinaryFile(ExtractSet(35),CP_UNICODELITTLE,True),vbNullChar)
		StrList2StrDic(FilterStrDic,TempList,StrToLong(ExtractSet(22)),0)
	End If
	If ExtractSet(23) = "1" Then
		If Dir$(ExtractSet(37)) <> "" Then
			TempList = ReSplit(ReadBinaryFile(ExtractSet(37),CP_UNICODELITTLE,True),vbNullChar)
		Else
			TempList = ReSplit(Convert(ExcludeStr),ItemJoinStr)
		End If
		StrList2StrDic(ReserveStrDic,TempList,StrToLong(ExtractSet(24)),0)
	End If
	'打开原始文件，开始提取字串并计时
	If ShowMsg > 0 Then
		SetTextBoxString ShowMsg,MsgList(0)
		If ExtractSet(25) = "1" Then
			SetTextBoxString ShowMsg,MsgList(13) & vbCrLf & Replace$(MsgList(12),vbTab,"-") & vbCrLf & MsgList(13),True
		End If
	ElseIf ShowMsg < 0 Then
		PSL.OutputWnd(0).Clear
		PSL.Output MsgList(0)
		If ExtractSet(25) = "1" Then
			PSL.Output MsgList(13) & vbCrLf & Replace$(MsgList(12),vbTab,"-") & vbCrLf & MsgList(13)
		End If
	End If
	Msg.hWnd = ShowMsg
	Msg.Massage = MsgList(0) & " "
	StartTime = Timer
	'初始化字串数据
	i = 0: k = 0
	ReDim DataList(0) As STRING_PROPERTIE,TempList(0) As String
	'显示主窗口的取消操作按钮和禁止主窗口的 Esc 键响应退出主窗口
	Call ShowButton(StopHwnd,VK_ESCAPE,True)
	'提取 .NET Unicode 字串
	If orgFile.LangType = NET_FILE_SIGNATURE Then
		If Mid$(ExtractSet(4),2,1) = "1" And ExtractSet(9) = "1" Then
			For i = 0 To n - 1 Step 2
				GetStrings = GetNETString(DataList,Dic,orgFile,FN,Msg,TempList,Mode,AddList(i),AddList(i + 1))
				If GetStrings < 0 Then GoTo ExitFunction
				k = k + GetStrings
				If CheckArray(TempList) = True Then
					WriteBinaryFile LogFN,CP_UNICODELITTLE,StrListJoin(TempList,""),True
				End If
			Next i
		End If
		'检查其他字串是否需要提取
		For i = 5 To 10
			If i < 8 Then
				If StrToLong(ExtractSet(i)) <> 0 Then
					i = 0
					Exit For
				End If
			ElseIf StrToLong(ExtractSet(IIf(i = 9,41,48))) <> 0 Then
				i = 0
				Exit For
			End If
		Next i
	End If
	If i = 0 Then
		Select Case StrToLong(ExtractSet(0))
		Case 0
			Select Case orgFile.Magic
			Case "PE64","NET64","MAC64","NotPE64"
				For i = 0 To n - 1 Step 2
					GetStrings = GetPE64SectionStrByVA(DataList,Dic,orgFile,FN,Msg,TempList,Mode,AddList(i),AddList(i + 1))
					If GetStrings < 0 Then GoTo ExitFunction
					k = k + GetStrings
					Msg.Passed = Msg.Passed + AddList(i + 1) - AddList(i) + 1
					If CheckArray(TempList) = True Then
						WriteBinaryFile LogFN,CP_UNICODELITTLE,StrListJoin(TempList,""),True
					End If
				Next i
			Case Else
				For i = 0 To n - 1 Step 2
					GetStrings = GetPE32SectionStrByVA(DataList,Dic,orgFile,FN,Msg,TempList,Mode,AddList(i),AddList(i + 1))
					If GetStrings < 0 Then GoTo ExitFunction
					k = k + GetStrings
					Msg.Passed = Msg.Passed + AddList(i + 1) - AddList(i) + 1
					If CheckArray(TempList) = True Then
						WriteBinaryFile LogFN,CP_UNICODELITTLE,StrListJoin(TempList,""),True
					End If
				Next i
			End Select
		Case 1
			For i = 0 To n - 1 Step 2
				GetStrings = GetSectionStrBySmall(DataList,Dic,orgFile,FN,Msg,TempList,Mode,AddList(i),AddList(i + 1))
				If GetStrings < 0 Then GoTo ExitFunction
				k = k + GetStrings
				Msg.Passed = Msg.Passed + AddList(i + 1) - AddList(i) + 1
				If CheckArray(TempList) = True Then
					WriteBinaryFile LogFN,CP_UNICODELITTLE,StrListJoin(TempList,""),True
				End If
			Next i
		Case Else
			For i = 0 To n - 1 Step 2
				GetStrings = GetSectionStrByFull(DataList,Dic,orgFile,FN,Msg,TempList,Mode,AddList(i),AddList(i + 1))
				If GetStrings < 0 Then GoTo ExitFunction
				k = k + GetStrings
				Msg.Passed = Msg.Passed + AddList(i + 1) - AddList(i) + 1
				If CheckArray(TempList) = True Then
					WriteBinaryFile LogFN,CP_UNICODELITTLE,StrListJoin(TempList,""),True
				End If
			Next i
		End Select
	End If
	Erase TempList,AddList
	GetStrings = k
	If ExtractSet(25) = "0" Then
		If ShowMsg > 0 Then
			SetTextBoxString ShowMsg,Msg.Massage & "100%"
		ElseIf ShowMsg < 0 Then
			PSL.OutputWnd(0).Clear
			PSL.Output Msg.Massage & "100%"
		End If
	End If
	'隐藏主窗口中的取消操作按钮，启用 Esc 键的退出响应
	Call ShowButton(StopHwnd,VK_ESCAPE,False)
	'获取字串的引用列表和引用地址前的自定义类型，并过滤不需要提取的标准字串和无引用字串
	If GetStrings > 0 Then
		Set StrIDIndexDic = Dic: Set Dic = Nothing
		If orgFile.Magic <> "" Then
			ReDim AddList(UBound(DataList)) As Long
			i = IIf(IIf(ExtractSet(10) = "0",0,CheckRefCustomStrType(UseStrTypeList,IIf(orgFile.Magic = "",0,1))) = 0,0,4)
			i = i + StrToLong(ExtractSet(48)) + IIf(StrToLong(ExtractSet(11)) = 0,0,2)
			n = IIf(ExtractSet(25) = "0",ShowMsg,0)
			GetStrings = getVAListAndStrTypeByVA(orgFile,FN,DataList,UseStrTypeList,AddList,0,i,Mode,MsgList(15),n,True)
			If GetStrings < -2 Then GoTo ExitFunction
		End If
	End If
	'关闭文件
	UnLoadFile(FN,0,Mode)
	If ShowMsg > 0 Then
		SetTextBoxString ShowMsg,MsgList(1) & Format$(DateAdd("s",Timer - StartTime,0),MsgList(2)),True
	ElseIf ShowMsg < 0 Then
		PSL.Output MsgList(1) & Format$(DateAdd("s",Timer - StartTime,0),MsgList(2))
	End If
	'最后处理
	If GetStrings > 0 Then
		AllStrDataList = DataList: Erase DataList
		If StrToLong(ExtractSet(0)) > 1 Or (orgFile.USStreamID > -1 And ExtractSet(9) = "1") Then
			Call SortStrArraysByAddress(StrIDIndexDic,AllStrDataList,0,UBound(AllStrDataList),False)
		End If
		'备份字串类型数组
		If ExtractSet(10) = "1" Then
			OrgStrTypeList = UseStrTypeList: OrgStrTypeListBak = UseStrTypeList
		Else
			ReDim OrgStrTypeList(0) As STRING_TYPE: OrgStrTypeListBak = OrgStrTypeList
		End If
		'记录字串结束符
		StringTerminator = StrEndChar2Pattern(ExtractSet(31),2)(0)
		'清空过滤器的自定义字串类型
		FilterStrSet(9) = Left$(FilterStrSet(9),2)
		'还原过滤字串列表字典为字串过滤显示用
		'其他情况会在 ReExtractString 函数中还原
		If ExtractSet(21) = "1" Then
			TempList = ReSplit(ReadBinaryFile(ExtractSet(35),CP_UNICODELITTLE,True),vbNullChar)
			StrList2StrDic(FilterStrDic,TempList,StrToLong(ReSplit(FilterStrSet(17),ItemJoinStr)(1)),1)
		End If
	End If
	If StrToLong(Selected(21)) = 1 Then Beep
	'添加最后提取记录并打开记录
	If ExtractSet(26) = "1" Or ExtractSet(51) = "1" Then
		WriteBinaryFile LogFN,CP_UNICODELITTLE,MsgList(13) & vbCrLf & MsgList(11) & Date & " " & Time & vbCrLf,True
		WriteBinaryFile LogFN,CP_UNICODELITTLE,MsgList(1) & Format$(DateAdd("s",Timer - StartTime,0),MsgList(2)),True
		Close #LogFN
		ReDim FileDataList(0) As String
		FileDataList(0) = orgFile.FilePath & ".log" & JoinStr & "unicodeFFFE"
		OpenFile(orgFile.FilePath & ".log",FileDataList,1,True)
	End If
	Set Dic = Nothing
	Exit Function
	ExitFunction:
	Set Dic = Nothing
	'关闭文件
	UnLoadFile(FN,0,Mode)
	'隐藏主窗口中的取消操作按钮，启用 Esc 键的退出响应
	Call ShowButton(StopHwnd,VK_ESCAPE,False)
	On Error Resume Next
	Close #LogFN
	Exit Function
	'错误处理
	ErrorHandle:
	Set Dic = Nothing
	On Error Resume Next
	Close #LogFN
	Err.Source = "NotWriteFile"
	Err.Description = Err.Description & JoinStr & orgFile.FilePath & ".log"
	Call sysErrorMassage(Err,1)
End Function


'批量获取字串的引用列表及引用地址前的自定义类型
'StartID 为增加数据的开始索引号，= 0 按原索引 (为全新的数据)，否则按 IDList 中记录的索引
'fType = 标准字串过滤项(0,1) + 无引用字串过滤项(0,1+2) & 是否获取引用地址前的自定义类型项(0,2+2)
'fType = 0+0+0 = 0 过滤标准字串，不过滤无引用字串，不获取引用地址前的自定义类型
'fType = 1+0+0 = 1 不过滤标准字串，不过滤无引用字串，不获取引用地址前的自定义类型
'fType = 0+2+0 = 2 过滤标准字串，过滤无引用字串，不获取引用地址前的自定义类型
'fType = 1+2+0 = 3 不过滤标准字串，过滤无引用字串，不获取引用地址前的自定义类型
'fType = 0+0+4 = 4 过滤标准字串，不过滤无引用字串，获取引用地址前的自定义类型
'fType = 1+0+4 = 5 不过滤标准字串，不过滤无引用字串，获取引用地址前的自定义类型
'fType = 0+2+4 = 6 过滤标准字串，过滤无引用字串，获取引用地址前的自定义类型
'fType = 1+2+4 = 7 不过滤标准字串，过滤无引用字串，获取引用地址前的自定义类型
'ShowMsg = 0 在获取获取引用时不显示进度，< 0 仅在本函数中显示一次，> 0 显示进度
'返回值：getVAListAndStrTypeByVA = -3 取消，否则为过滤后的实际数
Private Function getVAListAndStrTypeByVA(File As FILE_PROPERTIE,FN As FILE_IMAGE,DataList() As STRING_PROPERTIE, _
	TypeList() As STRING_TYPE,IDList() As Long,ByVal StartID As Long,ByVal fType As Long, _
	ByVal Mode As Long,Optional ByVal Msg As String,Optional ByVal ShowMsg As Long,Optional ByVal Stopable As Boolean) As Long
	Dim i As Long,j As Long,k As Long,m As Long,n As Long
	getVAListAndStrTypeByVA = UBound(IDList) + 1
	Select Case fType
	Case 0	'过滤标准字串，不过滤无引用字串，不获取引用地址前的自定义类型
		ReDim mArray(getVAListAndStrTypeByVA) As Long
		For i = 0 To getVAListAndStrTypeByVA - 1
			If StartID = 0 Then j = i Else j = IDList(i)
			If DataList(j).StrType = 0 Then
				mArray(m) = j
				m = m + 1
			Else
				IDList(k) = DataList(j).ID
				k = k + 1
			End If
		Next i
		getVAListAndStrTypeByVA = getVAListAndStrTypeByVA - m
		If k > 0 Then k = k - 1
		ReDim Preserve IDList(k) As Long
		If m > 0 Then
			ReDim Preserve mArray(m - 1) As Long
			Call DelDataArray(StrIDIndexDic,DataList,mArray)
		End If
		Exit Function
	Case 1	'不过滤标准字串，不过滤无引用字串，不获取引用地址前的自定义类型
		For i = 0 To getVAListAndStrTypeByVA - 1
			If StartID = 0 Then j = i Else j = IDList(i)
			IDList(i) = DataList(j).ID
		Next i
		Exit Function
	End Select
	If File.Magic = "" Then Exit Function
	ReDim mArray(getVAListAndStrTypeByVA) As Long	'记录过滤标准字串ID
	ReDim nArray(getVAListAndStrTypeByVA) As Long	'记录过滤无引用字串ID
	ReDim kArray(getVAListAndStrTypeByVA) As Long	'记录获取引用地址前的自定义类型字串ID
	'判断是否需要获取引用地址
	Select Case fType
	Case 2	'过滤标准字串，过滤无引用字串，不获取引用地址前的自定义类型
		For i = 0 To getVAListAndStrTypeByVA - 1
			If StartID = 0 Then j = i Else j = IDList(i)
			If DataList(j).Moveable = 0 Then
				nArray(n) = j
				n = n + 1
			End If
			If DataList(j).StrType = 0 Then
				mArray(m) = j
				m = m + 1
			End If
			IDList(i) = DataList(j).ID
		Next i
	Case 3	'不过滤标准字串，过滤无引用字串，不获取引用地址前的自定义类型
		For i = 0 To getVAListAndStrTypeByVA - 1
			If StartID = 0 Then j = i Else j = IDList(i)
			If DataList(j).Moveable = 0 Then
				nArray(n) = j
				n = n + 1
			End If
			IDList(i) = DataList(j).ID
		Next i
	Case 4	'过滤标准字串，不过滤无引用字串，获取引用地址前的自定义类型
		For i = 0 To getVAListAndStrTypeByVA - 1
			If StartID = 0 Then j = i Else j = IDList(i)
			If DataList(j).Moveable = 0 Then
				If DataList(j).StrType = 0 Then
					mArray(m) = j
					m = m + 1
					kArray(k) = j
					k = k + 1
				End If
			ElseIf DataList(j).StrType = 0 Then
				mArray(m) = j
				m = m + 1
			End If
			IDList(i) = DataList(j).ID
		Next i
	Case 5	'不过滤标准字串，不过滤无引用字串，获取引用地址前的自定义类型
		For i = 0 To getVAListAndStrTypeByVA - 1
			If StartID = 0 Then j = i Else j = IDList(i)
			If DataList(j).Moveable = 0 Then
				If DataList(j).StrType = 0 Then
					kArray(k) = j
					k = k + 1
				End If
			End If
			IDList(i) = DataList(j).ID
		Next i
	Case 6	'过滤标准字串，过滤无引用字串，获取引用地址前的自定义类型
		For i = 0 To getVAListAndStrTypeByVA - 1
			If StartID = 0 Then j = i Else j = IDList(i)
			If DataList(j).Moveable = 0 Then
				nArray(n) = j
				n = n + 1
				If DataList(j).StrType = 0 Then
					mArray(m) = j
					m = m + 1
					kArray(k) = j
					k = k + 1
				End If
			ElseIf DataList(j).StrType = 0 Then
				mArray(m) = j
				m = m + 1
			End If
			IDList(i) = DataList(j).ID
		Next i
	Case 7	'不过滤标准字串，过滤无引用字串，获取引用地址前的自定义类型
		For i = 0 To getVAListAndStrTypeByVA - 1
			If StartID = 0 Then j = i Else j = IDList(i)
			If DataList(j).Moveable = 0 Then
				nArray(n) = j
				n = n + 1
				If DataList(j).StrType = 0 Then
					kArray(k) = j
					k = k + 1
				End If
			End If
			IDList(i) = DataList(j).ID
		Next i
	End Select
	'无需要过滤的标准字串、无引用字串和获取引用地址前字串时跳过
	If m + n + k = 0 Then Exit Function
	'有需要过滤的标准字串、但无需要过滤无引用字串和获取引用地址前字串时删除标准字串
	If n + k = 0 Then
		getVAListAndStrTypeByVA = getVAListAndStrTypeByVA - m
		ReDim Preserve mArray(m - 1) As Long
		Call DelDataArray(StrIDIndexDic,DataList,mArray)
		Call DelLongArray(IDList,mArray)
		Exit Function
	End If
	'显示获取引用消息和进度
	If ShowMsg > 0 Then
		SetTextBoxString ShowMsg,Msg,True
	ElseIf ShowMsg < 0 Then
		PSL.Output Msg
	End If
	'获取引用地址和引用代码
	ReDim List(0) As Long
	If n > 0 Then
		ReDim TempList(n - 1) As String
		ReDim Preserve nArray(n - 1) As Long
		List = nArray
	ElseIf k > 0 Then
		ReDim TempList(k - 1) As String
		ReDim Preserve kArray(k - 1) As Long
		List = kArray
	End If
	j = GetVARefListBatch(File,FN,DataList,TypeList,List,TempList,4,Mode,ShowMsg,Stopable)
	If j < -1 Then
		getVAListAndStrTypeByVA = -3
		Exit Function
	End If
	'获取引用地址前的自定义类型
	If j > 0 And k > 0 Then
		ReDim Preserve kArray(k - 1) As Long
		For i = 0 To k - 1
			With DataList(kArray(i))
				If .Source.lReferenceNum > 0 Then
					.StrType = GetCustomStrTypeRegExp(FN,.Source,TypeList,Mode,-1)
					.TagType = TagType(.StrType,TypeList)
				End If
			End With
		Next i
	End If
	'无需要过滤的标准字串、无引用字串时跳过
	If m + n = 0 Then Exit Function
	'无需要过滤的标准字串，并且需要获取引用的字串数和获取到引用的字串数相同时跳过
	If m = 0 Then
		If j > 0 And (j = n Or j = k) Then Exit Function
	End If
	'过滤标准字串
	If m > 0 Then
		ReDim Preserve mArray(m - 1) As Long
		j = m: m = 0
		For i = 0 To j - 1
			With DataList(mArray(i))
				If .StrType = 0 Then
					mArray(m) = mArray(i)
					m = m + 1
				End If
			End With
		Next i
	End If
	'过滤无引用字串
	If n > 0 Then
		ReDim Preserve nArray(n - 1) As Long
		j = n: n = 0
		For i = 0 To j - 1
			With DataList(nArray(i))
				If .Source.lReferenceNum = 0 Then
					nArray(n) = nArray(i)
					n = n + 1
				End If
			End With
		Next i
	End If
	'无需要过滤的标准字串、无引用字串时跳过
	If m + n = 0 Then Exit Function
	'删除要过滤的标准字串和无引用字串
	If m > 0 And n = 0 Then
		ReDim Preserve mArray(m - 1) As Long
		List = mArray
	ElseIf m = 0 And n > 0 Then
		ReDim Preserve nArray(n - 1) As Long
		List = nArray
	Else
		ReDim Preserve mArray(m - 1) As Long
		List = mArray
		ReDim Preserve List(m + n - 1) As Long
		For i = 0 To n - 1
			List(m + i) = nArray(i)
		Next i
		List = ClearDecArray(List)
	End If
	getVAListAndStrTypeByVA = getVAListAndStrTypeByVA - UBound(List) - 1
	Call DelDataArray(StrIDIndexDic,DataList,List)
	Call DelLongArray(IDList,List)
End Function


'获取指定位置的字符串，无代码页指定时返回代码页
'fType < -1 添加时跳过文件数据目录所在区域，获取来源和翻译字串及数据
'fType = -1 添加时不跳过文件数据目录所在区域，获取来源和翻译字串及数据
'fType = 0  单个获取来源和翻译字串及数据
'fType = 1  单个获取来源字串
'fType > 1  单个获取翻译字串
'getVA = False 获取引用地址 (仅 fType < 1 时有效)
Private Function GetString(File As FILE_PROPERTIE,FN As FILE_IMAGE,strData As STRING_PROPERTIE, _
		CPList() As LANG_PROPERTIE,TypeList() As STRING_TYPE,OptionSet() As String, _
		ByVal fType As Long,ByVal Mode As Long,Optional ByVal getVA As Boolean) As STRING_PROPERTIE
	Dim i As Long,j As Long,RSize As Long,MinLength As Long,StrType As Integer,MinVal As Integer
	Dim Matches As Object,Data As STRING_SUB_PROPERTIE,EndCharList() As String,StrTypeEndChar() As String,EndChar As String

	If fType < 1 Then
		With strData.Source
			Data.lStartAddress = .lStartAddress
			Data.lEndAddress = .lEndAddress
			Data.lHexLength = .lHexLength
			Data.CodePage = .CodePage
			Data.inSectionID = .inSectionID
			Data.inSubSecID = .inSubSecID
		End With
	ElseIf fType = 1 Then
		With strData.Source
			GetString.Source.sString = ReConvert(ByteToString(GetBytes(FN,.lHexLength,.lStartAddress,Mode),.CodePage))
		End With
		Exit Function
	Else
		With strData.Trans
			GetString.Trans.sString = ReConvert(ByteToString(GetBytes(FN,.lHexLength,.lStartAddress,Mode),.CodePage))
		End With
		Exit Function
	End If

	With Data
		'获取文件区段最大地址
		If .inSectionID < 0 Then
			.inSectionID = SkipSection(File,.lStartAddress,0,RSize,1)
			If .inSectionID < 0 Then GoTo ExitFunction
		Else
			RSize = File.SecList(.inSectionID).lPointerToRawData + File.SecList(.inSectionID).lSizeOfRawData - 1
		End If
		'If File.SecList(.inSectionID).SubSecs > 0 Then
		'	.inSubSecID = SkipSubSection(File.SecList(.inSectionID),.lStartAddress,0,RSize)
		'	If .inSubSecID < 0 Then Exit Function
		'End If

		'跳过文件数据目录所在区域
		If fType < -1 Then
			If RSize > -fType Then RSize = -fType
		End If

		'获取字符串结束符的正则表达式模板
		EndCharList = StrEndChar2Pattern(OptionSet(31))
		EndChar = Mid(EndCharList(1),InStr(EndCharList(1),")(") + 2)
		EndChar = Left(EndChar,InStrRev(EndChar,")") - 1)
		'获取 Android 字符串前面长度标识符的最小字节长度
		'MinVal = IIf(OptionSet(41) = "0" And strData.StrType > -5,0,2)
		'获取字符串最小字符数长度
		MinLength = StrToLong(OptionSet(27))

		'获取 .NET 用户字串
		If File.LangType = NET_FILE_SIGNATURE And File.USStreamID > -1 Then
			i = File.StreamList(File.USStreamID).lPointerToRawData
			j = i + File.StreamList(File.USStreamID).lSizeOfRawData - 1
			If .lStartAddress >= i And .lStartAddress <= j Then
				If OptionSet(9) = "0" Then
					.lEndAddress = j
					GoTo ExitFunction
				'ElseIf Mid$(OptionSet(4),2,1) = "0" Then
				'	.lEndAddress = j
				'	GoTo ExitFunction
				End If
				Do
					.lStartAddress = .lStartAddress - 1
					If .lStartAddress < i Then Exit Do
					MinVal = GetByte(FN,.lStartAddress,Mode)
				Loop Until MinVal = 0 Or MinVal = 1
				.lStartAddress = .lStartAddress + 1
				Do
					StrType = -CorSigUncompressData(FN,.lStartAddress,.lHexLength,Mode)
					If .lHexLength = 0 Then
						.lStartAddress = getNotNullByte(FN,.lStartAddress + 1,j,Mode)
					End If
				Loop Until .lHexLength > 0 Or .lStartAddress >= j
				If .lHexLength >= MinLength * 2 Then
					.lStartAddress = .lStartAddress - StrType
					.lEndAddress = .lStartAddress + .lHexLength - 2
					'检查结束标识符是否符合要求
					'If GetByte(FN,.lEndAddress + 1,Mode) = IIf(CheckStrRegExp(.sString,"[\x01-\x7F]",0,1) = True,0,1) Then
					If GetByte(FN,.lEndAddress + 1,Mode) < 2 Then
						.lHexLength = .lHexLength - 1
						.CodePage = CP_UNICODELITTLE
						.sString = ByteToString(GetBytes(FN,.lHexLength,.lStartAddress,Mode),.CodePage)
						.lCharLength = Len(.sString)
						'获取字串的最大位置
						.lMaxAddress = getNotNullByte(FN,.lEndAddress + 2,j,Mode) - 1	'跳到非 &H00 开始处前一个字节
						GoTo AddStrData
					End If
				End If
				If fType < 0 Then
					.lEndAddress = .lStartAddress - StrType + .lHexLength - 1
					strData.Source.lMaxAddress = getNotNullByte(FN,.lEndAddress + 2,RSize,Mode) - 1
				End If
				Exit Function
			End If
		End If

		'获取非 .NET 用户字串
		ReDim intList(0) As Integer
		If .CodePage <> CP_UNKNOWN Then
			'获取字符编码的提取顺序和指定代码页的编码范围
			Select Case .CodePage
			Case CP_UNICODELITTLE
				intList(0) = 2
				j = 2
			Case CP_UTF8
				intList(0) = 3
				j = 1
			Case CP_UNICODEBIG
				intList(0) = 4
				j = 2
			Case CP_UTF7
				intList(0) = 5
				j = 1
			Case CP_UTF32LE, CP_UTF_32LE
				intList(0) = 6
				j = 4
			Case CP_UTF32BE, CP_UTF_32BE
				intList(0) = 7
				j = 4
			Case Else
				intList(0) = 1
				j = 1
			End Select
			'添加、导入字串和更改最大地址时重新获取结束地址
			If .lEndAddress = 0 Or .lEndAddress < .lStartAddress Then
				.lEndAddress = getEndByteRegExp(FN,.lStartAddress + 1,RSize,Mode,"\x00",-j) - 1	'跳到 &H0000 开始处前一个字节
				'If .lEndAddress < .lStartAddress + 1 Then .lEndAddress = RSize
				.lHexLength = .lEndAddress - .lStartAddress + 1
				If .lHexLength < MinLength * j Then GoTo ExitFunction
				'获取自定义字符串结束标识符的正则表达式模板
				StrTypeEndChar = StrTypeEndChar2Pattern(TypeList,CPList,intList,OptionSet(10))
				'检测字节的代码页
				'.lEndAddress = getNotNullByte(FN,.lEndAddress + 1,RSize,Mode) - 1	'跳到 &H0000 结束处
				.lMaxAddress = getCodePageRegExp(FN,Data,CPList,intList,MinLength,StrTypeEndChar,EndCharList,Mode,IIf(fType < 0,1,0), _
								StrToLong(OptionSet(52)),StrToLong(OptionSet(53)))
				If .CodePage = CP_UNKNOWN Then GoTo ExitFunction
			'添加、导入字串和更改代码页时直接获取字串
			Else
				If .lHexLength < MinLength * j Then GoTo ExitFunction
				.sString = ByteToString(GetBytes(FN,.lHexLength,.lStartAddress,Mode),.CodePage)
			End If
			'获取字符长度
			.lCharLength = Len(.sString)
			'检测是否为 Delphi 或自定义类型字符串
			If .lMaxAddress = 0 Then .lMaxAddress = .lEndAddress
			'If File.PELangType = DELPHI_FILE_SIGNATURE Or OptionSet(10) = "1" Or MinVal > 0 Then
			If InStr(OptionSet(5) & OptionSet(6) & OptionSet(7) & OptionSet(8) & OptionSet(10) & OptionSet(41),"1") Then
				StrType = GetStrType(File,FN,Data,TypeList,OptionSet,Mode,IIf(fType < 0,0,1))
			End If
			'获取字串的最大位置
			'.lMaxAddress = getNotNullByte(FN,.lEndAddress + EndByteLength(StrType,TypeList) + 1,RSize,Mode) - 1
			'.lMaxAddress = getNotNullByte(FN,.lMaxAddress + 1,RSize,Mode) - 1
			'.lMaxAddress = getNotNullByteRegExp(FN,.lMaxAddress + 1,RSize,Mode) - 1
			.lMaxAddress = getEndByteRegExp(FN,.lMaxAddress + 1,RSize,Mode,EndChar,CP_ISOLATIN1,True) - 1
			'避开 Delphi 窗体代码
			If File.LangType = DELPHI_FILE_SIGNATURE And .lMaxAddress + 6 < RSize Then
				If GetLong(FN,.lMaxAddress + 1,Mode) = &HFFFFFFFF Then
					If .lMaxAddress - 4 > .lEndAddress Then .lMaxAddress = .lMaxAddress - 4
				End If
			End If
		Else
			'获取双空字节之间的字节块地址
			If GetByte(FN,.lStartAddress,Mode) = 0 Then
				.lStartAddress = getNotNullByte(FN,.lStartAddress,RSize,Mode)	'跳到非 &H00 开始处
			End If
			'获取 CP_UTF32LE 和 CP_UTF32BE 所需的空字节长度
			If Mid$(OptionSet(4),6,1) <> "0" Or Mid$(OptionSet(4),7,1) <> "0" Then
				j = 4
			ElseIf Mid$(OptionSet(4),2,1) <> "0" Or Mid$(OptionSet(4),4,1) <> "0" Then
				j = 2
			Else
				j = 1
			End If
			.lEndAddress = getEndByteRegExp(FN,.lStartAddress + 1,RSize,Mode,"\x00",-j) - 1	'跳到 &H0000 开始处前一个字节
			'If .lEndAddress < .lStartAddress + 1 Then .lEndAddress = RSize
			.lHexLength = .lEndAddress - .lStartAddress + 1
			If .lHexLength < MinLength * j Then GoTo ExitFunction
			'转换字符编码的提取顺序
			intList = ConvertStrCPOrder(OptionSet(4))
			'获取自定义字符串结束标识符的正则表达式模板
			StrTypeEndChar = StrTypeEndChar2Pattern(TypeList,CPList,intList,OptionSet(10))
			'检测字节的代码页
			.lMaxAddress = getCodePageRegExp(FN,Data,CPList,intList,MinLength,StrTypeEndChar,EndCharList,Mode,1, _
							StrToLong(OptionSet(52)),StrToLong(OptionSet(53)))
			If .CodePage = CP_UNKNOWN Then GoTo ExitFunction
			'获取字串及其类型
			'.sString = ByteToString(GetBytes(FN,.lHexLength,.lStartAddress,Mode),.CodePage)
			.lCharLength = Len(.sString)
			'检测提取的字串是否确实为英文
			'If .CodePage <> CP_WESTEUROPE And .CodePage <> CP_UNICODELITTLE And .CodePage <> CP_UNICODEBIG And _
			'   .CodePage <> CP_UTF32LE And .CodePage <> CP_UTF32BE Then
			'	If MinVal = 0 Then
			'		If CheckStrRegExp(.sString,"[\x01-\x7F]",0,1) = True Then
			'			.CodePage = CP_WESTEUROPE
			'		End If
			'	End If
			'End If
			'检测是否为 Delphi 或自定义类型字符串
			'If File.PELangType = DELPHI_FILE_SIGNATURE Or OptionSet(10) = "1" Or MinVal > 0 Then
			If InStr(OptionSet(5) & OptionSet(6) & OptionSet(7) & OptionSet(8) & OptionSet(10) & OptionSet(41),"1") > 0 Then
				StrType = GetStrType(File,FN,Data,TypeList,OptionSet,Mode,0)
			End If
			'获取字串的最大位置
			'.lMaxAddress = getNotNullByte(FN,.lEndAddress + EndByteLength(StrType,TypeList) + 1,RSize,Mode) - 1
			'.lMaxAddress = getNotNullByte(FN,.lMaxAddress + 1,RSize,Mode) - 1
			'.lMaxAddress = getNotNullByteRegExp(FN,.lMaxAddress + 1,RSize,Mode) - 1
			.lMaxAddress = getEndByteRegExp(FN,.lMaxAddress + 1,RSize,Mode,EndChar,CP_ISOLATIN1,True) - 1
			'避开 Delphi 窗体代码
			If File.LangType = DELPHI_FILE_SIGNATURE And .lMaxAddress + 6 < RSize Then
				If GetLong(FN,.lMaxAddress + 1,Mode) = &HFFFFFFFF Then
					If .lMaxAddress - 4 > .lEndAddress Then .lMaxAddress = .lMaxAddress - 4
				End If
			End If
		End If

		'获取字串的引用列表
		If getVA = False Then
			If .inSectionID < File.MaxSecIndex Then
				'判断是否需要检查跟随引用地址的自定义字符类型
				i = IIf(OptionSet(10) = "0",0,CheckRefCustomStrType(TypeList,IIf(File.Magic = "",0,1)))
				If OptionSet(11) = "1" Or (StrType = 0 And i > 1) Then
					Call GetVARefList(File,FN,Data,TypeList,0,0,"",0,Mode,0)
					'过滤无引用的字串
					If OptionSet(11) = "1" And .lReferenceNum = 0 Then GoTo ExitFunction
					'获取引用地址前的自定义类型
					If StrType = 0 And i = 2 Then
						StrType = GetCustomStrTypeRegExp(FN,Data,TypeList,Mode,-1)
					End If
				End If
			End If
		End If

		'记录字串数据
		AddStrData:
		With GetString
			'.ID = strData.ID
			.ID = Data.lStartAddress
			If strData.ID > -1 Then
				If .ID <> strData.ID Then
					If StrIDIndexDic.Exists(strData.ID) Then
						If Not StrIDIndexDic.Exists(.ID) Then
							StrIDIndexDic.Key(strData.ID) = .ID
						End If
					End If
					If StrIDIndexDicBak.Exists(strData.ID) Then
						If Not StrIDIndexDicBak.Exists(.ID) Then
							StrIDIndexDicBak.Key(strData.ID) = .ID
							AllStrDataListBak(StrIDIndexDicBak.Item(.ID)).ID = .ID
						End If
					End If
					If UseStrIDIndexDic.Exists(strData.ID) Then
						If Not UseStrIDIndexDic.Exists(.ID) Then
							UseStrIDIndexDic.Key(strData.ID) = .ID
							UseStrDataList(UseStrIDIndexDic.Item(.ID)).ID = .ID
						End If
					End If
				End If
			End If
			.LockState = strData.LockState
			.StrType = StrType
			.TagType = TagType(.StrType,TypeList)
			.EndByteLength = EndByteLength(.StrType,TypeList)
			.ScapeIDBeMoved = -1
			.ScapeIDForMove = -1
			.Moveable = Moveable(File,GetString)
			.Source = Data
			.Source.inSubSecID = SkipSubSection(File.SecList(.Source.inSectionID),.Source.lStartAddress,0,0)
			.Source.sString = ReConvert(Data.sString)
			'.Source.CodePage = Data.CodePage
			'.Source.lStartAddress = Data.lStartAddress
			'.Source.lEndAddress = Data.lEndAddress
			'.Source.lMaxAddress = Data.lMaxAddress
			'.Source.lHexLength = Data.lEndAddress - Data.lStartAddress + 1
			.Source.iNullByteLength = NullByteLength(GetString,False)
			.Source.lMaxHexLength = .Source.lMaxAddress - .Source.lStartAddress + 1 - .EndByteLength - .Source.iNullByteLength
			'.Source.lCharLength = Len(Data.sString)
			'.Source.Reference = strData.Reference
			'.Source.inSectionID = strData.inSectionID
			.Trans = .Source
			ReDim GetString.Trans.Reference(0) 'As REFERENCE_PROPERTIE
			.Trans.GetRefState = 0
			.Trans.lReferenceNum = 0
			Call StrTypeLength(GetString,TypeList)
		End With
		Exit Function

		ExitFunction:
		If fType < 0 Then
			If .lMaxAddress <= .lEndAddress Then
				strData.Source.lMaxAddress = getNotNullByte(FN,.lEndAddress + 1,RSize,Mode) - 1
			Else
				strData.Source.lMaxAddress = .lMaxAddress
			End If
		End If
	End With
End Function


'写入字符串，成功返回 Ture，截断写入时返回写入的字符串
'fType < 0 原长写入字串(未超长的填充00)
'fType = 0 最长写入字串和引用地址(未超长的填充00)
'fType = 1 最长写入字串(未超长的填充00)
'fType = 2 写入引用地址
'MoveVal = 第二次时使用的第一次写入引起的地址差额，注意：不是隐蔽区段的差额
Private Function WritePEString(trnFile As FILE_PROPERTIE,FN1 As FILE_IMAGE,FN2 As FILE_IMAGE,strData() As STRING_PROPERTIE, _
		ByVal ID As Long,textStr As String,ByVal fType As Long,ByVal Mode As Long,Optional ByVal MoveVal As Long) As Integer
	Dim i As Long,trnStartPos As Long,trnLength As Long,trnMaxLength As Long,EndCharLength As Long
	Dim TempByte() As Byte,Temp As String,intList(3) As Integer

	On Error GoTo localError
	With strData(ID)
		If .Moveable > 0 Then
			trnStartPos = .Source.lStartAddress + .Source.MoveLength + MoveVal
			If fType < 0 Or .OverLengthWrite > 0 Then
				trnMaxLength = .Source.lHexLength + .Source.iNullByteLength + .EndByteLength
			Else
				trnMaxLength = .Source.lMaxAddress + MoveVal - trnStartPos + 1
			End If
		Else
			'还原为完整翻译的开始地址
			trnStartPos = .Trans.lStartAddress - .Trans.MoveLength
			trnMaxLength = .Trans.lMaxAddress - trnStartPos + 1
		End If
		trnLength = .Trans.lHexLength

		'转义字串
		Temp = Convert(.Trans.sString)

		'计算字串类型的最小移动值和截断写入长度
		If trnLength > trnMaxLength - .EndByteLength - .Trans.iNullByteLength Then
			'获取翻译的截断写入和完整翻译之间的长度差额
			.Trans.MoveLength = MinMoveLength(strData(ID),Temp,trnLength,trnMaxLength)
			'计算截断写入后的地址
			trnStartPos = trnStartPos + .Trans.MoveLength
			trnMaxLength = trnMaxLength - .Trans.MoveLength
			'返回被截断的字串
			textStr = ReConvert(Temp)
		Else
			'完整写入时截断写入修正值置零
			.Trans.MoveLength = 0
		End If
		If trnMaxLength < 1 Then Exit Function

		'返回写入翻译地址、长度数据和写入类型
		If .Moveable > 0 Then
			.Trans.lStartAddress = trnStartPos
			.Trans.lEndAddress = .Trans.lStartAddress + .Trans.lHexLength - 1
			.Trans.lMaxAddress = GetMaxAddress(strData(ID),False) + MoveVal
			.Trans.lMaxHexLength = .Trans.lMaxAddress - .Trans.lStartAddress + 1 - .EndByteLength - .Trans.iNullByteLength
			.WriteType = WriteType(trnFile,strData(ID),WriteSet)
		ElseIf trnStartPos <> .Trans.lStartAddress Then
			.Trans.lStartAddress = trnStartPos
			.Trans.lEndAddress = .Trans.lStartAddress + .Trans.lHexLength - 1
			.Trans.lMaxHexLength = trnMaxLength - .EndByteLength - .Trans.iNullByteLength
			If .Trans.lReferenceNum > 0 Then
				i = IIf(.MoveType < 4,1,-(.Trans.lStartAddress - .Trans.MoveLength))
				Call GetVARefList(trnFile,"",.Trans,OrgStrTypeList,.TagType,.Moveable,"",i,Mode,0)
			End If
		End If

		If fType < 2 Then
			'标记当前移位写入字串为已清空，以免再次被清空
			If .ScapeIDForMove > -1 Then
				If .WriteType > 2 Then
					i = StrIDIndexDic.Item(.ScapeIDForMove)
					If strData(i).SourceStringClearState = 0 Then
						strData(i).SourceStringClearState = 1
						'如果写入的位置是其他不移位字串的后面，则先清空其他字串结束地址至写入字串之间的字节
						'以免单独写入时不选择同时写入被覆盖的字串而导致被覆盖的字串以非 &H00 结束
						If strData(i).WriteType = 1 Then
							i = strData(i).Trans.lEndAddress + strData(i).EndByteLength + 1
							ReDim TempByte(.Trans.lStartAddress - (.Trans.StrTypeLength + .Trans.MoveLength) - i - 1) As Byte
							PutBytes(FN2,i,TempByte,.Trans.lStartAddress - (.Trans.StrTypeLength + .Trans.MoveLength) - i,Mode)
						End If
					End If
				End If
			End If

			'清空非部分移位字串原始地址的所有字节(全部移位时包括字串标识符)
			If .SourceStringClearState = 0 Then
				If .Moveable > 0 Then
					i = IIf(CheckStrVal(strData(ID),2,MoveVal) = False,.Source.StrTypeLength,0)
					ReDim TempByte(.Source.lHexLength + .EndByteLength + i - 1) As Byte
					PutBytes(FN2,.Source.lStartAddress - i + MoveVal,TempByte,.Source.lHexLength + .EndByteLength + i,Mode)
					.SourceStringClearState = 1
				ElseIf .WriteType > 0 And .WriteType < 4 And .SplitState = 0 Then
					i = IIf(.WriteType = 3,.Source.StrTypeLength,0)
					ReDim TempByte(.Source.lHexLength + .EndByteLength + i - 1) As Byte
					PutBytes(FN2,.Source.lStartAddress - i + MoveVal,TempByte,.Source.lHexLength + .EndByteLength + i,Mode)
					.SourceStringClearState = 1
				End If
			End If

			'写入字符串标识符参数
			If .StrType <> 0 Then
				i = 0
				If CheckStrVal(strData(ID),2,MoveVal) = False Then intList(0) = 1
				If .Trans.CodePage <> .Source.CodePage Then intList(1) = 1
				If trnLength <> .Source.lHexLength Then
					intList(2) = 1
				ElseIf .StrType < -4 Then
					If Len(Temp) <> .Source.lCharLength Then intList(2) = 1
				ElseIf .LengthModeID > 0 And .LengthModeID <> 1 And .LengthModeID <> 5 Then
					If Len(Temp) <> .Source.lCharLength Then intList(2) = 1
				End If
				If .StrType > -5 And .StrType < 0 Then
					intList(3) = 1
				ElseIf .EndByteLength > 0 Then
					intList(3) = 1
				End If
				Select Case .StrType
				Case Is < -4
					If intList(0) + intList(2) > 0 Then i = 1
				Case Is < 0
					If intList(0) + intList(2) + intList(3) > 0 Then i = 1
				Case 1
					If intList(0) + intList(1) + intList(2) > 0 Then i = 1
				Case Is > 4
					If intList(0) + intList(1) + intList(2) + intList(3) > 0 Then i = 1
				Case Else
					If intList(0) + intList(2) > 0 Then i = 1
				End Select
				If i = 1 Then
					WritePEString = WriteStrType(FN1,FN2,strData(ID),Temp,trnLength,intList,Mode,MoveVal)
					If WritePEString < 1 Then
						WritePEString = IIf(WritePEString = 0,-3,-1)
						Exit Function
					End If
				End If
			End If

			'写入翻译字串
			TempByte = StringToByte(Temp,.Trans.CodePage)
			PutBytes(FN2,.Trans.lStartAddress,TempByte,trnLength,Mode)
			'清空字串结束标识符至最大地址之间的字节
			trnMaxLength = trnMaxLength - trnLength - .EndByteLength
			If trnMaxLength > 0 Then
				ReDim TempByte(trnMaxLength - 1) As Byte
				If .Source.iNullByteLength > 0 Then
					EndCharLength = .Source.lMaxAddress - .Source.lEndAddress - .EndByteLength
					If EndCharLength >= trnMaxLength Then
						CopyMemory TempByte(0), GetBytes(FN1,EndCharLength,.Source.lEndAddress + .EndByteLength + 1 + MoveVal,Mode)(0),trnMaxLength
					ElseIf EndCharLength > 0 Then
						ReDim srcByte(0) As Byte
						srcByte = GetBytes(FN1,EndCharLength,.Source.lEndAddress + .EndByteLength + 1 + MoveVal,Mode)
						trnStartPos = trnMaxLength \ EndCharLength
						For i = 0 To trnStartPos - 1
							CopyMemory TempByte(EndCharLength * i), srcByte(0), EndCharLength
						Next i
						i = (trnMaxLength Mod EndCharLength)
						If i > 0 Then
							CopyMemory TempByte(EndCharLength * trnStartPos), srcByte(0), i
						End If
					End If
				End If
				PutBytes(FN2,.Trans.lStartAddress + trnLength + .EndByteLength,TempByte,trnMaxLength,Mode)
			End If
		End If

		'修改的引用代码
		If fType = 0 Or fType = 2 Then
			If .Moveable = 0 And .Source.lReferenceNum > 0 Then
				If (.WriteType > 2 And .WriteType < 5) Or .Source.MoveLength + .Trans.MoveLength <> 0 Then
					WritePEString = WriteRefCode(trnFile,FN1,FN2,strData(ID),Mode)
					If WritePEString < 1 Then
						WritePEString = IIf(WritePEString = 0,-2,-1)
						Exit Function
					End If
				End If
			End If
		End If
	End With
	WritePEString = 1
	Exit Function

	localError:
	WritePEString = -1
End Function


'超长写入字符串，成功返回 Ture，返回写入翻译地址、长度数据和写入类型
'fType = 1 短于原始字串的按原始字串最大长度留空，超长字串按代码页所需长度留空
'fType = 2 全部按原始字串后的原有空字节长度留空，短于原始字串的字节块被缩短
'fType >= 3 写入 .NET 字串，包括字串长度字节和尾随字节
'MoveVal = 第二次时使用的第一次写入引起的地址差额，注意：不是隐蔽区段的差额
Private Function WriteNotPEString(trnFile As FILE_PROPERTIE,FN1 As FILE_IMAGE,FN2 As FILE_IMAGE,strData() As STRING_PROPERTIE, _
		ByVal ID As Long,PreID As Long,ByVal fType As Long,ByVal Mode As Long,Optional ByVal MoveVal As Long) As Integer
	Dim i As Long,trnStartPos As Long,trnMaxLength As Long,EndCharLength As Long
	Dim TempByte() As Byte,Temp As String,intList(3) As Integer

	On Error GoTo localError
	With strData(ID)
		'写入翻译字串的后段字节
		If PreID < -1 Then
			If fType > 3 Then
				i = fType - (.Source.lMaxAddress + 1) + 1
				If i > 0 Then
					TempByte = GetBytes(FN1,i,.Source.lMaxAddress + 1 + MoveVal,Mode)
					PutBytes(FN2,.Trans.lMaxAddress + 1,TempByte,i,Mode)
				End If
				PreID = fType + MoveVal + 1 - (PreID + 2)
				i = GetFileLength(FN1,Mode) - PreID
				If i > 0 Then
					TempByte = GetBytes(FN1,i,fType + MoveVal + 1,Mode)
					PutBytes(FN2,PreID,TempByte,i,Mode)
					PreID = PreID + i
				End If
			Else
				PreID = .Trans.lMaxAddress + 1
				i = GetFileLength(FN1,Mode) - (.Source.lMaxAddress + 1 + MoveVal)
				If i > 0 Then
					TempByte = GetBytes(FN1,i,.Source.lMaxAddress + 1 + MoveVal,Mode)
					PutBytes(FN2,PreID,TempByte,i,Mode)
					PreID = PreID + i
				End If
			End If
			WriteNotPEString = 1
			Exit Function
		End If

		'先写入翻译前一段的原始字串包括其他未提取字串的字节
		If PreID < 0 Then
			trnStartPos = .Source.lStartAddress + MoveVal
			If trnStartPos > 0 Then
				TempByte = GetBytes(FN1,trnStartPos,0,Mode)
				PutBytes(FN2,0,TempByte,trnStartPos,Mode)
			End If
		Else
			trnStartPos = strData(PreID).Trans.lMaxAddress + 1
			i = .Source.lStartAddress - strData(PreID).Source.lMaxAddress - 1
			If i > 0 Then
				TempByte = GetBytes(FN1,i,strData(PreID).Source.lMaxAddress + 1 + MoveVal,Mode)
				PutBytes(FN2,trnStartPos,TempByte,i,Mode)
				trnStartPos = trnStartPos + i
			End If
		End If
		trnStartPos = trnStartPos + .Source.MoveLength

		'按写入方式计算字串写入地址和最大长度
		Select Case fType
		Case 1
			'翻译短于源文最大长度的，后面补足 &H00，否则增加 &H00
			If .Trans.lHexLength > .Source.lMaxHexLength Then
				trnMaxLength = .Trans.lHexLength + .Trans.iNullByteLength + .EndByteLength
			Else
				trnMaxLength = .Source.lMaxAddress - .Source.lStartAddress + 1
			End If
		Case 2
			trnMaxLength = .Trans.lHexLength + .Source.lMaxAddress - .Source.lEndAddress
		Case 3	'计算 .Net 字串的写入地址
			trnMaxLength = .Trans.lHexLength + .Trans.iNullByteLength + .EndByteLength
		End Select
		If trnMaxLength < 1 Then Exit Function

		'转义字串
		Temp = Convert(.Trans.sString)

		'完整写入时截断写入修正值置零
		.Trans.MoveLength = 0
		'返回写入翻译地址、长度数据和写入类型
		If .SplitState < 0 Then
			If PreID < 0 Then
				.Trans.lStartAddress = trnStartPos
			ElseIf strData(PreID).SplitState <> 0 Then
				.Trans.lStartAddress = trnStartPos + .Trans.StrTypeLength
			Else
				.Trans.lStartAddress = trnStartPos
			End If
		Else
			.Trans.lStartAddress = trnStartPos
		End If
		.Trans.lEndAddress = .Trans.lStartAddress + .Trans.lHexLength - 1
		.Trans.lMaxAddress = .Trans.lStartAddress + trnMaxLength - 1
		.Trans.lMaxHexLength = trnMaxLength - .EndByteLength - .Trans.iNullByteLength
		.WriteType = WriteType(trnFile,strData(ID),WriteSet)

		'写入字符串标识符参数
		If .StrType <> 0 Then
			i = 0
			If CheckStrVal(strData(ID),2,MoveVal) = False Then intList(0) = 1
			If .Trans.CodePage <> .Source.CodePage Then intList(1) = 1
			If .Trans.lHexLength <> .Source.lHexLength Then
				intList(2) = 1
			ElseIf .StrType < -4 Then
				If Len(Temp) <> .Source.lCharLength Then intList(2) = 1
			ElseIf .LengthModeID > 0 And .LengthModeID <> 1 And .LengthModeID <> 5 Then
				If Len(Temp) <> .Source.lCharLength Then intList(2) = 1
			End If
			If .StrType > -5 And .StrType < 0 Then
				intList(3) = 1
			ElseIf .EndByteLength > 0 Then
				intList(3) = 1
			End If
			Select Case .StrType
			Case Is < -4
				If intList(0) + intList(2) > 0 Then i = 1
			Case Is < 0
				If intList(0) + intList(2) + intList(3) > 0 Then i = 1
			Case 1
				If intList(0) + intList(1) + intList(2) > 0 Then i = 1
			Case Is > 4
				If intList(0) + intList(1) + intList(2) + intList(3) > 0 Then i = 1
			Case Else
				If intList(0) + intList(2) > 0 Then i = 1
			End Select
			If i > 0 Then
				WriteNotPEString = WriteStrType(FN1,FN2,strData(ID),Temp,.Trans.lHexLength,intList,Mode,MoveVal)
				If WriteNotPEString < 1 Then
					WriteNotPEString = IIf(WriteNotPEString = 0,-3,-1)
					PreID = ID
					Exit Function
				End If
			End If
		End If

		'写入翻译字串
		TempByte = StringToByte(Temp,.Trans.CodePage)
		PutBytes(FN2,.Trans.lStartAddress,TempByte,.Trans.lHexLength,Mode)
		'清空字串结束标识符至最大地址之间的字节
		trnMaxLength = trnMaxLength - .Trans.lHexLength - .EndByteLength
		If trnMaxLength > 0 Then
			ReDim TempByte(trnMaxLength - 1) As Byte
			If .Source.iNullByteLength > 0 Then
				EndCharLength = .Source.lMaxAddress - .Source.lEndAddress - .EndByteLength
				If EndCharLength >= trnMaxLength Then
					CopyMemory TempByte(0), GetBytes(FN1,EndCharLength,.Source.lEndAddress + .EndByteLength + 1 + MoveVal,Mode)(0),trnMaxLength
				ElseIf EndCharLength > 0 Then
					ReDim srcByte(0) As Byte
					srcByte = GetBytes(FN1,EndCharLength,.Source.lEndAddress + .EndByteLength + 1 + MoveVal,Mode)
					trnStartPos = trnMaxLength \ EndCharLength
					For i = 0 To trnStartPos - 1
						CopyMemory TempByte(EndCharLength * i), srcByte(0), EndCharLength
					Next i
					i = (trnMaxLength Mod EndCharLength)
					If i > 0 Then
						CopyMemory TempByte(EndCharLength * trnStartPos), srcByte(0), i
					End If
				End If
			End If
			PutBytes(FN2,.Trans.lStartAddress + .Trans.lHexLength + .EndByteLength,TempByte,trnMaxLength,Mode)
		End If
	End With
	'设置写入成功并退出函数
	PreID = ID
	WriteNotPEString = 1
	Exit Function

	localError:
	WriteNotPEString = -1
End Function


'写入字串引用代码
Private Function WriteRefCode(trnFile As FILE_PROPERTIE,FN1 As FILE_IMAGE,FN2 As FILE_IMAGE,strData As STRING_PROPERTIE,ByVal Mode As Long) As Integer
	Dim i As Long,srcByte() As Byte,trnByte() As Byte,VAList() As String,Data As STRING_SUB_PROPERTIE
	'On Error GoTo localError
	With strData
		If .Trans.lReferenceNum = 0 And .Source.MoveLength + .Trans.MoveLength = 0 Then
			WriteRefCode = 1
			Exit Function
		End If
		Select Case trnFile.Magic
		Case "PE64","NET64","MAC64","NotPE64"
			'修改原址内移位的字串引用代码
			If .Moveable <> 2 Then
				If .WriteType < 3 And .Trans.lReferenceNum < .Source.lReferenceNum Then
					Data = .Trans
					Data.Reference = .Source.Reference
					Data.lReferenceNum = .Source.lReferenceNum
					VAList = ChangeList(RefList2StrList(.Source,0),RefList2StrList(.Trans,0))
					Call GetVARefList(trnFile,"",Data,OrgStrTypeList,.TagType,.Moveable,StrListJoin(VAList,RefJoinStr),2,Mode,0)
					Call GetRefList(.Source,RefList2StrList(Data,0),VAList,False)
					If InStr(trnFile.Magic,"NotPE") = 0 Then
						For i = 0 To Data.lReferenceNum - 1
							If GetBytes(FN1,4,Data.Reference(i).lAddress,Mode) = HexStr2Bytes(VAList(i)) Then
								trnByte = HexStr2Bytes(Data.Reference(i).sCode)
								PutBytes(FN2,Data.Reference(i).lAddress,trnByte,4,Mode)
								WriteRefCode = WriteRefCode + 1
							End If
						Next i
					Else
						For i = 0 To Data.lReferenceNum - 1
							If GetBytes(FN1,UseRefTypeList(0).ByteLength,Data.Reference(i).lAddress,Mode) = HexStr2Bytes(VAList(i)) Then
								trnByte = HexStr2Bytes(Data.Reference(i).sCode)
								PutBytes(FN2,Data.Reference(i).lAddress,trnByte,UseRefTypeList(0).ByteLength,Mode)
								WriteRefCode = WriteRefCode + 1
							End If
						Next i
					End If
				End If
				'修改原址外移位的字串引用代码
				If .Trans.lReferenceNum > 0 Then
					Call GetRefList(.Source,RefList2StrList(.Trans,0),VAList,False)
					If InStr(trnFile.Magic,"NotPE") = 0 Then
						For i = 0 To .Trans.lReferenceNum - 1
							If GetBytes(FN1,4,.Trans.Reference(i).lAddress,Mode) = HexStr2Bytes(VAList(i)) Then
								trnByte = HexStr2Bytes(.Trans.Reference(i).sCode)
								PutBytes(FN2,.Trans.Reference(i).lAddress,trnByte,4,Mode)
								WriteRefCode = WriteRefCode + 1
							End If
						Next i
					Else
						For i = 0 To .Trans.lReferenceNum - 1
							If GetBytes(FN1,UseRefTypeList(0).ByteLength,.Trans.Reference(i).lAddress,Mode) = HexStr2Bytes(VAList(i)) Then
								trnByte = HexStr2Bytes(.Trans.Reference(i).sCode)
								PutBytes(FN2,.Trans.Reference(i).lAddress,trnByte,UseRefTypeList(0).ByteLength,Mode)
								WriteRefCode = WriteRefCode + 1
							End If
						Next i
					End If
				End If
			'修改 .NET 字串引用代码
			ElseIf .Trans.lReferenceNum > 0 Then
				srcByte = HexStr2Bytes(.Source.Reference(0).sCode)
				trnByte = HexStr2Bytes(.Trans.Reference(0).sCode)
				If InStr(trnFile.Magic,"NotPE") = 0 Then
					For i = 0 To .Trans.lReferenceNum - 1
						If GetBytes(FN1,4,.Trans.Reference(i).lAddress,Mode) = srcByte Then
							PutBytes(FN2,.Trans.Reference(i).lAddress,trnByte,4,Mode)
							WriteRefCode = WriteRefCode + 1
						End If
					Next i
				Else
					For i = 0 To .Trans.lReferenceNum - 1
						If GetBytes(FN1,UseRefTypeList(0).ByteLength,.Trans.Reference(i).lAddress,Mode) = srcByte Then
							PutBytes(FN2,.Trans.Reference(i).lAddress,trnByte,UseRefTypeList(0).ByteLength,Mode)
							WriteRefCode = WriteRefCode + 1
						End If
					Next i
				End If
			End If
		Case Else
			'修改原址内移位的字串引用代码
			If .Moveable <> 2 Then
				If .WriteType < 3 And .Trans.lReferenceNum < .Source.lReferenceNum Then
					Data = .Trans
					Data.Reference = .Source.Reference
					Data.lReferenceNum = .Source.lReferenceNum
					VAList = ChangeList(RefList2StrList(.Source,0),RefList2StrList(.Trans,0))
					Call GetVARefList(trnFile,"",Data,OrgStrTypeList,.TagType,.Moveable,StrListJoin(VAList,RefJoinStr),2,Mode,0)
					srcByte = HexStr2Bytes(.Source.Reference(0).sCode)
					trnByte = HexStr2Bytes(Data.Reference(0).sCode)
					If InStr(trnFile.Magic,"NotPE") = 0 Then
						For i = 0 To Data.lReferenceNum - 1
							If GetBytes(FN1,4,Data.Reference(i).lAddress,Mode) = srcByte Then
								PutBytes(FN2,Data.Reference(i).lAddress,trnByte,4,Mode)
								WriteRefCode = WriteRefCode + 1
							End If
						Next i
					Else
						For i = 0 To Data.lReferenceNum - 1
							If GetBytes(FN1,UseRefTypeList(0).ByteLength,Data.Reference(i).lAddress,Mode) = srcByte Then
								PutBytes(FN2,Data.Reference(i).lAddress,trnByte,UseRefTypeList(0).ByteLength,Mode)
								WriteRefCode = WriteRefCode + 1
							End If
						Next i
					End If
				End If
			End If
			'修改原址外移位的字串引用代码
			If .Trans.lReferenceNum > 0 Then
				srcByte = HexStr2Bytes(.Source.Reference(0).sCode)
				trnByte = HexStr2Bytes(.Trans.Reference(0).sCode)
				If InStr(trnFile.Magic,"NotPE") = 0 Then
					For i = 0 To .Trans.lReferenceNum - 1
						If GetBytes(FN1,4,.Trans.Reference(i).lAddress,Mode) = srcByte Then
							PutBytes(FN2,.Trans.Reference(i).lAddress,trnByte,4,Mode)
							WriteRefCode = WriteRefCode + 1
						End If
					Next i
				Else
					For i = 0 To .Trans.lReferenceNum - 1
						If GetBytes(FN1,UseRefTypeList(0).ByteLength,.Trans.Reference(i).lAddress,Mode) = srcByte Then
							PutBytes(FN2,.Trans.Reference(i).lAddress,trnByte,UseRefTypeList(0).ByteLength,Mode)
							WriteRefCode = WriteRefCode + 1
						End If
					Next i
				End If
			End If
		End Select
		If WriteRefCode <> .Trans.lReferenceNum + Data.lReferenceNum Then WriteRefCode = 0
	End With
	Exit Function
	localError:
	WriteRefCode = -1
End Function


'修改整个 .NET 字串的引用代码
Private Function WriteNETRefCode(orgFile As FILE_PROPERTIE,trnFile As FILE_PROPERTIE,FN1 As FILE_IMAGE,FN2 As FILE_IMAGE, _
				ByVal orgMinOffset As Long,ByVal orgMaxOffset As Long,ByVal trnMinOffset As Long,ByVal trnMaxOffset As Long, _
				ByVal MoveVal As Long,ByVal Mode As Long,Msg As PROGRESS_MSG) As Long
	Dim i As Long,j As Long,k As Long,n As Long,m As Long,x As Long,orgRSize As Long,trnRSize As Long
	Dim orgStrType As Integer,trnStrType As Integer,Temp1 As String,Temp2 As String,strData As STRING_PROPERTIE

	'获取 MetaData 中的 #US 流的 RWA 地址和大小
	If orgFile.USStreamID = -1 Then Exit Function
	i = orgFile.StreamList(orgFile.USStreamID).lPointerToRawData
	orgRSize = i + orgFile.StreamList(orgFile.USStreamID).lSizeOfRawData - 1
	j = trnFile.StreamList(trnFile.USStreamID).lPointerToRawData
	trnRSize = j + trnFile.StreamList(trnFile.USStreamID).lSizeOfRawData - 1
	'调整修改引用的区间
	If orgMaxOffset > orgMinOffset Then
		If orgRSize > orgMaxOffset Then orgRSize = orgMaxOffset
	End If
	If trnMaxOffset > trnMinOffset Then
		If trnRSize > trnMaxOffset Then trnRSize = trnMaxOffset
	End If
	If i < orgMinOffset Then i = orgMinOffset
	If j < trnMinOffset Then j = trnMinOffset

	'获取 #US 流前数据为文本，为获取引用做准备
	With orgFile
		n = .SecList(.MinSecID).lPointerToRawData
		m = .StreamList(.USStreamID).lPointerToRawData
	End With
	Temp1 = ByteToString(GetBytes(FN1,m - n + 1,n,Mode),CP_ISOLATIN1)

	'开始提取字串及引用并修改引用
	strData.Moveable = 2
	Do While i < orgRSize Or j < trnRSize
		n = 0: m = 0: k = 0
		If i < orgRSize Then
			With strData.Source
				.StrTypeLength = -CorSigUncompressData(FN1,i,.lHexLength,Mode)
				If .lHexLength < 1 Then
					i = getNotNullByte(FN1,i + 1,orgRSize,Mode)
				Else
					.lStartAddress = i - .StrTypeLength
					.lEndAddress = .lStartAddress + .lHexLength - 2
					'获取字串的最大位置
					.lMaxAddress = getNotNullByte(FN1,.lEndAddress + 2,orgRSize,Mode) - 1
					i = .lMaxAddress + 1
				End If
				If .lHexLength > 0 And .lEndAddress <= orgRSize Then
					'检查结束标识符是否符合要求
					'If GetByte(FN1,.lEndAddress + 1,Mode) = IIf(CheckStrRegExp(.sString,"[\x01-\x7F]",0,1) = True,0,1) Then
					If GetByte(FN1,.lEndAddress + 1,Mode) < 2 Then
						If MoveVal = 0 Then
							'仅获取未提取过的原始引用地址
							If StrIDIndexDic.Exists(.lStartAddress) Then
								n = StrIDIndexDic.Item(.lStartAddress)
								If AllStrDataList(n).Source.GetRefState > 0 Then
									strData.Source = AllStrDataList(n).Source
									k = k + 1
								Else
									.GetRefState = 0
									If GetNETVARefList(orgFile,FN1,strData.Source,-.StrTypeLength,Temp1,0,Mode) > 0 Then k = k + 1
								End If
							Else
								.GetRefState = 0
								If GetNETVARefList(orgFile,FN1,strData.Source,-.StrTypeLength,Temp1,0,Mode) > 0 Then k = k + 1
							End If
						Else
							.GetRefState = 0
							If GetNETVARefList(orgFile,FN1,strData.Source,-.StrTypeLength,Temp1,0,Mode) > 0 Then k = k + 1
						End If
					End If
				End If
			End With
		End If
		'修改字串及引用
		If j < trnRSize Then
			With strData.Trans
				Do
					.StrTypeLength = -CorSigUncompressData(FN2,j,.lHexLength,Mode)
					If .lHexLength < 1 Then
						j = getNotNullByte(FN2,j + 1,trnRSize,Mode)
					Else
						.lStartAddress = j - .StrTypeLength
						.lEndAddress = .lStartAddress + .lHexLength - 2
						'获取字串的最大位置
						.lMaxAddress = getNotNullByte(FN2,.lEndAddress + 2,trnRSize,Mode) - 1
						j = .lMaxAddress + 1
					End If
					If .lHexLength > 0 And .lEndAddress <= trnRSize Then
						'检查结束标识符是否符合要求
						'If GetByte(FN2,.lEndAddress + 1,Mode) = IIf(CheckStrRegExp(.sString,"[\x01-\x7F]",0,1) = True,0,1) Then
						If GetByte(FN2,.lEndAddress + 1,Mode) < 2 Then
							If k = 0 Then GoTo NextPos
							'获取翻译引用地址
							For x = 0 To 1
								If m < 1 Then
									If StrIDIndexDic.Exists(strData.Source.lStartAddress) Then
										n = StrIDIndexDic.Item(strData.Source.lStartAddress)
										'全部拆分的父字串
										If AllStrDataList(n).Trans.lReferenceNum = AllStrDataList(n).Source.lReferenceNum And _
											AllStrDataList(n).SplitState > 0 Then
											m = AllStrDataList(n).SplitState
										'部分拆分的父字串
										ElseIf AllStrDataList(n).SplitState > 0 Then
											.lReferenceNum = strData.Source.lReferenceNum
											.Reference = strData.Source.Reference
											Temp2 = StrListJoin(ChangeList(RefList2StrList(strData.Trans,0), _
													RefList2StrList(AllStrDataList(n).Trans,0,MoveVal)),RefJoinStr)
											If GetNETVARefList(trnFile,"",strData.Trans,-.StrTypeLength,Temp2,2,Mode) > 0 Then
												If .Reference(0).sCode <> strData.Source.Reference(0).sCode Then
													'写入翻译引用地址
													WriteNETRefCode = WriteRefCode(trnFile,FN1,FN2,strData,Mode)
													If WriteNETRefCode < 1 Then Exit Function
												End If
												'.lReferenceNum = AllStrDataList(n).Trans.lReferenceNum
												'.Reference = AllStrDataList(n).Trans.Reference
												'GetNETVARefList(trnFile,"",strData.Trans,-.StrTypeLength,"",1,Mode)
												'AllStrDataList(n).Trans.Reference = .Reference
											End If
											m = AllStrDataList(n).SplitState
											Exit For
										'未拆分的字串
										Else
											.lReferenceNum = strData.Source.lReferenceNum
											.Reference = strData.Source.Reference
											If GetNETVARefList(trnFile,"",strData.Trans,-.StrTypeLength,"",1,Mode) > 0 Then
												If .Reference(0).sCode <> strData.Source.Reference(0).sCode Then
													'写入翻译引用地址
													WriteNETRefCode = WriteRefCode(trnFile,FN1,FN2,strData,Mode)
													If WriteNETRefCode < 1 Then Exit Function
												End If
												'AllStrDataList(n).Trans.Reference = .Reference
											End If
											m = 0
											'测试用
											'Temp2 = ReConvert(ByteToString(GetBytes(FN2,.lHexLength - 1,.lStartAddress,Mode),CP_UNICODELITTLE))
											'If Temp2 <> AllStrDataList(n).Trans.sString Then
											'	PSL.Output 1 & "++" & AllStrDataList(n).Trans.lStartAddress & _
											'	AllStrDataList(n).Trans.sString & "++" & .lStartAddress & Temp2
											'End If
											Exit For
										End If
									Else
										'未被提取过的字串，获取引用地址
										.lReferenceNum = strData.Source.lReferenceNum
										.Reference = strData.Source.Reference
										If GetNETVARefList(trnFile,"", strData.Trans,-.StrTypeLength,"",1,Mode) > 0 Then
											If .Reference(0).sCode <> strData.Source.Reference(0).sCode Then
												'写入引用地址
												WriteNETRefCode = WriteRefCode(trnFile,FN1,FN2,strData,Mode)
												If WriteNETRefCode < 1 Then Exit Function
											End If
										End If
										m = 0
										Exit For
									End If
								Else
									'只处理已翻译的子字串
									Do While m > 0
										m = m - 1: n = n + 1
										If AllStrDataList(n).WriteType > 0 Then
											.lReferenceNum = AllStrDataList(n).Trans.lReferenceNum
											.Reference = AllStrDataList(n).Trans.Reference
											If GetNETVARefList(trnFile,"",strData.Trans,-.StrTypeLength,"",1,Mode) > 0 Then
												If .Reference(0).sCode <> strData.Source.Reference(0).sCode Then
													'写入翻译引用地址
													WriteNETRefCode = WriteRefCode(trnFile,FN1,FN2,strData,Mode)
													If WriteNETRefCode < 1 Then Exit Function
												End If
												'AllStrDataList(n).Trans.Reference = .Reference
											End If
											Exit Do
										End If
									Loop
									Exit For
								End If
							Next x
							NextPos:
						End If
					End If
				Loop Until m < 1
			End With
		End If
		If Msg.Total > 0 Then
			ChangeListBoxItems(Msg.hwnd,Replace$(Msg.Massage,"%s",Format$(i / orgRSize,"#%")),Msg.Passed,Msg.Passed)
			SetListBoxItems(Msg.hwnd,Msg.Passed)
		End If
	Loop
	If Msg.Total > 0 Then
		ChangeListBoxItems(Msg.hwnd,Replace$(Msg.Massage,"%s","100%"),Msg.Passed,Msg.Passed)
		SetListBoxItems(Msg.hwnd,Msg.Passed)
	End If
End Function


'写入字串类型
Private Function WriteStrType(FN1 As FILE_IMAGE,FN2 As FILE_IMAGE,strData As STRING_PROPERTIE,ByVal textStr As String, _
		ByVal trnLength As Long,intList() As Integer,ByVal Mode As Long,Optional ByVal MoveVal As Long) As Integer
	Dim i As Long,k As Long
	'On Error GoTo localError
	With strData
		Select Case .StrType
		Case Is < -4	'Android 字串
			k = CorSigUncompressData(FN1,.Source.lStartAddress - .Source.StrTypeLength + MoveVal,i,Mode)
			If i <> .Source.lCharLength Then Exit Function
			k = k + CorSigUncompressData(FN1,.Source.lStartAddress - .Source.StrTypeLength + MoveVal + k,i,Mode)
			If k <> .Source.StrTypeLength Or i <> .Source.lHexLength Then Exit Function
			ReDim TempByte(0) As Byte
			i = CorSigCompressData(trnLength,TempByte)
			PutBytes(FN2,.Trans.lStartAddress - i,TempByte,i,Mode)
			k = CorSigCompressData(Len(textStr),TempByte)
			PutBytes(FN2,.Trans.lStartAddress - i - k,TempByte,k,Mode)
			WriteStrType = 1
		Case Is < 0	'.NET 字串
			If CorSigUncompressData(FN1,.Source.lStartAddress - .Source.StrTypeLength + MoveVal,i,Mode) <> .Source.StrTypeLength Then
				Exit Function
			End If
			If i <> .Source.lHexLength + .EndByteLength Then Exit Function
			i = GetByte(FN1,.Source.lEndAddress + .EndByteLength + MoveVal,Mode)
			'If i <> IIf(CheckStrRegExp(.Source.sString,"[\x01-\x7F]",0,1) = True,0,1) Then Exit Function
			If i > 1 Then Exit Function
			ReDim TempByte(0) As Byte
			i = CorSigCompressData(trnLength + .EndByteLength,TempByte)
			PutBytes(FN2,.Trans.lStartAddress - i,TempByte,i,Mode)
			ReDim TempByte(.EndByteLength - 1) As Byte
			TempByte(0) = IIf(CheckStrRegExp(textStr,"[\x01-\x7F]",0,1) = True,0,1)
			PutBytes(FN2,.Trans.lStartAddress + trnLength,TempByte,.EndByteLength,Mode)
			WriteStrType = 1
		Case 1		'Delphi 默认字串
			Dim DelphiUnicodeStr As DELPHI_UNICODE_STRING
			'GetTypeValue(FN1,.Source.lStartAddress - .StrTypeLength + MoveVal,DelphiUnicodeStr,Mode)
			Select Case Mode
			Case Is < 0
				Get #FN1.hFile, .Source.lStartAddress - .Source.StrTypeLength + 1 + MoveVal, DelphiUnicodeStr
			Case 0
				CopyMemory DelphiUnicodeStr, FN1.ImageByte(.Source.lStartAddress - .Source.StrTypeLength + MoveVal), Len(DelphiUnicodeStr)
			Case Else
				MoveMemory DelphiUnicodeStr, FN1.MappedAddress + .Source.lStartAddress - .Source.StrTypeLength + MoveVal, Len(DelphiUnicodeStr)
			End Select
			If DelphiUnicodeStr.CodePage <> .Source.CodePage Or _
				DelphiUnicodeStr.Length <> .Source.lHexLength \ DelphiUnicodeStr.elemSize Then Exit Function
			DelphiUnicodeStr.CodePage = .Trans.CodePage
			DelphiUnicodeStr.elemSize = IIf(.Trans.CodePage = CP_UNICODELITTLE Or .Trans.CodePage = CP_UNICODEBIG,2,1)
			DelphiUnicodeStr.Length = trnLength \ DelphiUnicodeStr.elemSize
			'If PutTypeValue(FN2,.Trans.lStartAddress - .Trans.StrTypeLength,DelphiUnicodeStr,Mode) = False Then GoTo localError
			Select Case Mode
			Case Is < 0
				If .Trans.lStartAddress - .Trans.StrTypeLength < 0 Then
					Put #FN2.hFile, , DelphiUnicodeStr
				Else
					Put #FN2.hFile, .Trans.lStartAddress - .Trans.StrTypeLength + 1, DelphiUnicodeStr
				End If
			Case 0
				If (.Trans.lStartAddress - .Trans.StrTypeLength + Len(DelphiUnicodeStr)) > FN2.SizeOfFile Then
					FN2.SizeOfFile = .Trans.lStartAddress - .Trans.StrTypeLength + Len(DelphiUnicodeStr)
					If FN2.SizeOfFile > FN2.SizeOfImage Then
						FN2.SizeOfImage = FN2.SizeOfFile + 2048
						ReDim Preserve FN2.ImageByte(FN2.SizeOfImage - 1) 'As Byte
					End If
				End If
				CopyMemory FN2.ImageByte(.Trans.lStartAddress - .Trans.StrTypeLength), DelphiUnicodeStr, Len(DelphiUnicodeStr)
			Case Else
				If (.Trans.lStartAddress - .Trans.StrTypeLength + Len(DelphiUnicodeStr)) > FN2.SizeOfFile Then
					FN2.SizeOfFile = .Trans.lStartAddress - .Trans.StrTypeLength + Len(DelphiUnicodeStr)
					If FN2.SizeOfFile > FN2.SizeOfImage Then
						If MapFile(FN2.ModuleName,FN2,FN2.SizeOfFile + 2048,1,FN2.SizeOfFile) = False Then
							GoTo localError
						End If
					End If
				End If
				WriteMemory FN2.MappedAddress + .Trans.lStartAddress - .Trans.StrTypeLength, DelphiUnicodeStr, Len(DelphiUnicodeStr)
			End Select
			WriteStrType = 1
		Case 2		'Delphi 宽字串 (Unicode)
			Dim DelphiWideStr As DELPHI_WIDE_STRING
			'GetTypeValue(FN1,.Source.lStartAddress - .Source.StrTypeLength + MoveVal,DelphiWideStr,Mode)
			Select Case Mode
			Case Is < 0
				Get #FN1.hFile, .Source.lStartAddress - .Source.StrTypeLength + 1 + MoveVal, DelphiWideStr
			Case 0
				CopyMemory DelphiWideStr, FN1.ImageByte(.Source.lStartAddress - .Source.StrTypeLength + MoveVal), Len(DelphiWideStr)
			Case Else
				MoveMemory DelphiWideStr, FN1.MappedAddress + .Source.lStartAddress - .Source.StrTypeLength + MoveVal, Len(DelphiWideStr)
			End Select
			If DelphiWideStr.Length <> .Source.lHexLength Then Exit Function
			DelphiWideStr.Length = trnLength
			'If PutTypeValue(FN2,.Trans.lStartAddress - .Trans.StrTypeLength,DelphiWideStr,Mode) = False Then GoTo localError
			Select Case Mode
			Case Is < 0
				If .Trans.lStartAddress - .Trans.StrTypeLength < 0 Then
					Put #FN2.hFile, , DelphiWideStr
				Else
					Put #FN2.hFile, .Trans.lStartAddress - .Trans.StrTypeLength + 1, DelphiWideStr
				End If
			Case 0
				If (.Trans.lStartAddress - .Trans.StrTypeLength + Len(DelphiWideStr)) > FN2.SizeOfFile Then
					FN2.SizeOfFile = .Trans.lStartAddress - .Trans.StrTypeLength + Len(DelphiWideStr)
					If FN2.SizeOfFile > FN2.SizeOfImage Then
						FN2.SizeOfImage = FN2.SizeOfFile + 2048
						ReDim Preserve FN2.ImageByte(FN2.SizeOfImage - 1) 'As Byte
					End If
				End If
				CopyMemory FN2.ImageByte(.Trans.lStartAddress - .Trans.StrTypeLength), DelphiWideStr, Len(DelphiWideStr)
			Case Else
				If (.Trans.lStartAddress - .Trans.StrTypeLength + Len(DelphiWideStr)) > FN2.SizeOfFile Then
					FN2.SizeOfFile = .Trans.lStartAddress - .Trans.StrTypeLength + Len(DelphiWideStr)
					If FN2.SizeOfFile > FN2.SizeOfImage Then
						If MapFile(FN2.ModuleName,FN2,FN2.SizeOfFile + 2048,1,FN2.SizeOfFile) = False Then
							GoTo localError
						End If
					End If
				End If
				WriteMemory FN2.MappedAddress + .Trans.lStartAddress - .Trans.StrTypeLength, DelphiWideStr, Len(DelphiWideStr)
			End Select
			WriteStrType = 1
		Case 3		'Delphi 长字串 (ANSI)
			Dim DelphiAnsiStr As DELPHI_ANSI_STRING
			'GetTypeValue(FN1,.Source.lStartAddress - .Source.StrTypeLength + MoveVal,DelphiAnsiStr,Mode)
			Select Case Mode
			Case Is < 0
				Get #FN1.hFile, .Source.lStartAddress - .Source.StrTypeLength + 1 + MoveVal, DelphiAnsiStr
			Case 0
				CopyMemory DelphiAnsiStr, FN1.ImageByte(.Source.lStartAddress - .Source.StrTypeLength + MoveVal), Len(DelphiAnsiStr)
			Case Else
				MoveMemory DelphiAnsiStr, FN1.MappedAddress + .Source.lStartAddress - .Source.StrTypeLength + MoveVal, Len(DelphiAnsiStr)
			End Select
			If DelphiAnsiStr.Length <> .Source.lHexLength Then Exit Function
			DelphiAnsiStr.Length = trnLength
			'If PutTypeValue(FN2,.Trans.lStartAddress - .Trans.StrTypeLength,DelphiAnsiStr,Mode) = False Then GoTo localError
			Select Case Mode
			Case Is < 0
				If .Trans.lStartAddress - .Trans.StrTypeLength < 0 Then
					Put #FN2.hFile, , DelphiAnsiStr
				Else
					Put #FN2.hFile, .Trans.lStartAddress - .Trans.StrTypeLength + 1, DelphiAnsiStr
				End If
			Case 0
				If (.Trans.lStartAddress - .Trans.StrTypeLength + Len(DelphiAnsiStr)) > FN2.SizeOfFile Then
					FN2.SizeOfFile = .Trans.lStartAddress - .Trans.StrTypeLength + Len(DelphiAnsiStr)
					If FN2.SizeOfFile > FN2.SizeOfImage Then
						FN2.SizeOfImage = FN2.SizeOfFile + 2048
						ReDim Preserve FN2.ImageByte(FN2.SizeOfImage - 1) 'As Byte
					End If
				End If
				CopyMemory FN2.ImageByte(.Trans.lStartAddress - .Trans.StrTypeLength), DelphiAnsiStr, Len(DelphiAnsiStr)
			Case Else
				If (.Trans.lStartAddress - .Trans.StrTypeLength + Len(DelphiAnsiStr)) > FN2.SizeOfFile Then
					FN2.SizeOfFile = .Trans.lStartAddress - .Trans.StrTypeLength + Len(DelphiAnsiStr)
					If FN2.SizeOfFile > FN2.SizeOfImage Then
						If MapFile(FN2.ModuleName,FN2,FN2.SizeOfFile + 2048,1,FN2.SizeOfFile) = False Then
							GoTo localError
						End If
					End If
				End If
				WriteMemory FN2.MappedAddress + .Trans.lStartAddress - .Trans.StrTypeLength, DelphiAnsiStr, Len(DelphiAnsiStr)
			End Select
			WriteStrType = 1
		Case 4		'Delphi 短字串 (ANSI)
			Dim DelphiShortStr As DELPHI_SHORT_STRING
			'GetTypeValue(FN1,.Source.lStartAddress - .Source.StrTypeLength + MoveVal,DelphiShortStr,Mode)
			Select Case Mode
			Case Is < 0
				Get #FN1.hFile, .Source.lStartAddress - .Source.StrTypeLength + 1 + MoveVal, DelphiShortStr
			Case 0
				CopyMemory DelphiShortStr, FN1.ImageByte(.Source.lStartAddress - .Source.StrTypeLength + MoveVal), Len(DelphiShortStr)
			Case Else
				MoveMemory DelphiShortStr, FN1.MappedAddress + .Source.lStartAddress - .Source.StrTypeLength + MoveVal, Len(DelphiShortStr)
			End Select
			If DelphiShortStr.Length <> .Source.lHexLength Then Exit Function
			DelphiShortStr.Length = trnLength
			'If PutTypeValue(FN2,.Trans.lStartAddress - .Trans.StrTypeLength,DelphiShortStr,Mode) = False Then GoTo localError
			Select Case Mode
			Case Is < 0
				If .Trans.lStartAddress - .Trans.StrTypeLength < 0 Then
					Put #FN2.hFile, , DelphiShortStr
				Else
					Put #FN2.hFile, .Trans.lStartAddress - .Trans.StrTypeLength + 1, DelphiShortStr
				End If
			Case 0
				If (.Trans.lStartAddress - .Trans.StrTypeLength + Len(DelphiShortStr)) > FN2.SizeOfFile Then
					FN2.SizeOfFile = .Trans.lStartAddress - .Trans.StrTypeLength + Len(DelphiShortStr)
					If FN2.SizeOfFile > FN2.SizeOfImage Then
						FN2.SizeOfImage = FN2.SizeOfFile + 2048
						ReDim Preserve FN2.ImageByte(FN2.SizeOfImage - 1) 'As Byte
					End If
				End If
				CopyMemory FN2.ImageByte(.Trans.lStartAddress - .Trans.StrTypeLength), DelphiShortStr, Len(DelphiShortStr)
			Case Else
				If (.Trans.lStartAddress - .Trans.StrTypeLength + Len(DelphiShortStr)) > FN2.SizeOfFile Then
					FN2.SizeOfFile = .Trans.lStartAddress - .Trans.StrTypeLength + Len(DelphiShortStr)
					If FN2.SizeOfFile > FN2.SizeOfImage Then
						If MapFile(FN2.ModuleName,FN2,FN2.SizeOfFile + 2048,1,FN2.SizeOfFile) = False Then
							GoTo localError
						End If
					End If
				End If
				WriteMemory FN2.MappedAddress + .Trans.lStartAddress - .Trans.StrTypeLength, DelphiShortStr, Len(DelphiShortStr)
			End Select
			WriteStrType = 1
		Case Is > 4	'自定义字串
			WriteStrType = WriteCustomStrTypeRegExp(FN1,FN2,strData,textStr,trnLength,intList,Mode,MoveVal)
		End Select
	End With
	Exit Function
	localError:
	WriteStrType = -1
End Function


'写入自定义字串类型(正则表达式)
'跟随引用地址的字串类型将根据原始字串的引用地址而不是翻译的引用地址进行检查并修改
Private Function WriteCustomStrTypeRegExp(FN1 As FILE_IMAGE,FN2 As FILE_IMAGE,strData As STRING_PROPERTIE,ByVal textStr As String, _
				ByVal trnLength As Long,intList() As Integer,ByVal Mode As Long,Optional ByVal MoveVal As Long) As Long
	Dim i As Long,j As Long,k As Long,x As Long,s As Long,e As Long
	Dim n As Integer,y As Integer,Max As Integer,Matches As Object,Dic As Object
	Dim CodeBytes() As Byte,TempByte() As Byte,Temp As String,PatternList() As String
	'On Error GoTo localError
	With strData
		If OrgStrTypeList(.StrType - 5).CodeLoc > 0 Then
			If .Source.lReferenceNum = 0 Then Exit Function
			Max = .Source.lReferenceNum - 1
		End If
		'跳过部分移位字串的未选用引用
		If .Moveable = 0 And .WriteType = 4 Then
			Set Dic = CreateObject("Scripting.Dictionary")
			For i = 0 To .Trans.lReferenceNum - 1
				If Not Dic.Exists(.Trans.Reference(i).lAddress) Then
					Dic.Add(.Trans.Reference(i).lAddress,i)
				End If
			Next i
		End If
	End With
	ReDim CodeStr(0) As STRING_TYPE_LENGTH
	For i = 0 To UBound(OrgStrTypeList)
		s = 0: e = 0: x = -1
		With OrgStrTypeList(i)
		'跳过不需要检测的字串类型
		If OrgStrTypeList(strData.StrType - 5).CodeLoc = 0 Then
			If .CodeLoc > 0 Then GoTo NextNo
			If .FristCodePos = 0 And .EndCodeLength = 0 Then GoTo NextNo
			If strData.StrType - 5 <> i Then GoTo NextNo
		Else
			If .CodeLoc = 0 Then GoTo NextNo
			If .FristCodePos = 0 Then GoTo NextNo
			If .CPCodePos = 0 And .LengthCodePos = 0 Then GoTo NextNo
		End If
		If CheckArray(.RegExpPattern) = False Then GoTo NextNo
		If .CodeLoc = 0 Then
			CodeBytes = GetBytes(FN1,.FristCodePos,strData.Source.lStartAddress - .FristCodePos + MoveVal,Mode)
			'检查字串开始标识符是否符合
			If .StartCodePos <> 0 Then
				If .StartCodeLength > 0 Then
					k = IIf(.StartCodePos >= .StartCodeLength,.StartCodePos,.StartCodeLength)
					s = InByteRevRegExp(CodeBytes,.StartCodeByte,.FristCodePos - k,.FristCodePos - k + .StartCodeLength - 1)
					If s < 1 Then GoTo NextNo
					If .StartCodePos > 0 Then s = .FristCodePos - .StartCodePos + 1
				Else
					If .StartCodePos < 0 Then GoTo NextNo
					If .StartCodePos > .FristCodePos Then GoTo NextNo
					If CodeBytes(.FristCodePos - .StartCodePos) = 0 Then GoTo NextNo
					s = .FristCodePos - .StartCodePos + 1
				End If
			End If
			'检查字串结束标识符是否符合
			If .EndCodeLength > 0 Then
				If .EndCodeString = "00" Then
					'k = IIf(CheckStrRegExp(strData.Source.sString,"[\x01-\x7F]",0,1) = True,0,1)
					'e = IIf(GetByte(FN1,strData.Source.lEndAddress + .EndCodeLength + MoveVal,Mode) = k,1,0)
					e = IIf(GetByte(FN1,strData.Source.lEndAddress + .EndCodeLength + MoveVal,Mode) < 2,1,0)
					If e < 1 Then GoTo NextNo
				Else
					e = IIf(GetBytes(FN1,.EndCodeLength,strData.Source.lEndAddress + 1 + MoveVal,Mode) = .EndCodeByte,1,0)
					If e < 1 Then GoTo NextNo
				End If
			End If
		End If
		If .FristCodePos > 0 Then
			ReDim CodeStr(9) As STRING_TYPE_LENGTH
			'检查代码页的长度是否超过字串类型所定义的长度
			If .CPCodePos <> 0 And intList(1) > 0 Then
				If .CPCodeSize = 0 Then
					CodeStr(0).Size = GetEvenPos(Len(Hex$(strData.Source.CodePage))) \ 2
				Else
					If GetEvenPos(Len(Hex$(strData.Source.CodePage))) > .CPCodeSize * 2 Then GoTo NextNo
					CodeStr(0).Size = .CPCodeSize
				End If
				CodeStr(0).Length1 = strData.Source.CodePage
			End If
			'检查字串的长度是否超过字串类型所定义的长度
			If .LengthCodePos <> 0 And intList(2) > 0 Then
				x = GetCustomStrTypeValue(CodeStr,FN1,strData.Source,OrgStrTypeList(i),Mode,1,strData.LengthModeID,MoveVal)
				If x = -1 Then GoTo NextNo
				If .CodeLoc = 0 Then
					For k = 1 To 9
						If CodeStr(k).Length1 > 0 Then
							If k < 5 Then
								CodeStr(k).Pattern = Byte2RegExpPattern(Val2Bytes(CodeStr(k).Length1,CodeStr(k).Size,CodeStr(k).ByteOrder),1)
							ElseIf k = 7 Or k = 8 Then
								CodeStr(k).Pattern = Byte2RegExpPattern(CorSigCompressByte(CodeStr(k).Length1),1)
								CodeStr(k).Pattern = CodeStr(k).Pattern & Byte2RegExpPattern(CorSigCompressByte(CodeStr(k).Length2),1)
							Else
								CodeStr(k).Pattern = Byte2RegExpPattern(CorSigCompressByte(CodeStr(k).Length1),1)
							End If
						End If
					Next k
				End If
			End If
		End If
		'不需要检查时跳过
		If .CodeLoc = 0 Then
			'字串地址前的字串类型和所有字串类型的项目有关联
			If intList(0) + s + e + CodeStr(0).Length1 = 0 And x = -1 Then GoTo NextNo
		Else
			'引用地址前的字串类型只和代码页和长度项目有关联
			If CodeStr(0).Length1 = 0 And x = -1 Then GoTo NextNo
		End If
		'检查字串或每一个引用地址
		For j = 0 To Max
			k = 0  '初始化长度类型
			'跳过部分移位字串的未选用引用
			If strData.Moveable = 0 And strData.WriteType = 4 Then
				If Not Dic.Exists(strData.Source.Reference(j).lAddress) Then GoTo NextPos
			End If
			ReDim PosList(7) As Long
			'跳过不符合或已被写入过的引用地址，确定字串标识符的所在位置
			If .CodeLoc = 1 Then
				If strData.Source.Reference(j).StrType - 5 <> i Then GoTo NextPos
				CodeBytes = GetBytes(FN1,.FristCodePos,strData.Source.Reference(j).lAddress - .FristCodePos + MoveVal,Mode)
			ElseIf .CodeLoc = 2 Then
				If strData.Source.Reference(j).StrType - 5 <> i Then GoTo NextPos
				CodeBytes = GetBytes(FN1,.FristCodePos,strData.Source.Reference(j).lAddress + 4 + MoveVal,Mode)
			End If
			'记录需要修改标识符的数量
			WriteCustomStrTypeRegExp = WriteCustomStrTypeRegExp - 1
			'检查代码页值和字串长度值
			If CodeStr(0).Length1 > 0 Or x <> -1 Then
				'初始化正则表达式
				RegExp.Global = IIf(.CodeLoc < 2,True,False)
				RegExp.IgnoreCase = False
				Temp = ByteToString(CodeBytes,CP_ISOLATIN1)
				For y = 0 To IIf(.CodeLoc > 0 Or CodeStr(0).Length1 > 0,1,0)
					If .CodeLoc > 0 Or CodeStr(0).Length1 > 0 Then
						For n = 0 To IIf(.CodeLoc = 0,0,4)
							If CodeStr(n).Length1 > 0 Then
								CodeStr(n).ByteOrder = -y
								CodeStr(n).Pattern = Byte2RegExpPattern(Val2Bytes(CodeStr(n).Length1,CodeStr(n).Size,CodeStr(n).ByteOrder),1)
							End If
						Next n
					End If
					k = 0: PosList(7) = 0
					PatternList = .RegExpPattern
					For n = 0 To IIf(.CPCodePos < 0 Or .LengthCodePos < 0,1,0)
						PatternList(0) = StrListJoin(PatternList,"")
						If .LengthCodePos <> 0 Then
							If .CPCodePos <> 0 Then
								PatternList(1) = PatternList(0)
								PatternList(0) = Replace$(PatternList(0),"{CPCode}",CodeStr(0).Pattern)
							Else
								PatternList(0) = Replace$(PatternList(0),"{CPCode}","")
								PatternList(1) = PatternList(0)
							End If
							'定位代码页值和字串长度值的所在位置
							PosList(0) = InStr(PatternList(1),"{CPCode}")
							PosList(1) = InStr(PatternList(1),"{LengthCode}")
							k = IIf(.CodeLoc = 0,10,5)
							Do
								k = IIf(strData.LengthModeID > 0,strData.LengthModeID,IIf(.LengthMode = 0,k - 1,.LengthMode))
								If CodeStr(k).Length1 > 0 Then
									RegExp.Pattern = Replace$(PatternList(0),"{LengthCode}",CodeStr(k).Pattern)
									Set Matches = RegExp.Execute(Temp)
									'MsgBox Byte2Hex(StringToByte(Temp,CP_ISOLATIN1),0,-1) & "+++" & RegExp.Pattern & "+++" & Matches.Count
									If Matches.Count > 0 Then
										If .CodeLoc < 2 Then
											If GetStrTypeAddress(OrgStrTypeList(i),Matches(Matches.Count - 1),PosList) = True Then
												If strData.LengthModeID = 0 Then
													If .CodeLoc = 0 Then strData.LengthModeID = k
												End If
												PosList(7) = Matches.Count
												Exit For
											End If
										Else
											If GetStrTypeAddress(OrgStrTypeList(i),Matches(0),PosList) = True Then
												If strData.LengthModeID = 0 Then
													If .CodeLoc = 0 Then strData.LengthModeID = k
												End If
												PosList(7) = Matches.Count
												Exit For
											End If
										End If
									End If
								End If
							Loop Until k < 2 Or .LengthMode > 0
						ElseIf .CPCodePos <> 0 Then
							PatternList(0) = Replace$(PatternList(0),"{LengthCode}","")
							PatternList(1) = PatternList(0)
							'定位代码页值和字串长度值的所在位置
							PosList(0) = InStr(PatternList(1),"{CPCode}")
							PosList(1) = InStr(PatternList(1),"{LengthCode}")
							RegExp.Pattern = Replace$(PatternList(0),"{CPCode}",CodeStr(0).Pattern)
							Set Matches = RegExp.Execute(Temp)
							If Matches.Count > 0 Then
								If .CodeLoc < 2 Then
									If GetStrTypeAddress(OrgStrTypeList(i),Matches(Matches.Count - 1),PosList) = True Then
										PosList(7) = Matches.Count
									End If
								Else
									If GetStrTypeAddress(OrgStrTypeList(i),Matches(0),PosList) = True Then
										PosList(7) = Matches.Count
									End If
								End If
							End If
							Exit For
						Else
							Exit For
						End If
						'调换代码页和长度之间的位置
						PatternList = .RegExpPattern
						PatternList(0) = .RegExpPattern(2)
						PatternList(2) = .RegExpPattern(0)
					Next n
					If PosList(7) > 0 Then Exit For
					If .CodeLoc = 0 Then
						If CodeStr(0).Size = 1 Then Exit For
					End If
				Next y
				If PosList(7) < 1 Then GoTo NextPos
				'修改字串代码页值
				If PosList(2) > 0 Then
					CopyMemory CodeBytes(PosList(2) - 1),Val2Bytes(strData.Trans.CodePage,CodeStr(0).Size,CodeStr(0).ByteOrder)(0),CodeStr(0).Size
				End If
				'修改字串长度值
				If PosList(3) > 0 And k > 0 Then
					'准备长度标识符的写入字节数组和长度
					n = 0
					Select Case k
					Case 1
						TempByte = Val2Bytes(trnLength - .ByteLengthReviseVal, _
								IIf(.LengthCodeSize = 0,CodeStr(k).Size,.LengthCodeSize),CodeStr(k).ByteOrder)
					Case 2
						TempByte = Val2Bytes(Len(textStr) - .CharLengthReviseVal, _
								IIf(.LengthCodeSize = 0,CodeStr(k).Size,.LengthCodeSize),CodeStr(k).ByteOrder)
					Case 3
						Select Case strData.Trans.CodePage
						Case CP_UTF32LE, CP_UTF32BE
							TempByte = Val2Bytes((trnLength \ 4) - .CharLengthReviseVal, _
									IIf(.LengthCodeSize = 0,CodeStr(k).Size,.LengthCodeSize),CodeStr(k).ByteOrder)
						Case CP_UNICODELITTLE, CP_UNICODEBIG
							TempByte = Val2Bytes((trnLength \ 2) - .CharLengthReviseVal, _
									IIf(.LengthCodeSize = 0,CodeStr(k).Size,.LengthCodeSize),CodeStr(k).ByteOrder)
						Case Else
							TempByte = Val2Bytes(trnLength - .ByteLengthReviseVal, _
									IIf(.LengthCodeSize = 0,CodeStr(k).Size,.LengthCodeSize),CodeStr(k).ByteOrder)
						End Select
					Case 4
						TempByte = Val2Bytes(trnLength + Len(textStr) - .ByteLengthReviseVal - .CharLengthReviseVal, _
								IIf(.LengthCodeSize = 0,CodeStr(k).Size,.LengthCodeSize),CodeStr(k).ByteOrder)
					Case 5
						n = CodeStr(k).Size - 1
						'y = CorSigCompressLength(trnLength) - CorSigCompressLength(strData.Source.lHexLength)
						TempByte = CorSigCompressByte(trnLength - .ByteLengthReviseVal)
					Case 6
						n = CodeStr(k).Size - 1
						'y = CorSigCompressLength(Len(textStr)) - CorSigCompressLength(Len(strData.Source.sString))
						TempByte = CorSigCompressByte(Len(textStr) - .CharLengthReviseVal)
					Case 7
						n = CodeStr(k).Size - 1
						'y = CorSigCompressLength(trnLength) + CorSigCompressLength(Len(textStr)) - _
						'	CorSigCompressLength(strData.Source.lHexLength) - CorSigCompressLength(Len(strData.Source.sString))
						TempByte = MergeBytes(CorSigCompressByte(trnLength - .ByteLengthReviseVal),CorSigCompressByte(Len(textStr) - .CharLengthReviseVal))
					Case 8
						n = CodeStr(k).Size - 1
						'y = CorSigCompressLength(trnLength) + CorSigCompressLength(Len(textStr)) - _
						'	CorSigCompressLength(strData.Source.lHexLength) - CorSigCompressLength(Len(strData.Source.sString))
						TempByte = MergeBytes(CorSigCompressByte(Len(textStr) - .CharLengthReviseVal),CorSigCompressByte(trnLength - .ByteLengthReviseVal))
					Case 9
						n = CodeStr(k).Size - 1
						'y = CorSigCompressLength(trnLength + Len(textStr)) - _
						'	CorSigCompressLength(strData.Source.lHexLength + Len(strData.Source.sString))
						TempByte = CorSigCompressByte(trnLength + Len(textStr) - .ByteLengthReviseVal - .CharLengthReviseVal)
					End Select
					If k > 5 Then
						'移动长度标识符字节数组的写入位置
						y = strData.Source.MoveLength + strData.Trans.MoveLength
						If y = 0 Then
							CopyMemory CodeBytes(PosList(3) - 1),TempByte(0),UBound(TempByte) + 1
						ElseIf PosList(3) + n = .FristCodePos Then
							ReDim Preserve CodeBytes(.FristCodePos - 1 + y) As Byte
							CopyMemory CodeBytes(PosList(3) - 1),TempByte(0),UBound(TempByte) + 1
						Else
							If y > 0 Then ReDim Preserve CodeBytes(.FristCodePos - 1 + y) As Byte
							CopyMemory CodeBytes(PosList(3) + n + y),CodeBytes(PosList(3) + n),.FristCodePos - PosList(3) - n
							CopyMemory CodeBytes(PosList(3) - 1),TempByte(0),UBound(TempByte) + 1
							If y < 0 Then ReDim Preserve CodeBytes(.FristCodePos - 1 + y) As Byte
						End If
					Else
						CopyMemory CodeBytes(PosList(3) - 1),TempByte(0),UBound(TempByte) + 1
					End If
				End If
				'确定字串前变长标识符的第一个标识符(包括代码页标识符)位置并移位
			End If
			'写入修改值
			If intList(0) + s + e + PosList(2) + PosList(3) > 0 Then
				'确定第一个标识符(包括代码页标识符)位置
				y = 1
				For n = 2 To 4
					If PosList(n) > 0 Then
						If .CodeLoc < 2 Then
							If y = 1 Or PosList(n) < y Then
								y = PosList(n)
							End If
						ElseIf y = 1 Or PosList(n) > y Then
							If n = 2 Then
								y = PosList(n) + CodeStr(0).Size - 1
							ElseIf n = 3 Then
								y = PosList(n) + CodeStr(k).Size - 1
							Else
								y = PosList(n) - 1
							End If
						End If
					End If
				Next n
				If .CodeLoc = 0 Then
					'写入字串前的标识符
					If intList(0) + s + PosList(2) + PosList(3) > 0 Then
						If k > 4 Then
							If y > 1 Then
								k = strData.Source.MoveLength + strData.Trans.MoveLength
								CopyMemory CodeBytes(0),CodeBytes(y - 1),strData.Source.StrTypeLength + k
								ReDim Preserve CodeBytes(strData.Source.StrTypeLength + k - 1) As Byte
							End If
							y = strData.Trans.StrTypeLength + strData.Trans.MoveLength
							PutBytes(FN2,strData.Trans.lStartAddress - y,CodeBytes,y,Mode)
						Else
							PutBytes(FN2,strData.Trans.lStartAddress - .FristCodePos,CodeBytes,.FristCodePos,Mode)
						End If
					End If
					'写入字串后的结束标识符
					If e > 0 And intList(3) > 0 Then
						TempByte = GetBytes(FN1,.EndCodeLength,strData.Source.lEndAddress + 1,Mode)
						If .EndCodeString = "00" Then
							TempByte(0) = IIf(CheckStrRegExp(textStr,"[\x01-\x7F]",0,1) = True,0,1)
						End If
						PutBytes(FN2,strData.Trans.lStartAddress + trnLength,TempByte,.EndCodeLength,Mode)
					End If
					'记录需要已修改标识符的数量
					WriteCustomStrTypeRegExp = WriteCustomStrTypeRegExp + 1
				ElseIf PosList(2) + PosList(3) > 0 Then
					If .CodeLoc < 2 Then
						'写入引用地址前的标识符
						If y > 1 Then
							CopyMemory CodeBytes(0),CodeBytes(y - 1),.FristCodePos - y + 1
							ReDim Preserve CodeBytes(.FristCodePos - y) As Byte
						End If
						y = .FristCodePos - y + 1
						PutBytes(FN2,strData.Source.Reference(j).lAddress - y,CodeBytes,y,Mode)
					ElseIf y > 1 Then
						'写入引用地址后的标识符
						ReDim Preserve CodeBytes(y - 1) As Byte
						PutBytes(FN2,strData.Source.Reference(j).lAddress + 4,CodeBytes,y,Mode)
					End If
					'记录需要已修改标识符的数量
					WriteCustomStrTypeRegExp = WriteCustomStrTypeRegExp + 1
				End If
			End If
			NextPos:
		Next j
		NextNo:
		End With
	Next i
	Set Dic = Nothing
	WriteCustomStrTypeRegExp = IIf(WriteCustomStrTypeRegExp = 0,1,0)
	Exit Function
	localError:
	Set Dic = Nothing
	WriteCustomStrTypeRegExp = -1
End Function


'分行写入字串数组为文本文件
'BOM = False 检查并写入 BOM，否则不写入 BOM
Private Function WriteTextFileByLine(ByVal FilePath As String,ByVal CodePage As Long,StrList() As String,Optional ByVal BOM As Boolean) As Boolean
	Dim i As Long,FN As Variant
	On Error GoTo ErrHandle
	If Dir$(FilePath) <> "" Then Kill FilePath
	FN = FreeFile
	Open FilePath For Binary Access Write Lock Write As #FN
	WriteBinaryFile(FN,CodePage,StrList(LBound(StrList)) & TextJoinStr,BOM)
	For i = LBound(StrList) + 1 To UBound(StrList)
		WriteBinaryFile FN,CodePage,StrList(i) & TextJoinStr
	Next i
	Close #FN
	WriteTextFileByLine = True
	Exit Function
	'错误处理
	ErrHandle:
	On Error Resume Next
	Close #FN
	Err.Source = "NotWriteFile"
	Err.Description = Err.Description & JoinStr & FilePath
	Call sysErrorMassage(Err,1)
End Function


'字串过滤
'Mode = False 不过滤标准字串，否则过滤标准字串
Private Function StrFilter(strData As STRING_SUB_PROPERTIE,ByVal StrType As Integer,OptionSet() As String, _
				Optional ByVal FeatureCode As String,Optional ByVal Mode As Integer) As Boolean
	With strData
	'跳过小于最小字符数的字串
	If .lCharLength < StrToLong(OptionSet(27)) Then Exit Function
	'跳过大于最大字节数的字串
	If OptionSet(52) = "1" Then
		If .lHexLength > StrToLong(OptionSet(53)) Then Exit Function
	End If
	'跳过不属于提取语言的字串
	If FeatureCode <> "" Then
		If CheckStrRegExp(.sString,FeatureCode,0,2) = False Then Exit Function
	End If
	'跳过全为日期的字符
	'If IsDate(.sString) = True Then Exit Function
	'Select Case .CodePage
	'Case CP_UNICODELITTLE	'跳过不需要提取的 Unicode 字串
	'	If Mid$(OptionSet(4),2,1) = "0" Then Exit Function
	'Case CP_UTF8		'跳过不需要提取的 UTF-8 字串
	'	If Mid$(OptionSet(4),3,1) = "0" Then Exit Function
	'Case CP_UNICODEBIG	'跳过不需要提取的 UniBigEnd 字串
	'	If Mid$(OptionSet(4),4,1) = "0" Then Exit Function
	'Case CP_UTF7		'跳过不需要提取的 UTF-7 字串
	'	If Mid$(OptionSet(4),5,1) = "0" Then Exit Function
	'Case CP_UTF32LE 	'跳过不需要提取的 CP_UTF32LE 字串
	'	If Mid$(OptionSet(4),6,1) = "0" Then Exit Function
	'Case CP_UTF32BE	'跳过不需要提取的 CP_UTF32BE 字串
	'	If Mid$(OptionSet(4),7,1) = "0" Then Exit Function
	'Case Else			'跳过不需要提取的 ANSI 字串
	'	If Mid$(OptionSet(4),1,1) = "0" Then Exit Function
	'End Select
	'跳过不需要提取的无标识符标准字串
	If StrType = 0 Then
		If Mode = 0 Then
			If OptionSet(48) = "0" Then Exit Function
		End If
	Else
		Select Case StrType
		Case 1	'跳过不需要提取的 Pascal Unicode 字串
			If OptionSet(5) = "0" Then Exit Function
		Case 2	'跳过不需要提取的 Pascal Wide 字串
			If OptionSet(6) = "0" Then Exit Function
		Case 3	'跳过不需要提取的 Pascal Ansi 字串
			If OptionSet(7) = "0" Then Exit Function
		Case 4	'跳过不需要提取的 Pascal Short 字串
			If OptionSet(8) = "0" Then Exit Function
		Case -4 To -1	'跳过不需要提取的 .Net 字串
			If OptionSet(9) = "0" Then Exit Function
		Case Is < -4	'跳过不需要提取的 Android 字串类型
			If OptionSet(41) = "0" Then Exit Function
		Case Is > 4		'跳过不需要提取的自定义类型字串
			If OptionSet(10) = "0" Then Exit Function
		End Select
	End If
	'跳过需要保留的字串
	If OptionSet(23) = "1" Then
		If OptionSet(24) = "0" Then
			If ReserveStrDic.Exists(Trim$(.sString)) Then
				StrFilter = True
				Exit Function
			End If
		ElseIf ReserveStrDic.Exists(Trim$(DelAccKey(.sString))) Then
			StrFilter = True
			Exit Function
		End If
	End If
	'跳过需要被排除的字串
	If OptionSet(21) = "1" Then
		If OptionSet(22) = "0" Then
			If FilterStrDic.Exists(Trim$(.sString)) Then Exit Function
		ElseIf FilterStrDic.Exists(Trim$(DelAccKey(.sString))) Then
			Exit Function
		End If
	End If
	'跳过为空或全为空格的字串
	If OptionSet(12) = "1" Then
		If Trim$(.sString) = "" Then Exit Function
	End If
	'跳过只包含控制字符的字串
	If OptionSet(13) = "1" Then
		If CheckStrRegExp(.sString,CheckSkipStr(0),0,1) = True Then Exit Function
	End If
	'跳过全为数字和符号的字符
	If OptionSet(14) = "1" Then
		'跳过全为数字的字符
		If IsNumeric(Trim$(.sString)) = True Then Exit Function
		'跳过全为符号的字串
		If LCase$(.sString) = UCase$(.sString) Then
			If CheckStrRegExp(.sString,CheckSkipStr(1),0,1) = True Then Exit Function
		End If
	End If
	'跳过全为大写英文的字串
	If OptionSet(15) = "1" Then
		If UCase$(.sString) = .sString Then
			If InStr(.sString," ") = 0 Then
				If CheckStrRegExp(.sString,CheckSkipStr(2),0,1) = True Then Exit Function
			End If
		End If
	End If
	'跳过全为小写英文的字串
	If OptionSet(16) = "1" Then
		If LCase$(.sString) = .sString Then
			If InStr(.sString," ") = 0 Then
				If CheckStrRegExp(.sString,CheckSkipStr(3),0,1) = True Then Exit Function
			End If
		End If
	End If
	'跳过连续大小写混合的英文字串
	If OptionSet(17) = "1" Then
		If CheckStrRegExp(Trim$(.sString),CheckSkipStr(4),0,3) = True Then Exit Function
	End If
	'跳过连续同一字符的字串
	If OptionSet(18) = "1" Then
		If CheckStrRegExp(Trim$(.sString),CheckSkipStr(4),StrToLong(OptionSet(28)),4) = True Then Exit Function
	End If
	'跳过仅包含其他字符的字串
	If OptionSet(19) = "1" Then
		Select Case OptionSet(42)
		Case "0"
			If OptionSet(44) = "0" Then
				If CheckStrRegExp(.sString,OptionSet(32),0,1,IIf(OptionSet(43) = "0",True,False)) = True Then Exit Function
			Else
				If CheckStrRegExp(DelAccKey(.sString),OptionSet(32),0,1,IIf(OptionSet(43) = "0",True,False)) = True Then Exit Function
			End If
		Case "1"
			If OptionSet(44) = "0" Then
				If OptionSet(43) = "0" Then
					If (LCase$(.sString) Like LCase$(OptionSet(47))) = True Then Exit Function
				Else
					If (.sString Like OptionSet(47)) = True Then Exit Function
				End If
			Else
				If OptionSet(43) = "0" Then
					If (LCase$(DelAccKey(.sString)) Like LCase$(OptionSet(47))) = True Then Exit Function
				Else
					If (DelAccKey(.sString) Like OptionSet(47)) = True Then Exit Function
				End If
			End If
		Case "2"
			If OptionSet(44) = "0" Then
				If CheckStrRegExp(.sString,OptionSet(46),0,2,IIf(OptionSet(43) = "0",True,False)) = True Then Exit Function
			Else
				If CheckStrRegExp(DelAccKey(.sString),OptionSet(46),0,2,IIf(OptionSet(43) = "0",True,False)) = True Then Exit Function
			End If
		End Select
	End If
	'跳过包含其他字符的字串(默认全为控制字符，未在界面上显示)
	'If OptionSet(20) = "1" Then
	'	If CheckStrRegExp(.sString,OptionSet(33),0,2) = True Then Exit Function
	'End If
	End With
	StrFilter = True
End Function


'提取 Android 或指定区域中的用户字符串
'ROffset 为开始地址，RSize 为结束地址，开始地址和结束地址，均在某个区段内
'返回值 >0 获取的字串数，0 没有获取，-1 获取引用代码过程中中止 ，-2 获取字串过程中中止
Private Function GetAndroidString(DataList() As STRING_PROPERTIE,DataDic As Object,File As FILE_PROPERTIE,FN As FILE_IMAGE, _
		Msg As PROGRESS_MSG,LogList() As String,ByVal Mode As Long,ByVal ROffset As Long,ByVal RSize As Long) As Long
	Dim i As Long,j As Long,n As Long,m As Long,k As Long,LogNo As Long,LogMax As Long
	Dim Max As Long,SkipVal As Long,MaxVal As Long,MinVal As Long
	Dim MinLength As Integer,StrType As Integer,intList() As Integer
	Dim FeatureCode As String,FormatText As String,EndCharList() As String,StrTypeEndChar() As String
	Dim Matches As Object,strData As STRING_SUB_PROPERTIE
	Dim LengthSet As Long,MaxLength As Long,EndChar As String

	'获取字符串最小字符数长度
	MinLength = StrToLong(ExtractSet(27))
	i = RSize - ROffset + 1
	If i < MinLength Then Exit Function

	'按开始地址获取所在区段索引号
	strData.inSectionID = SkipSection(File,ROffset,0,0,1)
	If strData.inSectionID < 0 Then Exit Function

	'转换字符编码的提取顺序
	intList = ConvertStrCPOrder(ExtractSet(4))
	'获取字符串结束符的正则表达式模板
	EndCharList = StrEndChar2Pattern(ExtractSet(31))
	EndChar = Mid(EndCharList(1),InStr(EndCharList(1),")(") + 2)
	EndChar = Left(EndChar,InStrRev(EndChar,")") - 1)
	'获取自定义字符串结束标识符的正则表达式模板
	StrTypeEndChar = StrTypeEndChar2Pattern(UseStrTypeList,UseLangList,intList,ExtractSet(10))
	'检查是否需要检测多字节字符串的代码页
	FeatureCode = GetFeaturePattern(UseLangList)
	'获取 Android 字符串前面长度标识符的最小字节长度
	MinVal = IIf(ExtractSet(41) = "0",0,2)
	'超长而提取速度变慢的过滤设置
	LengthSet = StrToLong(ExtractSet(52))
	MaxLength = StrToLong(ExtractSet(53))

	'初始化提取消息参数
	LogNo = -1
	LogMax = IIf(i < 1000,10,i \ 100)
	ReDim LogList(LogMax) As String
	FormatText = String$(Len(CStr(RSize)),"0")

	'其他参数初始化
	n = UBound(DataList)
	If n = 0 And DataList(0).Source.CodePage = 0 Then n = -1
	Max = n + IIf(i < 1000,10,i \ 100)
	ReDim Preserve DataList(Max) As STRING_PROPERTIE
	DoEvents '转让控制权，允许操作系统处理其他事件

	'开始提取字串
	i = ROffset
	SkipVal = ROffset - 1
	With strData
		Do While i < RSize
		'排除各种文件头数据区段
		If i > SkipVal Then
			m = SkipHeader(File,i,SkipVal,1)
			If m = 0 Or m = 1 Or m = 5 Or m = 13 Then Exit Do
			If i > SkipVal Or SkipVal > RSize Then SkipVal = RSize + 1
			If i > RSize Then Exit Do
			RegExp.Global = True
			RegExp.IgnoreCase = False
			RegExp.Pattern = "\x00+"
			Set Matches = RegExp.Execute(GetBytes(FN,SkipVal - i,i,Mode) & vbNullChar)
			j = 0
			.lStartAddress = i
		End If
		If j >= Matches.Count Then
			i = SkipVal + 1
		Else
			.lEndAddress = i + Matches(j).FirstIndex - IIf(i = 0,0,1)
			'计算前后的零字节
			'If GetByte(FN,.lStartAddress,Mode) = 0 Then .lStartAddress = .lStartAddress + 1
			'If GetByte(FN,.lEndAddress,Mode) = 0 Then .lEndAddress = .lEndAddress - 1
			'提取字串
			m = .lEndAddress
			.lHexLength = .lEndAddress - .lStartAddress + 1
			Do While .lHexLength >= MinLength + MinVal
				Do
					StrType = CorSigUncompressData(FN,.lStartAddress,k,Mode)
					If k = 0 Then
						.lStartAddress = getNotNullByte(FN,.lStartAddress + 1,m,Mode)
					End If
				Loop Until k > 0 Or .lStartAddress >= m
				If .lStartAddress >= m Then Exit Do
				StrType = StrType + CorSigUncompressData(FN,.lStartAddress + StrType,.lHexLength,Mode)
				If .lHexLength = 0 Then
					.lStartAddress = getNotNullByte(FN,.lStartAddress + StrType,m,Mode)
				ElseIf .lHexLength < MinLength Then
					.lEndAddress = .lStartAddress + StrType + .lHexLength - 1
					.lStartAddress = getNotNullByte(FN,.lEndAddress + 1,m,Mode)
					.lHexLength = 0
				Else
					.lStartAddress = .lStartAddress + StrType
					.lEndAddress = .lStartAddress + .lHexLength - 1
					If .lEndAddress > m Then
						.lStartAddress = getEndByteRegExp(FN,.lStartAddress + 1,m,Mode,"\x00",CP_UNKNOWN) + 1
						.lHexLength = 0
					End If
				End If
				If .lHexLength >= MinLength + MinVal Then
					'检测字节的代码页
					.lMaxAddress = getCodePageRegExp(FN,strData,UseLangList,intList,MinLength,StrTypeEndChar,EndCharList,Mode,0,LengthSet,MaxLength)
					If .CodePage <> CP_UNKNOWN Then
						'检测字串的类型等其他属性
						'.sString = ByteToString(GetBytes(FN,.lHexLength,.lStartAddress,Mode),.CodePage)
						.lCharLength = Len(.sString)
						'检查字符数是否符合要求
						If k = .lCharLength Then
							StrType = -(StrType + 3)
							If .CodePage = CP_WESTEUROPE Then .CodePage = CP_UTF8
							If CheckString(File,FN,strData,StrType,0,FeatureCode,SkipVal,LogList,FormatText,LogMax,LogNo,Mode,Msg.hWnd,EndChar) > 0 Then
								'添加字串数据到数据库
								If AddToDataList(File,DataList,DataDic,strData,StrType,Max,n) = True Then
									GetAndroidString = GetAndroidString + 1
								End If
							End If
						End If
					End If
					.lStartAddress = getNotNullByte(FN,.lMaxAddress + 1,m,Mode)
				End If
				.lHexLength = m - .lStartAddress + 1
				If ExtractSet(25) = "0" Then
					If Msg.hWnd > 0 Then
						SetTextBoxString Msg.hWnd,Msg.Massage & Format$((.lStartAddress - ROffset + Msg.Passed) / Msg.Total,"#%")
					ElseIf Msg.hWnd < 0 Then
						PSL.OutputWnd(0).Clear
						PSL.Output Msg.Massage & Format$((.lStartAddress - ROffset + Msg.Passed) / Msg.Total,"#%")
					End If
				End If
				'DoEvents '转让控制权，允许操作系统处理其他事件
				If StopProcess(StopHwnd,VK_ESCAPE) = True Then
					GetAndroidString = -2
					GoTo ExitFunction
				End If
			Loop
			.lStartAddress = i + Matches(j).FirstIndex + Matches(j).Length
			j = j + 1
		End If
		Loop
	End With
	ExitFunction:
	If n > -1 Then
		ReDim Preserve DataList(n) As STRING_PROPERTIE
	Else
		ReDim DataList(0) As STRING_PROPERTIE
	End If
	ReDim Preserve LogList(IIf(LogNo > -1,LogNo,0)) As String
End Function


'提取整个 .NET MetaData 或指定 .NET MetaData 区域中的用户字符串
'ROffset 为开始地址，RSize 为结束地址，开始地址和结束地址，均在某个区段内
'返回值 >0 获取的字串数，0 没有获取，-1 获取引用代码过程中中止 ，-2 获取字串过程中中止
Private Function GetNETString(DataList() As STRING_PROPERTIE,DataDic As Object,File As FILE_PROPERTIE,FN As FILE_IMAGE, _
		Msg As PROGRESS_MSG,LogList() As String,ByVal Mode As Long,ByVal ROffset As Long,ByVal RSize As Long) As Long
	Dim i As Long,n As Long,Max As Long,LogNo As Long,LogMax As Long
	Dim MinLength As Integer,StrType As Integer,intList(0) As Integer
	Dim EndCharList() As String,StrTypeEndChar() As String,EndChar As String
	Dim FeatureCode As String,FormatText As String,strData As STRING_SUB_PROPERTIE

	'获取 MetaData 中的 #US 流的 RWA 地址和大小
	If File.USStreamID = -1 Then Exit Function
	i = File.StreamList(File.USStreamID).lPointerToRawData
	n = i + File.StreamList(File.USStreamID).lSizeOfRawData - 1
	If ROffset > n Then Exit Function
	If ROffset < i Then ROffset = i
	If RSize > n Then RSize = n

	'获取字符串最小字符数长度
	MinLength = StrToLong(ExtractSet(27))
	i = RSize - ROffset + 1
	If i < MinLength Then Exit Function

	'按开始地址获取所在区段索引号
	strData.inSectionID = SkipSection(File,ROffset,0,0,1)
	If strData.inSectionID < 0 Then Exit Function
	If strData.inSectionID > File.MaxSecIndex - 1 Then Exit Function

	'转换字符编码的提取顺序
	intList(0) = 2
	'获取字符串结束符的正则表达式模板
	EndCharList = ReSplit("(\x00*)(;)([\x00\x01])",";")
	EndChar = Mid(EndCharList(1),InStr(EndCharList(1),")(") + 2)
	EndChar = Left(EndChar,InStrRev(EndChar,")") - 1)
	'获取自定义字符串结束标识符的正则表达式模板
	StrTypeEndChar = StrTypeEndChar2Pattern(UseStrTypeList,UseLangList,intList,ExtractSet(10))
	'检查是否需要检测多字节字符串的代码页
	FeatureCode = GetFeaturePattern(UseLangList)

	'初始化提取消息参数
	LogNo = -1
	LogMax = IIf(i < 1000,10,i \ 100)
	ReDim LogList(LogMax) As String
	FormatText = String$(Len(CStr(RSize)),"0")

	'其他参数初始化
	n = UBound(DataList)
	If n = 0 And DataList(0).Source.CodePage = 0 Then n = -1
	Max = n + IIf(i < 1000,10,i \ 100)
	ReDim Preserve DataList(Max) As STRING_PROPERTIE
	DoEvents '转让控制权，允许操作系统处理其他事件

	'开始提取字串
	i = ROffset
	'SkipVal = ROffset - 1
	With strData
		Do While i < RSize
			StrType = -CorSigUncompressData(FN,i,.lHexLength,Mode)
			If .lHexLength < 1 Then
				i = getNotNullByte(FN,i + 1,RSize,Mode)
			Else
				.lStartAddress = i - StrType
				.lEndAddress = .lStartAddress + .lHexLength - 2
				'获取字串的最大位置
				.lMaxAddress = getNotNullByte(FN,.lEndAddress + 2,RSize,Mode) - 1
				i = .lMaxAddress + 1
			End If
			If .lHexLength >= MinLength * 2 And .lEndAddress <= RSize Then
				'检查结束标识符是否符合要求
				'If GetByte(FN,.lEndAddress + 1,Mode) = IIf(CheckStrRegExp(.sString,"[\x01-\x7F]",0,1) = True,0,1) Then
				If GetByte(FN,.lEndAddress + 1,Mode) < 2 Then
					'检测字节的代码页
					.lHexLength = .lHexLength - 2
					getCodePageRegExp(FN,strData,UseLangList,intList,MinLength,StrTypeEndChar,EndCharList,Mode,0,0,0)
					If .CodePage = CP_UNICODELITTLE Then
						'.lHexLength = .lHexLength - 1
						'.CodePage = CP_UNICODELITTLE
						'.sString = ByteToString(GetBytes(FN,.lHexLength - 1,.lStartAddress,Mode),.CodePage)
						.lMaxAddress = getNotNullByte(FN,.lEndAddress + 2,RSize,Mode) - 1
						If CheckString(File,FN,strData,StrType,0,FeatureCode,RSize,LogList,FormatText,LogMax,LogNo,Mode,Msg.hWnd,EndChar) > 0 Then
							'记录引用代码
							'ReDim strData.Reference(0) As REFERENCE_PROPERTIE
							'.Reference(0).sCode = ReverseHexCode(Hex$(.lStartAddress - ROffset + StrType),6) & "70"
							'添加字串数据到数据库
							If AddToDataList(File,DataList,DataDic,strData,StrType,Max,n) = True Then
								GetNETString = GetNETString + 1
							End If
						End If
					End If
				End If
			End If
			If ExtractSet(25) = "0" Then
				If Msg.hWnd > 0 Then
					SetTextBoxString Msg.hWnd,Msg.Massage & Format$((i - ROffset) / (RSize - ROffset),"#%")
				ElseIf Msg.hWnd < 0 Then
					PSL.OutputWnd(0).Clear
					PSL.Output Msg.Massage & Format$((i - ROffset) / (RSize - ROffset),"#%")
				End If
			End If
			'DoEvents '转让控制权，允许操作系统处理其他事件
			If StopProcess(StopHwnd,VK_ESCAPE) = True Then
				GetNETString = -2
				Exit Function
			End If
		Loop
	End With
	If n > -1 Then
		ReDim Preserve DataList(n) As STRING_PROPERTIE
	Else
		ReDim DataList(0) As STRING_PROPERTIE
	End If
	ReDim Preserve LogList(IIf(LogNo > -1,LogNo,0)) As String
End Function


'提取 PE64 指定节或指定区域中的字符串(快速 VA 分析法)
'ROffset 为开始地址，RSize 为结束地址，开始地址和结束地址，均在某个区段内
'返回值 >0 获取的字串数，0 没有获取，-1 获取引用代码过程中中止 ，-2 获取字串过程中中止
Private Function GetPE64SectionStrByVA(DataList() As STRING_PROPERTIE,DataDic As Object,File As FILE_PROPERTIE,FN As FILE_IMAGE, _
		Msg As PROGRESS_MSG,LogList() As String,ByVal Mode As Long,ByVal ROffset As Long,ByVal RSize As Long) As Long
	Dim i As Long,j As Long,n As Long,m As Long,k As Long,x As Long,y As Long,LogNo As Long,LogMax As Long
	Dim Max As Long,SkipVal As Long,MaxVal As Long,MinVal As Long,VRK As Long,RVA As Long
	Dim MinLength As Integer,StrType As Integer,TagType As Integer,intList() As Integer
	Dim FeatureCode As String,EndCharList() As String,StrTypeEndChar() As String,FormatText As String
	Dim strData As STRING_SUB_PROPERTIE,Dic As Object,EndChar As String,sVRK As Long,pDic As Object
	Dim TempList() As String,Temp As String,StrTypeLengthList() As String

	'没有字串开始地址算法的非 PE 文件，直接退出
	If InStr(File.Magic,"NotPE64") Then
		If UseRefTypeList(0).StrAddAlgorithm = "" Then Exit Function
		'获取第一种字串前自定义字符串的字串类型长度
		x = InStr(UseRefTypeList(0).StrAddAlgorithm,"{strtypelength}")
		StrTypeLengthList = GetStrTypeLength(UseStrTypeList,ExtractSet,x)
	Else
		x = 0
		ReDim StrTypeLengthList(0) As String
	End If

	'获取字符串最小字符数长度
	MinLength = StrToLong(ExtractSet(27))
	If RSize - ROffset + 1 < MinLength Then Exit Function

	'按开始地址获取所在区段索引号
	strData.inSectionID = SkipSection(File,ROffset,0,0,1)
	If strData.inSectionID < 0 Then Exit Function
	If strData.inSectionID > File.MaxSecIndex - 1 Then Exit Function
	If File.SecList(strData.inSubSecID).SubSecs > 0 Then
		strData.inSubSecID = SkipSubSection(File.SecList(strData.inSectionID),ROffset,0,0)
		If strData.inSubSecID < 0 Then Exit Function
	End If

	'转换字符编码的提取顺序
	intList = ConvertStrCPOrder(ExtractSet(4))
	'获取字符串结束符的正则表达式模板
	EndCharList = StrEndChar2Pattern(ExtractSet(31))
	EndChar = Mid(EndCharList(1),InStr(EndCharList(1),")(") + 2)
	EndChar = Left(EndChar,InStrRev(EndChar,")") - 1)
	'获取自定义字符串结束标识符的正则表达式模板
	StrTypeEndChar = StrTypeEndChar2Pattern(UseStrTypeList,UseLangList,intList,ExtractSet(10))

	'跳过各种文件头数据区段
	SkipHeader(File,ROffset,0,1)
	'提取区域不足时退出
	If RSize - ROffset + 1 < MinLength Then Exit Function
	'获取有字串的最小开始位置和最大结束位置
	If GetStrAddRangeRegExp(FN,ROffset,RSize,UseLangList,intList,MinLength,StrTypeEndChar,EndCharList,Mode) = 0 Then
		Exit Function
	End If
	'提取区域不足时退出
	If RSize - ROffset + 1 < MinLength Then Exit Function

	'其他参数初始化
	sVRK = File.SecList(strData.inSectionID).lVirtualAddress - File.SecList(strData.inSectionID).lPointerToRawData
	ReDim RVAList((RSize - ROffset + 1) \ 4) As Long
	Set Dic = CreateObject("Scripting.Dictionary")
	Set pDic = CreateObject("Scripting.Dictionary")
	DoEvents '转让控制权，允许操作系统处理其他事件

	'获取虚拟地址
	On Error Resume Next
	SkipVal = ROffset - 1
	For j = 0 To IIf(strData.inSectionID = 0,0,strData.inSectionID - 1)
		With File.SecList(j)
			MinVal = .lPointerToRawData
			MaxVal = MinVal + .lSizeOfRawData - 1
			VRK = sVRK - (.lVirtualAddress - .lPointerToRawData) - 4
		End With
		SkipVal = MinVal - 1
		'排除各种文件头数据区段
		Do While MinVal < MaxVal
			If MinVal > SkipVal Then
				i = MinVal: m = SkipHeader(File,i,SkipVal,1)
				If m = 2 Or m = 4 Or m = 5 Or m > 15 Then MinVal = i
				If MinVal > SkipVal Or SkipVal > MaxVal Then SkipVal = MaxVal + 1
				If MinVal > MaxVal Then Exit Do
			End If
			Temp = ByteToString(GetBytes(FN,SkipVal - MinVal,MinVal,Mode),CP_ISOLATIN1)
			i = IIf(j < strData.inSectionID,ROffset - SkipVal,0) + 4
			pDic.RemoveAll
			Do While i < RSize - MinVal + 1
				'm = &HFF - ((i + VRK) And &HFF)		'后3个字节查找，速度较慢
				'm = 65535 - Val("&H" & Right$("0000" & Hex$(i + VRK),4))	'后2个字节查找，速度较快
				m = 65535 - ((i + VRK) And 65535)	'后2个字节查找，速度较快，这里的 65535 不能替换成 &HFFFF，因为 &HFFFF 返回为 -1
				If m > RSize - MinVal + 1 - i Then m = RSize - MinVal + 1 - i
				If m < 1 Then
					m = 0
					GoTo NextNo
				End If
				If InStr(File.Magic,"NotPE") = 0 Then
					FeatureCode = Right$(ReverseHexCode(Hex$(i + VRK),8),4)
					If pDic.Exists(FeatureCode) Then GoTo NextNo
					pDic.Add(FeatureCode,"")
					TempList = GetVAListRegExp(Temp,RefFrontChar & HexStr2RegExpPattern(FeatureCode,1),MinVal)
					StrType = 3
				ElseIf UseRefTypeList(0).ByteOrder = 0 Then
					FeatureCode = Right$(ReverseHexCode(Hex$(i),UseRefTypeList(0).ByteLength * 2),UseRefTypeList(0).ByteLength)
					If pDic.Exists(FeatureCode) Then GoTo NextNo
					pDic.Add(FeatureCode,"")
					FeatureCode = "[\x00-\xFF]{" & UseRefTypeList(0).ByteLength \ 2 & "}" & HexStr2RegExpPattern(FeatureCode,1)
					TempList = GetVAListRegExp(Temp,UseRefTypeList(0).PrefixByte & FeatureCode,MinVal)
					StrType = UseRefTypeList(0).PrefixLength
				Else
					FeatureCode = Left$(ValToStr(i,-UseRefTypeList(0).ByteLength * 2,True),UseRefTypeList(0).ByteLength)
					If pDic.Exists(FeatureCode) Then GoTo NextNo
					pDic.Add(FeatureCode,"")
					TempList = GetVAListRegExp(Temp,UseRefTypeList(0).PrefixByte & HexStr2RegExpPattern(FeatureCode,1),MinVal)
					StrType = UseRefTypeList(0).PrefixLength
				End If
				If CheckArray(TempList) = False Then GoTo NextNo
				For y = 0 To UBound(TempList)
					Max = StrToLong(TempList(y)) + StrType
					'获取可能的虚拟地址(即引用代码值)
					For x = 0 To UBound(StrTypeLengthList)
						If InStr(File.Magic,"NotPE") = 0 Then
							RVA = GetLong(FN,Max,Mode)
							RVA = CheckLongPlus(RVA,Max - VRK)	'获取虚拟地址对应的可能的字串地址
						ElseIf UseRefTypeList(0).ByteOrder = 0 Then
							RVA = Bytes2Val(GetBytes(FN,UseRefTypeList(0).ByteLength,Max,Mode),UseRefTypeList(0).ByteLength,False)
							RVA = Eval(Replace(Replace(Replace(UseRefTypeList(0).StrAddAlgorithm,"{refcode}",CStr(RVA)), _
									"{refstartaddress}",CStr(Max)),"{strtypelength}",StrTypeLengthList(x)))
						Else
							RVA = Bytes2Val(GetBytes(FN,UseRefTypeList(0).ByteLength,Max,Mode),UseRefTypeList(0).ByteLength,True)
							RVA = Eval(Replace(Replace(Replace(UseRefTypeList(0).StrAddAlgorithm,"{refcode}",CStr(RVA)), _
									"{refstartaddress}",CStr(Max)),"{strtypelength}",StrTypeLengthList(x)))
						End If
						If RVA > Max Then
							'判断可能的字串地址是否符合范围
							If RVA >= ROffset And RVA < RSize Then
								If Not Dic.Exists(RVA) Then
									Dic.Add(RVA,Max)
									RVAList(k) = RVA
									k = k + 1
								End If
							End If
						End If
					Next x
					'DoEvents '转让控制权，允许操作系统处理其他事件
					If StopProcess(StopHwnd,VK_ESCAPE) = True Then
						GetPE64SectionStrByVA = -2
						GoTo ExitFunction
					End If
				Next y
				NextNo:
				i = i + m + 1
				If ExtractSet(25) = "0" Then
					If MinVal + i > LogMax Then
						LogMax = MinVal + i
						If Msg.hWnd > 0 Then
							SetTextBoxString Msg.hWnd,Msg.Massage & Format$((LogMax * (1 - ROffset / RSize) * 0.5 + Msg.Passed) / Msg.Total,"#%")
						ElseIf Msg.hWnd < 0 Then
							PSL.OutputWnd(0).Clear
							PSL.Output Msg.Massage & Format$((LogMax * (1 - ROffset / RSize) * 0.5 + Msg.Passed) / Msg.Total,"#%")
						End If
					End If
				End If
				'DoEvents '转让控制权，允许操作系统处理其他事件
				If StopProcess(StopHwnd,VK_ESCAPE) = True Then
					GetPE64SectionStrByVA = -2
					GoTo ExitFunction
				End If
			Loop
			MinVal = SkipVal + 1
		Loop
	Next j
	On Error GoTo 0
	Dic.RemoveAll
	Set pDic = Nothing
	Temp = ""
	If k = 0 Then GoTo ExitFunction
	k = k - 1
	ReDim Preserve RVAList(k) As Long
	Call SortNumArray(RVAList,0,k,False)

	'检查是否需要检测多字节字符串的代码页
	FeatureCode = GetFeaturePattern(UseLangList)
	'判断是否需要检查跟随引用地址的自定义字符类型
	If ExtractSet(10) = "1" Then TagType = CheckRefCustomStrType(UseStrTypeList,IIf(File.Magic = "",0,1))
	'获取 CP_UTF32LE 和 CP_UTF32BE 所需的空字节长度
	If Mid$(ExtractSet(4),6,1) <> "0" Or Mid$(ExtractSet(4),7,1) <> "0" Then
		MinVal = 4
	ElseIf Mid$(ExtractSet(4),2,1) <> "0" Or Mid$(ExtractSet(4),4,1) <> "0" Then
		MinVal = 2
	Else
		MinVal = 1
	End If
	'超长而提取速度变慢的过滤设置
	RVA = StrToLong(ExtractSet(52))
	VRK = StrToLong(ExtractSet(53))

	'初始化提取消息参数
	LogNo = -1
	LogMax = IIf((RSize - ROffset + 1) < 1000,10,(RSize - ROffset + 1) \ 100)
	ReDim LogList(LogMax) As String
	FormatText = String$(Len(CStr(RSize)),"0")

	'其他参数初始化
	n = UBound(DataList)
	If n = 0 And DataList(0).Source.CodePage = 0 Then n = -1
	Max = n + IIf((RSize - ROffset + 1) < 1000,10,(RSize - ROffset + 1) \ 100)
	ReDim Preserve DataList(Max) As STRING_PROPERTIE

	'提取字串
	SkipVal = ROffset - 1
	With strData
		i = 0: .lEndAddress = 0
		For j = 0 To k
			.lStartAddress = RVAList(j)
			'排除各种文件头数据区段
			If .lStartAddress > SkipVal Then
				i = .lStartAddress
				m = SkipHeader(File,i,SkipVal,1)
				If m = 0 Or m = 1 Or m = 5 Or m = 13 Then Exit For
				If i > SkipVal Or SkipVal > RSize Then SkipVal = RSize + 1
				If i > RSize Then Exit For
			End If
			If .lStartAddress >= i Then
				'.lEndAddress = getNullByte(FN,.lStartAddress + 1,MaxVal,Mode,2) - 1	'跳到 &H0000 开始处前一个字节
				.lEndAddress = getEndByteRegExp(FN,.lStartAddress + 1,SkipVal,Mode,"\x00",-MinVal) - 1	'跳到 &H0000 开始处前一个字节
				.lHexLength = .lEndAddress - .lStartAddress + 1
				'提取字串
				If .lHexLength >= MinLength Then
					'检测字节的代码页
					.lMaxAddress = getCodePageRegExp(FN,strData,UseLangList,intList,MinLength,StrTypeEndChar,EndCharList,Mode,0,RVA,VRK)
					'检测字串的类型等其他属性
					If .CodePage <> CP_UNKNOWN Then
						StrType = 0
						'.sString = ByteToString(GetBytes(FN,.lHexLength,.lStartAddress,Mode),.CodePage)
						If CheckString(File,FN,strData,StrType,TagType,FeatureCode,MaxVal,LogList,FormatText,LogMax,LogNo,Mode,Msg.hWnd,EndChar) > 0 Then
							'添加字串数据到数据库
							If Dic.Exists(-.lMaxAddress) Then
								m = Dic.Item(-.lMaxAddress)
								If .lStartAddress < DataList(m).Source.lStartAddress Or _
									.lEndAddress > DataList(m).Source.lEndAddress Then
									If DataDic.Exists(DataList(m).ID) Then
										DataDic.Remove(DataList(m).ID)
									End If
									AddToDataList(File,DataList,DataDic,strData,StrType,Max,m - 1)
								End If
							ElseIf AddToDataList(File,DataList,DataDic,strData,StrType,Max,n) = True Then
								Dic.Add(-.lMaxAddress,n)
								GetPE64SectionStrByVA = GetPE64SectionStrByVA + 1
							End If
						End If
						'开始地址最小值
						If .lMaxAddress > i Then i = .lMaxAddress + 1
					End If
				End If
			End If
			If ExtractSet(25) = "0" Then
				If j Mod 100 = 1 Then
					If Msg.hWnd > 0 Then
						SetTextBoxString Msg.hWnd,Msg.Massage & Format$(((RSize - ROffset) * (1 + j / k) * 0.5 + Msg.Passed) / Msg.Total,"#%")
					ElseIf Msg.hWnd < 0 Then
						PSL.OutputWnd(0).Clear
						PSL.Output Msg.Massage & Format$(((RSize - ROffset) * (1 + j / k) * 0.5 + Msg.Passed) / Msg.Total,"#%")
					End If
				End If
			End If
			'DoEvents '转让控制权，允许操作系统处理其他事件
			If StopProcess(StopHwnd,VK_ESCAPE) = True Then
				GetPE64SectionStrByVA = -2
				GoTo ExitFunction
			End If
		Next j
	End With
	ExitFunction:
	Set Dic = Nothing: Set pDic = Nothing
	If n > -1 Then
		ReDim Preserve DataList(n) As STRING_PROPERTIE
	Else
		ReDim DataList(0) As STRING_PROPERTIE
	End If
	ReDim Preserve LogList(IIf(LogNo > -1,LogNo,0)) As String
End Function


'提取 PE32 指定节或指定区域中的字符串(快速 VA 分析法)
'ROffset 为开始地址，RSize 为结束地址，开始地址和结束地址，均在某个区段内
'返回值 >0 获取的字串数，0 没有获取，-1 获取引用代码过程中中止 ，-2 获取字串过程中中止
Private Function GetPE32SectionStrByVA(DataList() As STRING_PROPERTIE,DataDic As Object,File As FILE_PROPERTIE,FN As FILE_IMAGE, _
		Msg As PROGRESS_MSG,LogList() As String,ByVal Mode As Long,ByVal ROffset As Long,ByVal RSize As Long) As Long
	Dim i As Long,j As Long,n As Long,m As Long,k As Long,x As Long,y As Long,LogNo As Long,LogMax As Long
	Dim Max As Long,SkipVal As Long,MaxVal As Long,MinVal As Long,VRK As Long,RVA As Long
	Dim MinLength As Integer,StrType As Integer,TagType As Integer,intList() As Integer
	Dim FeatureCode As String,EndCharList() As String,StrTypeEndChar() As String,FormatText As String
	Dim strData As STRING_SUB_PROPERTIE,Dic As Object,EndChar As String
	Dim TempList() As String,Temp As String,StrTypeLengthList() As String

	'没有字串开始地址算法的非 PE 文件，直接退出
	If InStr(File.Magic,"NotPE32") Then
		If UseRefTypeList(0).StrAddAlgorithm = "" Then Exit Function
		'获取第一种字串前自定义字符串的字串类型长度
		x = InStr(UseRefTypeList(0).StrAddAlgorithm,"{strtypelength}")
		StrTypeLengthList = GetStrTypeLength(UseStrTypeList,ExtractSet,x)
	Else
		x = 0
		ReDim StrTypeLengthList(0) As String
	End If

	'获取字符串最小字符数长度
	MinLength = StrToLong(ExtractSet(27))
	If RSize - ROffset + 1 < MinLength Then Exit Function

	'按开始地址获取所在区段索引号
	strData.inSectionID = SkipSection(File,ROffset,0,0,1)
	If strData.inSectionID < 0 Then Exit Function
	If strData.inSectionID > File.MaxSecIndex - 1 Then Exit Function
	If File.SecList(strData.inSubSecID).SubSecs > 0 Then
		strData.inSubSecID = SkipSubSection(File.SecList(strData.inSectionID),ROffset,0,0)
		If strData.inSubSecID < 0 Then Exit Function
	End If

	'转换字符编码的提取顺序
	intList = ConvertStrCPOrder(ExtractSet(4))
	'获取字符串结束符的正则表达式模板
	EndCharList = StrEndChar2Pattern(ExtractSet(31))
	EndChar = Mid(EndCharList(1),InStr(EndCharList(1),")(") + 2)
	EndChar = Left(EndChar,InStrRev(EndChar,")") - 1)
	'获取自定义字符串结束标识符的正则表达式模板
	StrTypeEndChar = StrTypeEndChar2Pattern(UseStrTypeList,UseLangList,intList,ExtractSet(10))

	'跳过各种文件头数据区段
	SkipHeader(File,ROffset,0,1)
	'提取区域不足时退出
	If RSize - ROffset + 1 < MinLength Then Exit Function
	'获取有字串的最小开始位置和最大结束位置
	If GetStrAddRangeRegExp(FN,ROffset,RSize,UseLangList,intList,MinLength,StrTypeEndChar,EndCharList,Mode) = 0 Then
		Exit Function
	End If
	'提取区域不足时退出
	If RSize - ROffset + 1 < MinLength Then Exit Function

	'其他参数初始化
	With File
		MinVal = .SecList(.MinSecID).lPointerToRawData
		If .DataDirs > 0 Then
			If .DataDirectory(2).lPointerToRawData > 0 Then
				If SkipSection(File,.DataDirectory(2).lPointerToRawData,0,0) > -1 Then
					MaxVal = .DataDirectory(2).lPointerToRawData - 1
				Else
					MaxVal = .SecList(.MaxSecID).lPointerToRawData + .SecList(.MaxSecID).lSizeOfRawData - 1
				End If
			Else
				MaxVal = .SecList(.MaxSecID).lPointerToRawData + .SecList(.MaxSecID).lSizeOfRawData - 1
			End If
		Else
			MaxVal = .SecList(.MaxSecID).lPointerToRawData + .SecList(.MaxSecID).lSizeOfRawData - 1
		End If
		If File.SecList(strData.inSectionID).SubSecs > 0 Then
			With File.SecList(strData.inSectionID).SubSecList(strData.inSubSecID)
				VRK = .lVirtualAddress - .lPointerToRawData + File.ImageBase
			End With
		Else
			VRK = .SecList(strData.inSectionID).lVirtualAddress - .SecList(strData.inSectionID).lPointerToRawData + .ImageBase
		End If
	End With
	'If Mode <> 0 Then
		Temp = ByteToString(GetBytes(FN,MaxVal - MinVal + 1,MinVal,Mode),CP_ISOLATIN1)
	'End If

	'其他参数初始化
	ReDim RVAList((RSize - ROffset + 1) \ 4) As Long
	Set Dic = CreateObject("Scripting.Dictionary")
	DoEvents '转让控制权，允许操作系统处理其他事件

	'获取字串的偏移地址
	On Error Resume Next
	i = ROffset
	SkipVal = ROffset - 1
	Do While i < RSize
		'排除各种文件头数据区段
		If i > SkipVal Then
			m = SkipHeader(File,i,SkipVal,1)
			If m = 0 Or m = 1 Or m = 5 Or m = 13 Then Exit Do
			If i > SkipVal Or SkipVal > RSize Then SkipVal = RSize + 1
			If i > RSize Then Exit Do
		End If
		'获取虚拟地址
		'm = &HFF - ((i + VRK) And &HFF)	'后3个字节查找，速度较慢
		'm = 65535 - Val("&H" & Right$("0000" & Hex$(i + VRK),4))	'后2个字节查找，速度较快
		m = 65535 - ((i + VRK) And 65535)	'后2个字节查找，速度较快，这里的 65535 不能替换成 &HFFFF，因为 &HFFFF 返回为 -1
		If m > SkipVal - i Then m = SkipVal - i
		If m < 1 Then
			m = 0
			GoTo NextNo
		End If
		If InStr(File.Magic,"NotPE") = 0 Then
			FeatureCode = Right$(ReverseHexCode(Hex$(i + VRK),8),4)
			If Dic.Exists(FeatureCode) Then GoTo NextNo
			Dic.Add(FeatureCode,"")
			TempList = GetVAListRegExp(Temp,HexStr2RegExpPattern(FeatureCode,1),MinVal)
			StrType = 0
			LogMax = IIf(Left$(FeatureCode,2) = Mid$(FeatureCode,3),1,2)
		ElseIf UseRefTypeList(0).ByteOrder = 0 Then
			FeatureCode = Right$(ReverseHexCode(Hex$(i),UseRefTypeList(0).ByteLength * 2),UseRefTypeList(0).ByteLength)
			If Dic.Exists(FeatureCode) Then GoTo NextNo
			Dic.Add(FeatureCode,"")
			FeatureCode = "[\x00-\xFF]{" & UseRefTypeList(0).ByteLength \ 2 & "}" & HexStr2RegExpPattern(FeatureCode,1)
			TempList = GetVAListRegExp(Temp,UseRefTypeList(0).PrefixByte & FeatureCode,MinVal)
			StrType = UseRefTypeList(0).PrefixLength
			LogMax = 2
		Else
			FeatureCode = Left$(ValToStr(i,-UseRefTypeList(0).ByteLength * 2,True),UseRefTypeList(0).ByteLength)
			If Dic.Exists(FeatureCode) Then GoTo NextNo
			Dic.Add(FeatureCode,"")
			TempList = GetVAListRegExp(Temp,UseRefTypeList(0).PrefixByte & HexStr2RegExpPattern(FeatureCode,1),MinVal)
			StrType = UseRefTypeList(0).PrefixLength
			LogMax = 2
		End If
		If CheckArray(TempList) = False Then GoTo NextNo
		For j = 0 To UBound(TempList)
			Max = StrToLong(TempList(j)) + StrType
			For y = 2 To LogMax Step -1
				If y = 1 Then
					'后移一位后的二位字节必须相同
					If GetByte(FN,Max + 1,Mode) <> GetByte(FN,Max + 2,Mode) Then Exit For
				End If
				For x = 0 To UBound(StrTypeLengthList)
					'获取可能的虚拟地址(即引用代码值)
					If InStr(File.Magic,"NotPE") = 0 Then
						RVA = GetLong(FN,Max - y,Mode)
					ElseIf UseRefTypeList(0).ByteOrder = 0 Then
						RVA = Bytes2Val(GetBytes(FN,UseRefTypeList(0).ByteLength,Max,Mode),UseRefTypeList(0).ByteLength,False)
						RVA = Eval(Replace(Replace(Replace(UseRefTypeList(0).StrAddAlgorithm,"{refcode}",CStr(RVA)), _
								"{refstartaddress}",CStr(Max)),"{strtypelength}",StrTypeLengthList(x)))
					Else
						RVA = Bytes2Val(GetBytes(FN,UseRefTypeList(0).ByteLength,Max,Mode),UseRefTypeList(0).ByteLength,True)
						RVA = Eval(Replace(Replace(Replace(UseRefTypeList(0).StrAddAlgorithm,"{refcode}",CStr(RVA)), _
								"{refstartaddress}",CStr(Max)),"{strtypelength}",StrTypeLengthList(x)))
					End If
					If RVA > VRK Then
						'获取虚拟地址对应的可能的字串地址
						RVA = RVA - VRK
						'判断可能的字串地址是否符合范围
						If RVA >= ROffset And RVA < RSize Then
							If Not Dic.Exists(RVA) Then
								Dic.Add(RVA,Max)
								RVAList(k) = RVA
								k = k + 1
							End If
						End If
					End If
				Next x
			Next y
			'DoEvents '转让控制权，允许操作系统处理其他事件
			If StopProcess(StopHwnd,VK_ESCAPE) = True Then
				GetPE32SectionStrByVA = -2
				GoTo ExitFunction
			End If
		Next j
		NextNo:
		i = i + m + 1
		If ExtractSet(25) = "0" Then
			If Msg.hwnd > 0 Then
				SetTextBoxString Msg.hwnd,Msg.Massage & Format$(((i - ROffset) * 0.5 + Msg.Passed) / Msg.Total,"#%")
			ElseIf Msg.hwnd < 0 Then
				PSL.OutputWnd(0).Clear
				PSL.Output Msg.Massage & Format$(((i - ROffset) * 0.5 + Msg.Passed) / Msg.Total,"#%")
			End If
		End If
		'DoEvents '转让控制权，允许操作系统处理其他事件
		If StopProcess(StopHwnd,VK_ESCAPE) = True Then
			GetPE32SectionStrByVA = -2
			GoTo ExitFunction
		End If
	Loop
	On Error GoTo 0
	Dic.RemoveAll
	Temp = ""
	If k = 0 Then GoTo ExitFunction
	k = k - 1
	ReDim Preserve RVAList(k) As Long
	Call SortNumArray(RVAList,0,k,False)

	'检查是否需要检测多字节字符串的代码页
	FeatureCode = GetFeaturePattern(UseLangList)
	'判断是否需要检查跟随引用地址的自定义字符类型
	If ExtractSet(10) = "1" Then TagType = CheckRefCustomStrType(UseStrTypeList,IIf(File.Magic = "",0,1))
	'获取 CP_UTF32LE 和 CP_UTF32BE 所需的空字节长度
	If Mid$(ExtractSet(4),6,1) <> "0" Or Mid$(ExtractSet(4),7,1) <> "0" Then
		MinVal = 4
	ElseIf Mid$(ExtractSet(4),2,1) <> "0" Or Mid$(ExtractSet(4),4,1) <> "0" Then
		MinVal = 2
	Else
		MinVal = 1
	End If
	'超长而提取速度变慢的过滤设置
	RVA = StrToLong(ExtractSet(52))
	VRK = StrToLong(ExtractSet(53))

	'初始化提取消息参数
	LogNo = -1
	LogMax = IIf((RSize - ROffset + 1) < 1000,10,(RSize - ROffset + 1) \ 100)
	ReDim LogList(LogMax) As String
	FormatText = String$(Len(CStr(RSize)),"0")

	'其他参数初始化
	n = UBound(DataList)
	If n = 0 And DataList(0).Source.CodePage = 0 Then n = -1
	Max = n + IIf((RSize - ROffset + 1) < 1000,10,(RSize - ROffset + 1) \ 100)
	ReDim Preserve DataList(Max) As STRING_PROPERTIE

	'提取字串
	SkipVal = ROffset - 1
	With strData
		i = 0: .lEndAddress = 0
		For j = 0 To k
			.lStartAddress = RVAList(j)
			'排除各种文件头数据区段
			If .lStartAddress > SkipVal Then
				i = .lStartAddress
				m = SkipHeader(File,i,SkipVal,1)
				If m = 0 Or m = 1 Or m = 5 Or m = 13 Then Exit For
				If i > SkipVal Or SkipVal > RSize Then SkipVal = RSize + 1
				If i > RSize Then Exit For
			End If
			If .lStartAddress >= i Then
				'.lEndAddress = getNullByte(FN,.lStartAddress + 1,MaxVal,Mode,2) - 1	'跳到 &H0000 开始处前一个字节
				.lEndAddress = getEndByteRegExp(FN,.lStartAddress + 1,SkipVal,Mode,"\x00",-MinVal) - 1	'跳到 &H0000 开始处前一个字节
				.lHexLength = .lEndAddress - .lStartAddress + 1
				'提取字串
				If .lHexLength >= MinLength Then
					'检测字节的代码页
					.lMaxAddress = getCodePageRegExp(FN,strData,UseLangList,intList,MinLength,StrTypeEndChar,EndCharList,Mode,0,RVA,VRK)
					'检测字串的类型等其他属性
					If .CodePage <> CP_UNKNOWN Then
						StrType = 0
						'.sString = ByteToString(GetBytes(FN,.lHexLength,.lStartAddress,Mode),.CodePage)
						If CheckString(File,FN,strData,StrType,TagType,FeatureCode,MaxVal,LogList,FormatText,LogMax,LogNo,Mode,Msg.hWnd,EndChar) > 0 Then
							'添加字串数据到数据库
							If Dic.Exists(-.lMaxAddress) Then
								m = Dic.Item(-.lMaxAddress)
								If .lStartAddress < DataList(m).Source.lStartAddress Or _
									.lEndAddress > DataList(m).Source.lEndAddress Then
									If DataDic.Exists(DataList(m).ID) Then
										DataDic.Remove(DataList(m).ID)
									End If
									AddToDataList(File,DataList,DataDic,strData,StrType,Max,m - 1)
								End If
							ElseIf AddToDataList(File,DataList,DataDic,strData,StrType,Max,n) = True Then
								Dic.Add(-.lMaxAddress,n)
								GetPE32SectionStrByVA = GetPE32SectionStrByVA + 1
							End If
						End If
						'开始地址最小值
						If .lMaxAddress > i Then i = .lMaxAddress + 1
					End If
				End If
			End If
			If ExtractSet(25) = "0" Then
				If j Mod 100 = 1 Then
					If Msg.hWnd > 0 Then
						SetTextBoxString Msg.hWnd,Msg.Massage & Format$(((RSize - ROffset) * (1 + j / k) * 0.5 + Msg.Passed) / Msg.Total,"#%")
					ElseIf Msg.hWnd < 0 Then
						PSL.OutputWnd(0).Clear
						PSL.Output Msg.Massage & Format$(((RSize - ROffset) * (1 + j / k) * 0.5 + Msg.Passed) / Msg.Total,"#%")
					End If
				End If
			End If
			'DoEvents '转让控制权，允许操作系统处理其他事件
			If StopProcess(StopHwnd,VK_ESCAPE) = True Then
				GetPE32SectionStrByVA = -2
				GoTo ExitFunction
			End If
		Next j
	End With
	ExitFunction:
	Set Dic = Nothing
	If n > -1 Then
		ReDim Preserve DataList(n) As STRING_PROPERTIE
	Else
		ReDim DataList(0) As STRING_PROPERTIE
	End If
	ReDim Preserve LogList(IIf(LogNo > -1,LogNo,0)) As String
End Function


'提取指定节或指定区域中的字符串(字节块分析法)
'ROffset 为开始地址，RSize 为结束地址，开始地址和结束地址，均在某个区段内
'返回值 >0 获取的字串数，0 没有获取，-1 获取引用代码过程中中止 ，-2 获取字串过程中中止
Private Function GetSectionStrBySmall(DataList() As STRING_PROPERTIE,DataDic As Object,File As FILE_PROPERTIE,FN As FILE_IMAGE, _
		Msg As PROGRESS_MSG,LogList() As String,ByVal Mode As Long,ByVal ROffset As Long,ByVal RSize As Long) As Long
	Dim i As Long,j As Long,n As Long,m As Long
	Dim Max As Long,SkipVal As Long,MaxVal As Long,LogNo As Long,LogMax As Long
	Dim MinLength As Integer,StrType As Integer,TagType As Integer,intList() As Integer
	Dim FeatureCode As String,EndCharList() As String,StrTypeEndChar() As String,FormatText As String
	Dim Matches As Object,strData As STRING_SUB_PROPERTIE,MinVal As Integer,EndChar As String
	Dim LengthSet As Long,MaxLength As Long

	'获取字符串最小字符数长度
	MinLength = StrToLong(ExtractSet(27))
	i =  RSize - ROffset + 1
	If i < MinLength Then Exit Function

	'按开始地址获取所在区段索引号
	strData.inSectionID = SkipSection(File,ROffset,0,0,1)
	If strData.inSectionID < 0 Then Exit Function
	If File.SecList(strData.inSubSecID).SubSecs > 0 Then
		strData.inSubSecID = SkipSubSection(File.SecList(strData.inSectionID),ROffset,0,0)
		If strData.inSubSecID < 0 Then Exit Function
	End If

	'转换字符编码的提取顺序
	intList = ConvertStrCPOrder(ExtractSet(4))
	'获取字符串结束符的正则表达式模板
	EndCharList = StrEndChar2Pattern(ExtractSet(31))
	EndChar = Mid(EndCharList(1),InStr(EndCharList(1),")(") + 2)
	EndChar = Left(EndChar,InStrRev(EndChar,")") - 1)
	'获取自定义字符串结束标识符的正则表达式模板
	StrTypeEndChar = StrTypeEndChar2Pattern(UseStrTypeList,UseLangList,intList,ExtractSet(10))
	'检查是否需要检测多字节字符串的代码页
	FeatureCode = GetFeaturePattern(UseLangList)
	'判断是否需要检查跟随引用地址的自定义字符类型
	If ExtractSet(10) = "1" Then TagType = CheckRefCustomStrType(UseStrTypeList,IIf(File.Magic = "",0,1))
	'获取 CP_UTF32LE 和 CP_UTF32BE 所需的空字节长度
	MinVal = IIf(Mid$(ExtractSet(4),6,1) = "0" And Mid$(ExtractSet(4),7,1) = "0",1,2)
	'超长而提取速度变慢的过滤设置
	LengthSet = StrToLong(ExtractSet(52))
	MaxLength = StrToLong(ExtractSet(53))

	'初始化提取消息参数
	LogNo = -1
	LogMax = IIf(i < 1000,10,i \ 100)
	ReDim LogList(LogMax) As String
	FormatText = String$(Len(CStr(RSize)),"0")

	'其他参数初始化
	n = UBound(DataList)
	If n = 0 And DataList(0).Source.CodePage = 0 Then n = -1
	Max = n + IIf(i < 1000,10,i \ 100)
	ReDim Preserve DataList(Max) As STRING_PROPERTIE
	DoEvents '转让控制权，允许操作系统处理其他事件

	'开始提取字串
	i = ROffset
	SkipVal = ROffset - 1
	With strData
		Do While i < RSize
			'排除各种文件头数据区段
			If i > SkipVal Then
				m = SkipHeader(File,i,SkipVal,1)
				If m = 0 Or m = 1 Or m = 5 Or m = 13 Then Exit Do
				If i > SkipVal Or SkipVal > RSize Then SkipVal = RSize + 1
				If i > RSize Then Exit Do
				'获取有字串的最小开始位置和最大结束位置
				MaxVal = SkipVal
				If GetStrAddRangeRegExp(FN,i,MaxVal,UseLangList,intList,MinLength,StrTypeEndChar,EndCharList,Mode) = 0 Then
					i = SkipVal + 1
					GoTo NextNo
				End If
				'为获取双空字节的位置做准备
				RegExp.Global = True
				RegExp.IgnoreCase = False
				RegExp.Pattern = "\x00{" & MinVal & ",}"
				Set Matches = RegExp.Execute(GetBytes(FN,MaxVal - i,i,Mode) & vbNullChar & vbNullChar)
				j = 0: .lStartAddress = i
			End If
			If j >= Matches.Count Then
				i = SkipVal + 1
			Else
				.lStartAddress = getNotNullByte(FN,.lStartAddress,MaxVal,Mode)
				.lEndAddress = getNotNullByteRev(FN,i + Matches(j).FirstIndex * 2,.lStartAddress,Mode)
				'提取字串
				m = .lEndAddress
				.lHexLength = .lEndAddress - .lStartAddress + 1
				Do While .lHexLength >= MinLength
					'检测字节的代码页
					.lMaxAddress = getCodePageRegExp(FN,strData,UseLangList,intList,MinLength,StrTypeEndChar,EndCharList,Mode,1,LengthSet,MaxLength)
					If .CodePage = CP_UNKNOWN Then Exit Do
					'检测字串的类型等其他属性
					StrType = 0
					'.sString = ByteToString(GetBytes(FN,.lHexLength,.lStartAddress,Mode),.CodePage)
					If CheckString(File,FN,strData,StrType,TagType,FeatureCode,MaxVal,LogList,FormatText,LogMax,LogNo,Mode,Msg.hWnd,EndChar) > 0 Then
						'添加字串数据到数据库
						If AddToDataList(File,DataList,DataDic,strData,StrType,Max,n) = True Then
							GetSectionStrBySmall = GetSectionStrBySmall + 1
						End If
					End If
					.lStartAddress = getNotNullByte(FN,.lMaxAddress + 1,MaxVal,Mode)
					.lEndAddress = m
					.lHexLength = .lEndAddress - .lStartAddress + 1
					If ExtractSet(25) = "0" Then
						If Msg.hWnd > 0 Then
							SetTextBoxString Msg.hWnd,Msg.Massage & Format$((.lStartAddress - ROffset + Msg.Passed) / Msg.Total,"#%")
						ElseIf Msg.hWnd < 0 Then
							PSL.OutputWnd(0).Clear
							PSL.Output Msg.Massage & Format$((.lStartAddress - ROffset + Msg.Passed) / Msg.Total,"#%")
						End If
					End If
					'DoEvents '转让控制权，允许操作系统处理其他事件
					If StopProcess(StopHwnd,VK_ESCAPE) = True Then
						GetSectionStrBySmall = -2
						GoTo ExitFunction
					End If
				Loop
				.lStartAddress = i + (Matches(j).FirstIndex + Matches(j).Length) * 2
				j = j + 1
			End If
			NextNo:
			If i > .lStartAddress Then
				If ExtractSet(25) = "0" Then
					If Msg.hWnd > 0 Then
						SetTextBoxString Msg.hWnd,Msg.Massage & Format$((i - ROffset + Msg.Passed) / Msg.Total,"#%")
					ElseIf Msg.hWnd < 0 Then
						PSL.OutputWnd(0).Clear
						PSL.Output Msg.Massage & Format$((i - ROffset + Msg.Passed) / Msg.Total,"#%")
					End If
				End If
			End If
			'DoEvents '转让控制权，允许操作系统处理其他事件
			If StopProcess(StopHwnd,VK_ESCAPE) = True Then
				GetSectionStrBySmall = -2
				GoTo ExitFunction
			End If
		Loop
	End With
	ExitFunction:
	If n > -1 Then
		ReDim Preserve DataList(n) As STRING_PROPERTIE
	Else
		ReDim DataList(0) As STRING_PROPERTIE
	End If
	ReDim Preserve LogList(IIf(LogNo > -1,LogNo,0)) As String
End Function


'提取指定节或指定区域中的字符串(正则表达式法)
'ROffset 为开始地址，RSize 为结束地址，开始地址和结束地址，均在某个区段内
'返回值 >0 获取的字串数，0 没有获取，-1 获取引用代码过程中中止 ，-2 获取字串过程中中止
Private Function GetSectionStrByFull(DataList() As STRING_PROPERTIE,DataDic As Object,File As FILE_PROPERTIE,FN As FILE_IMAGE, _
		Msg As PROGRESS_MSG,LogList() As String,ByVal Mode As Long,ByVal ROffset As Long,ByVal RSize As Long) As Long
	Dim i As Long,j As Long,n As Long,m As Long,k As Long,t As Long,x As Long,LogNo As Long,LogMax As Long
	Dim Max As Long,SkipVal As Long,MaxVal As Long,MaxPos As Long,CP As Long
	Dim MinLength As Integer,StrType As Integer,TagType As Integer,intList() As Integer
	Dim FeatureCode As String,EndCharList() As String,StrTypeEndChar() As String,FormatText As String
	Dim Matches As Object,strData As STRING_SUB_PROPERTIE,EndChar As String
	Dim Dic As Object,EncodeMax As Integer,CPMax As Integer

	'获取字符串最小字符数长度
	MinLength = StrToLong(ExtractSet(27))
	i= RSize - ROffset + 1
	If i < MinLength Then Exit Function

	'按开始地址获取所在区段索引号
	strData.inSectionID = SkipSection(File,ROffset,0,0,1)
	If strData.inSectionID < 0 Then Exit Function
	If File.SecList(strData.inSubSecID).SubSecs > 0 Then
		strData.inSubSecID = SkipSubSection(File.SecList(strData.inSectionID),ROffset,0,0)
		If strData.inSubSecID < 0 Then Exit Function
	End If

	'转换字符编码的提取顺序
	intList = ConvertStrCPOrder(ExtractSet(4))
	'获取字符串结束符的正则表达式模板
	EndCharList = StrEndChar2Pattern(ExtractSet(31))
	EndChar = Mid(EndCharList(1),InStr(EndCharList(1),")(") + 2)
	EndChar = Left(EndChar,InStrRev(EndChar,")") - 1)
	'获取自定义字符串结束标识符的正则表达式模板
	StrTypeEndChar = StrTypeEndChar2Pattern(UseStrTypeList,UseLangList,intList,ExtractSet(10))
	'检查是否需要检测多字节字符串的代码页
	FeatureCode = GetFeaturePattern(UseLangList)
	'判断是否需要检查跟随引用地址的自定义字符类型
	If ExtractSet(10) = "1" Then TagType = CheckRefCustomStrType(UseStrTypeList,IIf(File.Magic = "",0,1))
	'获取 CP_UTF32LE 和 CP_UTF32BE 所需的空字节长度
	'MinVal = IIf(Mid$(ExtractSet(4),6,1) = "0" And Mid$(ExtractSet(4),7,1) = "0",1,2)

	'初始化提取消息参数
	LogNo = -1
	LogMax = IIf(i < 1000,10,i \ 100)
	ReDim LogList(LogMax) As String
	FormatText = String$(Len(CStr(RSize)),"0")

	'其他参数初始化
	EncodeMax = UBound(intList)
	CPMax = UBound(UseLangList)
	Set Dic = CreateObject("Scripting.Dictionary")
	n = UBound(DataList)
	If n = 0 And DataList(0).Source.CodePage = 0 Then n = -1
	Max = n + IIf(i < 1000,10,i \ 100)
	ReDim Preserve DataList(Max) As STRING_PROPERTIE
	DoEvents '转让控制权，允许操作系统处理其他事件

	'开始提取字串
	i = ROffset
	SkipVal = ROffset - 1
	With strData
		Do While i < RSize
			'排除各种文件头数据区段
			If i <= SkipVal Then i = SkipVal + 1
			If i > SkipVal Then
				m = SkipHeader(File,i,SkipVal,1)
				If m = 0 Or m = 1 Or m = 5 Or m = 13 Then Exit Do
				If i > SkipVal Or SkipVal > RSize Then SkipVal = RSize + 1
				If i > RSize Then Exit Do
				'获取有字串的最小开始位置和最大结束位置
				MaxVal = SkipVal
				If GetStrAddRangeRegExp(FN,i,MaxVal,UseLangList,intList,MinLength,StrTypeEndChar,EndCharList,Mode) = 0 Then
					i = SkipVal + 1
					GoTo NextNo
				End If
			End If
			For j = 0 To UBound(UseLangList)
				For m = 0 To UBound(intList)
					k = intList(m)
					Select Case k
					Case 1
						CP = UseLangList(j).CodePage
					Case 2
						CP = CP_UNICODELITTLE
					Case 3
						CP = CP_UTF8: k = 1
					Case 4
						CP = CP_UNICODEBIG: k = 2
					Case 5
						CP = CP_UTF7: k = 1
					Case 6
						CP = CP_UTF32LE: k = 4
					Case 7
						CP = CP_UTF32BE: k = 4
					End Select
					RegExp.Global = True
					RegExp.IgnoreCase = False
					RegExp.Pattern = EndCharList(0) & UseLangList(j).UniCodeRegExpPattern & "{" & CStr$(MinLength) & ",}" & _
									Replace$(EndCharList(1),")(",StrTypeEndChar(j,m),,1)
					Set Matches = RegExp.Execute(ByteToString(GetBytes(FN,MaxVal - i,i,Mode),CP) & vbNullChar)
					If Matches.Count > 0 Then
						.lMaxAddress = i
						For t = 0 To Matches.Count - 1
							.lHexLength = -1
							.lStartAddress = i: .lEndAddress = MaxVal - 1: .CodePage = CP
							Call GetStrAddress(FN,strData,Matches(t),Mode)
							'提取字串
							If CPMax + EncodeMax > 0 Then
								'检查字串是否是其他字串的一部分
								.lMaxAddress = getNotNullByte(FN,.lMaxAddress + 1,MaxVal,Mode) - 1
								If j + m > 0 Then
									'检查字串是否是其他字串的一部分
									x = IIf(k = 1,.lStartAddress,.lEndAddress)
									If Dic.Exists(.lMaxAddress) = False And Dic.Exists(.lStartAddress) = False Then
										Do
											If Dic.Exists(x) Then
												If k = 1 Then
													x = Dic.Item(x)
													If .lStartAddress > Dic.Item(x) And .lMaxAddress < x Then x = -1
												ElseIf Dic.Exists(-x) Then
													Dic.Key(-x) = -.lMaxAddress
												End If
												Exit Do
											ElseIf DataDic.Exists(x) Then
												If k = 1 Then
													x = DataDic.Item(x)
													If .lStartAddress > DataList(x).Source.lStartAddress And _
														.lEndAddress < DataList(x).Source.lEndAddress Then
														x = -1
													End If
												ElseIf Dic.Exists(-x) Then
													Dic.Key(-x) = -.lMaxAddress
												End If
												Exit Do
											End If
											x = x - 1
											'DoEvents '转让控制权，允许操作系统处理其他事件
											If StopProcess(StopHwnd,VK_ESCAPE) = True Then
												GetSectionStrByFull = -2
												GoTo ExitFunction
											End If
										Loop Until x <= IIf(k = 1,i,.lStartAddress)
									ElseIf Dic.Exists(.lMaxAddress) Then
										If .lStartAddress > Dic.Item(.lMaxAddress) Then x = -1
									ElseIf Dic.Exists(.lStartAddress) Then
										If .lMaxAddress < Dic.Item(.lStartAddress) Then x = -1
									End If
								End If
								If x > -1 Then
									If Not Dic.Exists(.lMaxAddress) Then Dic.Add(.lMaxAddress,.lStartAddress)
									If Not Dic.Exists(.lStartAddress) Then Dic.Add(.lStartAddress,.lMaxAddress)
									StrType = 0
									.sString = Matches(t).SubMatches(1)
									If CheckString(File,FN,strData,StrType,TagType,FeatureCode,MaxVal,LogList,FormatText,LogMax,LogNo,Mode,Msg.hWnd,EndChar) > 0 Then
										'添加字串数据到数据库
										If Dic.Exists(-.lMaxAddress) Then
											x = Dic.Item(-.lMaxAddress)
											If .lStartAddress < DataList(x).Source.lStartAddress Or _
												.lEndAddress > DataList(x).Source.lEndAddress Then
												If DataDic.Exists(DataList(x).ID) Then
													DataDic.Remove(DataList(x).ID)
												End If
												AddToDataList(File,DataList,DataDic,strData,StrType,Max,x - 1)
											End If
										ElseIf AddToDataList(File,DataList,DataDic,strData,StrType,Max,n) = True Then
											Dic.Add(-.lMaxAddress,n)
											GetSectionStrByFull = GetSectionStrByFull + 1
										End If
									End If
								End If
							Else
								StrType = 0
								.sString = Matches(t).SubMatches(1)
								If CheckString(File,FN,strData,StrType,TagType,FeatureCode,MaxVal,LogList,FormatText,LogMax,LogNo,Mode,Msg.hWnd,EndChar) > 0 Then
									'添加字串数据到数据库
									If AddToDataList(File,DataList,DataDic,strData,StrType,Max,n) = True Then
										GetSectionStrByFull = GetSectionStrByFull + 1
									End If
								End If
							End If
							If ExtractSet(25) = "0" Then
								If .lMaxAddress > MaxPos Then
									MaxPos = .lMaxAddress
									If Msg.hWnd > 0 Then
										SetTextBoxString Msg.hWnd,Msg.Massage & Format$((MaxPos - ROffset + Msg.Passed) / Msg.Total,"#%")
									ElseIf Msg.hWnd < 0 Then
										PSL.OutputWnd(0).Clear
										PSL.Output Msg.Massage & Format$((MaxPos - ROffset + Msg.Passed) / Msg.Total,"#%")
									End If
								End If
							End If
							'DoEvents '转让控制权，允许操作系统处理其他事件
							If StopProcess(StopHwnd,VK_ESCAPE) = True Then
								GetSectionStrByFull = -2
								GoTo ExitFunction
							End If
						Next t
					End If
					'DoEvents '转让控制权，允许操作系统处理其他事件
					If StopProcess(StopHwnd,VK_ESCAPE) = True Then
						GetSectionStrByFull = -2
						GoTo ExitFunction
					End If
				Next m
			Next j
			NextNo:
			If ExtractSet(25) = "0" Then
				If SkipVal > MaxPos Then
					MaxPos = SkipVal
					If Msg.hWnd > 0 Then
						SetTextBoxString Msg.hWnd,Msg.Massage & Format$((MaxPos - ROffset + Msg.Passed) / Msg.Total,"#%")
					ElseIf Msg.hWnd < 0 Then
						PSL.OutputWnd(0).Clear
						PSL.Output Msg.Massage & Format$((MaxPos - ROffset + Msg.Passed) / Msg.Total,"#%")
					End If
				End If
			End If
			'DoEvents '转让控制权，允许操作系统处理其他事件
			If StopProcess(StopHwnd,VK_ESCAPE) = True Then
				GetSectionStrByFull = -2
				GoTo ExitFunction
			End If
		Loop
	End With
	ExitFunction:
	Set Dic = Nothing
	If n > -1 Then
		ReDim Preserve DataList(n) As STRING_PROPERTIE
	Else
		ReDim DataList(0) As STRING_PROPERTIE
	End If
	ReDim Preserve LogList(IIf(LogNo > -1,LogNo,0)) As String
End Function


'获取有字串的最小开始位置和最大结束位置
Private Function GetStrAddRangeRegExp(FN As FILE_IMAGE,Min As Long,Max As Long,CPList() As LANG_PROPERTIE, _
			EncodeList() As Integer,ByVal MinLength As Integer,StrTypeEndChar() As String,EndChar() As String, _
			ByVal Mode As Long) As Long
	Dim i As Long,j As Long,k As Long,n As Long,sp As Long,ep As Long,MinPos As Long,MaxPos As Long
	Dim Matches As Object,Data As STRING_SUB_PROPERTIE,MinAddress As Long,MaxAddress As Long
	With Data
	'Min = GetEvenPos(Min,1): Max = GetEvenPos(Max,0)
	MinAddress = Max: MaxAddress = Min: MinPos = Min: MaxPos = Max
	sp = Min
	Do
		ep = IIf(sp + 1024 < Max,sp + 1024,Max)
		If ep - sp + 1 < MinLength Then Exit Do
		For i = 0 To UBound(CPList)
			For j = 0 To UBound(EncodeList)
				k = EncodeList(j)
				Select Case k
				Case 1
					.CodePage = CPList(i).CodePage
				Case 2
					.CodePage = CP_UNICODELITTLE
				Case 3
					.CodePage = CP_UTF8: k = 1
				Case 4
					.CodePage = CP_UNICODEBIG: k = 2
				Case 5
					.CodePage = CP_UTF7: k = 1
				Case 6
					.CodePage = CP_UTF32LE: k = 4
				Case 7
					.CodePage = CP_UTF32BE: k = 4
				End Select
				For n = 0 To k - 1
					RegExp.Global = False
					RegExp.IgnoreCase = True
					RegExp.Pattern = EndChar(0) & CPList(i).UniCodeRegExpPattern & "{" & CStr$(MinLength) & ",}" & _
									Replace$(EndChar(1),")(",StrTypeEndChar(i,j),,1)
					Set Matches = RegExp.Execute(ByteToString(GetBytes(FN,ep - sp + 1 + n,sp - n,Mode),.CodePage) & vbNullChar)
					If Matches.Count > 0 Then
						.lHexLength = -1
						.lStartAddress = sp - n: .lMaxAddress = sp - n: .lEndAddress = ep
						Call GetStrAddress(FN,Data,Matches(0),Mode)
						If .lHexLength > -1 Then
							If .lCharLength < MinAddress Then
								MinAddress = .lCharLength: MinPos = .lCharLength
							End If
							If .lMaxAddress > MaxAddress Then MaxAddress = .lMaxAddress
						End If
						GetStrAddRangeRegExp = 1
						Exit For
					End If
				Next n
			Next j
		Next i
		If GetStrAddRangeRegExp = 1 Then Exit Do
		sp = ep
	Loop Until ep >= Max
	If GetStrAddRangeRegExp = 0 Then
		Min = Max
		Exit Function
	End If
	ep = Max
	Do
		sp = IIf(ep - 1024 > MaxAddress,ep - 1024,MaxAddress)
		If ep - sp + 1 < MinLength Then Exit Do
		For i = 0 To UBound(CPList)
			For j = 0 To UBound(EncodeList)
				k = EncodeList(j)
				Select Case k
				Case 1
					.CodePage = CPList(i).CodePage
				Case 2
					.CodePage = CP_UNICODELITTLE
				Case 3
					.CodePage = CP_UTF8: k = 1
				Case 4
					.CodePage = CP_UNICODEBIG: k = 2
				Case 5
					.CodePage = CP_UTF7: k = 1
				Case 6
					.CodePage = CP_UTF32LE: k = 4
				Case 7
					.CodePage = CP_UTF32BE: k = 4
				End Select
				For n = 0 To k - 1
					RegExp.Global = True
					RegExp.IgnoreCase = False
					RegExp.Pattern = EndChar(0) & CPList(i).UniCodeRegExpPattern & "{" & CStr$(MinLength) & ",}" & _
									Replace$(EndChar(1),")(",StrTypeEndChar(i,j),,1)
					Set Matches = RegExp.Execute(ByteToString(GetBytes(FN,ep - sp + 1 + n,sp - n,Mode),.CodePage) & vbNullChar)
					If Matches.Count > 0 Then
						.lHexLength = -1
						.lStartAddress = sp - n: .lMaxAddress = sp - n: .lEndAddress = ep
						Call GetStrAddress(FN,Data,Matches(Matches.Count - 1),Mode)
						If .lHexLength > -1 Then
							If .lMaxAddress > MaxAddress Then
								MaxAddress = .lMaxAddress: MaxPos = .lMaxAddress
							End If
						End If
						GetStrAddRangeRegExp = 2
						Exit For
					End If
				Next n
			Next j
		Next i
		If GetStrAddRangeRegExp = 2 Then Exit Do
		ep = sp
	Loop Until sp <= MaxAddress
	End With
	If GetStrAddRangeRegExp = 1 Then MaxPos = MaxAddress
	If MinPos > Min Then Min = MinPos
	If MaxPos < Max Then Max = getNotNullByte(FN,MaxPos + 1,Max,Mode) + 1
End Function


'检查字串的类型
Private Function GetStrType(File As FILE_PROPERTIE,FN As FILE_IMAGE,strData As STRING_SUB_PROPERTIE, _
		TypeList() As STRING_TYPE,OptionSet() As String,ByVal Mode As Long,ByVal fType As Long) As Integer
	Dim i As Long,j As Long,k As Long
	On Error GoTo ExitFunction
	With strData
		'获取 Android 类型字符串 (Uincode、UTF8)
		If OptionSet(41) = "1" And ((fType > -1 And fType < 3) Or fType = 9) Then
			i = .lStartAddress
			Do
				i = i - 1
				If i < .lStartAddress - 8 Then Exit Do
			Loop Until GetByte(FN,i,Mode) = 0 Or i < 0
			i = i + 1
			j = CorSigUncompressData(FN,i,k,Mode)
			If k = .lCharLength Then
				j = j + CorSigUncompressData(FN,i + j,k,Mode)
				If (k = .lHexLength) And i + j + k - 1 = .lEndAddress Then
					.lStartAddress = i + j
					.sString = ByteToString(GetBytes(FN,.lHexLength,.lStartAddress,Mode),.CodePage)
					.lCharLength = Len(.sString)
					GetStrType = -(j + 3)
					Exit Function
				End If
			ElseIf k < .lCharLength Then
				j = j + CorSigUncompressData(FN,i + j,k,Mode)
				If k > 0 And i + j + k - 1 = .lEndAddress Then
					.lStartAddress = i + j
					.lHexLength = k
					.sString = ByteToString(GetBytes(FN,.lHexLength,.lStartAddress,Mode),.CodePage)
					.lCharLength = Len(.sString)
					GetStrType = -(j + 3)
					Exit Function
				End If
			End If
			If fType = 9 Then Exit Function
		End If
		'获取 .NET 类型字符串 (Unicode)
		If OptionSet(9) = "1" And (fType = 2 Or fType = 8) Then
		'If OptionSet(9) = "1" And ((fType > -1 And fType < 3) Or fType = 8) Then
			i = .lStartAddress
			Do
				i = i - 1
				If i < .lStartAddress - 4 Then Exit Do
				k = GetByte(FN,i,Mode)
			Loop Until k = 0 Or k = 1
			i = i + 1
			j = CorSigUncompressData(FN,i,k,Mode)
			If k = .lHexLength + 1 Then
				'检查结束标识符是否符合要求
				'If GetByte(FN,.lEndAddress + 1,Mode) = IIf(CheckStrRegExp(.sString,"[\x01-\x7F]",0,1) = True,0,1) Then
				If GetByte(FN,.lEndAddress + 1,Mode) < 2 Then
					.lStartAddress = i + j
					.sString = ByteToString(GetBytes(FN,.lHexLength,.lStartAddress,Mode),.CodePage)
					.lCharLength = Len(.sString)
					GetStrType = -j
					'记录引用代码
					'ReDim strData.Reference(0) As REFERENCE_PROPERTIE
					'i = File.StreamList(File.USStreamID).lPointerToRawData
					'.Reference(0).sCode = ReverseHexCode(Hex$(.lStartAddress - i + GetStrType),6) & "70"
					Exit Function
				End If
			ElseIf k < .lHexLength + 1 Then
				If i + j + k - 2 = .lEndAddress Then
					'检查结束标识符是否符合要求
					'If GetByte(FN,.lEndAddress + 1,Mode) = IIf(CheckStrRegExp(.sString,"[\x01-\x7F]",0,1) = True,0,1) Then
					If GetByte(FN,.lEndAddress + 1,Mode) < 2 Then
						.lStartAddress = i + j
						.lHexLength = k - 1
						.sString = ByteToString(GetBytes(FN,.lHexLength,.lStartAddress,Mode),.CodePage)
						.lCharLength = Len(.sString)
						GetStrType = -j
						'记录引用代码
						'ReDim strData.Reference(0) As REFERENCE_PROPERTIE
						'i = File.StreamList(File.USStreamID).lPointerToRawData
						'.Reference(0).sCode = ReverseHexCode(Hex$(.lStartAddress - i + GetStrType),6) & "70"
						Exit Function
					End If
				End If
			End If
			If fType = 8 Then Exit Function
		End If
		'获取 Delphi 类型字符串
		If InStr(OptionSet(5) & OptionSet(6) & OptionSet(7) & OptionSet(8),"1") Then
			Dim DelphiUnicodeStr As DELPHI_UNICODE_STRING
			'GetTypeValue FN,.lStartAddress - 12,DelphiUnicodeStr,Mode
			Select Case Mode
			Case Is < 0
				Get #FN.hFile, .lStartAddress - 12 + 1, DelphiUnicodeStr
			Case 0
				CopyMemory DelphiUnicodeStr, FN.ImageByte(.lStartAddress - 12), Len(DelphiUnicodeStr)
			Case Else
				MoveMemory DelphiUnicodeStr, FN.MappedAddress + .lStartAddress - 12, Len(DelphiUnicodeStr)
			End Select
			If DelphiUnicodeStr.RefCount = &HFFFFFFFF Then
				'获取 Delphi Unicode 类型字符串
				If OptionSet(5) = "1" And ((fType > -1 And fType < 3) Or fType = 4) Then
					'获取 Delphi Unicode 类型字符串 (ANSI、UTF8)
					If DelphiUnicodeStr.elemSize = 1 Then
						If .lStartAddress - .lEndAddress + DelphiUnicodeStr.elemSize * DelphiUnicodeStr.Length = 1 Then
							GetStrType = 1
							If .CodePage <> DelphiUnicodeStr.CodePage Then
								.CodePage = DelphiUnicodeStr.CodePage
								.sString = ByteToString(GetBytes(FN,.lHexLength,.lStartAddress,Mode),.CodePage)
								.lCharLength = Len(.sString)
							End If
							Exit Function
						End If
					'获取 Delphi Unicode 类型字符串 (Unicode)
					ElseIf DelphiUnicodeStr.elemSize = 2 Then
						If .lStartAddress - .lEndAddress + DelphiUnicodeStr.elemSize * DelphiUnicodeStr.Length > 0 And _
							.lStartAddress - .lEndAddress + DelphiUnicodeStr.elemSize * DelphiUnicodeStr.Length < 3 Then
							i = GetInteger(FN,.lStartAddress + DelphiUnicodeStr.elemSize * DelphiUnicodeStr.Length - 2,Mode)
							If i > 0 And i < &H80 Then
								GetStrType = 1
								i = .lStartAddress + DelphiUnicodeStr.elemSize * DelphiUnicodeStr.Length - 1
								If .CodePage <> DelphiUnicodeStr.CodePage Or i <> .lEndAddress Then
									.CodePage = DelphiUnicodeStr.CodePage
									.lEndAddress = i
									.lHexLength = .lEndAddress - .lStartAddress + 1
									.sString = ByteToString(GetBytes(FN,.lHexLength,.lStartAddress,Mode),.CodePage)
									.lCharLength = Len(.sString)
								End If
								Exit Function
							ElseIf .lStartAddress - .lEndAddress + DelphiUnicodeStr.elemSize * DelphiUnicodeStr.Length = 1 Then
								GetStrType = 1
								If .CodePage <> DelphiUnicodeStr.CodePage Then
									.CodePage = DelphiUnicodeStr.CodePage
									.sString = ByteToString(GetBytes(FN,.lHexLength,.lStartAddress,Mode),.CodePage)
									.lCharLength = Len(.sString)
								End If
								Exit Function
							End If
						End If
					End If
					If fType = 4 Then Exit Function
				End If
				'获取 Delphi Ansi 类型字符串 (ANSI)
				If OptionSet(7) = "1" And ((fType > -1 And fType < 3) Or fType = 6) Then
					If .CodePage <> CP_UNICODELITTLE And .CodePage <> CP_UNICODEBIG And _
						.CodePage <> CP_UTF7 And .CodePage <> CP_UTF8 And _
						.CodePage <> CP_UTF32LE And .CodePage <> CP_UTF32BE Then
						If .lStartAddress - .lEndAddress + DelphiUnicodeStr.Length = 1 Then
							GetStrType = 3
							'.CodePage = CP_WESTEUROPE
							Exit Function
						End If
					End If
					If fType = 6 Then Exit Function
				End If
			'获取 Delphi Wide 类型字符串 (Unicode)
			ElseIf OptionSet(6) = "1" And ((fType > -1 And fType < 3) Or fType = 5) Then
				If .CodePage = CP_UNICODELITTLE Or .CodePage = CP_UNICODEBIG Then
					If .lStartAddress - .lEndAddress + DelphiUnicodeStr.Length > 0 And _
						.lStartAddress - .lEndAddress + DelphiUnicodeStr.Length < 3 Then
						i = GetInteger(FN,.lStartAddress + DelphiUnicodeStr.Length - 2,Mode)
						If i > 0 And i < &H80 Then
							GetStrType = 2
							'.CodePage = CP_UNICODELITTLE
							i = .lStartAddress + DelphiUnicodeStr.Length - 1
							If i <> .lEndAddress Then
								.lEndAddress = i
								.lHexLength = .lEndAddress - .lStartAddress + 1
								.sString = ByteToString(GetBytes(FN,.lHexLength,.lStartAddress,Mode),.CodePage)
								.lCharLength = Len(.sString)
							End If
							Exit Function
						ElseIf .lStartAddress - .lEndAddress + DelphiUnicodeStr.Length = 1 Then
							GetStrType = 2
							'.CodePage = CP_UNICODELITTLE
							Exit Function
						End If
					End If
				End If
				If fType = 5 Then Exit Function
			End If
			'获取 Delphi Short 类型字符串 (ANSI)
			If OptionSet(8) = "1" And ((fType > -1 And fType < 3) Or fType = 7) Then
				If .CodePage <> CP_UNICODELITTLE And .CodePage <> CP_UNICODEBIG And _
					.CodePage <> CP_UTF7 And .CodePage <> CP_UTF8 And _
					.CodePage <> CP_UTF32LE And .CodePage <> CP_UTF32BE Then
					Dim DelphiShortStr As DELPHI_SHORT_STRING
					i = IIf(GetByte(FN,.lStartAddress - 1,Mode) = 0,1,0)
					'GetTypeValue FN,.lStartAddress + i - 1,DelphiShortStr,Mode
					Select Case Mode
					Case Is < 0
						Get #FN.hFile, .lStartAddress + i - 1 + 1, DelphiShortStr
					Case 0
						CopyMemory DelphiShortStr, FN.ImageByte(.lStartAddress + i - 1), Len(DelphiShortStr)
					Case Else
						MoveMemory DelphiShortStr, FN.MappedAddress + .lStartAddress + i - 1, Len(DelphiShortStr)
					End Select
					If .lStartAddress - .lEndAddress + DelphiShortStr.Length + i = 1 Then
						GetStrType = 4
						'.CodePage = CP_WESTEUROPE
						If i <> 0 Then
							.lStartAddress = .lStartAddress + i
							.lHexLength = .lEndAddress - .lStartAddress + 1
							.sString = ByteToString(GetBytes(FN,.lHexLength,.lStartAddress,Mode),.CodePage)
							.lCharLength = Len(.sString)
						End If
						Exit Function
					End If
				End If
				If fType = 7 Then Exit Function
			End If
		End If
	End With
	On Error GoTo 0
	ExitFunction:
	'获取自定义类型字符串
	If OptionSet(10) = "1" And GetStrType = 0 Then
		If (fType > -1 And fType < 3) Or fType > 9 Then
			GetStrType = GetCustomStrTypeRegExp(FN,strData,TypeList,Mode,fType)
		End If
	End If
End Function


'获取自定义字串类型(正则表达式)
'fType >= 0 检查跟随字串的类型, 0,2 检查 StartCodePos, StartCodeString 项, 1,>2 不检查 StartCodePos, StartCodeString 项
'fType > 9 检查指定的跟随字串的类型, 不检查 StartCodePos, StartCodeString 项
'fType < 0 检查跟随引用地址的类型，不检查 StartCodePos, StartCodeString 项
'fType = 2 检查跟随字串和跟随引用地址的类型，跟随字串的检查 StartCodePos, StartCodeString 项
'GetCustomType > 0 时，返回 StartPos、EndPos 值
Private Function GetCustomStrTypeRegExp(FN As Variant,strData As STRING_SUB_PROPERTIE,TypeList() As STRING_TYPE,ByVal Mode As Long,ByVal fType As Long) As Integer
	Dim i As Long,j As Long,k As Long,x As Long,s As Long,e As Long,t As Long
	Dim n As Integer,y As Integer,Max As Integer,sType As Integer
	Dim Data As STRING_SUB_PROPERTIE,Temp As String,Temp1 As String,Matches As Object,PatternList() As String
	If strData.CodePage < 101 Then Exit Function
	Data = strData: sType = fType
	If Data.lReferenceNum > 0 Then
		For i = 0 To Data.lReferenceNum - 1
			Data.Reference(i).StrType = 0
		Next i
	End If
	ReDim CodeStr(0) As STRING_TYPE_LENGTH
	For i = 0 To UBound(TypeList)
		s = 0: e = 0: x = -1
		With TypeList(i)
		'根据字串类型的不同转换检查方式
		If sType = 2 Then
			fType = IIf(.CodeLoc = 0,sType,-sType)
		ElseIf sType > 9 Then
			If i <> sType - 10 Then GoTo NextNo
			fType = IIf(.CodeLoc = 0,sType,-sType)
		End If
		'跳过不需要检测的字串类型
		If fType >= 0 Then
			If .CodeLoc > 0 Then GoTo NextNo
			If .FristCodePos = 0 And .EndCodeLength = 0 Then GoTo NextNo
			Max = 0
		Else
			If .CodeLoc = 0 Then GoTo NextNo
			If .FristCodePos = 0 Then GoTo NextNo
			If .CPCodePos = 0 And .LengthCodePos = 0 Then GoTo NextNo
			If Data.lReferenceNum = 0 Then GoTo NextNo
			Max = Data.lReferenceNum - 1
		End If
		If CheckArray(.RegExpPattern) = False Then GoTo NextNo
		If .CodeLoc = 0 Then
			Data = strData
			'检查字串开始标识符是否符合
			If .StartCodePos <> 0 Then
				If .StartCodeLength > 0 Then
					k = IIf(.StartCodePos >= .StartCodeLength,.StartCodePos,.StartCodeLength)
					If fType = 0 Or fType = 2 Then
						s = InByteRevRegExp(GetBytes(FN,.FristCodePos + k,Data.lStartAddress - .FristCodePos,Mode), _
							.StartCodeByte,.FristCodePos - k,.FristCodePos + k)
						If s < 1 Then GoTo NextNo
						If .FristCodePos - s - k + 1 <> 0 Then
							Data.lStartAddress = Data.lStartAddress - (.FristCodePos - s - k + 1)
							Data.lHexLength = Data.lEndAddress - Data.lStartAddress + 1
							Data.sString = ByteToString(GetBytes(FN,Data.lHexLength,Data.lStartAddress,Mode),Data.CodePage)
							Data.lCharLength = Len(Data.sString)
							s = .FristCodePos - k + 1
						End If
					Else
						s = InByteRevRegExp(GetBytes(FN,.FristCodePos,Data.lStartAddress - .FristCodePos,Mode), _
							.StartCodeByte,.FristCodePos - k,.FristCodePos - k + .StartCodeLength - 1)
						If s < 1 Then GoTo NextNo
						If .StartCodePos > 0 Then s = .FristCodePos - .StartCodePos + 1
					End If
				Else
					If .StartCodePos < 0 Then GoTo NextNo
					If .StartCodePos > .FristCodePos Then GoTo NextNo
					If GetByte(FN,Data.lStartAddress - .StartCodePos,Mode) = 0 Then GoTo NextNo
					s = .FristCodePos - .StartCodePos + 1
				End If
			End If
			'检查字串结束标识符是否符合
			If .EndCodeLength > 0 Then
				If .EndCodeString = "00" Then
					'k = IIf(CheckStrRegExp(Data.sString,"[\x01-\x7F]",0,1) = True,0,1)
					'e = IIf(GetByte(FN,Data.lEndAddress + .EndCodeLength,Mode) = k,1,0)
					e = IIf(GetByte(FN,Data.lEndAddress + .EndCodeLength,Mode) < 2,1,0)
					If e < 1 Then GoTo NextNo
				ElseIf fType = 0 Or fType = 2 Then
					k = IIf(Data.lMaxAddress - Data.lEndAddress = 0,.EndCodeLength,Data.lMaxAddress - Data.lEndAddress) + 1
					e = InByteRevRegExp(GetBytes(FN,.EndCodeLength + k,Data.lEndAddress - .EndCodeLength,Mode),.EndCodeByte)
					If e < 1 Then GoTo NextNo
					If .EndCodeLength - e + 2 <> 0 Then
						Data.lEndAddress = Data.lEndAddress - (.EndCodeLength - e + 2)
						Data.lHexLength = Data.lEndAddress - Data.lStartAddress + 1
						Data.sString = ByteToString(GetBytes(FN,Data.lHexLength,Data.lStartAddress,Mode),Data.CodePage)
						Data.lCharLength = Len(Data.sString)
					End If
				Else
					e = IIf(GetBytes(FN,.EndCodeLength,Data.lEndAddress + 1,Mode) = .EndCodeByte,1,0)
					If e < 1 Then GoTo NextNo
				End If
			End If
		End If
		If .FristCodePos > 0 Then
			ReDim CodeStr(9) As STRING_TYPE_LENGTH
			'检查代码页长度是否符合字串类型所定义的要求
			If .CPCodePos <> 0 Then
				If .CPCodeSize = 0 Then
					CodeStr(0).Size = GetEvenPos(Len(Hex$(Data.CodePage))) \ 2
				Else
					If GetEvenPos(Len(Hex$(Data.CodePage))) > .CPCodeSize * 2 Then GoTo NextNo
					CodeStr(0).Size = .CPCodeSize
				End If
				CodeStr(0).Length1 = Data.CodePage
			End If
			'检查字串长度是否符合字串类型所定义的要求
			If .LengthCodePos <> 0 Then
				x = GetCustomStrTypeValue(CodeStr,FN,Data,TypeList(i),Mode,fType)
				If x = -1 Then GoTo NextNo
				If .CodeLoc = 0 Then
					For k = 1 To 9
						If CodeStr(k).Length1 > 0 Then
							If k < 5 Then
								CodeStr(k).Pattern = Byte2RegExpPattern(Val2Bytes(CodeStr(k).Length1,CodeStr(k).Size,CodeStr(k).ByteOrder),1)
							ElseIf k = 7 Or k = 8 Then
								CodeStr(k).Pattern = Byte2RegExpPattern(CorSigCompressByte(CodeStr(k).Length1),1)
								CodeStr(k).Pattern = CodeStr(k).Pattern & Byte2RegExpPattern(CorSigCompressByte(CodeStr(k).Length2),1)
							Else
								CodeStr(k).Pattern = Byte2RegExpPattern(CorSigCompressByte(CodeStr(k).Length1),1)
							End If
						End If
					Next k
				End If
			End If
			If .CodeLoc = 0 Then
				If x = -1 Or x = 0 Then
					Temp = ByteToString(GetBytes(FN,.FristCodePos,Data.lStartAddress - .FristCodePos,Mode),CP_ISOLATIN1)
				Else
					Temp = ByteToString(GetBytes(FN,.FristCodePos,Data.lStartAddress + x - .FristCodePos,Mode),CP_ISOLATIN1)
					Temp1 = ByteToString(GetBytes(FN,.FristCodePos,Data.lStartAddress - .FristCodePos,Mode),CP_ISOLATIN1)
				End If
			End If
		End If
		'不需要检查时跳过
		If s + e + CodeStr(0).Length1 = 0 And x = -1 Then GoTo NextNo
		'初始化正则表达式
		RegExp.Global = IIf(.CodeLoc < 2,True,False)
    	RegExp.IgnoreCase = False
    	'检查字串或每一个引用地址
		For j = 0 To Max
			ReDim PosList(7) As Long
			'跳过已被识别的引用地址，确定字串标识符的所在位置
			If .CodeLoc > 0 Then
				If Data.Reference(j).StrType > 0 Then GoTo NextPos
			End If
			If .FristCodePos > 0 Then
				If .CodeLoc = 1 Then
					Temp = ByteToString(GetBytes(FN,.FristCodePos,Data.Reference(j).lAddress - .FristCodePos,Mode),CP_ISOLATIN1)
				ElseIf .CodeLoc = 2 Then
					Temp = ByteToString(GetBytes(FN,.FristCodePos,Data.Reference(j).lAddress + 4,Mode),CP_ISOLATIN1)
				End If
				'检查代码页值和字串长度值
				For y = 0 To IIf(.CodeLoc > 0 Or CodeStr(0).Length1 > 0,1,0)
					If .CodeLoc > 0 Or CodeStr(0).Length1 > 0 Then
						For n = 0 To IIf(.CodeLoc = 0,0,4)
							If CodeStr(n).Length1 > 0 Then
								CodeStr(n).ByteOrder = -y
								CodeStr(n).Pattern = Byte2RegExpPattern(Val2Bytes(CodeStr(n).Length1,CodeStr(n).Size,CodeStr(n).ByteOrder),1)
							End If
						Next n
					End If
					k = 0: PosList(7) = 0
					PatternList = .RegExpPattern
					For n = 0 To IIf(.CPCodePos < 0 Or .LengthCodePos < 0,1,0)
						PatternList(0) = StrListJoin(PatternList,"")
						If .LengthCodePos <> 0 Then
							If .CPCodePos <> 0 Then
								PatternList(1) = PatternList(0)
								PatternList(0) = Replace$(PatternList(0),"{CPCode}",CodeStr(0).Pattern)
							Else
								PatternList(0) = Replace$(PatternList(0),"{CPCode}","")
								PatternList(1) = PatternList(0)
							End If
							'计算代码页值和字串长度值位置
							PosList(0) = InStr(PatternList(1),"{CPCode}")
							PosList(1) = InStr(PatternList(1),"{LengthCode}")
							k = IIf(.CodeLoc = 0,10,5)
							Do
								k = IIf(.LengthMode = 0,k - 1,.LengthMode)
								If CodeStr(k).Length1 > 0 Then
									RegExp.Pattern = Replace$(PatternList(0),"{LengthCode}",CodeStr(k).Pattern)
									For t = 0 To IIf(x = -1 Or x = 0,0,1)
										If t = 0 Then
											Set Matches = RegExp.Execute(Temp)
										Else
											Set Matches = RegExp.Execute(Temp1)
										End If
										If Matches.Count > 0 Then
											'If Data.lStartAddress = 1560768Then
											'	MsgBox Byte2Hex(StringToByte(Temp,CP_ISOLATIN1),0,-1) & "+++" & RegExp.Pattern & "+++" & Matches.Count
											'End If
											If .CodeLoc < 2 Then
												If GetStrTypeAddress(TypeList(i),Matches(Matches.Count - 1),PosList) = True Then
													PosList(7) = Matches.Count
													Exit Do
												End If
											Else
												If GetStrTypeAddress(TypeList(i),Matches(0),PosList) = True Then
													PosList(7) = Matches.Count
													Exit Do
												End If
											End If
										End If
									Next t
								End If
							Loop Until k < 2 Or .LengthMode > 0
							If PosList(7) > 0 Then Exit For
						ElseIf .CPCodePos <> 0 Then
							PatternList(0) = Replace$(PatternList(0),"{LengthCode}","")
							PatternList(1) = PatternList(0)
							'计算代码页值和字串长度值位置
							PosList(0) = InStr(PatternList(1),"{CPCode}")
							PosList(1) = InStr(PatternList(1),"{LengthCode}")
							RegExp.Pattern = Replace$(PatternList(0),"{CPCode}",CodeStr(0).Pattern)
							For t = 0 To IIf(x = -1 Or x = 0,0,1)
								If t = 0 Then
									Set Matches = RegExp.Execute(Temp)
								Else
									Set Matches = RegExp.Execute(Temp1)
								End If
								If Matches.Count > 0 Then
									If .CodeLoc < 2 Then
										If GetStrTypeAddress(TypeList(i),Matches(Matches.Count - 1),PosList) = True Then
											PosList(7) = Matches.Count
											Exit For
										End If
									Else
										If GetStrTypeAddress(TypeList(i),Matches(0),PosList) = True Then
											PosList(7) = Matches.Count
											Exit For
										End If
									End If
								End If
							Next t
							Exit For
						Else
							Exit For
						End If
						'调换代码页和长度之间的位置
						PatternList = .RegExpPattern
						PatternList(0) = .RegExpPattern(2)
						PatternList(2) = .RegExpPattern(0)
					Next n
					If PosList(7) > 0 Then Exit For
					If .CodeLoc = 0 Then
						If CodeStr(0).Size = 1 Then Exit For
					End If
				Next y
				If PosList(7) < 1 Then GoTo NextPos
			End If
 			'返回检测结果
			If s + e + PosList(2) + PosList(3) > 0 Then
				If fType >= 0 Then
					GetCustomStrTypeRegExp = i + 5
					If .CodeLoc = 0 Then
						If fType = 0 Or fType = 2 Then strData = Data
						If .LengthCodePos <> 0 And PosList(3) > 0 And x <> -1 And x <> 0 Then
							Select Case t
							Case 0
								strData.lStartAddress = strData.lStartAddress + x
								strData.lHexLength = strData.lHexLength - x
							Case 1
								strData.lEndAddress = strData.lEndAddress - x
								strData.lHexLength = strData.lHexLength - x
							Case Else
								Exit Function
							End Select
							strData.sString = ByteToString(GetBytes(FN,strData.lHexLength,strData.lStartAddress,Mode),strData.CodePage)
							strData.lCharLength = Len(strData.sString)
						End If
					End If
					Exit Function
				ElseIf PosList(2) + PosList(3) > 0 Then
					strData.Reference(j).StrType = i + 5
					If GetCustomStrTypeRegExp = 0 Then GetCustomStrTypeRegExp = i + 5
				End If
			End If
			NextPos:
		Next j
		NextNo:
		End With
	Next i
End Function


'获取自定义字串类型的长度(正则表达式)
'跟随引用地址的字串类型因为不移位而不需要获取
'不通过缩短字串长度检查是否符合长度标识符要求
Private Function GetCustomStrTypeLengthRegExp(FN As Variant,strData As STRING_PROPERTIE,StrType As STRING_TYPE,ByVal Mode As Long) As Long
	Dim k As Long,x As Long,s As Long,e As Long,n As Integer,y As Integer
	Dim CodeBytes() As Byte,CodeStr(9) As STRING_TYPE_LENGTH
	Dim Temp As String,Matches As Object,PatternList() As String
	On Error GoTo localError
	With StrType
		'跳过不需要检测的字串类型
		If .CodeLoc > 0 Then Exit Function
		If .FristCodePos = 0 Then Exit Function
		If .LengthMode > 0 And .LengthMode < 5 Then
			GetCustomStrTypeLengthRegExp = .FristCodePos
			Exit Function
		End If
		If CheckArray(.RegExpPattern) = False Then Exit Function
		CodeBytes = GetBytes(FN,.FristCodePos,strData.Source.lStartAddress - .FristCodePos,Mode)
		'检查字串开始标识符是否符合
		If .StartCodePos <> 0 Then
			If .StartCodeLength > 0 Then
				k = IIf(.StartCodePos >= .StartCodeLength,.StartCodePos,.StartCodeLength)
				s = InByteRevRegExp(CodeBytes,.StartCodeByte,.FristCodePos - k,.FristCodePos - k + .StartCodeLength - 1)
				If s < 1 Then Exit Function
				If .StartCodePos > 0 Then s = .FristCodePos - .StartCodePos + 1
			Else
				If .StartCodePos < 0 Then Exit Function
				If .StartCodePos > .FristCodePos Then Exit Function
				If CodeBytes(.FristCodePos - .StartCodePos) = 0 Then Exit Function
				s = .FristCodePos - .StartCodePos + 1
			End If
		End If
		'检查字串结束标识符是否符合
		If .EndCodeLength > 0 Then
			If .EndCodeString = "00" Then
				'k = IIf(CheckStrRegExp(strData.Source.sString,"[\x01-\x7F]",0,1) = True,0,1)
				'e = IIf(GetByte(FN,strData.Source.lEndAddress + .EndCodeLength,Mode) = k,1,0)
				e = IIf(GetByte(FN,strData.Source.lEndAddress + .EndCodeLength,Mode) < 2,1,0)
				If e < 1 Then Exit Function
			Else
				e = IIf(GetBytes(FN,.EndCodeLength,strData.Source.lEndAddress + 1,Mode) = .EndCodeByte,1,0)
				If e < 1 Then Exit Function
			End If
		End If
		'检查代码页的长度是否超过字串类型所定义的长度
		If .CPCodePos <> 0 Then
			If .CPCodeSize = 0 Then
				CodeStr(0).Size = GetEvenPos(Len(Hex$(strData.Source.CodePage))) \ 2
			Else
				If GetEvenPos(Len(Hex$(strData.Source.CodePage))) > .CPCodeSize * 2 Then Exit Function
				CodeStr(0).Size = .CPCodeSize
			End If
			CodeStr(0).Length1 = strData.Source.CodePage
		End If
		'检查字串的长度是否超过字串类型所定义的长度
		If .LengthCodePos <> 0 Then
			x = GetCustomStrTypeValue(CodeStr,FN,strData.Source,StrType,Mode,1,strData.LengthModeID) + 1
			If x = 0 Then Exit Function
			For k = 1 To 9
				If CodeStr(k).Length1 > 0 Then
					If k < 5 Then
						CodeStr(k).Pattern = Byte2RegExpPattern(Val2Bytes(CodeStr(k).Length1,CodeStr(k).Size,CodeStr(k).ByteOrder),1)
					ElseIf k = 7 Or k = 8 Then
						CodeStr(k).Pattern = Byte2RegExpPattern(CorSigCompressByte(CodeStr(k).Length1),1)
						CodeStr(k).Pattern = CodeStr(k).Pattern & Byte2RegExpPattern(CorSigCompressByte(CodeStr(k).Length2),1)
					Else
						CodeStr(k).Pattern = Byte2RegExpPattern(CorSigCompressByte(CodeStr(k).Length1),1)
					End If
				End If
			Next k
		End If
		'不需要检查时跳过
		If s + e + CodeStr(0).Length1 + x = 0 Then Exit Function
		'检查代码页和长度值
		k = 0
		If .FristCodePos > 0 Then
			'初始化正则表达式
			RegExp.Global = True
			RegExp.IgnoreCase = False
			Temp = ByteToString(CodeBytes,CP_ISOLATIN1)
			'检查代码页值和字串长度值
			For y = 0 To IIf(CodeStr(0).Length1 > 0,1,0)
				If CodeStr(0).Length1 > 0 Then
					CodeStr(0).ByteOrder = -y
					CodeStr(0).Pattern = Byte2RegExpPattern(Val2Bytes(CodeStr(0).Length1,CodeStr(0).Size,CodeStr(0).ByteOrder),1)
				End If
				k = 0: ReDim PosList(7) As Long
				PatternList = .RegExpPattern
				For n = 0 To IIf(.CPCodePos < 0 Or .LengthCodePos < 0,1,0)
					PatternList(0) = StrListJoin(PatternList,"")
					If .LengthCodePos <> 0 Then
						If .CPCodePos <> 0 Then
							PatternList(1) = PatternList(0)
							PatternList(0) = Replace$(PatternList(0),"{CPCode}",CodeStr(0).Pattern)
						Else
							PatternList(0) = Replace$(PatternList(0),"{CPCode}","")
							PatternList(1) = PatternList(0)
						End If
						'计算代码页值和字串长度值位置
						PosList(0) = InStr(PatternList(1),"{CPCode}")
						PosList(1) = InStr(PatternList(1),"{LengthCode}")
						k = IIf(.CodeLoc = 0,10,5)
						Do
							k = IIf(strData.LengthModeID > 0,strData.LengthModeID,IIf(.LengthMode = 0,k - 1,.LengthMode))
							If CodeStr(k).Length1 > 0 Then
								RegExp.Pattern = Replace$(PatternList(0),"{LengthCode}",CodeStr(k).Pattern)
								Set Matches = RegExp.Execute(Temp)
								If Matches.Count > 0 Then
									If .CodeLoc < 2 Then
										If GetStrTypeAddress(StrType,Matches(Matches.Count - 1),PosList) = True Then
											If strData.LengthModeID = 0 Then strData.LengthModeID = k
											PosList(7) = Matches.Count
											Exit For
										End If
									Else
										If GetStrTypeAddress(StrType,Matches(0),PosList) = True Then
											If strData.LengthModeID = 0 Then strData.LengthModeID = k
											PosList(7) = Matches.Count
											Exit For
										End If
									End If
								End If
							End If
						Loop Until k < 2 Or .LengthMode > 0 Or strData.LengthModeID > 0
					ElseIf .CPCodePos <> 0 Then
						PatternList(0) = Replace$(PatternList(0),"{LengthCode}","")
						PatternList(1) = PatternList(0)
						'计算代码页值和字串长度值位置
						PosList(0) = InStr(PatternList(1),"{CPCode}")
						PosList(1) = InStr(PatternList(1),"{LengthCode}")
						RegExp.Pattern = Replace$(PatternList(0),"{CPCode}",CodeStr(0).Pattern)
						Set Matches = RegExp.Execute(Temp)
						If Matches.Count > 0 Then
							If .CodeLoc < 2 Then
								If GetStrTypeAddress(StrType,Matches(Matches.Count - 1),PosList) = True Then
									PosList(7) = Matches.Count
								End If
							Else
								If GetStrTypeAddress(StrType,Matches(0),PosList) = True Then
									PosList(7) = Matches.Count
								End If
							End If
						End If
						Exit For
					Else
						Exit For
					End If
					'调换代码页和长度之间的位置
					PatternList = .RegExpPattern
					PatternList(0) = .RegExpPattern(2)
					PatternList(2) = .RegExpPattern(0)
				Next n
				If PosList(7) > 0 Then Exit For
				If CodeStr(0).Size = 1 Then Exit For
			Next y
			If PosList(7) < 1 Then Exit Function
		End If
		If k < 5 Then
			GetCustomStrTypeLengthRegExp = .FristCodePos
		Else
			k = 1
			For n = 2 To 3
				If PosList(n) > 0 Then
					If k = 1 Then
						k = PosList(n)
					ElseIf PosList(n) < k Then
						k = PosList(n)
					End If
				End If
			Next n
			GetCustomStrTypeLengthRegExp = .FristCodePos - k + 1
		End If
	End With
	localError:
End Function


'定位代码页值和字串长度值的所在位置
'LocList(0) = 检测代码页值，LocList(1) = 检测长度值
'LocList(2) = 代码页值位置，LocList(3) = 字串长度值的位置，LocList(4) = 结束标记的位置
Private Function GetStrTypeAddress(StrType As STRING_TYPE,Match As Object,LocList() As Long) As Boolean
	Dim i As Integer
	LocList(2) = 0: LocList(3) = 0: LocList(4) = 0
	If LocList(0) = 0 And LocList(1) = 0 Then Exit Function
	i = Match.FirstIndex + 1
	With StrType
	If LocList(0) > 0 And LocList(1) = 0 Then
		If .CodeLoc = 0 Then
			LocList(2) = i
			If .StartCodePos > 0 Then
				LocList(4) = LocList(2) + Len(Match.SubMatches(0) & Match.SubMatches(1))
			End If
		ElseIf .CodeLoc > 0 Then
			If .CPCodeStartLength = 0 Then
				LocList(2) = i
				If .RefCodeStartPos > 0 Then
					LocList(4) = LocList(2) + Len(Match.SubMatches(0) & Match.SubMatches(1))
				End If
			Else
				LocList(2) = i + Len(Match.SubMatches(0))
				If .RefCodeStartPos > 0 Then
					LocList(4) = LocList(2) + Len(Match.SubMatches(1) & Match.SubMatches(2))
				End If
			End If
		End If
		If .CPCodePos > 0 Then
			If .CodeLoc < 2 Then
				If LocList(2) <> .FristCodePos - .CPCodePos + 1 Then Exit Function
			Else
				If LocList(2) <> .CPCodePos Then Exit Function
			End If
		End If
		If .StartCodePos > 0 Then
			If LocList(4) <> .FristCodePos - .StartCodePos + 1 Then Exit Function
		ElseIf .RefCodeStartPos > 0 Then
			If .CodeLoc < 2 Then
				If LocList(3) <> .FristCodePos - .RefCodeStartPos + 1 Then Exit Function
			Else
				If LocList(4) <> .RefCodeStartPos Then Exit Function
			End If
		End If
	ElseIf LocList(0) = 0 And LocList(1) > 0 Then
		If .CodeLoc = 0 Then
			LocList(3) = i
			If .StartCodePos > 0 Then
				LocList(4) = LocList(3) + Len(Match.SubMatches(0) & Match.SubMatches(1))
			End If
		ElseIf .CodeLoc > 0 Then
			If .LengthCodeStartLength = 0 Then
				LocList(3) = i
				If .RefCodeStartPos > 0 Then
					LocList(4) = LocList(3) + Len(Match.SubMatches(0) & Match.SubMatches(1))
				End If
			Else
				LocList(3) = i + Len(Match.SubMatches(0))
				If .RefCodeStartPos > 0 Then
					LocList(4) = LocList(3) + Len(Match.SubMatches(1) & Match.SubMatches(2))
				End If
			End If
		End If
		If .LengthCodePos > 0 Then
			If .CodeLoc < 2 Then
				If LocList(3) <> .FristCodePos - .LengthCodePos + 1 Then Exit Function
			Else
				If LocList(3) <> .LengthCodePos Then Exit Function
			End If
		End If
		If .StartCodePos > 0 Then
			If LocList(4) <> .FristCodePos - .StartCodePos + 1 Then Exit Function
		ElseIf .RefCodeStartPos > 0 Then
			If .CodeLoc < 2 Then
				If LocList(4) <> .FristCodePos - .RefCodeStartPos + 1 Then Exit Function
			Else
				If LocList(4) <> .RefCodeStartPos Then Exit Function
			End If
		End If
	ElseIf LocList(0) < LocList(1) Then
		If .CodeLoc = 0 Then
			LocList(2) = i
		ElseIf .CodeLoc > 0 Then
			If .CPCodeStartLength = 0 Then
				LocList(2) = i
			Else
				LocList(2) = i + Len(Match.SubMatches(0))
			End If
		End If
		If .CPCodePos > 0 Then
			If .CodeLoc < 2 Then
				If LocList(2) <> .FristCodePos - .CPCodePos + 1 Then Exit Function
			Else
				If LocList(2) <> .CPCodePos Then Exit Function
			End If
		End If
		If .CodeLoc = 0 Then
			LocList(3) = LocList(2) + Len(Match.SubMatches(0) & Match.SubMatches(1))
			If .StartCodePos > 0 Then
				LocList(4) = LocList(3) + Len(Match.SubMatches(2))
			End If
		ElseIf .CodeLoc > 0 Then
			If .LengthCodeStartLength = 0 Then
				If .CPCodeStartLength = 0 Then
					LocList(3) = LocList(2) + Len(Match.SubMatches(0) & Match.SubMatches(1))
					If .RefCodeStartPos > 0 Then
						LocList(4) = LocList(3) + Len(Match.SubMatches(2))
					End If
				Else
					LocList(3) = LocList(2) + Len(Match.SubMatches(1) & Match.SubMatches(2))
					If .RefCodeStartPos > 0 Then
						LocList(4) = LocList(3) + Len(Match.SubMatches(3))
					End If
				End If
			Else
				If .CPCodeStartLength = 0 Then
					LocList(3) = LocList(2) + Len(Match.SubMatches(0) & Match.SubMatches(1) & Match.SubMatches(2))
					If .RefCodeStartPos > 0 Then
						LocList(4) = LocList(3) + Len(Match.SubMatches(3))
					End If
				Else
					LocList(3) = LocList(2) + Len(Match.SubMatches(1) & Match.SubMatches(2) & Match.SubMatches(3))
					If .RefCodeStartPos > 0 Then
						LocList(4) = LocList(3) + Len(Match.SubMatches(4))
					End If
				End If
			End If
		End If
		If .LengthCodePos > 0 Then
			If .CodeLoc < 2 Then
				If LocList(3) <> .FristCodePos - .LengthCodePos + 1 Then Exit Function
			Else
				If LocList(3) <> .LengthCodePos Then Exit Function
			End If
		End If
		If .StartCodePos > 0 Then
			If LocList(4) <> .FristCodePos - .StartCodePos + 1 Then Exit Function
		ElseIf .RefCodeStartPos > 0 Then
			If .CodeLoc < 2 Then
				If LocList(4) <> .FristCodePos - .RefCodeStartPos + 1 Then Exit Function
			Else
				If LocList(4) <> .RefCodeStartPos Then Exit Function
			End If
		End If
	Else
		If .CodeLoc = 0 Then
			LocList(3) = i
		ElseIf .CodeLoc > 0 Then
			If .LengthCodeStartLength = 0 Then
				LocList(3) = i
			Else
				LocList(3) = i + Len(Match.SubMatches(0))
			End If
		End If
		If .LengthCodePos > 0 Then
			If .CodeLoc < 2 Then
				If LocList(3) <> .FristCodePos - .LengthCodePos + 1 Then Exit Function
			Else
				If LocList(3) <> .LengthCodePos Then Exit Function
			End If
		End If
		If .CodeLoc = 0 Then
			LocList(2) = LocList(3) + Len(Match.SubMatches(0) & Match.SubMatches(1))
			If .StartCodePos > 0 Then
				LocList(4) = LocList(2) + Len(Match.SubMatches(2))
			End If
		ElseIf .CodeLoc > 0 Then
			If .CPCodeStartLength = 0 Then
				If .LengthCodeStartLength = 0 Then
					LocList(2) = LocList(3) + Len(Match.SubMatches(0) & Match.SubMatches(1))
					If .RefCodeStartPos > 0 Then
						LocList(4) = LocList(2) + Len(Match.SubMatches(2))
					End If
				Else
					LocList(2) = LocList(3) + Len(Match.SubMatches(1) & Match.SubMatches(2))
					If .RefCodeStartPos > 0 Then
						LocList(4) = LocList(2) + Len(Match.SubMatches(3))
					End If
				End If
			Else
				If .LengthCodeStartLength = 0 Then
					LocList(2) = LocList(3) + Len(Match.SubMatches(0) & Match.SubMatches(1) & Match.SubMatches(2))
					If .RefCodeStartPos > 0 Then
						LocList(4) = LocList(2) + Len(Match.SubMatches(3))
					End If
				Else
					LocList(2) = LocList(3) + Len(Match.SubMatches(1) & Match.SubMatches(2) & Match.SubMatches(3))
					If .RefCodeStartPos > 0 Then
						LocList(4) = LocList(2) + Len(Match.SubMatches(4))
					End If
				End If
			End If
		End If
		If .CPCodePos > 0 Then
			If .CodeLoc < 2 Then
				If LocList(2) <> .FristCodePos - .CPCodePos + 1 Then Exit Function
			Else
				If LocList(2) <> .CPCodePos Then Exit Function
			End If
		End If
		If .StartCodePos > 0 Then
			If LocList(4) <> .FristCodePos - .StartCodePos + 1 Then Exit Function
		ElseIf .RefCodeStartPos > 0 Then
			If .CodeLoc < 2 Then
				If LocList(4) <> .FristCodePos - .RefCodeStartPos + 1 Then Exit Function
			Else
				If LocList(4) <> .RefCodeStartPos Then Exit Function
			End If
		End If
	End If
	End With
	GetStrTypeAddress = True
End Function


'转换自定义字串类型模板
Private Sub StrType2RegExpPattern(TypeList() As STRING_TYPE,Optional ByVal TypeID As Long = -1)
	If CheckStrTypeArray(TypeList) = False Then Exit Sub
	Dim i As Long,Max As Long,Temp As String
	If TypeID < 0 Or TypeID > UBound(TypeList) Then
		TypeID = LBound(TypeList): Max = UBound(TypeList)
	Else
		Max = TypeID
	End If
	For i = TypeID To Max
		ReDim TypeList(i).RegExpPattern(4) 'As String
		With TypeList(i)
		If .CPCodePos <> 0 Then
			If .CPCodeStartLength > 0 Then
				.RegExpPattern(0) = "(" & HexStr2RegExpPattern(.CPCodeStartString,1) & "[\x00-\xFF]*?)({CPCode})"
			Else
				.RegExpPattern(0) = "({CPCode})"
			End If
		End If
		If .CPCodePos <> 0 And .LengthCodePos <> 0 Then
			.RegExpPattern(1) = "([\x00-\xFF]*?)"
		End If
		If .LengthCodePos <> 0 Then
			If .LengthCodeStartLength > 0 Then
				.RegExpPattern(2) = "(" & HexStr2RegExpPattern(.LengthCodeStartString,1) & "[\x00-\xFF]*?)({LengthCode})"
			Else
				.RegExpPattern(2) = "({LengthCode})"
			End If
		End If
		If .CPCodePos > 0 And .LengthCodePos > 0 Then
			If .CodeLoc < 2 Then
				If .LengthCodePos > .CPCodePos Then
					Temp = .RegExpPattern(0)
					.RegExpPattern(0) = .RegExpPattern(2)
					.RegExpPattern(2) = Temp
				End If
			Else
				If .CPCodePos > .LengthCodePos Then
					Temp = .RegExpPattern(0)
					.RegExpPattern(0) = .RegExpPattern(2)
					.RegExpPattern(2) = Temp
				End If
			End If
		End If
		If .StartCodePos <> 0 Then
			.RegExpPattern(3) = "([\x00-\xFF]*?)"
			If .StartCodePos > 0 Then
				.RegExpPattern(4) = "(" & HexStr2RegExpPattern(.StartCodeString,1) & "[\x00-\xFF]{" & Abs(.StartCodePos - .StartCodeLength) & "})"
			ElseIf .StartCodeLength > 0 Then
				.RegExpPattern(4) = "(" & HexStr2RegExpPattern(.StartCodeString,1) & ")"
			End If
		ElseIf .RefCodeStartPos <> 0 Then
			If .CPCodeStartLength > 0 Or .LengthCodeStartLength > 0 Then
				.RegExpPattern(3) = "([^" & HexStr2RegExpPattern(.CPCodeStartString,1) & HexStr2RegExpPattern(.LengthCodeStartString,1) & "]*?)"
			Else
				.RegExpPattern(3) = "([\x00-\xFF]*?)"
			End If
			If .RefCodeStartPos > 0 Then
				If .CodeLoc < 2 Then
					.RegExpPattern(4) = "(" & HexStr2RegExpPattern(.RefCodeStartString,1) & _
										"[\x00-\xFF]{" & Abs(.RefCodeStartPos - .RefCodeStartLength) & "})"
				Else
					.RegExpPattern(4) = "(" & HexStr2RegExpPattern(.RefCodeStartString,1) & _
										"[\x00-\xFF]{" & Abs(.FristCodePos - .RefCodeStartPos + 1 - .RefCodeStartLength) & "})"
				End If
			ElseIf .RefCodeStartLength > 0 Then
				.RegExpPattern(4) = "(" & HexStr2RegExpPattern(.RefCodeStartString,1) & ")"
			End If
		End If
		End With
	Next i
End Sub


'获取自定义字串类型的长度标识符的检查值
'fType >= 0 检查跟随字串的类型, 0,2 通过缩短字串长度检查是否符合长度标识符要求, 1,>2 不通过缩短字串长度检查是否符合长度标识符要求
'fType < 0 检查跟随引用地址的类型，不通过缩短字串长度检查是否符合长度标识符要求
Private Function GetCustomStrTypeValue(CodeStr() As STRING_TYPE_LENGTH,FN As Variant,Data As STRING_SUB_PROPERTIE,StrType As STRING_TYPE, _
		ByVal Mode As Long,ByVal fType As Long,Optional ByVal LengthModeID As Integer,Optional ByVal MoveVal As Long) As Long
	Dim i As Long,j As Long,k As Long,x As Long,y As Long,m As Long,n As Long,t As Long
	Dim Stemp As Boolean,TempByte() As Byte
	GetCustomStrTypeValue = -1
	With StrType
		k = IIf(.CodeLoc = 0,10,5)
		Do
			k = IIf(LengthModeID > 0,LengthModeID,IIf(.LengthMode = 0,k - 1,.LengthMode))
			Select Case k
			Case 1   '字串字节数 (按字符数检测)
				x = Data.lHexLength - .ByteLengthReviseVal
				If .CodeLoc = 0 Then
					If .LengthCodeSize = 0 Then
						j = GetEvenPos(Len(Hex$(x))) \ 2
					ElseIf GetEvenPos(Len(Hex$(x))) <= .LengthCodeSize * 2 Then
						j = .LengthCodeSize
					Else
						j = 0
					End If
					If j > 0 Then
						i = IIf(.LengthCodePos > 0,.LengthCodePos,.FristCodePos)
						If fType = 0 Or fType = 2 Then
							CodeStr(k).Bytes = GetBytes(FN,j + i + 1,Data.lStartAddress + MoveVal - i,Mode)
							m = 0
							For n = 0 To j + 1
								For t = 0 To 1
									For y = 0 To IIf(j = 1,0,-1) Step -1
										If InByteRegExp(CodeStr(k).Bytes,Val2Bytes(x - m,j,y),0,i + m - 1) > 0 Then
											CodeStr(k).Length1 = x - m: CodeStr(k).Size = j: CodeStr(k).ByteOrder = y
											GetCustomStrTypeValue = m
											Exit Do
										End If
									Next y
									If t = 0 Then
										m = StrHexLength(Mid$(Data.sString,1,n + 1),Data.CodePage,0)
									ElseIf n < Data.lCharLength And n < j Then
										m = StrHexLength(Mid$(Data.sString,Data.lCharLength - n,n + 1),Data.CodePage,0)
									Else
										Exit For
									End If
								Next t
							Next n
						Else
							CodeStr(k).Bytes = GetBytes(FN,i,Data.lStartAddress + MoveVal - i,Mode)
							For y = 0 To IIf(j = 1,0,-1) Step -1
								If InByteRegExp(CodeStr(k).Bytes,Val2Bytes(x,j,y),0,i - 1) > 0 Then
									CodeStr(k).Length1 = x: CodeStr(k).Size = j: CodeStr(k).ByteOrder = y
									GetCustomStrTypeValue = 0
									Exit Do
								End If
							Next y
						End If
					End If
				Else
					If .LengthCodeSize = 0 Then
						CodeStr(k).Length1 = x: CodeStr(k).Size = GetEvenPos(Len(Hex$(x))) \ 2: GetCustomStrTypeValue = 0
					ElseIf GetEvenPos(Len(Hex$(x))) <= .LengthCodeSize * 2 Then
						CodeStr(k).Length1 = x: CodeStr(k).Size = .LengthCodeSize: GetCustomStrTypeValue = 0
					End If
				End If
			Case 2   '字串字符数 (按字符数检测)
				x = Data.lCharLength - .ByteLengthReviseVal
				If .CodeLoc = 0 Then
					If .LengthCodeSize = 0 Then
						j = GetEvenPos(Len(Hex$(x))) \ 2
					ElseIf GetEvenPos(Len(Hex$(x))) <= .LengthCodeSize * 2 Then
						j = .LengthCodeSize
					Else
						j = 0
					End If
					If j > 0 Then
						i = IIf(.LengthCodePos > 0,.LengthCodePos,.FristCodePos)
						If fType = 0 Or fType = 2 Then
							CodeStr(k).Bytes = GetBytes(FN,j + i + 1,Data.lStartAddress + MoveVal - i,Mode)
							m = 0
							For n = 0 To j + 1
								For t = 0 To 1
									For y = 0 To IIf(j = 1,0,-1) Step -1
										If InByteRegExp(CodeStr(k).Bytes,Val2Bytes(x - n,j,y),0,i + m - 1) > 0 Then
											CodeStr(k).Length1 = x - n: CodeStr(k).Size = j: CodeStr(k).ByteOrder = y
											GetCustomStrTypeValue = m
											Exit Do
										End If
									Next y
									If t = 0 Then
										m = StrHexLength(Mid$(Data.sString,1,n + 1),Data.CodePage,0)
									ElseIf n < Data.lCharLength And n < j Then
										m = StrHexLength(Mid$(Data.sString,Data.lCharLength - n,n + 1),Data.CodePage,0)
									Else
										Exit For
									End If
								Next t
							Next n
						Else
							CodeStr(k).Bytes = GetBytes(FN,i,Data.lStartAddress + MoveVal - i,Mode)
							For y = 0 To IIf(j = 1,0,-1) Step -1
								If InByteRegExp(CodeStr(k).Bytes,Val2Bytes(x,j,y),0,i - 1) > 0 Then
									CodeStr(k).Length1 = x: CodeStr(k).Size = j: CodeStr(k).ByteOrder = y
									GetCustomStrTypeValue = 0
									Exit Do
								End If
							Next y
						End If
					End If
				Else
					If .LengthCodeSize = 0 Then
						CodeStr(k).Length1 = x: CodeStr(k).Size = GetEvenPos(Len(Hex$(x))) \ 2: GetCustomStrTypeValue = 0
					ElseIf GetEvenPos(Len(Hex$(x))) <= .LengthCodeSize * 2 Then
						CodeStr(k).Length1 = x: CodeStr(k).Size = .LengthCodeSize: GetCustomStrTypeValue = 0
					End If
				End If
			Case 3   '代码页 (按字符数检测)
				If Data.CodePage = CP_UNICODELITTLE Or Data.CodePage = CP_UNICODEBIG Or _
					Data.CodePage = CP_UTF32LE Or Data.CodePage = CP_UTF32BE Then
					x = Data.lCharLength - .CharLengthReviseVal
					Stemp = True
				Else
					x = Data.lHexLength - .ByteLengthReviseVal
					Stemp = False
				End If
				If .CodeLoc = 0 Then
					If .LengthCodeSize = 0 Then
						j = GetEvenPos(Len(Hex$(x))) \ 2
					ElseIf GetEvenPos(Len(Hex$(x))) <= .LengthCodeSize * 2 Then
						j = .LengthCodeSize
					Else
						j = 0
					End If
					If j > 0 Then
						i = IIf(.LengthCodePos > 0,.LengthCodePos,.FristCodePos)
						If fType = 0 Or fType = 2 Then
							CodeStr(k).Bytes = GetBytes(FN,j + i + 1,Data.lStartAddress + MoveVal - i,Mode)
							m = 0
							If Stemp = False Then
								For n = 0 To j + 1
									For t = 0 To 1
										For y = 0 To IIf(j = 1,0,-1) Step -1
											If InByteRegExp(CodeStr(k).Bytes,Val2Bytes(x - m,j,y),0,i + m - 1) > 0 Then
												CodeStr(k).Length1 = x - m: CodeStr(k).Size = j: CodeStr(k).ByteOrder = y
												GetCustomStrTypeValue = m
												Exit Do
											End If
										Next y
										If t = 0 Then
											m = StrHexLength(Mid$(Data.sString,1,n + 1),Data.CodePage,0)
										ElseIf n < Data.lCharLength And n < j Then
											m = StrHexLength(Mid$(Data.sString,Data.lCharLength - n,n + 1),Data.CodePage,0)
										Else
											Exit For
										End If
									Next t
								Next n
							Else
								For n = 0 To j + 1
									For t = 0 To 1
										For y = 0 To IIf(j = 1,0,-1) Step -1
											If InByteRegExp(CodeStr(k).Bytes,Val2Bytes(x - n,j,y),0,i + m - 1) > 0 Then
												CodeStr(k).Length1 = x - n: CodeStr(k).Size = j: CodeStr(k).ByteOrder = y
												GetCustomStrTypeValue = m
												Exit Do
											End If
										Next y
										If t = 0 Then
											m = StrHexLength(Mid$(Data.sString,1,n + 1),Data.CodePage,0)
										ElseIf n < Data.lCharLength And n < j Then
											m = StrHexLength(Mid$(Data.sString,Data.lCharLength - n,n + 1),Data.CodePage,0)
										Else
											Exit For
										End If
									Next t
								Next n
							End If
						Else
							CodeStr(k).Bytes = GetBytes(FN,i,Data.lStartAddress + MoveVal - i,Mode)
							For y = 0 To IIf(j = 1,0,-1) Step -1
								If InByteRegExp(CodeStr(k).Bytes,Val2Bytes(x,j,y),0,i - 1) > 0 Then
									CodeStr(k).Length1 = x: CodeStr(k).Size = j: CodeStr(k).ByteOrder = y
									GetCustomStrTypeValue = 0
									Exit Do
								End If
							Next y
						End If
					End If
				Else
					If .LengthCodeSize = 0 Then
						CodeStr(k).Length1 = x: CodeStr(k).Size = GetEvenPos(Len(Hex$(x))) \ 2: GetCustomStrTypeValue = 0
					ElseIf GetEvenPos(Len(Hex$(x))) <= .LengthCodeSize * 2 Then
						CodeStr(k).Length1 = x: CodeStr(k).Size = .LengthCodeSize: GetCustomStrTypeValue = 0
					End If
				End If
			Case 4   '字串字节数 + 字符数 (按字符数检测)
				x = Data.lHexLength + Data.lCharLength - .ByteLengthReviseVal - .CharLengthReviseVal
				If .CodeLoc = 0 Then
					If .LengthCodeSize = 0 Then
						j = GetEvenPos(Len(Hex$(x))) \ 2
					ElseIf GetEvenPos(Len(Hex$(x))) <= .LengthCodeSize * 2 Then
						j = .LengthCodeSize
					Else
						j = 0
					End If
					If j > 0 Then
						i = IIf(.LengthCodePos > 0,.LengthCodePos,.FristCodePos)
						If fType = 0 Or fType = 2 Then
							CodeStr(k).Bytes = GetBytes(FN,j + i + 1,Data.lStartAddress + MoveVal - i,Mode)
							m = 0
							For n = 0 To j + 1
								For t = 0 To 1
									For y = 0 To IIf(j = 1,0,-1) Step -1
										If InByteRegExp(CodeStr(k).Bytes,Val2Bytes(x - n - m,j,y),0,i + m - 1) > 0 Then
											CodeStr(k).Length1 = x - n - m: CodeStr(k).Size = j: CodeStr(k).ByteOrder = y
											GetCustomStrTypeValue = m
											Exit Do
										End If
									Next y
									If t = 0 Then
										m = StrHexLength(Mid$(Data.sString,1,n + 1),Data.CodePage,0)
									ElseIf n < Data.lCharLength And n < j Then
										m = StrHexLength(Mid$(Data.sString,Data.lCharLength - n,n + 1),Data.CodePage,0)
									Else
										Exit For
									End If
								Next t
							Next n
						Else
							CodeStr(k).Bytes = GetBytes(FN,i,Data.lStartAddress + MoveVal - i,Mode)
							For y = 0 To IIf(j = 1,0,-1) Step -1
								If InByteRegExp(CodeStr(k).Bytes,Val2Bytes(x,j,y),0,i - 1) > 0 Then
									CodeStr(k).Length1 = x: CodeStr(k).Size = j: CodeStr(k).ByteOrder = y
									GetCustomStrTypeValue = 0
									Exit Do
								End If
							Next y
						End If
					End If
				Else
					If .LengthCodeSize = 0 Then
						CodeStr(k).Length1 = x: CodeStr(k).Size = GetEvenPos(Len(Hex$(x))) \ 2: GetCustomStrTypeValue = 0
					ElseIf GetEvenPos(Len(Hex$(x))) <= .LengthCodeSize * 2 Then
						CodeStr(k).Length1 = x: CodeStr(k).Size = .LengthCodeSize: GetCustomStrTypeValue = 0
					End If
				End If
			Case 5   '压缩字串字节数
				If .CodeLoc = 0 Then
					j = CorSigCompressLength(Data.lHexLength - .ByteLengthReviseVal)
					i = Data.lStartAddress + MoveVal
					If fType = 0 Or fType = 2 Then
						For n = 0 To j
							CodeStr(k).Size = CorSigUncompressData(FN,i - j + n,x,Mode)
							If x = Data.lHexLength - .ByteLengthReviseVal - n Then
								If .LengthCodeSize = 0 Then
									CodeStr(k).Length1 = x: GetCustomStrTypeValue = n
									Exit Do
								ElseIf CodeStr(k).Size = .LengthCodeSize Then
									CodeStr(k).Length1 = x: GetCustomStrTypeValue = n
									Exit Do
								End If
							End If
						Next n
					Else
						CodeStr(k).Size = CorSigUncompressData(FN,i - j,x,Mode)
						If x = Data.lHexLength - .ByteLengthReviseVal Then
							If .LengthCodeSize = 0 Then
								CodeStr(k).Length1 = x: GetCustomStrTypeValue = 0
								Exit Do
							ElseIf CodeStr(k).Size = .LengthCodeSize Then
								CodeStr(k).Length1 = x: GetCustomStrTypeValue = 0
								Exit Do
							End If
						End If
					End If
				Else
					x = Data.lHexLength - .ByteLengthReviseVal
					If .LengthCodeSize = 0 Then
						CodeStr(k).Length1 = x: CodeStr(k).Size = GetEvenPos(Len(Hex$(x))) \ 2: GetCustomStrTypeValue = 0
					ElseIf GetEvenPos(Len(Hex$(x))) <= .LengthCodeSize * 2 Then
						CodeStr(k).Length1 = x: CodeStr(k).Size = .LengthCodeSize: GetCustomStrTypeValue = 0
					End If
				End If
			Case 6   '压缩字串字符数
				If .CodeLoc = 0 Then
					j = CorSigCompressLength(Data.lCharLength - .CharLengthReviseVal)
					i = Data.lStartAddress + MoveVal
					If fType = 0 Or fType = 2 Then
						For n = 0 To j
							CodeStr(k).Size = CorSigUncompressData(FN,i - j + n,x,Mode)
							If x = Len(ByteToString(GetBytes(FN,Data.lHexLength - n,i + n,Mode),Data.CodePage)) - .CharLengthReviseVal Then
								If .LengthCodeSize = 0 Then
									CodeStr(k).Length1 = x: GetCustomStrTypeValue = n
									Exit Do
								ElseIf CodeStr(k).Size = .LengthCodeSize Then
									CodeStr(k).Length1 = x: GetCustomStrTypeValue = n
									Exit Do
								End If
							End If
						Next n
					Else
						CodeStr(k).Size = CorSigUncompressData(FN,i - j,x,Mode)
						If x = Data.lCharLength - .CharLengthReviseVal Then
							If .LengthCodeSize = 0 Then
								CodeStr(k).Length1 = x: GetCustomStrTypeValue = 0
								Exit Do
							ElseIf CodeStr(k).Size = .LengthCodeSize Then
								CodeStr(k).Length1 = x: GetCustomStrTypeValue = 0
								Exit Do
							End If
						End If
					End If
				Else
					x = Data.lCharLength - .CharLengthReviseVal
					If .LengthCodeSize = 0 Then
						CodeStr(k).Length1 = x: CodeStr(k).Size = GetEvenPos(Len(Hex$(x))) \ 2: GetCustomStrTypeValue = 0
					ElseIf GetEvenPos(Len(Hex$(x))) <= .LengthCodeSize * 2 Then
						CodeStr(k).Length1 = x: CodeStr(k).Size = .LengthCodeSize: GetCustomStrTypeValue = 0
					End If
				End If
			Case 7   '压缩字串字节数 & 字符数
				If .CodeLoc = 0 Then
					j = CorSigCompressLength(Data.lHexLength - .ByteLengthReviseVal) + _
						CorSigCompressLength(Data.lCharLength - .CharLengthReviseVal)
					i = Data.lStartAddress + MoveVal
					If fType = 0 Or fType = 2 Then
						For n = 0 To j
							CodeStr(k).Size = CorSigUncompressData(FN,i - j + n,x,Mode)
							If x = Data.lHexLength - .ByteLengthReviseVal - n Then
								CodeStr(k).Size = CodeStr(k).Size + CorSigUncompressData(FN,i - j + n + CodeStr(k).Size,y,Mode)
								If y = Len(ByteToString(GetBytes(FN,Data.lHexLength - n,i + n,Mode),Data.CodePage)) - .CharLengthReviseVal Then
									If .LengthCodeSize = 0 Then
										CodeStr(k).Length1 = x: CodeStr(k).Length2 = y: GetCustomStrTypeValue = n
										Exit Do
									ElseIf CodeStr(k).Size = .LengthCodeSize Then
										CodeStr(k).Length1 = x: CodeStr(k).Length2 = y: GetCustomStrTypeValue = n
										Exit Do
									End If
								End If
							End If
						Next n
					Else
						CodeStr(k).Size = CorSigUncompressData(FN,i - j,x,Mode)
						If x = Data.lHexLength - .ByteLengthReviseVal Then
							CodeStr(k).Size = CodeStr(k).Size + CorSigUncompressData(FN,i - CodeStr(k).Size,y,Mode)
							If y = Data.lCharLength - .CharLengthReviseVal Then
								If .LengthCodeSize = 0 Then
									CodeStr(k).Length1 = x: CodeStr(k).Length2 = y: GetCustomStrTypeValue = 0
									Exit Do
								ElseIf CodeStr(k).Size = .LengthCodeSize Then
									CodeStr(k).Length1 = x: CodeStr(k).Length2 = y: GetCustomStrTypeValue = 0
									Exit Do
								End If
							End If
						End If
					End If
				Else
					x = Data.lHexLength - .ByteLengthReviseVal
					y = Data.lCharLength - .CharLengthReviseVal
					If .LengthCodeSize = 0 Then
						CodeStr(k).Length1 = x: CodeStr(k).Length2 = y: CodeStr(k).Size = GetEvenPos(Len(Hex$(x + y))) \ 2: GetCustomStrTypeValue = 0
					ElseIf GetEvenPos(Len(Hex$(x + y))) <= .LengthCodeSize * 2 Then
						CodeStr(k).Length1 = x: CodeStr(k).Length2 = y: CodeStr(k).Size = .LengthCodeSize: GetCustomStrTypeValue = 0
					End If
				End If
			Case 8   '压缩字串字符数 & 字节数
				If .CodeLoc = 0 Then
					j = CorSigCompressLength(Data.lHexLength - .ByteLengthReviseVal) + _
						CorSigCompressLength(Data.lCharLength - .CharLengthReviseVal)
					i = Data.lStartAddress + MoveVal
					If fType = 0 Or fType = 2 Then
						For n = 0 To j
							CodeStr(k).Size = CorSigUncompressData(FN,i - j + n,x,Mode)
							If x = Len(ByteToString(GetBytes(FN,Data.lHexLength - n,i + n,Mode),Data.CodePage)) - .CharLengthReviseVal Then
								CodeStr(k).Size = CodeStr(k).Size + CorSigUncompressData(FN,i - j + n + CodeStr(k).Size,y,Mode)
								If y = Data.lHexLength - .ByteLengthReviseVal - n Then
									If .LengthCodeSize = 0 Then
										CodeStr(k).Length1 = x: CodeStr(k).Length2 = y: GetCustomStrTypeValue = n
										Exit Do
									ElseIf CodeStr(k).Size = .LengthCodeSize Then
										CodeStr(k).Length1 = x: CodeStr(k).Length2 = y: GetCustomStrTypeValue = n
										Exit Do
									End If
								End If
							End If
						Next n
					Else
						CodeStr(k).Size = CorSigUncompressData(FN,i - j,x,Mode)
						If x = Data.lCharLength - .CharLengthReviseVal Then
							CodeStr(k).Size = CodeStr(k).Size + CorSigUncompressData(FN,i - CodeStr(k).Size,y,Mode)
							If y = Data.lHexLength - .ByteLengthReviseVal Then
								If .LengthCodeSize = 0 Then
									CodeStr(k).Length1 = x: CodeStr(k).Length2 = y: GetCustomStrTypeValue = 0
									Exit Do
								ElseIf CodeStr(k).Size = .LengthCodeSize Then
									CodeStr(k).Length1 = x: CodeStr(k).Length2 = y: GetCustomStrTypeValue = 0
									Exit Do
								End If
							End If
						End If
					End If
				Else
					x = Data.lCharLength - .CharLengthReviseVal
					y = Data.lHexLength - .ByteLengthReviseVal
					If .LengthCodeSize = 0 Then
						CodeStr(k).Length1 = x: CodeStr(k).Length2 = y: CodeStr(k).Size = GetEvenPos(Len(Hex$(x + y))) \ 2: GetCustomStrTypeValue = 0
					ElseIf GetEvenPos(Len(Hex$(x + y))) <= .LengthCodeSize * 2 Then
						CodeStr(k).Length1 = x: CodeStr(k).Length2 = y: CodeStr(k).Size = .LengthCodeSize: GetCustomStrTypeValue = 0
					End If
				End If
			Case 9   '压缩字串字节数 + 字符数
				If .CodeLoc = 0 Then
					j = CorSigCompressLength(Data.lHexLength + Data.lCharLength - .ByteLengthReviseVal - .CharLengthReviseVal)
					i = Data.lStartAddress + MoveVal
					If fType = 0 Or fType = 2 Then
						For n = 0 To j
							CodeStr(k).Size = CorSigUncompressData(FN,i - j + n,x,Mode)
							If x = Len(ByteToString(GetBytes(FN,Data.lHexLength - n,i + n,Mode),Data.CodePage)) + _
									Data.lHexLength - .ByteLengthReviseVal - .CharLengthReviseVal - n Then
								If .LengthCodeSize = 0 Then
									CodeStr(k).Length1 = x: GetCustomStrTypeValue = n
									Exit Do
								ElseIf CodeStr(k).Size = .LengthCodeSize Then
									CodeStr(k).Length1 = x: GetCustomStrTypeValue = n
									Exit Do
								End If
							End If
							i = i + 1
						Next n
					Else
						CodeStr(k).Size = CorSigUncompressData(FN,i - j,x,Mode)
						If x = Data.lHexLength + Data.lCharLength - .ByteLengthReviseVal - .CharLengthReviseVal Then
							If .LengthCodeSize = 0 Then
								CodeStr(k).Length1 = x: GetCustomStrTypeValue = 0
								Exit Do
							ElseIf CodeStr(k).Size = .LengthCodeSize Then
								CodeStr(k).Length1 = x: GetCustomStrTypeValue = 0
								Exit Do
							End If
						End If
					End If
				Else
					x = Data.lHexLength + Data.lCharLength - .ByteLengthReviseVal - .CharLengthReviseVal
					If .LengthCodeSize = 0 Then
						CodeStr(k).Length1 = x: CodeStr(k).Size = GetEvenPos(Len(Hex$(x))) \ 2: GetCustomStrTypeValue = 0
					ElseIf GetEvenPos(Len(Hex$(x))) <= .LengthCodeSize * 2 Then
						CodeStr(k).Length1 = x: CodeStr(k).Size = .LengthCodeSize: GetCustomStrTypeValue = 0
					End If
				End If
			End Select
		Loop Until k < 2 Or .LengthMode > 0 Or LengthModeID > 0
	End With
End Function


'提取字串的公共函数
'StrType = 0 需要检测，否则已经检测
Private Function CheckString(File As FILE_PROPERTIE,FN As FILE_IMAGE,strData As STRING_SUB_PROPERTIE,StrType As Integer, _
		ByVal TagType As Integer,ByVal FeatureCode As String,ByVal MaxSize As Long,LogList() As String,ByVal FormatText As String, _
		LogMax As Long,LogNo As Long,ByVal Mode As Long,ByVal ShowMsg As Long,ByVal EndChar As String) As Long
	With strData
		.lCharLength = Len(.sString)
		'检测提取的字串是否确实为英文
		'If .CodePage <> CP_WESTEUROPE And .CodePage <> CP_UNICODELITTLE And .CodePage <> CP_UNICODEBIG And _
		'	.CodePage <> CP_UTF32LE And .CodePage <> CP_UTF32BE Then
		'	If ExtractSet(41) = "0" Then
		'		If CheckStrRegExp(.sString,"[\x01-\x7F]",0,1) = True Then
		'			.CodePage = CP_WESTEUROPE
		'		End If
		'	End If
		'End If
		'检测是否为 Delphi 或自定义类型字符串
		If StrType = 0 Then	'不等于 0 时，已检测不用检测
			If InStr(ExtractSet(5) & ExtractSet(6) & ExtractSet(7) & ExtractSet(8) & ExtractSet(10) & ExtractSet(41),"1") Then
				StrType = GetStrType(File,FN,strData,UseStrTypeList,ExtractSet,Mode,0)
				'获取 Android 字串时，过滤不是 Android 字串类型的字串
				'If StrType > -1 And ExtractSet(41) = "1" Then Exit Function
			End If
		End If
		'过滤字串
		If StrFilter(strData,StrType,ExtractSet,FeatureCode,TagType) = True Then
			''获取字串的引用列表
			''If .inSectionID < File.MaxSecIndex then
			''	If ExtractSet(11) = "1" Or (StrType = 0 And TagType > 1) Then
			''		Call getVARefList(File,FN,strData,0,0,"",0,Mode,0)
					'获取引用地址前的自定义类型
			''		If StrType = 0 And TagType = 2 Then
			''			StrType = GetCustomStrTypeRegExp(FN,strData,UseStrTypeList,Mode,-1)
			''		End If
			''	End If
			''End If
			'获取字串的最大位置
			'.lMaxAddress = getNotNullByte(FN,.lEndAddress + EndByteLength(StrType,UseStrTypeList) + 1,MaxSize,Mode) - 1
			'.lMaxAddress = getNotNullByte(FN,.lMaxAddress + 1,MaxSize,Mode) - 1
			'.lMaxAddress = getNotNullByteRegExp(FN,.lMaxAddress + 1,MaxSize,Mode) - 1
			.lMaxAddress = getEndByteRegExp(FN,.lMaxAddress + 1,MaxSize,Mode,EndChar,CP_ISOLATIN1,True) - 1
			CheckString = .lMaxAddress
			'过滤无引用的字串
			''If ExtractSet(11) = "0" Or .lReferenceNum <> 0 Then
				'避开 Delphi 窗体代码
				If File.LangType = DELPHI_FILE_SIGNATURE And .lMaxAddress + 6 < MaxSize Then
					If GetLong(FN,.lMaxAddress + 1,Mode) = &HFFFFFFFF Then
						If .lMaxAddress - 4 > .lEndAddress Then .lMaxAddress = .lMaxAddress - 4
					End If
				End If
			''Else
			''	CheckString = -CheckString
			''End If
		Else
			'获取字串的最大位置
			'.lMaxAddress = getNotNullByte(FN,.lEndAddress + EndByteLength(StrType,UseStrTypeList) + 1,MaxSize,Mode) - 1
			'.lMaxAddress = getNotNullByte(FN,.lMaxAddress + 1,MaxSize,Mode) - 1
			'.lMaxAddress = getNotNullByteRegExp(FN,.lMaxAddress + 1,MaxSize,Mode) - 1
			.lMaxAddress = getEndByteRegExp(FN,.lMaxAddress + 1,MaxSize,Mode,EndChar,CP_ISOLATIN1,True) - 1
			CheckString = -.lMaxAddress
			'仅记录被过滤的字串
			If ExtractSet(51) = "1" Then
				LogNo = LogNo + 1
				If LogNo >= LogMax Then
					LogMax = LogMax * 2
					ReDim Preserve LogList(LogMax) As String
				End If
				If Selected(16) = "1" Then
					LogList(LogNo) = ValToStr(.lStartAddress,File.FileSize,True) & "-" & ValToStr(.lEndAddress,File.FileSize,True) & _
							vbTab & CStr$(.CodePage) & vbTab & CStr$(StrType) & vbTab & ReConvert(.sString) & vbCrLf
				Else
					LogList(LogNo) = Format$(.lStartAddress,FormatText) & "-" & Format$(.lEndAddress,FormatText) & _
							vbTab & CStr$(.CodePage) & vbTab & CStr$(StrType) & vbTab & ReConvert(.sString) & vbCrLf
				End If
			End If
		End If
		'输出或记录提取消息
		If ExtractSet(25) = "1" Then
			If ShowMsg > 0 Then
				If Selected(16) = "1" Then
					SetTextBoxString ShowMsg,ValToStr(.lStartAddress,File.FileSize,True) & "-" & ValToStr(.lEndAddress,File.FileSize,True) & _
							"-" & CStr$(.CodePage) & "-" & CStr$(StrType) & "-" & ReConvert(.sString),True
				Else
					SetTextBoxString ShowMsg,Format$(.lStartAddress,FormatText) & "-" & Format$(.lEndAddress,FormatText) & _
							"-" & CStr$(.CodePage) & "-" & CStr$(StrType) & "-" & ReConvert(.sString),True
				End If
			ElseIf ShowMsg < 0 Then
				If Selected(16) = "1" Then
					PSL.Output ValToStr(.lStartAddress,File.FileSize,True) & "-" & ValToStr(.lEndAddress,File.FileSize,True) & _
							"-" & CStr$(.CodePage) & "-" & CStr$(StrType) & "-" & ReConvert(.sString)
				Else
					PSL.Output Format$(.lStartAddress,FormatText) & "-" & Format$(.lEndAddress,FormatText) & _
							"-" & CStr$(.CodePage) & "-" & CStr$(StrType) & "-" & ReConvert(.sString)
				End If
			End If
		ElseIf ExtractSet(26) = "1" Then
			LogNo = LogNo + 1
			If LogNo >= LogMax Then
				LogMax = LogMax * 2
				ReDim Preserve LogList(LogMax) As String
			End If
			If Selected(16) = "1" Then
				LogList(LogNo) = ValToStr(.lStartAddress,File.FileSize,True) & "-" & ValToStr(.lEndAddress,File.FileSize,True) & _
						vbTab & CStr$(.CodePage) & vbTab & CStr$(StrType) & vbTab & ReConvert(.sString) & vbCrLf
			Else
				LogList(LogNo) = Format$(.lStartAddress,FormatText) & "-" & Format$(.lEndAddress,FormatText) & _
						vbTab & CStr$(.CodePage) & vbTab & CStr$(StrType) & vbTab & ReConvert(.sString) & vbCrLf
			End If
		End If
	End With
End Function


'添加字串数据到数据库
Private Function AddToDataList(File As FILE_PROPERTIE,DataList() As STRING_PROPERTIE,DataDic As Object, _
		strData As STRING_SUB_PROPERTIE,ByVal StrType As Integer,IndexMax As Long,Index As Long) As Boolean
	Dim i As Long
	'初始化字串字典
	If Index = -1 Then DataDic.RemoveAll
	'检查字串是否已存在
	With strData
		If DataDic.Exists(.lStartAddress) Then
			i = DataDic.Item(.lStartAddress)
			If .lEndAddress <= DataList(i).Source.lEndAddress Then Exit Function
		Else
			Index = Index + 1
			If Index >= IndexMax Then
				IndexMax = IndexMax * 2
				ReDim Preserve DataList(IndexMax) As STRING_PROPERTIE
			End If
			i = Index
			DataDic.Add(.lStartAddress,i)
		End If
	End With
	'添加字串数据
	With DataList(i)
		.ID = strData.lStartAddress
		.StrType = StrType
		.TagType = TagType(.StrType,UseStrTypeList)
		.EndByteLength = EndByteLength(.StrType,UseStrTypeList)
		.ScapeIDBeMoved = -1
		.ScapeIDForMove = -1
		.Moveable = Moveable(File,DataList(i))
		.Source = strData
		'.Source.inSubSecID = SkipSubSection(File.SecList(.Source.inSectionID),.Source.lStartAddress,0,0)
		.Source.sString = ReConvert(strData.sString)
		'.Source.CodePage = strData.CodePage
		'.Source.lStartAddress = strData.lStartAddress
		'.Source.lEndAddress = strData.lEndAddress
		'.Source.lMaxAddress = strData.lMaxAddress
		'.Source.lHexLength = strData.lEndAddress - strData.lStartAddress + 1
		.Source.iNullByteLength = NullByteLength(DataList(i),False)
		.Source.lMaxHexLength = strData.lMaxAddress - strData.lStartAddress + 1 - .EndByteLength - .Source.iNullByteLength
		'.Source.lCharLength = Len(strData.sString)

		'.Source.Reference = strData.Reference
		'.Source.inSectionID = strData.inSectionID
		.Trans = .Source
		ReDim Preserve DataList(i).Trans.Reference(0) 'As REFERENCE_PROPERTIE
		.Trans.GetRefState = 0
		.Trans.lReferenceNum = 0
		Call StrTypeLength(DataList(i),UseStrTypeList)
	End With
	AddToDataList = True
End Function


'创建默认代码页数组 (代码页名称、代码值、Unicode 编码范围)

'874 （ANSI/OEM - 泰文）
'932 （ANSI/OEM - 日文 Shift-JIS）
'936 （ANSI/OEM - 简体中文 GBK）
'949 （ANSI/OEM - 韩文）
'950 （ANSI/OEM - 繁体中文 Big5）
'1250 （ANSI - 中欧）
'1251 （ANSI - 西里尔文）
'1252 （ANSI - 拉丁文 I）
'1253 （ANSI - 希腊文）
'1254 （ANSI - 土耳其文）
'1255 （ANSI - 希伯来文）
'1256 （ANSI - 阿拉伯文）
'1257 （ANSI - 波罗的海文）
'1258 （ANSI/OEM - 越南）

'1258 越南语
'1257 波罗的语
'1256 阿拉伯语
'1255 希伯来语
'1254 土耳其语
'1253 希腊语
'1252 拉丁 1 字符 (ANSI)
'1251 西里尔语
'1250 中欧语言
'950 繁体中文
'949 朝鲜语
'936 简体中文
'932 日语
'874 泰国语
'850 多语种 (MS-DOS Latin1)
'437 MS-DOS 美国英语

'注：中文范围 4E00-9FBF：CJK 统一表意符号 (CJK Unified Ideographs)
'0000-007F：C0控制符及基本拉丁文 (C0 Control And Basic Latin)
'0080-00FF：C1控制符及拉丁文补充-1 (C1 Control And Latin 1 Supplement)
'0100-017F：拉丁文扩展-A (Latin Extended-A)
'0180-024F：拉丁文扩展-B (Latin Extended-B)
'0250-02AF：国际音标扩展 (IPA Extensions)
'02B0-02FF：空白修饰字母 (Spacing Modifiers)
'0300-036F：结合用读音符号 (Combining Diacritics Marks)
'0370-03FF：希腊文及科普特文 (Greek And Coptic)
'0400-04FF：西里尔字母 (Cyrillic)
'0500-052F：西里尔字母补充 (Cyrillic Supplement)
'0530-058F：亚美尼亚语 (Armenian)
'0590-05FF：希伯来文 (Hebrew)
'0600-06FF：阿拉伯文 (Arabic)
'0700-074F：叙利亚文 (Syriac)
'0750-077F：阿拉伯文补充 (Arabic Supplement)
'0780-07BF：马尔代夫语 (Thaana)
'07C0-077F：西非书面语言 (N'Ko)
'0800-085F：阿维斯塔语及巴列维语 (Avestan And Pahlavi)
'0860-087F：Mandaic
'0880-08AF：撒马利亚语 (Samaritan)
'0900-097F：天城文书 (Devanagari)
'0980-09FF：孟加拉语 (Bengali)
'0A00-0A7F：锡克教文 (Gurmukhi)
'0A80-0AFF：古吉拉特文 (Gujarati)
'0B00-0B7F：奥里亚文 (Oriya)
'0B80-0BFF：泰米尔文 (Tamil)
'0C00-0C7F：泰卢固文 (Telugu)
'0C80-0CFF：卡纳达文 (Kannada)
'0D00-0D7F：德拉维族语 (Malayalam)
'0D80-0DFF：僧伽罗语 (Sinhala)
'0E00-0E7F：泰文 (Thai)
'0E80-0EFF：老挝文 (Lao)
'0F00-0FFF：藏文 (Tibetan)
'1000-109F：缅甸语 (Myanmar)
'10A0-10FF：格鲁吉亚语 (Georgian)
'1100-11FF：朝鲜文 (Hangul Jamo)
'1200-137F：埃塞俄比亚语 (Ethiopic)
'1380-139F：埃塞俄比亚语补充 (Ethiopic Supplement)
'13A0-13FF：切罗基语 (Cherokee)
'1400-167F：统一加拿大土著语音节 (Unified Canadian Aboriginal Syllabics)
'1680-169F：欧甘字母 (Ogham)
'16A0-16FF：如尼文 (Runic)
'1700-171F：塔加拉语 (Tagalog)
'1720-173F：Hanunóo
'1740-175F：Buhid
'1760-177F：Tagbanwa
'1780-17FF：高棉语 (Khmer)
'1800-18AF：蒙古文 (Mongolian)
'18B0-18FF：Cham
'1900-194F：Limbu
'1950-197F：德宏泰语 (Tai Le)
'1980-19DF：新傣仂语 (New Tai Lue)
'19E0-19FF：高棉语记号 (Kmer Symbols)
'1A00-1A1F：Buginese
'1A20-1A5F：Batak
'1A80-1AEF：Lanna
'1B00-1B7F：巴厘语 (Balinese)
'1B80-1BB0：巽他语 (Sundanese)
'1BC0-1BFF：Pahawh Hmong
'1C00-1C4F：雷布查语(Lepcha)
'1C50-1C7F：Ol Chiki
'1C80-1CDF：曼尼普尔语 (Meithei/Manipuri)
'1D00-1D7F：语音学扩展 (Phonetic Extensions)
'1D80-1DBF：语音学扩展补充 (Phonetic Extensions Supplement)
'1DC0-1DFF：结合用读音符号补充 (Combining Diacritics Marks Supplement)
'1E00-1EFF：拉丁文扩充附加 (Latin Extended Additional)
'1F00-1FFF：希腊语扩充 (Greek Extended)
'2000-206F：常用标点 (General Punctuation)
'2070-209F：上标及下标 (Superscripts And Subscripts)
'20A0-20CF：货币符号 (Currency Symbols)
'20D0-20FF：组合用记号 (Combining Diacritics Marks For Symbols)
'2100-214F：字母式符号 (Letterlike Symbols)
'2150-218F：数字形式 (Number Form)
'2190-21FF：箭头 (Arrows)
'2200-22FF：数学运算符 (Mathematical Operator)
'2300-23FF：杂项工业符号 (Miscellaneous Technical)
'2400-243F：控制图片 (Control Pictures)
'2440-245F：光学识别符 (Optical Character Recognition)
'2460-24FF：封闭式字母数字 (Enclosed Alphanumerics)
'2500-257F：制表符 (Box Drawing)
'2580-259F：方块元素 (Block Element)
'25A0-25FF：几何图形 (Geometric Shapes)
'2600-26FF：杂项符号 (Miscellaneous Symbols)
'2700-27BF：印刷符号 (Dingbats)
'27C0-27EF：杂项数学符号-A (Miscellaneous Mathematical Symbols-A)
'27F0-27FF：追加箭头-A (Supplemental Arrows-A)
'2800-28FF：盲文点字模型 (Braille Patterns)
'2900-297F：追加箭头-B (Supplemental Arrows-B)
'2980-29FF：杂项数学符号-B (Miscellaneous Mathematical Symbols-B)
'2A00-2AFF：追加数学运算符 (Supplemental Mathematical Operator)
'2B00-2BFF：杂项符号和箭头 (Miscellaneous Symbols And Arrows)
'2C00-2C5F：格拉哥里字母 (Glagolitic)
'2C60-2C7F：拉丁文扩展-C (Latin Extended-C)
'2C80-2CFF：古埃及语 (Coptic)
'2D00-2D2F：格鲁吉亚语补充 (Georgian Supplement)
'2D30-2D7F：提非纳文 (Tifinagh)
'2D80-2DDF：埃塞俄比亚语扩展 (Ethiopic Extended)
'2E00-2E7F：追加标点 (Supplemental Punctuation)
'2E80-2EFF：CJK 部首补充 (CJK Radicals Supplement)
'2F00-2FDF：康熙字典部首 (Kangxi Radicals)
'2FF0-2FFF：表意文字描述符 (Ideographic Description Characters)
'3000-303F：CJK 符号和标点 (CJK Symbols And Punctuation)
'3040-309F：日文平假名 (Hiragana)
'30A0-30FF：日文片假名 (Katakana)
'3100-312F：注音字母 (Bopomofo)
'3130-318F：朝鲜文兼容字母 (Hangul Compatibility Jamo)
'3190-319F：象形字注释标志 (Kanbun)
'31A0-31BF：注音字母扩展 (Bopomofo Extended)
'31C0-31EF：CJK 笔画 (CJK Strokes)
'31F0-31FF：日文片假名语音扩展 (Katakana Phonetic Extensions)
'3200-32FF：封闭式 CJK 文字和月份 (Enclosed CJK Letters And Months)
'3300-33FF：CJK 兼容 (CJK Compatibility)
'3400-4DBF：CJK 统一表意符号扩展 A (CJK Unified Ideographs Extension A)
'4DC0-4DFF：易经六十四卦符号 (Yijing Hexagrams Symbols)
'4E00-9FBF：CJK 统一表意符号 (CJK Unified Ideographs)
'A000-A48F：彝文音节 (Yi Syllables)
'A490-A4CF：彝文字根 (Yi Radicals)
'A500-A61F：Vai
'A660-A6FF：统一加拿大土著语音节补充 (Unified Canadian Aboriginal Syllabics Supplement)
'A700-A71F：声调修饰字母 (Modifier Tone Letters)
'A720-A7FF：拉丁文扩展-D (Latin Extended-D)
'A800-A82F：Syloti Nagri
'A840-A87F：八思巴字 (Phags-pa)
'A880-A8DF：Saurashtra
'A900-A97F：爪哇语 (Javanese)
'A980-A9DF：Chakma
'AA00-AA3F：Varang Kshiti
'AA40-AA6F：Sorang Sompeng
'AA80-AADF：Newari
'AB00-AB5F：越南傣语 (Vietnam Thai)
'AB80-ABA0：Kayah Li
'AC00-D7AF：朝鲜文音节 (Hangul Syllables)
'D800-DBFF：High-half zone of UTF-16
'DC00-DFFF：Low-half zone of UTF-16
'E000-F8FF：自行使用区域 (Private Use Zone)
'F900-FAFF：CJK 兼容象形文字 (CJK Compatibility Ideographs)
'FB00-FB4F：字母表达形式 (Alphabetic Presentation Form)
'FB50-FDFF：阿拉伯表达形式A (Arabic Presentation Form-A)
'FE00-FE0F：变量选择符 (Variation Selector)
'FE10-FE1F：竖排形式 (Vertical Forms)
'FE20-FE2F：组合用半符号 (Combining Half Marks)
'FE30-FE4F：CJK 兼容形式中文直排符 (CJK Compatibility Forms)
'FE50-FE6F：小型变体形式 (Small Form Variants)
'FE70-FEFF：阿拉伯表达形式B (Arabic Presentation Form-B)
'FF00-FFEF：半型及全型形式 (Halfwidth And Fullwidth Form)
'FFF0-FFFF：特殊 (Specials)

'FA30-FA6A 是槿毡JIS X 0213:2000 却ae字符法c法有少S差的h字而O;
'FA70-FAD9 是楸表n却ae字符法c法有少S差的h字而O

Private Function GetWinCPList(ByVal MinNum As Long,ByVal MaxNum As Long) As LANG_PROPERTIE()
	Dim i As Long,MsgList() As String
	Dim CodePage(20) As Long,UniRange(20) As String,FeatureCode(20) As String
	If getMsgList(UIDataList,MsgList,"GetUniCodePageList",1) = False Then Exit Function

	CodePage(0) = CP_UNKNOWN		'未知 (自动监测) = -1
	CodePage(1) = CP_WESTEUROPE		'拉丁文 1 (ANSI) = 1252
	CodePage(2) = CP_EASTEUROPE	    '拉丁文 2 (中欧) = 1250
	CodePage(3) = CP_RUSSIAN		'西里尔文 (斯拉夫) = 1251
	CodePage(4) = CP_GREEK			'希腊文 = 1253
	CodePage(5) = CP_TURKISH		'拉丁文 5 (土耳其) = 1254
	CodePage(6) = CP_HEBREW			'希伯来文 = 1255
	CodePage(7) = CP_ARABIC			'阿拉伯文 = 1256
	CodePage(8) = CP_BALTIC			'波罗的海文 = 1257
	CodePage(9) = CP_VIETNAMESE		'越南文 = 1258
	CodePage(10) = CP_JAPAN			'日文 = 932
	CodePage(11) = CP_CHINA			'简体中文 = 936
	CodePage(12) = CP_KOREA			'韩文 = 949
	CodePage(13) = CP_TAIWAN 		'繁体中文 = 950
	CodePage(14) = CP_THAI 			'泰文 = 874
	CodePage(15) = CP_UTF7			'UTF-7 = 65000
	CodePage(16) = CP_UTF8			'UTF-8 = 65001
	CodePage(17) = CP_UNICODELITTLE	'Unicode = 1200
	CodePage(18) = CP_UNICODEBIG	'Unicode = 1201
	CodePage(19) = CP_UTF32LE		'UnicodeLE = 65005
	CodePage(20) = CP_UTF32BE		'UnicodeBE = 65006

	UniRange(1) = "0009-000A,000D,0020-007E,0080,00A9,00AE"
	UniRange(2) = "0009-000A,000D,0020-007E,0080,00A9,00AE,00C0-02AF,1E00-1EFF"
	UniRange(3) = "0009-000A,000D,0020-007E,0080,00A9,00AE,0400-052F"
	UniRange(4) = "0009-000A,000D,0020-007E,0080,00A9,00AE,0370-03FF,1F00-1FFF,2C80-2CFF"
	UniRange(5) = "0009-000A,000D,0020-007E,0080,00A9,00AE,00C0-02AF,1E00-1EFF"
	UniRange(6) = "0009-000A,000D,0020-007E,0080,00A9,00AE,0590-05FF"
	UniRange(7) = "0009-000A,000D,0020-007E,0080,00A9,00AE,0600-06FF,0750-077F"
	UniRange(8) = "0009-000A,000D,0020-007E,0080,00A9,00AE"
	UniRange(9) = "0009-000A,000D,0020-007E,0080,00A9,00AE,AB00-AB5F"
	UniRange(10) = "0009-000A,000D,0020-007E,0080,00A9,00AE,2000-206F,3000-303F,3040-30FF,31F0-31FF,3200-33FF,3400-4DBF,4E00-9FBF,FF00-FFEF"
	UniRange(11) = "0009-000A,000D,0020-007E,0080,00A9,00AE,2000-206F,2E80-2FDF,2E00-2E7F,3000-303F,3400-4DBF,4E00-9FA5,F900-FAFF,FE30-FE4F,FF00-FFEF"
	UniRange(12) = "0009-000A,000D,0020-007E,0080,00A9,00AE,2000-206F,1100-11FF,3130-318F,AC00-D7AF,FF00-FFEF"
	UniRange(13) = "0009-000A,000D,0020-007E,0080,00A9,00AE,2000-206F,2E80-2FDF,3000-303F,3400-4DBF,4E00-9FBF,F900-FAFF,FE30-FE4F,FF00-FFEF"
	UniRange(14) = "0009-000A,000D,0020-007E,0080,00A9,00AE,0E00-0E7F"

	FeatureCode(1) = "0020-007E"
	FeatureCode(2) = "00C0-02AF,1E00-1EFF"
	FeatureCode(3) = "0400-052F"
	FeatureCode(4) = "0370-03FF,1F00-1FFF,2C80-2CFF"
	FeatureCode(5) = "00C0-02AF,1E00-1EFF"
	FeatureCode(6) = "0590-05FF"
	FeatureCode(7) = "0600-06FF,0750-077F"
	FeatureCode(8) = ""
	FeatureCode(9) = "AB00-AB5F"
	FeatureCode(10) = "3040-30FF,31F0-31FF"
	FeatureCode(11) = "4E00-9FA5,F900-FAFF"
	FeatureCode(12) = "1100-11FF,3130-318F,AC00-D7AF"
	FeatureCode(13) = "4E00-9FA5,F900-FAFF"
	FeatureCode(14) = "0E00-0E7F"

	i = UBound(CodePage)
	If MaxNum > i Then MaxNum = i
	ReDim CPList(MaxNum - MinNum) As LANG_PROPERTIE
	For i = MinNum To MaxNum
		With CPList(i - MinNum)
			.CPName = MsgList(i)
			.CodePage = CodePage(i)
			.UniCodeRange = UniRange(i)
			.UniCodeRegExpPattern = "[\u" & Replace$(Replace$(UniRange(i),"-","-\u"),",","\u") & "]"
			.UniCodeByteRange = Convert(.UniCodeRegExpPattern)
			.FeatureCode = FeatureCode(i)
			.FeatureCodeRegExpPattern = "[\u" & Replace$(Replace$(FeatureCode(i),"-","-\u"),",","\u") & "]"
			.FeatureCodeByteRange = Convert(.FeatureCodeRegExpPattern)
		End With
	Next i
	GetWinCPList = CPList
End Function


'创建 OEM 代码页数组 (代码页名称、代码值、Unicode 编码范围)
Private Function GetOEMCPList(ByVal MinNum As Long,ByVal MaxNum As Long) As LANG_PROPERTIE()
	Dim i As Long,MsgList() As String
	Dim CodePage(20) As Long,UniRange(20) As String,FeatureCode(20) As String
	'If getMsgList(UIDataList,MsgList,"GetUniCodePageList",1) = False Then Exit Function

	CodePage(0) = CP_UNKNOWN		'未知 (自动监测) = -1
	CodePage(1) = CP_IBM437			'OEM United States
	CodePage(2) = CP_ASMO708		'Arabic (ASMO 708)
	CodePage(3) = CP_DOS720			'Arabic (Transparent ASMO); Arabic (DOS)
	CodePage(4) = CP_IBM737			'OEM Greek (formerly 437G); Greek (DOS)
	CodePage(5) = CP_IMB775			'OEM Baltic; Baltic (DOS)
	CodePage(6) = CP_IBM850			'OEM Multilingual Latin 1; Western European (DOS)
	CodePage(7) = CP_IBM852			'OEM Latin 2; Central European (DOS)
	CodePage(8) = CP_IBM855			'OEM Cyrillic (primarily Russian)
	CodePage(9) = CP_IBM857			'OEM Turkish; Turkish (DOS)
	CodePage(10) = CP_IBM00858		'OEM Multilingual Latin 1 + Euro symbol
	CodePage(11) = CP_IBM860		'OEM Portuguese; Portuguese (DOS)
	CodePage(12) = CP_IMB861		'OEM Icelandic; Icelandic (DOS)
	CodePage(13) = CP_DOS862		'OEM Hebrew; Hebrew (DOS)
	CodePage(14) = CP_IBM863		'OEM French Canadian; French Canadian (DOS)
	CodePage(15) = CP_IBM864		'OEM Arabic; Arabic (864)
	CodePage(16) = CP_IBM865		'OEM Nordic; Nordic (DOS)
	CodePage(17) = CP_CP866			'OEM Russian; Cyrillic (DOS)
	CodePage(18) = CP_IMB869		'OEM Modern Greek; Greek, Modern (DOS)
	CodePage(19) = CP_IMB870		'IBM EBCDIC Multilingual/ROECE (Latin 2); IBM EBCDIC Multilingual Latin 2
	'CodePage(20) = CP_THAI			'ANSI/OEM Thai (same as 28605, ISO 8859-15); Thai (Windows)
	CodePage(20) = CP_CP875			'IBM EBCDIC Greek Modern

	UniRange(1) = "0009-000A,000D,0020-007E,0080,0082-008C,008E,0091-009C,009E-00AC,00AE-00FE"
	UniRange(2) = "0009-000A,000D,0020-007E,0080,0082-008C,008E,0091-009C,009E-00AC,00AE-00FE"
	UniRange(3) = "0009-000A,000D,0020-007E,0080,0082-008C,008E,0091-009C,009E-00AC,00AE-00FE"
	UniRange(4) = "0009-000A,000D,0020-007E,0080,0082-008C,008E,0091-009C,009E-00AC,00AE-00FE"
	UniRange(5) = "0009-000A,000D,0020-007E,0080,0082-008C,008E,0091-009C,009E-00AC,00AE-00FE"
	UniRange(6) = "0009-000A,000D,0020-007E,0080,0082-008C,008E,0091-009C,009E-00AC,00AE-00FE"
	UniRange(7) = "0009-000A,000D,0020-007E,0080,0082-008C,008E,0091-009C,009E-00AC,00AE-00FE"
	UniRange(8) = "0009-000A,000D,0020-007E,0080,0082-008C,008E,0091-009C,009E-00AC,00AE-00FE"
	UniRange(9) = "0009-000A,000D,0020-007E,0080,0082-008C,008E,0091-009C,009E-00AC,00AE-00FE"
	UniRange(10) = "0009-000A,000D,0020-007E,0080,0082-008C,008E,0091-009C,009E-00AC,00AE-00FE"
	UniRange(11) = "0009-000A,000D,0020-007E,0080,0082-008C,008E,0091-009C,009E-00AC,00AE-00FE"
	UniRange(12) = "0009-000A,000D,0020-007E,0080,0082-008C,008E,0091-009C,009E-00AC,00AE-00FE"
	UniRange(13) = "0009-000A,000D,0020-007E,0080,0082-008C,008E,0091-009C,009E-00AC,00AE-00FE"
	UniRange(14) = "0009-000A,000D,0020-007E,0080,0082-008C,008E,0091-009C,009E-00AC,00AE-00FE"
	UniRange(15) = "0009-000A,000D,0020-007E,0080,0082-008C,008E,0091-009C,009E-00AC,00AE-00FE"
	UniRange(16) = "0009-000A,000D,0020-007E,0080,0082-008C,008E,0091-009C,009E-00AC,00AE-00FE"
	UniRange(17) = "0009-000A,000D,0020-007E,0080,0082-008C,008E,0091-009C,009E-00AC,00AE-00FE"
	UniRange(18) = "0009-000A,000D,0020-007E,0080,0082-008C,008E,0091-009C,009E-00AC,00AE-00FE"
	UniRange(19) = "0009-000A,000D,0020-007E,0080,0082-008C,008E,0091-009C,009E-00AC,00AE-00FE"
	UniRange(20) = "0009-000A,000D,0020-007E,0080,0082-008C,008E,0091-009C,009E-00AC,00AE-00FE"

	FeatureCode(1) = "0082-008C,008E,0091-009C,009E-00AC,00AE-00FE"
	FeatureCode(2) = "0082-008C,008E,0091-009C,009E-00AC,00AE-00FE"
	FeatureCode(3) = "0082-008C,008E,0091-009C,009E-00AC,00AE-00FE"
	FeatureCode(4) = "0082-008C,008E,0091-009C,009E-00AC,00AE-00FE"
	FeatureCode(5) = "0082-008C,008E,0091-009C,009E-00AC,00AE-00FE"
	FeatureCode(6) = "0082-008C,008E,0091-009C,009E-00AC,00AE-00FE"
	FeatureCode(7) = "0082-008C,008E,0091-009C,009E-00AC,00AE-00FE"
	FeatureCode(8) = "0082-008C,008E,0091-009C,009E-00AC,00AE-00FE"
	FeatureCode(9) = "0082-008C,008E,0091-009C,009E-00AC,00AE-00FE"
	FeatureCode(10) = "0082-008C,008E,0091-009C,009E-00AC,00AE-00FE"
	FeatureCode(11) = "0082-008C,008E,0091-009C,009E-00AC,00AE-00FE"
	FeatureCode(12) = "0082-008C,008E,0091-009C,009E-00AC,00AE-00FE"
	FeatureCode(13) = "0082-008C,008E,0091-009C,009E-00AC,00AE-00FE"
	FeatureCode(14) = "0082-008C,008E,0091-009C,009E-00AC,00AE-00FE"
	FeatureCode(15) = "0082-008C,008E,0091-009C,009E-00AC,00AE-00FE"
	FeatureCode(16) = "0082-008C,008E,0091-009C,009E-00AC,00AE-00FE"
	FeatureCode(17) = "0082-008C,008E,0091-009C,009E-00AC,00AE-00FE"
	FeatureCode(18) = "0082-008C,008E,0091-009C,009E-00AC,00AE-00FE"
	FeatureCode(19) = "0082-008C,008E,0091-009C,009E-00AC,00AE-00FE"
	FeatureCode(20) = "0082-008C,008E,0091-009C,009E-00AC,00AE-00FE"

	i = UBound(CodePage)
	If MaxNum > i Then MaxNum = i
	ReDim CPList(MaxNum - MinNum) As LANG_PROPERTIE
	For i = MinNum To MaxNum
		With CPList(i - MinNum)
			'.CPName = MsgList(i)
			.CodePage = CodePage(i)
			.UniCodeRange = UniRange(i)
			.UniCodeRegExpPattern = "[\u" & Replace$(Replace$(UniRange(i),"-","-\u"),",","\u") & "]"
			.UniCodeByteRange = Convert(.UniCodeRegExpPattern)
			.FeatureCode = FeatureCode(i)
			.FeatureCodeRegExpPattern = "[\u" & Replace$(Replace$(FeatureCode(i),"-","-\u"),",","\u") & "]"
			.FeatureCodeByteRange = Convert(.FeatureCodeRegExpPattern)
		End With
	Next i
	GetOEMCPList = CPList
End Function


'获取默认语言列表 (语言名称、语言ID、代码页及 Unicode 编码范围)
Private Function GetLngList(WinCPList() As LANG_PROPERTIE) As LANG_PROPERTIE()
	Dim i As Long,j As Long,k As Long,m As Long,n As Long,Result As Long,WinVersion As Integer
	Dim bteValue(255) As Byte,Dic As Object,OEMCPList() As LANG_PROPERTIE,Temp As String,Stemp As Boolean
	'WinVersion = StrToLong(GetWindowsVersion())
	Set Dic = CreateObject("Scripting.Dictionary")
	For i = 0 To UBound(WinCPList)
		If Not Dic.Exists(WinCPList(i).CodePage) Then
			Dic.Add(WinCPList(i).CodePage,i)
		End If
	Next i
	OEMCPList = GetOEMCPList(6,6)
	For i = 0 To UBound(OEMCPList)
		If Not Dic.Exists(-OEMCPList(i).CodePage) Then
			Dic.Add(-OEMCPList(i).CodePage,i)
		End If
	Next i
	ReDim TempList(0) As String
	TempList = ReSplit("0401,0402,0403,0404,0405,0406,0407,0408,0409,040a,040b,040c,040d,040e,040f," & _
			"0410,0411,0412,0413,0414,0415,0416,0417,0418,0419,041a,041b,041c,041d,041e," & _
			"041f,0420,0421,0422,0423,0424,0425,0426,0427,0428,0429,042a,042b,042c,042d," & _
			"042e,042f,0430,0431,0432,0433,0434,0435,0436,0437,0438,0439,043a,043b,043d," & _
			"043e,043f,0440,0441,0442,0443,0444,0445,0446,0447,0448,0449,044a,044b,044c," & _
			"044d,044e,044f,0450,0451,0452,0453,0454,0455,0456,0457,0458,0459,045a,045b," & _
			"045c,045d,045e,045f,0461,0462,0463,0464,0465,0466,0467,0468,0469,046a,046b," & _
			"046c,046d,046e,046f,0470,0471,0472,0473,0474,0475,0476,0477,0478,0479,047a," & _
			"047c,047e,0480,0481,0482,0483,0484,0485,0486,0487,0488,048c,0491,0492,0801," & _
			"0803,0804,0807,0809,080a,080c,0810,0813,0814,0816,0818,0819,081a,081d,0820," & _
			"082c,082e,0832,083b,083c,083e,0843,0845,0846,0849,0850,0859,085d,085f,0860," & _
			"0861,0867,086b,0873,0c01,0c04,0c07,0c09,0c0a,0c0c,0c1a,0c3b,0c50,0c51,0c6b," & _
			"1000,1001,1004,1007,1009,100a,100c,101a,103b,105f,1401,1404,1407,1409,140a," & _
			"140c,141a,143b,1801,1809,180a,180c,181a,183b,1c01,1c09,1c0a,1c0c,1c1a,1c3b," & _
			"2001,2009,200a,200c,201a,203b,2401,2409,240a,240c,241a,243b,2801,2809,280a," & _
			"280c,281a,2c01,2c09,2c0a,2c0c,2c1a,3001,3009,300a,300c,301a,3401,3409,340a," & _
			"340c,3801,3809,380a,380c,3c01,3c09,3c0a,3c0c,4001,4009,400a,4409,440a,4809," & _
			"480a,4c0a,500a,540a,580a,5c0a",",")
	m = UBound(TempList)
	ReDim LngList(m * 2 + 1) As LANG_PROPERTIE
	Do
		If n <= m Then
			Temp = TempList(n)
		Else
			If n = m + 1 Then
				'打开操作系统语言注册表键
				If RegOpenKey(HKEY_LOCAL_MACHINE,"SYSTEM\CurrentControlSet\Control\Nls\Language",Result) <> 0 Then Exit Do
			End If
			'检查系统语言列表中新增的语言
			'创建 255 个字符的缓冲区
			Temp = String$(255, 0)
			'枚举出该键下的所有值名和值
			If RegEnumValue(Result,n,Temp,255,0,1,bteValue(0),255) <> 0 Then Exit Do
			'获取空字符前的字符
			Temp = Replace$(Temp,vbNullChar,"")
		End If
		'检查值名是否合格的十六进制字符
		If CheckStrRegExp(Temp,CheckSkipStr(6),0,1,True) Then
			If Not Dic.Exists(Temp) Then
				Dic.Add(Temp,"")
				With LngList(k)
					.LangID = Val("&H" & Temp)
					'If WinVersion < 60 Then 'OS XP
						.LangName = PSL.GetLangCode(.LangID,pslCodeText)
						'检查值名是否合格的十六进制字符
						If CheckStrRegExp(.LangName,"[0-9]",0,2) Then GoTo NextNo
					'Else
					'	.LangName = GetLCIDInfo(.LangID,LOCALE_SLANGUAGE)
					'End If
					'.CodePage = PSL.GetDefaultCodePage(.LangID)
					.CodePage = StrToLong(GetLCIDInfo(.LangID,LOCALE_IDEFAULTANSICODEPAGE),CP_UNKNOWN)
					If .CodePage < 2 Then .CodePage = CP_UNKNOWN
					If Dic.Exists(.CodePage) Then
						i = Dic.Item(.CodePage)
						.CPName = WinCPList(i).CPName
						j = StrToLong(GetLCIDInfo(.LangID,LOCALE_IDEFAULTCODEPAGE),CP_UNKNOWN)
						If j < 2 Then j = CP_UNKNOWN	'避免出现 -1
						If Dic.Exists(-j) Then
							j = Dic.Item(-j)
							.UniCodeRange = OEMCPList(j).UniCodeRange
							.UniCodeRegExpPattern = OEMCPList(j).UniCodeRegExpPattern
							.UniCodeByteRange = OEMCPList(j).UniCodeByteRange
							.FeatureCode = OEMCPList(j).FeatureCode
							.FeatureCodeRegExpPattern = OEMCPList(j).FeatureCodeRegExpPattern
							.FeatureCodeByteRange = OEMCPList(j).FeatureCodeByteRange
							.FeatureCodeEnable = OEMCPList(j).FeatureCodeEnable
						Else
							.UniCodeRange = WinCPList(i).UniCodeRange
							.UniCodeRegExpPattern = WinCPList(i).UniCodeRegExpPattern
							.UniCodeByteRange = WinCPList(i).UniCodeByteRange
							.FeatureCode = WinCPList(i).FeatureCode
							.FeatureCodeRegExpPattern = WinCPList(i).FeatureCodeRegExpPattern
							.FeatureCodeByteRange = WinCPList(i).FeatureCodeByteRange
							.FeatureCodeEnable = WinCPList(i).FeatureCodeEnable
						End If
						If .UniCodeRange = "" Then .CodePage = CP_UNKNOWN
						k = k + 1
					End If
					NextNo:
				End With
			End If
		End If
        n = n + 1
    Loop
	RegCloseKey(Result)   '操作完成，关闭注册表键
	Set Dic = Nothing
	If k > 0 Then k = k - 1
	ReDim Preserve LngList(k) As LANG_PROPERTIE
	GetLngList = LngList
End Function


'更新代码页名称
Private Function UpdateCPName(CPList() As LANG_PROPERTIE) As LANG_PROPERTIE()
	Dim i As Long,MsgList() As String,Dic As Object
	If getMsgList(UIDataList,MsgList,"GetUniCodePageList",1) = False Then
		UpdateCPName = CPList
		Exit Function
	End If
	Set Dic = CreateObject("Scripting.Dictionary")
	Dic.Add CP_UNKNOWN, MsgList(0)			'未知 (自动监测) = -1
	Dic.Add CP_WESTEUROPE, MsgList(1)		'拉丁文 1 (ANSI) = 1252
	Dic.Add CP_EASTEUROPE, MsgList(2)		'拉丁文 2 (中欧) = 1250
	Dic.Add CP_RUSSIAN, MsgList(3)			'西里尔文 (斯拉夫) = 1251
	Dic.Add CP_GREEK, MsgList(4)			'希腊文 = 1253
	Dic.Add CP_TURKISH, MsgList(5)			'拉丁文 5 (土耳其) = 1254
	Dic.Add CP_HEBREW, MsgList(6)			'希伯来文 = 1255
	Dic.Add CP_ARABIC, MsgList(7)			'阿拉伯文 = 1256
	Dic.Add CP_BALTIC, MsgList(8)			'波罗的海文 = 1257
	Dic.Add CP_VIETNAMESE, MsgList(9)		'越南文 = 1258
	Dic.Add CP_JAPAN, MsgList(10)			'日文 = 932
	Dic.Add CP_CHINA, MsgList(11)			'简体中文 = 936
	Dic.Add CP_KOREA, MsgList(12)			'韩文 = 949
	Dic.Add CP_TAIWAN, MsgList(13) 			'繁体中文 = 950
	Dic.Add CP_THAI, MsgList(14) 			'泰文 = 874
	Dic.Add CP_UTF7, MsgList(15)			'UTF-7 = 65000
	Dic.Add CP_UTF8, MsgList(16)			'UTF-8 = 65001
	Dic.Add CP_UNICODELITTLE, MsgList(17)	'Unicode = 1200
	Dic.Add CP_UNICODEBIG, MsgList(18)		'Unicode = 1201
	Dic.Add CP_UTF32LE, MsgList(19)			'UnicodeLE = 65005
	Dic.Add CP_UTF32BE, MsgList(20)			'UnicodeBE = 65006
	For i = 0 To UBound(CPList)
		CPList(i).CPName = GetDicVal(Dic,CPList(i).CodePage,CPList(i).CPName)
	Next i
	Set Dic = Nothing
	UpdateCPName = CPList
End Function


'更新并合并默认和自定义语言，返回语言字典
Private Function UpdateLangList(Dic As Object,LangList() As LANG_PROPERTIE,LangListBak() As LANG_PROPERTIE) As Boolean
	Dim i As Long,j As Long,n As Long
	Set Dic = CreateObject("Scripting.Dictionary")
	n = UBound(LangListBak)
	For i = 0 To n
		If Not Dic.Exists(LangListBak(i).LangID) Then Dic.Add(LangListBak(i).LangID,i)
	Next i
	If LangList(0).LangID > -2 Then
		For i = 0 To UBound(LangList)
			With LangList(i)
				If Dic.Exists(.LangID) Then
					j = Dic.Item(.LangID)
					.LangName = LangListBak(j).LangName
					.CPName = LangListBak(j).CPName
					If .FeatureCode = "" Then
						.FeatureCode = LangListBak(j).FeatureCode
						.FeatureCodeRegExpPattern = LangListBak(j).FeatureCodeRegExpPattern
						.FeatureCodeByteRange = LangListBak(j).FeatureCodeByteRange
						.FeatureCodeEnable = LangListBak(j).FeatureCodeEnable
					End If
					LangListBak(j) = LangList(i)
				ElseIf .dwFlags = True Then
					n = n + 1
					ReDim Preserve LangListBak(n) As LANG_PROPERTIE
					LangListBak(n) = LangList(i)
					Dic.Add(.LangID,n)
				End If
			End With
		Next i
	End If
	'按语言ID从小到大排序，以便将相同的语言集合在一起
	Call SortLangArraysByLngName(Dic,LangListBak,0,n,False)
	LangList = LangListBak
	UpdateLangList = True
End Function


'添加语言和语言字典
Private Function AddLangList(LangList() As LANG_PROPERTIE,NewLangList() As LANG_PROPERTIE) As String()
	Dim i As Integer,j As Integer,k As Integer,n As Integer,Dic As Object
	Set Dic = CreateObject("Scripting.Dictionary")
	n = UBound(LangList): j = UBound(NewLangList)
	For i = 0 To n
		If Not Dic.Exists(LangList(i).LangID) Then Dic.Add(LangList(i).LangID,i)
	Next i
	ReDim Preserve LangList(n + j + 1) As LANG_PROPERTIE
	ReDim TempList(j) As String
	j = n
	For i = 0 To UBound(NewLangList)
		With NewLangList(i)
			If Not Dic.Exists(.LangID) Then
				n = n + 1
				Dic.Add(.LangID,n)
				LangList(n) = NewLangList(i)
				TempList(k) = CStr$(n)
				k = k + 1
			End If
		End With
	Next i
	Set Dic = Nothing
	If n > j Then
		ReDim Preserve LangList(n) As LANG_PROPERTIE,TempList(n - j - 1) As String
	Else
		ReDim Preserve LangList(j) As LANG_PROPERTIE,TempList(0) As String
	End If
	AddLangList = TempList
End Function


'获取符合指定代码页的语言数据列表
'Mode = False 无该代码页时返回全部语言数据列表，否则返回空语言数据列表
Private Function GetSubLangListByCP(LangList() As LANG_PROPERTIE,ByVal CP As Long,Optional ByVal Mode As Boolean) As LANG_PROPERTIE()
	Dim i As Long,n As Long
	ReDim tmpLangList(UBound(LangList)) As LANG_PROPERTIE
	For i = 0 To UBound(LangList)
		If LangList(i).CodePage = CP Then
			tmpLangList(n) = LangList(i)
			n = n + 1
		End If
	Next i
	If n > 0 Then
		ReDim Preserve tmpLangList(n - 1) As LANG_PROPERTIE
	ElseIf Mode = False Then
		tmpLangList = LangList
	Else
		ReDim tmpLangList(0) As LANG_PROPERTIE
	End If
	GetSubLangListByCP = tmpLangList
End Function


'获取符合指定语言ID的代码页值字串
'无该语言时返回字串
Private Function GetCPStrByLangID(LangList() As LANG_PROPERTIE,ByVal LangIDs As String,ByVal Separator As String) As String
	Dim i As Long,n As Long,TempList() As String,Dic As Object
	Set Dic = CreateObject("Scripting.Dictionary")
	For i = 0 To UBound(LangList)
		If Not Dic.Exists(CStr$(LangList(i).LangID)) Then
			Dic.Add(CStr$(LangList(i).LangID),CStr$(LangList(i).CodePage))
		End If
	Next i
	TempList = ReSplit(LangIDs,Separator)
	For i = 0 To UBound(TempList)
		If Dic.Exists(TempList(i)) Then
			TempList(n) = Dic.Item(TempList(i))
			n = n + 1
		End If
	Next i
	Set Dic = Nothing
	If n > 0 Then
		ReDim Preserve TempList(n - 1) As String
		GetCPStrByLangID = StrListJoin(TempList,Separator)
	End If
End Function


'设置对话框
'OutputSet = 0 允许更改消息输出设置，否则不允许
Private Function Settings(ByVal OptionID As Integer) As Integer
	Dim MsgList() As String,TempList() As String
	Settings = -1
	If getMsgList(UIDataList,MsgList,"Settings",1) = False Then Exit Function
	ReDim TempList(7) As String
	TempList(0) = MsgList(28)
	TempList(1) = MsgList(98)
	TempList(2) = MsgList(77)
	TempList(3) = MsgList(53)
	TempList(4) = MsgList(106)
	TempList(5) = MsgList(8)
	TempList(6) = MsgList(22)
	TempList(7) = MsgList(118)
	Begin Dialog UserDialog 770,518,MsgList(0),.SettingsDlgFunc ' %GRID:10,7,1,1
		TextBox 0,0,0,21,.SuppValueBox
		Text 10,7,750,28,MsgList(1),.MainText
		ListBox 10,49,120,427,TempList(),.MenuList

		Text 10,7,750,28,MsgList(29),.StrTypeText
		Text 10,7,750,28,MsgList(30),.RefStrTypeText
		GroupBox 140,42,620,434,MsgList(31),.StrTypeListGroup
		DropListBox 160,63,260,21,TempList(),.StrTypeNameList
		PushButton 420,63,30,21,MsgList(2),.LevelButton
		PushButton 470,63,90,21,MsgList(32),.AddButton
		PushButton 560,63,90,21,MsgList(33),.ChangeButton
		PushButton 650,63,90,21,MsgList(34),.DelButton

		Text 160,98,200,14,MsgList(35),.CodeLocGroup
		OptionGroup .CodeLoc
			OptionButton 380,98,120,14,MsgList(36),.StrAddBefore
			OptionButton 500,98,120,14,MsgList(37),.RefAddBefore
			OptionButton 620,98,120,14,MsgList(96),.RefAddAfter

		Text 160,126,580,14,MsgList(38),.FristCodeGroup
		Text 180,147,470,14,MsgList(44),.FristCodePosText
		DropListBox 670,143,70,21,TempList(),.FristCodePosList

		Text 160,175,580,14,MsgList(39),.CPCodeGroup
		Text 180,196,470,14,MsgList(44),.CPCodePosText
		Text 180,217,470,14,MsgList(47),.CPCodeSizeText
		DropListBox 670,192,70,21,TempList(),.CPCodePosList
		DropListBox 670,214,70,21,TempList(),.CPCodeSizeList

		Text 160,245,580,14,MsgList(40),.LengthCodeGroup
		Text 180,266,470,14,MsgList(44),.LengthCodePosText
		Text 180,287,470,14,MsgList(47),.LengthCodeSizeText
		Text 180,308,310,14,MsgList(48),.LengthReviseValText
		Text 180,329,310,14,MsgList(49),.LengthModeText
		DropListBox 670,262,70,21,TempList(),.LengthCodePosList
		DropListBox 670,283,70,21,TempList(),.LengthCodeSizeList
		DropListBox 510,304,150,21,TempList(),.LengthReviseNameList
		DropListBox 670,304,70,21,TempList(),.ByteLengthReviseValList
		DropListBox 670,304,70,21,TempList(),.CharLengthReviseValList
		DropListBox 510,325,230,21,TempList(),.LengthModeList

		Text 160,357,580,14,MsgList(41),.StartCodeGroup
		Text 180,378,470,14,MsgList(46),.StartCodePosText
		Text 180,399,420,14,MsgList(50),.StartCodeStrText
		DropListBox 670,374,70,21,TempList(),.StartCodePosList
		TextBox 610,395,130,21,.StartCodeStrBox

		Text 160,427,580,14,MsgList(42),.EndCodeGroup
		Text 180,448,420,14,MsgList(50),.EndCodeStrText
		PushButton 710,444,30,21,MsgList(3),.EndCodeStrButton
		TextBox 610,444,100,21,.EndCodeStrBox

		Text 160,126,580,14,MsgList(38),.RefFristCodeGroup
		Text 160,126,580,14,MsgList(76),.RefAfterCodeGroup
		Text 180,147,470,14,MsgList(45),.RefAddBeforeFristCodePosText
		Text 180,147,470,14,MsgList(97),.RefAddAfterFristCodePosText
		DropListBox 670,144,70,21,TempList(),.RefFristCodePosList

		Text 160,175,580,14,MsgList(39),.RefCPCodeGroup
		Text 180,196,470,14,MsgList(45),.RefAddBeforeCPCodePosText
		Text 180,196,470,14,MsgList(97),.RefAddAfterCPCodePosText
		Text 180,217,470,14,MsgList(47),.RefCPCodeSizeText
		Text 180,238,420,14,MsgList(51),.RefCPCodeBefStrText
		DropListBox 670,191,70,21,TempList(),.RefCPCodePosList
		DropListBox 670,213,70,21,TempList(),.RefCPCodeSizeList
		TextBox 610,234,130,21,.RefCPCodeBefStrBox

		Text 160,266,580,14,MsgList(40),.RefLengthCodeGroup
		Text 180,287,470,14,MsgList(45),.RefAddBeforeLengthCodePosText
		Text 180,287,470,14,MsgList(97),.RefAddAfterLengthCodePosText
		Text 180,308,470,14,MsgList(47),.RefLengthCodeSizeText
		Text 180,329,310,14,MsgList(48),.RefLengthReviseValText
		Text 180,350,310,14,MsgList(49),.RefLengthModeText
		Text 180,371,420,14,MsgList(51),.RefLengthCodeBefStrText
		DropListBox 670,283,70,21,TempList(),.RefLengthCodePosList
		DropListBox 670,304,70,21,TempList(),.RefLengthCodeSizeList
		DropListBox 510,325,150,21,TempList(),.RefLengthReviseNameList
		DropListBox 670,325,70,21,TempList(),.RefByteLengthReviseValList
		DropListBox 670,325,70,21,TempList(),.RefCharLengthReviseValList
		DropListBox 510,346,230,21,TempList(),.RefLengthModeList
		TextBox 610,367,130,21,.RefLengthCodeBefStrBox

		Text 160,399,580,14,MsgList(43),.RefCodeBefGroup
		Text 180,420,470,14,MsgList(45),.RefAddBeforeCodeBefPosText
		Text 180,420,470,14,MsgList(97),.RefAddAfterCodeBefPosText
		Text 180,441,420,14,MsgList(52),.RefCodeBefStrText
		DropListBox 670,416,70,21,TempList(),.RefCodeBefPosList
		TextBox 610,437,130,21,.RefCodeBefStrBox

		GroupBox 140,42,620,434,MsgList(77),.LngGroup
		DropListBox 160,70,290,21,TempList(),.LngNameList
		PushButton 470,70,90,21,MsgList(32),.LngAddButton
		PushButton 560,70,90,21,MsgList(33),.LngChangeButton
		PushButton 650,70,90,21,MsgList(34),.LngDelButton
		Text 170,108,90,14,MsgList(78),.LngIDText
		TextBox 270,105,90,21,.LngIDTextBox
		Text 370,108,90,14,MsgList(79),.CPNameText
		DropListBox 470,105,270,21,TempList(),.CPNameList
		DropListBox 470,105,270,21,TempList(),.CPValList
		PushButton 710,105,30,21,MsgList(3),.CPMenuButton
		Text 160,140,580,14,MsgList(80),.UniCodeRangeText
		TextBox 160,161,580,105,.UniCodeRangeTextBox,1
		Text 160,273,460,14,MsgList(81),.FeatureCodeText
		CheckBox 630,273,110,14,MsgList(82),.FeatureCodeEnableCheckBox
		TextBox 160,294,580,63,.FeatureCodeTextBox,1
		Text 160,371,580,91,MsgList(83),.CPTipText

		GroupBox 140,42,620,322,MsgList(58),.FreeByteGroup
		CheckBox 160,63,480,21,MsgList(59),.StrFreeByteCheckBox
		DropListBox 690,63,50,21,TempList(),.StrFreeByteMacthLoopsList
		CheckBox 160,84,580,21,MsgList(60),.NotStrFreeByteCheckBox
		Text 200,112,430,14,MsgList(61),.NoMarkPEFreeByteText
		TextBox 690,112,50,21,.NoMarkPEFreeByteTextBox
		CheckBox 160,133,580,21,MsgList(62),.SectionEndFreeByteCheckBox
		CheckBox 160,154,480,21,MsgList(63),.AddSectionEndFreeByteCheckBox
		PushButton 650,154,90,21,MsgList(64),.ViewAddSectionEndFreeByteButton
		CheckBox 160,175,580,21,MsgList(65),.AddLastSectionEndCheckBox
		CheckBox 160,196,580,21,MsgList(66),.NewSectionCheckBox
		Text 160,227,80,14,MsgList(67),.WriteOrderText
		TextBox 240,224,470,21,.WriteOrderTextBox
		PushButton 710,224,30,21,MsgList(2),.WriteOrderButton
		CheckBox 240,252,500,21,MsgList(68),.OrgFreeByteCheckBox
		Text 160,276,80,14,MsgList(69),.FileAlignText
		CheckBox 240,273,500,21,MsgList(70),.FileAlignCheckBox
		Text 160,308,580,42,MsgList(71),.FreeByteTipText

		GroupBox 140,378,620,98,MsgList(72),.AllWriteMsgGroup
		CheckBox 160,399,580,21,MsgList(73),.WriteLogFileCheckBox
		CheckBox 160,420,580,21,MsgList(74),.OpenLogFileCheckBox
		CheckBox 160,441,580,21,MsgList(75),.TranStrOnlyMsgCheckBox

		GroupBox 140,42,620,98,MsgList(9),.UpdateSetGroup
		OptionGroup .UpdateSet
			OptionButton 160,63,580,21,MsgList(10),.AutoButton
			OptionButton 160,84,580,21,MsgList(11),.ManualButton
			OptionButton 160,105,580,21,MsgList(12),.OffButton
		GroupBox 140,154,620,56,MsgList(13),.CheckGroup
		Text 160,178,100,14,MsgList(14),.UpdateCycleText
		TextBox 270,175,40,21,.UpdateCycleBox
		Text 320,178,60,14,MsgList(15),.UpdateDatesText
		Text 410,178,130,14,MsgList(16),.UpdateDateText
		TextBox 550,175,100,21,.UpdateDateBox
		PushButton 660,175,80,21,MsgList(21),.CheckButton
		GroupBox 140,224,620,98,MsgList(17),.WebSiteGroup
		TextBox 160,245,580,63,.WebSiteBox,1
		GroupBox 140,336,620,140,MsgList(18),.CmdGroup
		Text 160,357,550,14,MsgList(19),.CmdPathBoxText
		Text 160,413,550,14,MsgList(20),.ArgumentBoxText
		TextBox 160,378,550,21,.CmdPathBox
		TextBox 160,434,550,21,.ArgumentBox
		PushButton 710,378,30,21,MsgList(2),.ExeBrowseButton
		PushButton 710,434,30,21,MsgList(3),.ArgumentButton

		GroupBox 140,42,620,168,MsgList(23),.UILangSetGroup
		Text 160,63,580,98,MsgList(24),.UILangSetText1
		Text 160,178,150,14,MsgList(25),.UILangSetText2
		DropListBox 300,175,390,21,TempList(),.UILangList

		GroupBox 140,224,620,105,MsgList(84),.UIFontSetGroup
		Text 160,248,130,14,MsgList(85),.MainFontText
		Text 160,269,130,14,MsgList(86),.SrcStrFontText
		Text 160,290,130,14,MsgList(87),.TrnStrFontText
		TextBox 300,245,360,21,.MainFontBox
		TextBox 300,266,360,21,.SrcStrFontBox
		TextBox 300,287,360,21,.TrnStrFontBox
		PushButton 660,245,30,21,MsgList(3),.MainFontButton
		PushButton 660,266,30,21,MsgList(3),.SrcStrFontButton
		PushButton 660,287,30,21,MsgList(3),.TrnStrFontButton

		GroupBox 140,343,300,49,MsgList(26),.NumDisplayFormatText
		OptionGroup .NumDisplayFormatGroup
			OptionButton 160,364,130,14,MsgList(88),.DecDisplayFormatButton
			OptionButton 300,364,130,14,MsgList(89),.HexDisplayFormatButton
		GroupBox 460,343,300,49,MsgList(90),.MsgOutputGroupText
		OptionGroup .MsgOutputGroup
			OptionButton 480,364,130,14,MsgList(91),.PSLOutputButton
			OptionButton 620,364,130,14,MsgList(92),.HCSOutputButton
		GroupBox 140,406,620,70,MsgList(93),.OtherGroup
		CheckBox 160,427,580,14,MsgList(94),.SpaceWithPointCheckBox
		CheckBox 160,448,580,14,MsgList(95),.FilterDisplayAtStartupBox

		Text 10,7,750,28,MsgList(99),.RefTypeText
		GroupBox 140,42,620,434,MsgList(100),.RefTypeListGroup
		DropListBox 160,70,290,21,TempList(),.RefTypeNameList
		PushButton 470,70,90,21,MsgList(32),.RefAddButton
		PushButton 560,70,90,21,MsgList(33),.RefChangeButton
		PushButton 650,70,90,21,MsgList(34),.RefDelButton

		Text 160,112,560,14,MsgList(101),.RefAlgorithmText
		TextBox 160,133,550,21,.RefAlgorithmBox
		PushButton 710,133,30,21,MsgList(3),.RefAlgorithmButton
		Text 160,168,560,14,MsgList(117),.StrAddAlgorithmText
		TextBox 160,189,550,21,.StrAddAlgorithmBox
		PushButton 710,189,30,21,MsgList(3),.StrAddAlgorithmButton
		Text 160,231,510,14,MsgList(102),.RefCodeLengthText
		TextBox 690,227,50,21,.RefCodeLengthBox
		Text 160,273,470,14,MsgList(103),.RefCodeByteSequenceText
		DropListBox 650,269,90,21,TempList(),.RefCodeByteSequenceList
		Text 160,308,290,28,MsgList(104),.RefCodePrefixByteText
		TextBox 460,308,280,21,.RefCodePrefixByteBox
		Text 160,357,510,14,MsgList(105),.RefCodePrefixLengthText
		TextBox 690,350,50,21,.RefCodePrefixLengthBox

		GroupBox 140,42,620,112,MsgList(54),.OpenFileModeGroup
		OptionGroup .OpenFileModeOption
			OptionButton 160,63,580,21,MsgList(55),.StreamModeButton
			OptionButton 160,91,580,21,MsgList(56),.ByteModeButton
			OptionButton 160,119,580,21,MsgList(57),.MapFileButton

		GroupBox 140,168,620,308,MsgList(107),.VoiceGroup
		CheckBox 160,189,570,21,MsgList(108),.GetStringVoiceCheckBox
		CheckBox 160,217,570,21,MsgList(109),.ImportSrcVoiceCheckBox
		CheckBox 160,245,570,21,MsgList(110),.ImportTrnVoiceCheckBox
		CheckBox 160,273,570,21,MsgList(111),.ParseStrDataVoiceCheckBox
		CheckBox 160,301,570,21,MsgList(112),.GetStrTypeVoiceCheckBox
		CheckBox 160,329,570,21,MsgList(113),.MoveStringVoiceCheckBox
		CheckBox 160,357,570,21,MsgList(114),.AddAndDelFilterVoiceCheckBox
		CheckBox 160,385,570,21,MsgList(115),.AddAndDelReserveVoiceCheckBox
		CheckBox 160,413,570,21,MsgList(116),.WriteStringVoiceCheckBox

		GroupBox 140,42,620,434,MsgList(118),.HelpSystemGroup
		Text 160,70,580,63,MsgList(119),.HelpSystemText
		OptionGroup .HelpSystemOption
			OptionButton 170,147,570,28,MsgList(120),.TextHelpSystemButton
			OptionButton 170,182,570,21,MsgList(121),.CHMHelpSystemButton

		PushButton 20,490,90,21,MsgList(4),.HelpButton
		PushButton 120,490,100,21,MsgList(7),.ResetButton
		PushButton 330,490,90,21,MsgList(5),.TestButton
		PushButton 230,490,90,21,MsgList(6),.CleanButton
		PushButton 120,490,160,21,MsgList(27),.EditUILangButton
		OKButton 560,490,90,21,.OKButton
		CancelButton 660,490,90,21,.CancelButton
	End Dialog
	Dim dlg As UserDialog
	dlg.MenuList = OptionID
	If Dialog(dlg) = 0 Then Exit Function
	Settings = dlg.MenuList
End Function


'设置对话框函数
Private Function SettingsDlgFunc(DlgItem$, Action%, SuppValue&) As Boolean
	Dim i As Long,j As Long,n As Long,HeaderID As Long,Stemp As Boolean
	Dim TempList() As String,TempArray() As String,MsgList() As String
	Dim Data() As STRING_PROPERTIE,TempData() As STRING_TYPE
	Dim Dic As Object,Temp As String

	Select Case Action%
	Case 1 ' 对话框窗口初始化
		If getMsgList(UIDataList,MsgList,"SettingsDlgFunc",1) = False Then Exit Function
		DlgText "SuppValueBox",CStr$(SuppValue)
		DlgVisible "SuppValueBox",False
		DlgVisible "CPValList",False
		DlgVisible "CPMenuButton",False

		ReDim Preserve TempList(32) As String
		For i = 0 To 32
  			TempList(i) = CStr$(i)
  		Next i
  		DlgListBoxArray "FristCodePosList",TempList()
  		DlgListBoxArray "RefFristCodePosList",TempList()

  		TempList = ReSplit("-5,-4,-3,-2,-1,0,1,2,3,4,5",",")
  		DlgListBoxArray "ByteLengthReviseValList",TempList()
  		DlgListBoxArray "CharLengthReviseValList",TempList()
  		DlgListBoxArray "RefByteLengthReviseValList",TempList()
		DlgListBoxArray "RefCharLengthReviseValList",TempList()

		TempList = ReSplit(MsgList(46),";")
  		DlgListBoxArray "LengthModeList",TempList()

  		TempList = ReSplit(MsgList(47),";")
  		DlgListBoxArray "RefLengthModeList",TempList()

  		TempList = ReSplit(MsgList(48) & ",1,2,4,8",",")
  		DlgListBoxArray "CPCodeSizeList",TempList()
  		DlgListBoxArray "LengthCodeSizeList",TempList()
  		DlgListBoxArray "RefCPCodeSizeList",TempList()
  		DlgListBoxArray "RefLengthCodeSizeList",TempList()

  		ReDim Preserve TempList(33) As String
  		For i = 1 To 33
  			TempList(i) = CStr$(i - 1)
  		Next i
  		DlgListBoxArray "CPCodePosList",TempList()
  		DlgListBoxArray "LengthCodePosList",TempList()
  		DlgListBoxArray "StartCodePosList",TempList()
  		DlgListBoxArray "RefCPCodePosList",TempList()
  		DlgListBoxArray "RefLengthCodePosList",TempList()
		DlgListBoxArray "RefCodeBefPosList",TempList()

		TempList = ReSplit(MsgList(49),";")
		DlgListBoxArray "LengthReviseNameList",TempList()
  		DlgListBoxArray "RefLengthReviseNameList",TempList()

  		TempList =  ReSplit("1,2,3,4,5,6",",")
  		DlgListBoxArray "StrFreeByteMacthLoopsList",TempList()

		ReDim TempList(UBound(UIFileList) + 2) As String
		n = 1
		For i = 0 To UBound(UIFileList) + 2
			If i = 0 Then
				TempList(i) = MsgList(44)
			ElseIf i = 1 Then
				TempList(i) = MsgList(51)
			ElseIf UIFileList(i - 2).FilePath <> "" Then
				TempList(i) = UIFileList(i - 2).LangName
				n = n + 1
				If Selected(0) = UIFileList(i - 2).LangID Then HeaderID = i
			End If
		Next i
		ReDim Preserve TempList(n) As String
		DlgListBoxArray "UILangList",TempList()
		DlgValue "UILangList",IIf(HeaderID < 2,StrToLong(Selected(0),0),HeaderID)
		DlgText "MainFontBox",GetFontText(SuppValue,LFList(0))
		DlgText "SrcStrFontBox",GetFontText(SuppValue,LFList(1))
		DlgText "TrnStrFontBox",GetFontText(SuppValue,LFList(2))

		If Selected(11) = "" Then Selected(11) = "4132"
		TempArray = ReSplit(MsgList(27),";")
		n = UBound(TempArray)
		ReDim TempList(n) As String
		For i = 0 To n
			TempList(i) = TempArray(StrToLong(Mid$(Selected(11),i + 1,1)) - 1)
		Next i
		DlgValue "OpenFileModeOption",StrToLong(Selected(1)) + 1
		DlgValue "StrFreeByteCheckBox",StrToLong(Selected(2))
		DlgValue "NotStrFreeByteCheckBox",StrToLong(Selected(3))
		DlgText "NoMarkPEFreeByteTextBox",Selected(9)
		DlgValue "SectionEndFreeByteCheckBox",StrToLong(Selected(4))
		DlgValue "AddSectionEndFreeByteCheckBox",StrToLong(Selected(5))
		DlgValue "AddLastSectionEndCheckBox",StrToLong(Selected(6))
		DlgValue "NewSectionCheckBox",StrToLong(Selected(7))
		DlgText "WriteOrderTextBox",StrListJoin(TempList,ItemJoinStr)
		DlgValue "OrgFreeByteCheckBox",StrToLong(Selected(10))
		DlgValue "FileAlignCheckBox",StrToLong(Selected(12))
		DlgValue "WriteLogFileCheckBox",StrToLong(Selected(13))
		DlgValue "OpenLogFileCheckBox",StrToLong(Selected(14))
		DlgValue "TranStrOnlyMsgCheckBox",StrToLong(Selected(15))
		DlgValue "NumDisplayFormatGroup",StrToLong(Selected(16))
		DlgValue "MsgOutputGroup",IIf(StrToLong(Selected(17)) = -1,0,1)
		DlgText "StrFreeByteMacthLoopsList",Selected(18)
		DlgValue "SpaceWithPointCheckBox",StrToLong(Selected(19))
		DlgValue "FilterDisplayAtStartupBox",StrToLong(Selected(20))
		DlgValue "GetStringVoiceCheckBox",StrToLong(Selected(21))
		DlgValue "ImportSrcVoiceCheckBox",StrToLong(Selected(22))
		DlgValue "ImportTrnVoiceCheckBox",StrToLong(Selected(23))
		DlgValue "ParseStrDataVoiceCheckBox",StrToLong(Selected(24))
		DlgValue "GetStrTypeVoiceCheckBox",StrToLong(Selected(25))
		DlgValue "MoveStringVoiceCheckBox",StrToLong(Selected(26))
		DlgValue "AddAndDelFilterVoiceCheckBox",StrToLong(Selected(27))
		DlgValue "AddAndDelReserveVoiceCheckBox",StrToLong(Selected(28))
		DlgValue "WriteStringVoiceCheckBox",StrToLong(Selected(29))
		DlgValue "HelpSystemOption",StrToLong(Selected(30))

		If CheckArray(UpdateSet) = True Then
			DlgValue "UpdateSet",StrToLong(UpdateSet(0))
			DlgText "WebSiteBox",UpdateSet(1)
			DlgText "CmdPathBox",UpdateSet(2)
			DlgText "ArgumentBox",UpdateSet(3)
			DlgText "UpdateCycleBox",UpdateSet(4)
			DlgText "UpdateDateBox",UpdateSet(5)
		End If
		If DlgText("UpdateDateBox") = "" Then DlgText "UpdateDateBox",MsgList(3)
		DlgEnable "UpdateDateBox",False

		If CheckStrTypeArray(StrTypeList) = False Then
			StrTypeList(0).sName = MsgList(45)
			StrTypeListBak(0).sName = MsgList(45)
		End If
		TempList = GetStrTypeNameList(StrTypeList)
		DlgListBoxArray "StrTypeNameList",TempList()
		DlgText "StrTypeNameList",UseStrTypeList(0).sName
		If DlgText("StrTypeNameList") = "" Then DlgValue "StrTypeNameList",0
		With StrTypeList(DlgValue("StrTypeNameList"))
			DlgValue "CodeLoc",.CodeLoc
			If .CodeLoc = 0 Then
				DlgText "FristCodePosList",CStr(.FristCodePos)
				If DlgValue("FristCodePosList") < 0 Then
					DlgValue "FristCodePosList",DlgListBoxArray("FristCodePosList") - 1
				End If
				If .CPCodePos < 0 Then
					DlgValue "CPCodePosList",0
				Else
					DlgText "CPCodePosList",CStr(.CPCodePos)
					If DlgValue("CPCodePosList") < 0 Then
						DlgValue "CPCodePosList",DlgListBoxArray("CPCodePosList") - 1
					End If
				End If
				If .CPCodeSize = 0 Then
					DlgValue "CPCodeSizeList",0
				Else
					DlgText "CPCodeSizeList",CStr(.CPCodeSize)
				End If
				If .LengthCodePos < 0 Then
					DlgValue "LengthCodePosList",0
				Else
					DlgText "LengthCodePosList",CStr(.LengthCodePos)
					If DlgValue("LengthCodePosList") < 0 Then
						DlgValue "LengthCodePosList",DlgListBoxArray("LengthCodePosList") - 1
					End If
				End If
				If .LengthCodeSize = 0 Then
					DlgValue "LengthCodeSizeList",0
				Else
					DlgText "LengthCodeSizeList",CStr(.LengthCodeSize)
				End If
				DlgValue "LengthReviseNameList",IIf(.LengthMode = 2 Or .LengthMode = 6,1,0)
				DlgText "ByteLengthReviseValList",CStr(.ByteLengthReviseVal)
				DlgText "CharLengthReviseValList",CStr(.CharLengthReviseVal)
				DlgValue "LengthModeList",.LengthMode
				If .StartCodePos < 0 Then
					DlgValue "StartCodePosList",0
				Else
					DlgText "StartCodePosList",CStr(.StartCodePos)
					If DlgValue("StartCodePosList") < 0 Then
						DlgValue "StartCodePosList",DlgListBoxArray("StartCodePosList") - 1
					End If
				End If
				DlgText "StartCodeStrBox",.StartCodeString
				DlgText "EndCodeStrBox",.EndCodeString
			Else
				DlgText "RefFristCodePosList",CStr(.FristCodePos)
				If DlgValue("RefFristCodePosList") < 0 Then
					DlgValue "RefFristCodePosList",DlgListBoxArray("RefFristCodePosList") - 1
				End If
				If .CPCodePos < 0 Then
					DlgValue "RefCPCodePosList",0
				Else
					DlgText "RefCPCodePosList",CStr(.CPCodePos)
					If DlgValue("RefCPCodePosList") < 0 Then
						DlgValue "RefCPCodePosList",DlgListBoxArray("RefCPCodePosList") - 1
					End If
				End If
				If .CPCodeSize = 0 Then
					DlgValue "RefCPCodeSizeList",0
				Else
					DlgText "RefCPCodeSizeList",CStr(.CPCodeSize)
				End If
				If .LengthCodePos < 0 Then
					DlgValue "RefLengthCodePosList",0
				Else
					DlgText "RefLengthCodePosList",CStr(.LengthCodePos)
					If DlgValue("RefLengthCodePosList") < 0 Then
						DlgValue "RefLengthCodePosList",DlgListBoxArray("RefLengthCodePosList") - 1
					End If
				End If
				If .LengthCodeSize = 0 Then
					DlgValue "RefLengthCodeSizeList",0
				Else
					DlgText "RefLengthCodeSizeList",CStr(.LengthCodeSize)
				End If
				DlgValue "RefLengthReviseNameList",IIf(.LengthMode = 2 Or .LengthMode = 6,1,0)
				DlgText "RefByteLengthReviseValList",CStr(.ByteLengthReviseVal)
				DlgText "RefCharLengthReviseValList",CStr(.CharLengthReviseVal)
				DlgValue "RefLengthModeList",.LengthMode
				DlgText "RefCPCodeBefStrBox",.CPCodeStartString
				DlgText "RefLengthCodeBefStrBox",.LengthCodeStartString
				If .RefCodeStartPos < 0 Then
					DlgValue "RefCodeBefPosList",0
				Else
					DlgText "RefCodeBefPosList",CStr(.RefCodeStartPos)
					If DlgValue("RefCodeBefPosList") < 0 Then
						DlgValue "RefCodeBefPosList",DlgListBoxArray("RefCodeBefPosList") - 1
					End If
				End If
				DlgText "RefCodeBefStrBox",.RefCodeStartString
			End If
		End With
		If UBound(StrTypeList) = 0 Then
			DlgEnable "DelButton",False
			DlgEnable "AddButton",CheckStrTypeArray(StrTypeList)
		End If

		TempList = ReSplit(MsgList(76),";")
		DlgListBoxArray "RefCodeByteSequenceList",TempList()
		If CheckRefTypeArray(RefTypeList) = False Then
			RefTypeList(0).sName = MsgList(69)
			RefTypeListBak(0).sName = MsgList(69)
		End If
		TempList = GetRefTypeNameList(RefTypeList)
		DlgListBoxArray "RefTypeNameList",TempList()
		DlgText "RefTypeNameList",UseRefTypeList(0).sName
		If DlgText("RefTypeNameList") = "" Then DlgValue "RefTypeNameList",0
		With RefTypeList(DlgValue("RefTypeNameList"))
			DlgText "RefAlgorithmBox",.Algorithm
			DlgText "RefCodeLengthBox",CStr(.ByteLength)
			DlgValue "RefCodeByteSequenceList",.ByteOrder
			DlgText "RefCodePrefixByteBox",.PrefixByte
			DlgText "RefCodePrefixLengthBox",CStr(.PrefixLength)
			DlgText "StrAddAlgorithmBox",.StrAddAlgorithm
		End With
		If UBound(RefTypeList) = 0 Then
			DlgEnable "RefDelButton",False
			DlgEnable "RefAddButton",CheckRefTypeArray(RefTypeList)
		End If

		TempList = GetLangStrList(UniLangList,0)
		DlgListBoxArray "LngNameList",TempList()
		TempList = GetLangStrList(UniLangList,3)
		DlgListBoxArray "CPNameList",TempList()
		TempList = GetLangStrList(UniLangList,4)
		DlgListBoxArray "CPValList",TempList()
		DlgText "LngNameList",UseLangList(0).LangName
		If DlgValue("LngNameList") < 0 Then DlgValue "LngNameList",0
		With UniLangList(DlgValue("LngNameList"))
			DlgText "LngIDTextBox",CStr(.LangID)
			DlgText "CPValList",CStr(.CodePage)
			DlgValue "CPNameList",DlgValue("CPValList")
			DlgText "UniCodeRangeTextBox",.UniCodeRange
			DlgText "FeatureCodeTextBox",.FeatureCode
			DlgValue "FeatureCodeEnableCheckBox",.FeatureCodeEnable
		End With

		If SourceFile.Magic = "" Then
			DlgEnable "ViewAddSectionEndFreeByteButton",False
		'ElseIf InStr(SourceFile.Magic,"MAC") Then
		'	DlgEnable "NewSectionCheckBox",False
		'	If DlgValue("NewSectionCheckBox") = 1 Then
		'		DlgValue "AddLastSectionEndCheckBox",1
		'		DlgValue "NewSectionCheckBox",0
		'	End If
		End If
		DlgEnable "WriteOrderTextBox",False
		DlgEnable "MainFontBox",False
		DlgEnable "SrcStrFontBox",False
		DlgEnable "TrnStrFontBox",False
		'DlgEnable "WebSiteBox",False
		If DlgValue("MenuList") <> 0 Then
			DlgVisible "StrTypeText",False
			DlgVisible "RefStrTypeText",False
			DlgVisible "StrTypeListGroup",False
			DlgVisible "StrTypeNameList",False
			DlgVisible "LevelButton",False
			DlgVisible "AddButton",False
			DlgVisible "ChangeButton",False
			DlgVisible "DelButton",False
			DlgVisible "CodeLocGroup",False
			DlgVisible "CodeLoc",False
			DlgVisible "StrTypeText",False
			DlgVisible "FristCodeGroup",False
			DlgVisible "FristCodePosText",False
			DlgVisible "FristCodePosList",False
			DlgVisible "CPCodeGroup",False
			DlgVisible "CPCodePosText",False
			DlgVisible "CPCodeSizeText",False
			DlgVisible "CPCodePosList",False
			DlgVisible "CPCodeSizeList",False
			DlgVisible "LengthCodeGroup",False
			DlgVisible "LengthCodePosText",False
			DlgVisible "LengthCodeSizeText",False
			DlgVisible "LengthReviseValText",False
			DlgVisible "LengthModeText",False
			DlgVisible "LengthCodePosList",False
			DlgVisible "LengthCodeSizeList",False
			DlgVisible "LengthReviseNameList",False
			DlgVisible "ByteLengthReviseValList",False
			DlgVisible "CharLengthReviseValList",False
			DlgVisible "LengthModeList",False
			DlgVisible "StartCodeGroup",False
			DlgVisible "StartCodePosText",False
			DlgVisible "StartCodeStrText",False
			DlgVisible "StartCodePosList",False
			DlgVisible "StartCodeStrBox",False
			DlgVisible "EndCodeGroup",False
			DlgVisible "EndCodeStrText",False
			DlgVisible "EndCodeStrBox",False
			DlgVisible "EndCodeStrButton",False

			DlgVisible "RefStrTypeText",False
			DlgVisible "RefFristCodeGroup",False
			DlgVisible "RefAfterCodeGroup",False
			DlgVisible "RefAddBeforeFristCodePosText",False
			DlgVisible "RefAddAfterFristCodePosText",False
			DlgVisible "RefFristCodePosList",False
			DlgVisible "RefCPCodeGroup",False
			DlgVisible "RefAddBeforeCPCodePosText",False
			DlgVisible "RefAddAfterCPCodePosText",False
			DlgVisible "RefCPCodeSizeText",False
			DlgVisible "RefCPCodeBefStrText",False
			DlgVisible "RefCPCodePosList",False
			DlgVisible "RefCPCodeSizeList",False
			DlgVisible "RefCPCodeBefStrBox",False
			DlgVisible "RefLengthCodeGroup",False
			DlgVisible "RefAddBeforeLengthCodePosText",False
			DlgVisible "RefAddAfterLengthCodePosText",False
			DlgVisible "RefLengthCodeSizeText",False
			DlgVisible "RefLengthReviseNameList",False
			DlgVisible "RefLengthReviseValText",False
			DlgVisible "RefLengthModeText",False
			DlgVisible "RefLengthCodeBefStrText",False
			DlgVisible "RefLengthCodePosList",False
			DlgVisible "RefLengthCodeSizeList",False
			DlgVisible "RefLengthReviseNameList",False
			DlgVisible "RefByteLengthReviseValList",False
			DlgVisible "RefCharLengthReviseValList",False
			DlgVisible "RefLengthModeList",False
			DlgVisible "RefLengthCodeBefStrBox",False
			DlgVisible "RefCodeBefGroup",False
			DlgVisible "RefAddBeforeCodeBefPosText",False
			DlgVisible "RefAddAfterCodeBefPosText",False
			DlgVisible "RefCodeBefStrText",False
			DlgVisible "RefCodeBefPosList",False
			DlgVisible "RefCodeBefStrBox",False
		ElseIf DlgValue("CodeLoc") <> 0 Then
			DlgVisible "StrTypeText",False
			DlgVisible "FristCodeGroup",False
			DlgVisible "FristCodePosText",False
			DlgVisible "FristCodePosList",False
			DlgVisible "CPCodeGroup",False
			DlgVisible "CPCodePosText",False
			DlgVisible "CPCodeSizeText",False
			DlgVisible "CPCodePosList",False
			DlgVisible "CPCodeSizeList",False
			DlgVisible "LengthCodeGroup",False
			DlgVisible "LengthCodePosText",False
			DlgVisible "LengthCodeSizeText",False
			DlgVisible "LengthReviseValText",False
			DlgVisible "LengthModeText",False
			DlgVisible "LengthCodePosList",False
			DlgVisible "LengthCodeSizeList",False
			DlgVisible "LengthReviseNameList",False
			DlgVisible "ByteLengthReviseValList",False
			DlgVisible "CharLengthReviseValList",False
			DlgVisible "LengthModeList",False
			DlgVisible "StartCodeGroup",False
			DlgVisible "StartCodePosText",False
			DlgVisible "StartCodeStrText",False
			DlgVisible "StartCodePosList",False
			DlgVisible "StartCodeStrBox",False
			DlgVisible "EndCodeGroup",False
			DlgVisible "EndCodeStrText",False
			DlgVisible "EndCodeStrBox",False
			DlgVisible "EndCodeStrButton",False

			If DlgValue("CodeLoc") <> 1 Then
				DlgVisible "RefFristCodeGroup",False
				DlgVisible "RefAddBeforeFristCodePosText",False
				DlgVisible "RefAddBeforeCPCodePosText",False
				DlgVisible "RefAddBeforeLengthCodePosText",False
				DlgVisible "RefAddBeforeCodeBefPosText",False
			Else
				DlgVisible "RefAfterCodeGroup",False
				DlgVisible "RefAddAfterFristCodePosText",False
				DlgVisible "RefAddAfterCPCodePosText",False
				DlgVisible "RefAddAfterLengthCodePosText",False
				DlgVisible "RefAddAfterCodeBefPosText",False
			End If
			If DlgValue("RefLengthReviseNameList") = 0 Then
				DlgVisible "RefCharLengthReviseValList",False
			Else
				DlgVisible "RefByteLengthReviseValList",False
			End If
		Else
			If DlgValue("LengthReviseNameList") = 0 Then
				DlgVisible "CharLengthReviseValList",False
			Else
				DlgVisible "ByteLengthReviseValList",False
			End If
			DlgVisible "RefStrTypeText",False
			DlgVisible "RefFristCodeGroup",False
			DlgVisible "RefAfterCodeGroup",False
			DlgVisible "RefAddBeforeFristCodePosText",False
			DlgVisible "RefAddAfterFristCodePosText",False
			DlgVisible "RefFristCodePosList",False
			DlgVisible "RefCPCodeGroup",False
			DlgVisible "RefAddBeforeCPCodePosText",False
			DlgVisible "RefAddAfterCPCodePosText",False
			DlgVisible "RefCPCodeSizeText",False
			DlgVisible "RefCPCodeBefStrText",False
			DlgVisible "RefCPCodePosList",False
			DlgVisible "RefCPCodeSizeList",False
			DlgVisible "RefCPCodeBefStrBox",False
			DlgVisible "RefLengthCodeGroup",False
			DlgVisible "RefAddBeforeLengthCodePosText",False
			DlgVisible "RefAddAfterLengthCodePosText",False
			DlgVisible "RefLengthCodeSizeText",False
			DlgVisible "RefLengthReviseValText",False
			DlgVisible "RefLengthModeText",False
			DlgVisible "RefLengthCodeBefStrText",False
			DlgVisible "RefLengthCodePosList",False
			DlgVisible "RefLengthCodeSizeList",False
			DlgVisible "RefLengthReviseNameList",False
			DlgVisible "RefByteLengthReviseValList",False
			DlgVisible "RefCharLengthReviseValList",False
			DlgVisible "RefLengthModeList",False
			DlgVisible "RefLengthCodeBefStrBox",False
			DlgVisible "RefCodeBefGroup",False
			DlgVisible "RefAddBeforeCodeBefPosText",False
			DlgVisible "RefAddAfterCodeBefPosText",False
			DlgVisible "RefCodeBefStrText",False
			DlgVisible "RefCodeBefPosList",False
			DlgVisible "RefCodeBefStrBox",False
		End If
		If DlgValue("MenuList") <> 1 Then
			DlgVisible "RefTypeText",False
			DlgVisible "RefTypeListGroup",False
			DlgVisible "RefTypeNameList",False
			DlgVisible "RefAddButton",False
			DlgVisible "RefChangeButton",False
			DlgVisible "RefDelButton",False
			DlgVisible "RefAlgorithmText",False
			DlgVisible "RefAlgorithmBox",False
			DlgVisible "RefAlgorithmButton",False
			DlgVisible "RefCodeLengthText",False
			DlgVisible "RefCodeLengthBox",False
			DlgVisible "RefCodeByteSequenceText",False
			DlgVisible "RefCodeByteSequenceList",False
			DlgVisible "RefCodePrefixByteText",False
			DlgVisible "RefCodePrefixByteBox",False
			DlgVisible "RefCodePrefixLengthText",False
			DlgVisible "RefCodePrefixLengthBox",False
			DlgVisible "StrAddAlgorithmText",False
			DlgVisible "StrAddAlgorithmBox",False
			DlgVisible "StrAddAlgorithmButton",False
		End If
		If DlgValue("MenuList") <> 2 Then
			DlgVisible "LngGroup",False
			DlgVisible "LngNameList",False
			DlgVisible "LngAddButton",False
			DlgVisible "LngChangeButton",False
			DlgVisible "LngDelButton",False
			DlgVisible "LngIDText",False
			DlgVisible "LngIDTextBox",False
			DlgVisible "CPNameText",False
			DlgVisible "CPNameList",False
			'DlgVisible "CPMenuButton",False
			DlgVisible "UniCodeRangeText",False
			DlgVisible "UniCodeRangeTextBox",False
			DlgVisible "FeatureCodeText",False
			DlgVisible "FeatureCodeEnableCheckBox",False
			DlgVisible "FeatureCodeTextBox",False
			DlgVisible "CPTipText",False
		End If
		If DlgValue("MenuList") <> 3 Then
			DlgVisible "FreeByteGroup",False
			DlgVisible "StrFreeByteCheckBox",False
			DlgVisible "StrFreeByteMacthLoopsList",False
			DlgVisible "NotStrFreeByteCheckBox",False
			DlgVisible "NoMarkPEFreeByteText",False
			DlgVisible "NoMarkPEFreeByteTextBox",False
			DlgVisible "SectionEndFreeByteCheckBox",False
			DlgVisible "AddSectionEndFreeByteCheckBox",False
			DlgVisible "ViewAddSectionEndFreeByteButton",False
			DlgVisible "AddLastSectionEndCheckBox",False
			DlgVisible "NewSectionCheckBox",False
			DlgVisible "WriteOrderText",False
			DlgVisible "WriteOrderTextBox",False
			DlgVisible "WriteOrderButton",False
			DlgVisible "OrgFreeByteCheckBox",False
			DlgVisible "FileAlignText",False
			DlgVisible "FileAlignCheckBox",False
			DlgVisible "FreeByteTipText",False
			DlgVisible "AllWriteMsgGroup",False
			DlgVisible "WriteLogFileCheckBox",False
			DlgVisible "OpenLogFileCheckBox",False
			DlgVisible "TranStrOnlyMsgCheckBox",False
		End If
		If DlgValue("MenuList") <> 4 Then
			DlgVisible "OpenFileModeGroup",False
			DlgVisible "OpenFileModeOption",False

			DlgVisible "VoiceGroup",False
			DlgVisible "GetStringVoiceCheckBox",False
			DlgVisible "ImportSrcVoiceCheckBox",False
			DlgVisible "ImportTrnVoiceCheckBox",False
			DlgVisible "ParseStrDataVoiceCheckBox",False
			DlgVisible "GetStrTypeVoiceCheckBox",False
			DlgVisible "MoveStringVoiceCheckBox",False
			DlgVisible "AddAndDelFilterVoiceCheckBox",False
			DlgVisible "AddAndDelReserveVoiceCheckBox",False
			DlgVisible "WriteStringVoiceCheckBox",False
		End If
		If DlgValue("MenuList") <> 5 Then
			DlgVisible "UpdateSetGroup",False
			DlgVisible "UpdateSet",False
			DlgVisible "AutoButton",False
			DlgVisible "ManualButton",False
			DlgVisible "OffButton",False
			DlgVisible "CheckGroup",False
			DlgVisible "UpdateCycleText",False
			DlgVisible "UpdateCycleBox",False
			DlgVisible "UpdateDatesText",False
			DlgVisible "UpdateDateText",False
			DlgVisible "UpdateDateBox",False
			DlgVisible "CheckButton",False
			DlgVisible "WebSiteGroup",False
			DlgVisible "WebSiteBox",False
			DlgVisible "CmdGroup",False
			DlgVisible "CmdPathBoxText",False
			DlgVisible "ArgumentBoxText",False
			DlgVisible "CmdPathBox",False
			DlgVisible "ArgumentBox",False
			DlgVisible "ExeBrowseButton",False
			DlgVisible "ArgumentButton",False
		End If
		If DlgValue("MenuList") <> 6 Then
			DlgVisible "UILangSetGroup",False
			DlgVisible "UILangSetText1",False
			DlgVisible "UILangSetText2",False
			DlgVisible "UILangList",False

			DlgVisible "UIFontSetGroup",False
			DlgVisible "MainFontText",False
			DlgVisible "SrcStrFontText",False
			DlgVisible "TrnStrFontText",False
			DlgVisible "MainFontBox",False
			DlgVisible "SrcStrFontBox",False
			DlgVisible "TrnStrFontBox",False
			DlgVisible "MainFontButton",False
			DlgVisible "SrcStrFontButton",False
			DlgVisible "TrnStrFontButton",False

			DlgVisible "NumDisplayFormatText",False
			DlgVisible "NumDisplayFormatGroup",False
			DlgVisible "MsgOutputGroupText",False
			DlgVisible "MsgOutputGroup",False
			DlgVisible "OtherGroup",False
			DlgVisible "SpaceWithPointCheckBox",False
			DlgVisible "FilterDisplayAtStartupBox",False
		End If
		If DlgValue("MenuList") <> 7 Then
			DlgVisible "HelpSystemGroup",False
			DlgVisible "HelpSystemText",False
			DlgVisible "HelpSystemOption",False
			DlgVisible "TextHelpSystemButton",False
			DlgVisible "CHMHelpSystemButton",False
		End If
		Select Case DlgValue("MenuList")
		Case Is < 5
			DlgVisible "TestButton",False
			DlgVisible "EditUILangButton",False
		Case 5
			DlgVisible "EditUILangButton",False
		Case 6
			DlgVisible "ResetButton",False
			DlgVisible "TestButton",False
			DlgVisible "CleanButton",False
		Case 7
			DlgVisible "TestButton",False
			DlgVisible "CleanButton",False
			DlgVisible "EditUILangButton",False
		End Select

		'设置当前对话框字体
		If CheckFont(LFList(0)) = True Then
			j = CreateFont(0,LFList(0))
			If j = 0 Then Exit Function
			For i = 0 To DlgCount() - 1
				SendMessageLNG(GetDlgItem(SuppValue,DlgControlId(DlgName(i))),WM_SETFONT,j,0)
			Next i
		End If
	Case 2 ' 数值更改或者按下了按钮
		SettingsDlgFunc = True '防止按下按钮关闭对话框窗口
		If getMsgList(UIDataList,MsgList,"SettingsDlgFunc",1) = False Then Exit Function
		Select Case DlgItem$
		Case "MenuList"
			If DlgValue("MenuList") = 0 Then
				DlgVisible "StrTypeListGroup",True
				DlgVisible "StrTypeNameList",True
				DlgVisible "LevelButton",True
				DlgVisible "AddButton",True
				DlgVisible "ChangeButton",True
				DlgVisible "DelButton",True
				DlgVisible "CodeLocGroup",True
				DlgVisible "CodeLoc",True
				If DlgValue("CodeLoc") = 0 Then
					DlgVisible "StrTypeText",True
					DlgVisible "FristCodeGroup",True
					DlgVisible "FristCodePosText",True
					DlgVisible "FristCodePosList",True
					DlgVisible "CPCodeGroup",True
					DlgVisible "CPCodePosText",True
					DlgVisible "CPCodeSizeText",True
					DlgVisible "CPCodePosList",True
					DlgVisible "CPCodeSizeList",True
					DlgVisible "LengthCodeGroup",True
					DlgVisible "LengthCodePosText",True
					DlgVisible "LengthCodeSizeText",True
					DlgVisible "LengthReviseValText",True
					DlgVisible "LengthModeText",True
					DlgVisible "LengthCodePosList",True
					DlgVisible "LengthCodeSizeList",True
					DlgVisible "LengthReviseNameList",True
					If DlgValue("LengthReviseNameList") = 0 Then
						DlgVisible "ByteLengthReviseValList",True
						DlgVisible "CharLengthReviseValList",False
					Else
						DlgVisible "ByteLengthReviseValList",False
						DlgVisible "CharLengthReviseValList",True
					End If
					DlgVisible "LengthModeList",True
					DlgVisible "StartCodeGroup",True
					DlgVisible "StartCodePosText",True
					DlgVisible "StartCodeStrText",True
					DlgVisible "StartCodePosList",True
					DlgVisible "StartCodeStrBox",True
					DlgVisible "EndCodeGroup",True
					DlgVisible "EndCodeStrText",True
					DlgVisible "EndCodeStrBox",True
					DlgVisible "EndCodeStrButton",True

					DlgVisible "RefStrTypeText",False
					DlgVisible "RefFristCodeGroup",False
					DlgVisible "RefAfterCodeGroup",False
					DlgVisible "RefAddBeforeFristCodePosText",False
					DlgVisible "RefAddAfterFristCodePosText",False
					DlgVisible "RefFristCodePosList",False
					DlgVisible "RefCPCodeGroup",False
					DlgVisible "RefAddBeforeCPCodePosText",False
					DlgVisible "RefAddAfterCPCodePosText",False
					DlgVisible "RefCPCodeSizeText",False
					DlgVisible "RefCPCodeBefStrText",False
					DlgVisible "RefCPCodePosList",False
					DlgVisible "RefCPCodeSizeList",False
					DlgVisible "RefCPCodeBefStrBox",False
					DlgVisible "RefLengthCodeGroup",False
					DlgVisible "RefAddBeforeLengthCodePosText",False
					DlgVisible "RefAddAfterLengthCodePosText",False
					DlgVisible "RefLengthCodeSizeText",False
					DlgVisible "RefLengthReviseValText",False
					DlgVisible "RefLengthModeText",False
					DlgVisible "RefLengthCodeBefStrText",False
					DlgVisible "RefLengthCodePosList",False
					DlgVisible "RefLengthCodeSizeList",False
					DlgVisible "RefLengthReviseNameList",False
					DlgVisible "RefByteLengthReviseValList",False
					DlgVisible "RefCharLengthReviseValList",False
					DlgVisible "RefLengthModeList",False
					DlgVisible "RefLengthCodeBefStrBox",False
					DlgVisible "RefCodeBefGroup",False
					DlgVisible "RefAddBeforeCodeBefPosText",False
					DlgVisible "RefAddAfterCodeBefPosText",False
					DlgVisible "RefCodeBefStrText",False
					DlgVisible "RefCodeBefPosList",False
					DlgVisible "RefCodeBefStrBox",False
				Else
					DlgVisible "StrTypeText",False
					DlgVisible "FristCodeGroup",False
					DlgVisible "FristCodePosText",False
					DlgVisible "FristCodePosList",False
					DlgVisible "CPCodeGroup",False
					DlgVisible "CPCodePosText",False
					DlgVisible "CPCodeSizeText",False
					DlgVisible "CPCodePosList",False
					DlgVisible "CPCodeSizeList",False
					DlgVisible "LengthCodeGroup",False
					DlgVisible "LengthCodePosText",False
					DlgVisible "LengthCodeSizeText",False
					DlgVisible "LengthReviseValText",False
					DlgVisible "LengthModeText",False
					DlgVisible "LengthCodePosList",False
					DlgVisible "LengthCodeSizeList",False
					DlgVisible "LengthReviseNameList",False
					DlgVisible "ByteLengthReviseValList",False
					DlgVisible "CharLengthReviseValList",False
					DlgVisible "LengthModeList",False
					DlgVisible "StartCodeGroup",False
					DlgVisible "StartCodePosText",False
					DlgVisible "StartCodeStrText",False
					DlgVisible "StartCodePosList",False
					DlgVisible "StartCodeStrBox",False
					DlgVisible "EndCodeGroup",False
					DlgVisible "EndCodeStrText",False
					DlgVisible "EndCodeStrBox",False
					DlgVisible "EndCodeStrButton",False

					DlgVisible "RefStrTypeText",True
					If DlgValue("CodeLoc") = 1 Then
						DlgVisible "RefFristCodeGroup",True
						DlgVisible "RefAddBeforeFristCodePosText",True
						DlgVisible "RefAfterCodeGroup",False
						DlgVisible "RefAddAfterFristCodePosText",False
					Else
						DlgVisible "RefFristCodeGroup",False
						DlgVisible "RefAddBeforeFristCodePosText",False
						DlgVisible "RefAfterCodeGroup",True
						DlgVisible "RefAddAfterFristCodePosText",True
					End If
					DlgVisible "RefFristCodePosList",True
					DlgVisible "RefCPCodeGroup",True
					If DlgValue("CodeLoc") = 1 Then
						DlgVisible "RefAddBeforeCPCodePosText",True
						DlgVisible "RefAddAfterCPCodePosText",False
					Else
						DlgVisible "RefAddBeforeCPCodePosText",False
						DlgVisible "RefAddAfterCPCodePosText",True
					End If
					DlgVisible "RefCPCodeSizeText",True
					DlgVisible "RefCPCodeBefStrText",True
					DlgVisible "RefCPCodePosList",True
					DlgVisible "RefCPCodeSizeList",True
					DlgVisible "RefCPCodeBefStrBox",True
					DlgVisible "RefLengthCodeGroup",True
					If DlgValue("CodeLoc") = 1 Then
						DlgVisible "RefAddBeforeLengthCodePosText",True
						DlgVisible "RefAddAfterLengthCodePosText",False
					Else
						DlgVisible "RefAddBeforeLengthCodePosText",False
						DlgVisible "RefAddAfterLengthCodePosText",True
					End If
					DlgVisible "RefLengthCodeSizeText",True
					DlgVisible "RefLengthReviseNameList",True
					DlgVisible "RefLengthReviseValText",True
					DlgVisible "RefLengthModeText",True
					DlgVisible "RefLengthCodeBefStrText",True
					DlgVisible "RefLengthCodePosList",True
					DlgVisible "RefLengthCodeSizeList",True
					DlgVisible "RefLengthReviseNameList",True
					If DlgValue("RefLengthReviseNameList") = 0 Then
						DlgVisible "RefByteLengthReviseValList",True
						DlgVisible "RefCharLengthReviseValList",False
					Else
						DlgVisible "RefByteLengthReviseValList",False
						DlgVisible "RefCharLengthReviseValList",True
					End If
					DlgVisible "RefLengthModeList",True
					DlgVisible "RefLengthCodeBefStrBox",True
					DlgVisible "RefCodeBefGroup",True
					If DlgValue("CodeLoc") = 1 Then
						DlgVisible "RefAddBeforeCodeBefPosText",True
						DlgVisible "RefAddAfterCodeBefPosText",False
					Else
						DlgVisible "RefAddBeforeCodeBefPosText",False
						DlgVisible "RefAddAfterCodeBefPosText",True
					End If
					DlgVisible "RefCodeBefStrText",True
					DlgVisible "RefCodeBefPosList",True
					DlgVisible "RefCodeBefStrBox",True
				End If
			Else
				DlgVisible "StrTypeText",False
				DlgVisible "RefStrTypeText",False
				DlgVisible "StrTypeListGroup",False
				DlgVisible "StrTypeNameList",False
				DlgVisible "LevelButton",False
				DlgVisible "AddButton",False
				DlgVisible "ChangeButton",False
				DlgVisible "DelButton",False
				DlgVisible "CodeLocGroup",False
				DlgVisible "CodeLoc",False
				DlgVisible "FristCodeGroup",False
				DlgVisible "FristCodePosText",False
				DlgVisible "FristCodePosList",False
				DlgVisible "CPCodeGroup",False
				DlgVisible "CPCodePosText",False
				DlgVisible "CPCodeSizeText",False
				DlgVisible "CPCodePosList",False
				DlgVisible "CPCodeSizeList",False
				DlgVisible "LengthCodeGroup",False
				DlgVisible "LengthCodePosText",False
				DlgVisible "LengthCodeSizeText",False
				DlgVisible "LengthReviseValText",False
				DlgVisible "LengthModeText",False
				DlgVisible "LengthCodePosList",False
				DlgVisible "LengthCodeSizeList",False
				DlgVisible "LengthReviseNameList",False
				DlgVisible "ByteLengthReviseValList",False
				DlgVisible "CharLengthReviseValList",False
				DlgVisible "LengthModeList",False
				DlgVisible "StartCodeGroup",False
				DlgVisible "StartCodePosText",False
				DlgVisible "StartCodeStrText",False
				DlgVisible "StartCodePosList",False
				DlgVisible "StartCodeStrBox",False
				DlgVisible "EndCodeGroup",False
				DlgVisible "EndCodeStrText",False
				DlgVisible "EndCodeStrBox",False
				DlgVisible "EndCodeStrButton",False

				DlgVisible "RefFristCodeGroup",False
				DlgVisible "RefAfterCodeGroup",False
				DlgVisible "RefAddBeforeFristCodePosText",False
				DlgVisible "RefAddAfterFristCodePosText",False
				DlgVisible "RefFristCodePosList",False
				DlgVisible "RefCPCodeGroup",False
				DlgVisible "RefAddBeforeCPCodePosText",False
				DlgVisible "RefAddAfterCPCodePosText",False
				DlgVisible "RefCPCodeSizeText",False
				DlgVisible "RefCPCodeBefStrText",False
				DlgVisible "RefCPCodePosList",False
				DlgVisible "RefCPCodeSizeList",False
				DlgVisible "RefCPCodeBefStrBox",False
				DlgVisible "RefLengthCodeGroup",False
				DlgVisible "RefAddBeforeLengthCodePosText",False
				DlgVisible "RefAddAfterLengthCodePosText",False
				DlgVisible "RefLengthCodeSizeText",False
				DlgVisible "RefLengthReviseValText",False
				DlgVisible "RefLengthModeText",False
				DlgVisible "RefLengthCodeBefStrText",False
				DlgVisible "RefLengthCodePosList",False
				DlgVisible "RefLengthCodeSizeList",False
				DlgVisible "RefLengthReviseNameList",False
				DlgVisible "RefByteLengthReviseValList",False
				DlgVisible "RefCharLengthReviseValList",False
				DlgVisible "RefLengthModeList",False
				DlgVisible "RefLengthCodeBefStrBox",False
				DlgVisible "RefCodeBefGroup",False
				DlgVisible "RefAddBeforeCodeBefPosText",False
				DlgVisible "RefAddAfterCodeBefPosText",False
				DlgVisible "RefCodeBefStrText",False
				DlgVisible "RefCodeBefPosList",False
				DlgVisible "RefCodeBefStrBox",False
			End If

			If DlgValue("MenuList") = 1 Then
				DlgVisible "RefTypeText",True
				DlgVisible "RefTypeListGroup",True
				DlgVisible "RefTypeNameList",True
				DlgVisible "RefAddButton",True
				DlgVisible "RefChangeButton",True
				DlgVisible "RefDelButton",True
				DlgVisible "RefAlgorithmText",True
				DlgVisible "RefAlgorithmBox",True
				DlgVisible "RefAlgorithmButton",True
				DlgVisible "RefCodeLengthText",True
				DlgVisible "RefCodeLengthBox",True
				DlgVisible "RefCodeByteSequenceText",True
				DlgVisible "RefCodeByteSequenceList",True
				DlgVisible "RefCodePrefixByteText",True
				DlgVisible "RefCodePrefixByteBox",True
				DlgVisible "RefCodePrefixLengthText",True
				DlgVisible "RefCodePrefixLengthBox",True
				DlgVisible "StrAddAlgorithmText",True
				DlgVisible "StrAddAlgorithmBox",True
				DlgVisible "StrAddAlgorithmButton",True
			Else
				DlgVisible "RefTypeText",False
				DlgVisible "RefTypeListGroup",False
				DlgVisible "RefTypeNameList",False
				DlgVisible "RefAddButton",False
				DlgVisible "RefChangeButton",False
				DlgVisible "RefDelButton",False
				DlgVisible "RefAlgorithmText",False
				DlgVisible "RefAlgorithmBox",False
				DlgVisible "RefAlgorithmButton",False
				DlgVisible "RefCodeLengthText",False
				DlgVisible "RefCodeLengthBox",False
				DlgVisible "RefCodeByteSequenceText",False
				DlgVisible "RefCodeByteSequenceList",False
				DlgVisible "RefCodePrefixByteText",False
				DlgVisible "RefCodePrefixByteBox",False
				DlgVisible "RefCodePrefixLengthText",False
				DlgVisible "RefCodePrefixLengthBox",False
				DlgVisible "StrAddAlgorithmText",False
				DlgVisible "StrAddAlgorithmBox",False
				DlgVisible "StrAddAlgorithmButton",False
			End If

			If DlgValue("MenuList") = 2 Then
				DlgVisible "LngGroup",True
				DlgVisible "LngNameList",True
				DlgVisible "LngAddButton",True
				DlgVisible "LngChangeButton",True
				DlgVisible "LngDelButton",True
				DlgVisible "LngIDText",True
				DlgVisible "LngIDTextBox",True
				DlgVisible "CPNameText",True
				DlgVisible "CPNameList",True
				'DlgVisible "CPMenuButton",True
				DlgVisible "UniCodeRangeText",True
				DlgVisible "UniCodeRangeTextBox",True
				DlgVisible "FeatureCodeText",True
				DlgVisible "FeatureCodeEnableCheckBox",True
				DlgVisible "FeatureCodeTextBox",True
				DlgVisible "CPTipText",True
			Else
				DlgVisible "LngGroup",False
				DlgVisible "LngNameList",False
				DlgVisible "LngAddButton",False
				DlgVisible "LngChangeButton",False
				DlgVisible "LngDelButton",False
				DlgVisible "LngIDText",False
				DlgVisible "LngIDTextBox",False
				DlgVisible "CPNameText",False
				DlgVisible "CPNameList",False
				'DlgVisible "CPMenuButton",False
				DlgVisible "UniCodeRangeText",False
				DlgVisible "UniCodeRangeTextBox",False
				DlgVisible "FeatureCodeText",False
				DlgVisible "FeatureCodeEnableCheckBox",False
				DlgVisible "FeatureCodeTextBox",False
				DlgVisible "CPTipText",False
			End If

			If DlgValue("MenuList") = 3 Then
				DlgVisible "FreeByteGroup",True
				DlgVisible "StrFreeByteCheckBox",True
				DlgVisible "StrFreeByteMacthLoopsList",True
				DlgVisible "NotStrFreeByteCheckBox",True
				DlgVisible "NoMarkPEFreeByteText",True
				DlgVisible "NoMarkPEFreeByteTextBox",True
				DlgVisible "SectionEndFreeByteCheckBox",True
				DlgVisible "AddSectionEndFreeByteCheckBox",True
				DlgVisible "ViewAddSectionEndFreeByteButton",True
				DlgVisible "AddLastSectionEndCheckBox",True
				DlgVisible "NewSectionCheckBox",True
				DlgVisible "WriteOrderText",True
				DlgVisible "WriteOrderTextBox",True
				DlgVisible "WriteOrderButton",True
				DlgVisible "OrgFreeByteCheckBox",True
				DlgVisible "FileAlignText",True
				DlgVisible "FileAlignCheckBox",True
				DlgVisible "FreeByteTipText",True
				DlgVisible "AllWriteMsgGroup",True
				DlgVisible "WriteLogFileCheckBox",True
				DlgVisible "OpenLogFileCheckBox",True
				DlgVisible "TranStrOnlyMsgCheckBox",True
				DlgEnable "ViewAddSectionEndFreeByteButton",IIf(SourceFile.Magic = "",False,True)
			Else
				DlgVisible "FreeByteGroup",False
				DlgVisible "StrFreeByteCheckBox",False
				DlgVisible "StrFreeByteMacthLoopsList",False
				DlgVisible "NotStrFreeByteCheckBox",False
				DlgVisible "NoMarkPEFreeByteText",False
				DlgVisible "NoMarkPEFreeByteTextBox",False
				DlgVisible "SectionEndFreeByteCheckBox",False
				DlgVisible "AddSectionEndFreeByteCheckBox",False
				DlgVisible "ViewAddSectionEndFreeByteButton",False
				DlgVisible "AddLastSectionEndCheckBox",False
				DlgVisible "NewSectionCheckBox",False
				DlgVisible "WriteOrderText",False
				DlgVisible "WriteOrderTextBox",False
				DlgVisible "WriteOrderButton",False
				DlgVisible "OrgFreeByteCheckBox",False
				DlgVisible "FileAlignText",False
				DlgVisible "FileAlignCheckBox",False
				DlgVisible "FreeByteTipText",False
				DlgVisible "AllWriteMsgGroup",False
				DlgVisible "WriteLogFileCheckBox",False
				DlgVisible "OpenLogFileCheckBox",False
				DlgVisible "FreeByteTipText",False
				DlgVisible "TranStrOnlyMsgCheckBox",False
			End If

			If DlgValue("MenuList") = 4 Then
				DlgVisible "OpenFileModeGroup",True
				DlgVisible "OpenFileModeOption",True

				DlgVisible "VoiceGroup",True
				DlgVisible "GetStringVoiceCheckBox",True
				DlgVisible "ImportSrcVoiceCheckBox",True
				DlgVisible "ImportTrnVoiceCheckBox",True
				DlgVisible "ParseStrDataVoiceCheckBox",True
				DlgVisible "GetStrTypeVoiceCheckBox",True
				DlgVisible "MoveStringVoiceCheckBox",True
				DlgVisible "AddAndDelFilterVoiceCheckBox",True
				DlgVisible "AddAndDelReserveVoiceCheckBox",True
				DlgVisible "WriteStringVoiceCheckBox",True
			Else
				DlgVisible "OpenFileModeGroup",False
				DlgVisible "OpenFileModeOption",False

				DlgVisible "VoiceGroup",False
				DlgVisible "GetStringVoiceCheckBox",False
				DlgVisible "ImportSrcVoiceCheckBox",False
				DlgVisible "ImportTrnVoiceCheckBox",False
				DlgVisible "ParseStrDataVoiceCheckBox",False
				DlgVisible "GetStrTypeVoiceCheckBox",False
				DlgVisible "MoveStringVoiceCheckBox",False
				DlgVisible "AddAndDelFilterVoiceCheckBox",False
				DlgVisible "AddAndDelReserveVoiceCheckBox",False
				DlgVisible "WriteStringVoiceCheckBox",False
			End If

			If DlgValue("MenuList") = 5 Then
				DlgVisible "UpdateSetGroup",True
				DlgVisible "UpdateSet",True
				DlgVisible "AutoButton",True
				DlgVisible "ManualButton",True
				DlgVisible "OffButton",True
				DlgVisible "CheckGroup",True
				DlgVisible "UpdateCycleText",True
				DlgVisible "UpdateCycleBox",True
				DlgVisible "UpdateDatesText",True
				DlgVisible "UpdateDateText",True
				DlgVisible "UpdateDateBox",True
				DlgVisible "CheckButton",True
				DlgVisible "WebSiteGroup",True
				DlgVisible "WebSiteBox",True
				DlgVisible "CmdGroup",True
				DlgVisible "CmdPathBoxText",True
				DlgVisible "ArgumentBoxText",True
				DlgVisible "CmdPathBox",True
				DlgVisible "ArgumentBox",True
				DlgVisible "ExeBrowseButton",True
				DlgVisible "ArgumentButton",True
			Else
				DlgVisible "UpdateSetGroup",False
				DlgVisible "UpdateSet",False
				DlgVisible "AutoButton",False
				DlgVisible "ManualButton",False
				DlgVisible "OffButton",False
				DlgVisible "CheckGroup",False
				DlgVisible "UpdateCycleText",False
				DlgVisible "UpdateCycleBox",False
				DlgVisible "UpdateDatesText",False
				DlgVisible "UpdateDateText",False
				DlgVisible "UpdateDateBox",False
				DlgVisible "CheckButton",False
				DlgVisible "WebSiteGroup",False
				DlgVisible "WebSiteBox",False
				DlgVisible "CmdGroup",False
				DlgVisible "CmdPathBoxText",False
				DlgVisible "ArgumentBoxText",False
				DlgVisible "CmdPathBox",False
				DlgVisible "ArgumentBox",False
				DlgVisible "ExeBrowseButton",False
				DlgVisible "ArgumentButton",False
			End If

			If DlgValue("MenuList") = 6 Then
				DlgVisible "UILangSetGroup",True
				DlgVisible "UILangSetText1",True
				DlgVisible "UILangSetText2",True
				DlgVisible "UILangList",True

				DlgVisible "UIFontSetGroup",True
				DlgVisible "MainFontText",True
				DlgVisible "SrcStrFontText",True
				DlgVisible "TrnStrFontText",True
				DlgVisible "MainFontBox",True
				DlgVisible "SrcStrFontBox",True
				DlgVisible "TrnStrFontBox",True
				DlgVisible "MainFontButton",True
				DlgVisible "SrcStrFontButton",True
				DlgVisible "TrnStrFontButton",True

				DlgVisible "NumDisplayFormatText",True
				DlgVisible "NumDisplayFormatGroup",True
				DlgVisible "MsgOutputGroupText",True
				DlgVisible "MsgOutputGroup",True

				DlgVisible "OtherGroup",True
				DlgVisible "SpaceWithPointCheckBox",True
				DlgVisible "FilterDisplayAtStartupBox",True
			Else
				DlgVisible "UILangSetGroup",False
				DlgVisible "UILangSetText1",False
				DlgVisible "UILangSetText2",False
				DlgVisible "UILangList",False

				DlgVisible "UIFontSetGroup",False
				DlgVisible "MainFontText",False
				DlgVisible "SrcStrFontText",False
				DlgVisible "TrnStrFontText",False
				DlgVisible "MainFontBox",False
				DlgVisible "SrcStrFontBox",False
				DlgVisible "TrnStrFontBox",False
				DlgVisible "MainFontButton",False
				DlgVisible "SrcStrFontButton",False
				DlgVisible "TrnStrFontButton",False

				DlgVisible "NumDisplayFormatText",False
				DlgVisible "NumDisplayFormatGroup",False
				DlgVisible "MsgOutputGroupText",False
				DlgVisible "MsgOutputGroup",False

				DlgVisible "OtherGroup",False
				DlgVisible "SpaceWithPointCheckBox",False
				DlgVisible "FilterDisplayAtStartupBox",False
			End If

			If DlgValue("MenuList") = 7 Then
				DlgVisible "HelpSystemGroup",True
				DlgVisible "HelpSystemText",True
				DlgVisible "HelpSystemOption",True
				DlgVisible "TextHelpSystemButton",True
				DlgVisible "CHMHelpSystemButton",True
			Else
				DlgVisible "HelpSystemGroup",False
				DlgVisible "HelpSystemText",False
				DlgVisible "HelpSystemOption",False
				DlgVisible "TextHelpSystemButton",False
				DlgVisible "CHMHelpSystemButton",False
			End If

			Select Case DlgValue("MenuList")
			Case Is < 5
				DlgVisible "ResetButton",True
				DlgVisible "TestButton",False
				DlgVisible "CleanButton",True
				DlgVisible "EditUILangButton",False
			Case 5
				DlgVisible "ResetButton",True
				DlgVisible "TestButton",True
				DlgVisible "CleanButton",True
				DlgVisible "EditUILangButton",False
			Case 6
				DlgVisible "ResetButton",False
				DlgVisible "TestButton",False
				DlgVisible "CleanButton",False
				DlgVisible "EditUILangButton",True
			Case 7
				DlgVisible "ResetButton",True
				DlgVisible "TestButton",False
				DlgVisible "CleanButton",False
				DlgVisible "EditUILangButton",False
			End Select
			Exit Function
		Case "HelpButton"
			Select Case DlgValue("MenuList")
			Case 0
				If StrToLong(Selected(30)) = 1 Then
					If OpenCHM(CLng(DlgText("SuppValueBox")),1012,Selected(0),OSLanguage,UIFileList) = True Then Exit Function
				End If
				Call Help("StrTypeSetHelp")
			Case 1
				If StrToLong(Selected(30)) = 1 Then
					If OpenCHM(CLng(DlgText("SuppValueBox")),1021,Selected(0),OSLanguage,UIFileList) = True Then Exit Function
				End If
				Call Help("RefTypeSetHelp")
			Case 2
				If StrToLong(Selected(30)) = 1 Then
					If OpenCHM(CLng(DlgText("SuppValueBox")),1005,Selected(0),OSLanguage,UIFileList) = True Then Exit Function
				End If
				Call Help("EncodeRangeSetHelp")
			Case 3
				If StrToLong(Selected(30)) = 1 Then
					If OpenCHM(CLng(DlgText("SuppValueBox")),1026,Selected(0),OSLanguage,UIFileList) = True Then Exit Function
				End If
				Call Help("WriteSetHelp")
			Case 4
				If StrToLong(Selected(30)) = 1 Then
					If OpenCHM(CLng(DlgText("SuppValueBox")),1013,Selected(0),OSLanguage,UIFileList) = True Then Exit Function
				End If
				Call Help("FileReadWriteAndVoiceSetHelp")
			Case 5
				If StrToLong(Selected(30)) = 1 Then
					If OpenCHM(CLng(DlgText("SuppValueBox")),1003,Selected(0),OSLanguage,UIFileList) = True Then Exit Function
				End If
				Call Help("UpdateSetHelp")
			Case 6
				If StrToLong(Selected(30)) = 1 Then
					If OpenCHM(CLng(DlgText("SuppValueBox")),1027,Selected(0),OSLanguage,UIFileList) = True Then Exit Function
				End If
				Call Help("UILangSetHelp")
			Case 7
				If StrToLong(Selected(30)) = 1 Then
					If OpenCHM(CLng(DlgText("SuppValueBox")),1028,Selected(0),OSLanguage,UIFileList) = True Then Exit Function
				End If
				Call Help("HelpSystemSetHelp")
			End Select
			Exit Function
		Case "CancelButton"
			Temp = Selected(0)
			Selected = SelectedBak
			Selected(0) = Temp
			UpdateSet = UpdateSetBak
			StrTypeList = StrTypeListBak
			RefTypeList = RefTypeListBak
			UniLangList = UniLangListBak
			SettingsDlgFunc = False
			Exit Function
		Case "OKButton"
			'检查自动更新配置
			If DlgText("CmdPathBox") = "" And DlgText("ArgumentBox") = "" Then
				MsgBox MsgList(7),vbOkOnly+vbInformation,MsgList(0)
			ElseIf Dir$(DlgText("CmdPathBox")) = "" Then
				MsgBox MsgList(61),vbOkOnly+vbInformation,MsgList(0)
				Exit Function
			End If
			'检查字串类型配置
			Set Dic = CreateObject("Scripting.Dictionary")
			If CheckStrTypeArray(StrTypeList) = True Then
				For i = 0 To UBound(StrTypeList)
					With StrTypeList(i)
						For j = 0 To 2
							Select Case j
							Case 0
								Temp = IIf(.CodeLoc = 0,.StartCodeString,.CPCodeStartString)
							Case 1
								Temp = IIf(.CodeLoc = 0,.EndCodeString,.LengthCodeStartString)
							Case 2
								Temp = IIf(.CodeLoc = 0,"",.RefCodeStartString)
							End Select
							If Temp <> "" And Temp <> "00" Then
								If InStr(Temp,"\") Then
									MsgBox Replace$(Replace$(MsgList(21),"%s",.sName),"%d",MsgList(14)),vbOkOnly+vbInformation,MsgList(0)
									Set Dic = Nothing
									Exit Function
								ElseIf (Len(Temp) Mod 2) <> 0 Then
									MsgBox Replace$(Replace$(MsgList(21),"%s",.sName),"%d",MsgList(15)),vbOkOnly+vbInformation,MsgList(0)
									Set Dic = Nothing
									Exit Function
								ElseIf Temp = "00" Then
									MsgBox Replace$(Replace$(MsgList(21),"%s",.sName),"%d",MsgList(16)),vbOkOnly+vbInformation,MsgList(0)
									Set Dic = Nothing
									Exit Function
								ElseIf Left$(Temp,2) = "00" Then
									MsgBox Replace$(Replace$(MsgList(21),"%s",.sName),"%d",MsgList(17)),vbOkOnly+vbInformation,MsgList(0)
									Set Dic = Nothing
									Exit Function
								ElseIf CheckStrRegExp(Temp,CheckSkipStr(6),0,1,True) = False Then
									MsgBox Replace$(Replace$(MsgList(21),"%s",.sName),"%d",MsgList(18)),vbOkOnly+vbInformation,MsgList(0)
									Set Dic = Nothing
									Exit Function
								End If
							End If
						Next j
						If .CodeLoc = 0 Then
							.CPCodeStartString = ""
							.CPCodeStartLength = 0
							.CPCodeStartByte = HexStr2Bytes(.CPCodeStartString)
							.LengthCodeStartString = ""
							.LengthCodeStartLength = 0
							.LengthCodeStartByte = HexStr2Bytes(.LengthCodeStartString)
							.RefCodeStartPos = 0
							.RefCodeStartString = ""
							.RefCodeStartLength = 0
							.RefCodeStartByte = HexStr2Bytes(.RefCodeStartString)
							If Abs(.CPCodePos) + Abs(.LengthCodePos) + Abs(.StartCodePos) > 0 Then
								ReDim intList(2) As Long
								intList(0) = IIf(.CPCodePos < 0,0,.CPCodePos)
								intList(1) = IIf(.LengthCodePos < 0,0,.LengthCodePos)
								intList(2) = IIf(.StartCodePos < 0,.StartCodeLength,.StartCodePos)
								Call SortNumArray(intList,0,2,True)
								n = IIf(.CPCodePos = 0,0,IIf(.CPCodeSize = 0,2,.CPCodeSize)) + _
									IIf(.LengthCodePos = 0,0,IIf(.LengthCodeSize = 0,1,.LengthCodeSize)) + _
									IIf(.StartCodePos = 0,0,IIf(.StartCodePos > 0,.StartCodePos,.StartCodeLength))
								If intList(0) > n Then n = intList(0)
								If .LengthCodePos <> 0 Then
									If .LengthMode = 5 Or .LengthMode = 6 Or .LengthMode = 9 Then
										n = n + IIf(.LengthCodePos < 0 And .LengthCodeSize = 0,3,4)
									ElseIf .LengthMode = 7 Or .LengthMode = 8 Then
										n = n + IIf(.LengthCodePos < 0 And .LengthCodeSize = 0,7,8)
									End If
								End If
								If .FristCodePos < n Then
									If .LengthMode > 4 Then
										If MsgBox(Replace$(Replace$(MsgList(38),"%s",.sName),"%d",Replace$(MsgList(19),"%s",CStr(n))), _
												vbYesNo+vbInformation,MsgList(12)) = vbYes Then
											Set Dic = Nothing
											Exit Function
										End If
									Else
										MsgBox Replace$(Replace$(MsgList(21),"%s",.sName),"%d",Replace$(MsgList(19),"%s",CStr(n))), _
												vbOkOnly+vbInformation,MsgList(0)
										Set Dic = Nothing
										Exit Function
									End If
								ElseIf .StartCodePos < 0 And .StartCodeLength = 0 Then
									MsgBox Replace$(Replace$(MsgList(21),"%s",.sName),"%d",MsgList(36)),vbOkOnly+vbInformation,MsgList(0)
									Set Dic = Nothing
									Exit Function
								ElseIf .CPCodePos = 0 And .CPCodeSize <> 0 Then
									MsgBox Replace$(Replace$(MsgList(21),"%s",.sName),"%d",MsgList(62)),vbOkOnly+vbInformation,MsgList(0)
									Set Dic = Nothing
									Exit Function
								ElseIf .LengthCodePos = 0 And .LengthCodeSize <> 0 Then
									MsgBox Replace$(Replace$(MsgList(21),"%s",.sName),"%d",MsgList(63)),vbOkOnly+vbInformation,MsgList(0)
									Set Dic = Nothing
									Exit Function
								ElseIf .StartCodePos = 0 And .StartCodeLength <> 0 Then
									MsgBox Replace$(Replace$(MsgList(21),"%s",.sName),"%d",MsgList(64)),vbOkOnly+vbInformation,MsgList(0)
									Set Dic = Nothing
									Exit Function
								End If
							ElseIf .FristCodePos > 0 Or (.EndCodeLength = 0 And i > 0) Then
								MsgBox Replace$(Replace$(MsgList(21),"%s",.sName),"%d",MsgList(60)),vbOkOnly+vbInformation,MsgList(0)
								Set Dic = Nothing
								Exit Function
							End If
						Else
							.StartCodePos = 0
							.StartCodeString = ""
							.StartCodeLength = 0
							.StartCodeByte = HexStr2Bytes(.StartCodeString)
							.EndCodeString = ""
							.EndCodeLength =0
							.EndCodeByte = HexStr2Bytes(.StartCodeString)
							If Abs(.CPCodePos) + Abs(.LengthCodePos) > 0 Then
								If .CodeLoc = 1 Then
									ReDim intList(2) As Long
									intList(0) = IIf(.CPCodePos < 0,0,.CPCodePos)
									intList(1) = IIf(.LengthCodePos < 0,0,.LengthCodePos)
									intList(2) = IIf(.RefCodeStartPos < 0,.RefCodeStartLength,.RefCodeStartPos)
									Call SortNumArray(intList,0,2,True)
									n = .CPCodeStartLength + .LengthCodeStartLength + _
										IIf(.CPCodePos = 0,0,IIf(.CPCodeSize = 0,2,.CPCodeSize)) + _
										IIf(.LengthCodePos = 0,0,IIf(.LengthCodeSize = 0,1,.LengthCodeSize)) + _
										IIf(.RefCodeStartPos = 0,0,IIf(.RefCodeStartPos > 0,.RefCodeStartPos,.RefCodeStartLength))
									If intList(0) > n Then n = intList(0)
									If .FristCodePos < n Then
										MsgBox Replace$(Replace$(MsgList(21),"%s",.sName),"%d",Replace$(MsgList(19),"%s",CStr(n))), _
												vbOkOnly+vbInformation,MsgList(0)
										Set Dic = Nothing
										Exit Function
									End If
								Else
									Call SortNumArray(intList,0,2,True)
									n = .CPCodeStartLength + .LengthCodeStartLength + _
										IIf(.CPCodePos = 0,0,IIf(.CPCodeSize = 0,2,.CPCodeSize)) + _
										IIf(.LengthCodePos = 0,0,IIf(.LengthCodeSize = 0,1,.LengthCodeSize)) + _
										IIf(.RefCodeStartPos = 0,0,.RefCodeStartLength)
									j = IIf(.RefCodeStartPos = 0,0,IIf(.RefCodeStartPos > 0,.RefCodeStartPos + .RefCodeStartLength,.RefCodeStartLength))
									If j > n Then n = j
									If .FristCodePos < n Then
										MsgBox Replace$(Replace$(MsgList(21),"%s",.sName),"%d",Replace$(MsgList(68),"%s",CStr(n))), _
												vbOkOnly+vbInformation,MsgList(0)
										Set Dic = Nothing
										Exit Function
									End If
								End If
								If .RefCodeStartPos < 0 And .RefCodeStartLength = 0 Then
									MsgBox Replace$(Replace$(MsgList(21),"%s",.sName),"%d",MsgList(37)),vbOkOnly+vbInformation,MsgList(0)
									Set Dic = Nothing
									Exit Function
								ElseIf .CPCodePos = 0 And .CPCodeSize <> 0 Then
									MsgBox Replace$(Replace$(MsgList(21),"%s",.sName),"%d",MsgList(62)),vbOkOnly+vbInformation,MsgList(0)
									Set Dic = Nothing
									Exit Function
								ElseIf .LengthCodePos = 0 And .LengthCodeSize <> 0 Then
									MsgBox Replace$(Replace$(MsgList(21),"%s",.sName),"%d",MsgList(63)),vbOkOnly+vbInformation,MsgList(0)
									Set Dic = Nothing
									Exit Function
								ElseIf .RefCodeStartPos = 0 And .RefCodeStartLength <> 0 Then
									MsgBox Replace$(Replace$(MsgList(21),"%s",.sName),"%d",MsgList(65)),vbOkOnly+vbInformation,MsgList(0)
									Set Dic = Nothing
									Exit Function
								End If
							ElseIf .FristCodePos > 0 Or i > 0 Then
								MsgBox Replace$(Replace$(MsgList(21),"%s",.sName),"%d",MsgList(60)),vbOkOnly+vbInformation,MsgList(0)
								Set Dic = Nothing
								Exit Function
							End If
						End If
						Temp = StrTypeToString(StrTypeList,i)
						If Dic.Exists(Temp) Then
							MsgBox Replace$(Replace$(MsgList(40),"%s",StrTypeList(i).sName),"%d",StrTypeList(Dic.Item(Temp)).sName), _
									vbOkOnly+vbInformation,MsgList(0)
							Set Dic = Nothing
							Exit Function
						Else
							Dic.Add(Temp,i)
						End If
						If Dic.Exists(.sName) Then
							MsgBox Replace$(Replace$(MsgList(21),"%s",.sName),"%d",MsgList(66)),vbOkOnly+vbInformation,MsgList(0)
							Set Dic = Nothing
							Exit Function
						Else
							Dic.Add(.sName,i)
						End If
					End With
				Next i
				'转换更改的自定义字串类型为正则表达式模板
				Call StrType2RegExpPattern(StrTypeList)
				'更新 HCS 文件中的字串类型名称，用于字串编辑对话框的显示
				If CheckStrTypeArray(OrgStrTypeList) = True Then
					'检查名称是否被当前字串所使用
					n = UBound(OrgStrTypeList)
					ReDim TempData(n) As STRING_TYPE,TempList(n) As String
					TempData = OrgStrTypeList
					j = 0
					'更新 HCS 文件中的字串类型名称
					For i = 0 To UBound(OrgStrTypeList)
						Temp = StrTypeToString(OrgStrTypeList,i)
						If Dic.Exists(Temp) Then
							TempData(i).sName = StrTypeList(Dic.Item(Temp)).sName
						ElseIf Dic.Exists(OrgStrTypeList(i).sName) Then
							TempList(j) = OrgStrTypeList(i).sName
							j = j + 1
						End If
					Next i
					If j > 0 Then
						ReDim Preserve TempList(j - 1) As String
						MsgBox Replace$(MsgList(67),"%s",StrListJoin(TempList,vbCrLf)),vbOkOnly+vbInformation,MsgList(0)
						Set Dic = Nothing
						Exit Function
					End If
					OrgStrTypeList = TempData
				End If
				'更新当前正在使用的字串类型名称和数据
				If CheckStrTypeArray(UseStrTypeList) = True Then
					n = UBound(StrTypeList)
					ReDim TempData(n) As STRING_TYPE,TempList(n) As String
					n = 0: j = 0
					For i = 0 To UBound(UseStrTypeList)
						Temp = StrTypeToString(UseStrTypeList,i)
						If Dic.Exists(Temp) Then
							TempData(n) = StrTypeList(Dic.Item(Temp))
							n = n + 1
						Else
							TempList(j) = UseStrTypeList(i).sName
							j = j + 1
						End If
					Next i
					If j > 0 Then
						ReDim Preserve TempList(j - 1) As String
						If MsgBox(Replace$(MsgList(22),"%s",StrListJoin(TempList,vbCrLf)), _
								vbYesNo+vbInformation,MsgList(12)) = vbNo Then
							Set Dic = Nothing
							Exit Function
						End If
					End If
					If n > 0 Then n = n - 1
					ReDim Preserve TempData(n) As STRING_TYPE
					UseStrTypeList = TempData
				End If
				Dic.RemoveAll
			ElseIf CheckStrTypeArray(UseStrTypeList) = True Then
				TempList = GetStrTypeNameList(UseStrTypeList)
				Temp = Replace$(MsgList(41),"%s",StrListJoin(TempList,vbCrLf))
				If MsgBox(Temp,vbYesNo+vbInformation,MsgList(12)) = vbNo Then
					Set Dic = Nothing
					Exit Function
				End If
				ReDim UseStrTypeList(0) As STRING_TYPE
			End If
			'检查引用算法
			If CheckRefTypeArray(RefTypeList) = True Then
				For i = 0 To UBound(RefTypeList)
					With RefTypeList(i)
						If .Algorithm = "" Then
							MsgBox Replace$(Replace$(MsgList(71),"%s",.sName),"%d",MsgList(72)),vbOkOnly+vbInformation,MsgList(0)
							Set Dic = Nothing
							Exit Function
						ElseIf CheckStrRegExp(.Algorithm,"[0-9\{\}StrAdesfTypLngth\+\-\x20]",0,1,True) = False Then
							MsgBox Replace$(Replace$(MsgList(71),"%s",.sName),"%d",MsgList(73)),vbOkOnly+vbInformation,MsgList(0)
							Set Dic = Nothing
							Exit Function
						ElseIf .ByteLength < 1 Then
							MsgBox Replace$(Replace$(MsgList(71),"%s",.sName),"%d",MsgList(74)),vbOkOnly+vbInformation,MsgList(0)
							Set Dic = Nothing
							Exit Function
						ElseIf (.ByteLength Mod 2) <> 0 Then
							MsgBox Replace$(Replace$(MsgList(71),"%s",.sName),"%d",MsgList(82)),vbOkOnly+vbInformation,MsgList(0)
							Set Dic = Nothing
							Exit Function
						ElseIf .PrefixByte <> "" Then
							If CheckRegExp(RegExp,.PrefixByte) = False Then
								MsgBox Replace$(Replace$(MsgList(71),"%s",.sName),"%d",MsgList(77)),vbOkOnly+vbInformation,MsgList(0)
								Set Dic = Nothing
								Exit Function
							ElseIf .PrefixLength < 1 Then
								MsgBox Replace$(Replace$(MsgList(71),"%s",.sName),"%d",MsgList(74)),vbOkOnly+vbInformation,MsgList(0)
								Set Dic = Nothing
								Exit Function
							End If
						ElseIf .PrefixLength > 0 Then
							MsgBox Replace$(Replace$(MsgList(71),"%s",.sName),"%d",MsgList(81)),vbOkOnly+vbInformation,MsgList(0)
							Set Dic = Nothing
							Exit Function
						ElseIf .StrAddAlgorithm <> "" Then
							If CheckStrRegExp(.StrAddAlgorithm,"[0-9\{\}RefCodStrAdsTypLngth\+\-\x20]",0,1,True) = False Then
								MsgBox Replace$(Replace$(MsgList(71),"%s",.sName),"%d",MsgList(84)),vbOkOnly+vbInformation,MsgList(0)
								Set Dic = Nothing
								Exit Function
							End If
						End If
						Temp = RefTypeToString(RefTypeList,i)
						If Dic.Exists(Temp) Then
							MsgBox Replace$(Replace$(MsgList(78),"%s",.sName),"%d",RefTypeList(Dic.Item(Temp)).sName), _
										vbOkOnly+vbInformation,MsgList(0)
							Set Dic = Nothing
							Exit Function
						Else
							Dic.Add(Temp,i)
						End If
						If Dic.Exists(.sName) Then
							MsgBox Replace$(Replace$(MsgList(71),"%s",.sName),"%d",MsgList(79)),vbOkOnly+vbInformation,MsgList(0)
							Set Dic = Nothing
							Exit Function
						Else
							Dic.Add(.sName,i)
						End If
					End With
				Next i
				'检查当前使用的算法是否还存在
				If CheckRefTypeArray(UseRefTypeList) = True Then
					j = 0
					For i = 0 To UBound(RefTypeList)
						If RefTypeList(i).Template <> UseRefTypeList(0).Template Then
							If RefTypeList(i).sName = UseRefTypeList(0).sName Then
								j = j + 1
								Exit For
							End If
						End If
					Next i
					If j > 0 Then
						MsgBox Replace$(MsgList(75),"%s",UseRefTypeList(0).sName),vbOkOnly+vbInformation,MsgList(0)
						Set Dic = Nothing
						Exit Function
					End If
				End If
				Dic.RemoveAll
			ElseIf CheckRefTypeArray(UseRefTypeList) = True Then
				Temp = Replace$(MsgList(80),"%s",UseRefTypeList(0).sName)
				If MsgBox(Temp,vbYesNo+vbInformation,MsgList(12)) = vbNo Then
					Set Dic = Nothing
					Exit Function
				End If
				ReDim UseRefTypeList(1) As REF_TYPE
			End If
			'检查代码页错误
			For i = 0 To UBound(UniLangList)
				With UniLangList(i)
					If .UniCodeRange = "" Then .CodePage = CP_UNKNOWN
					If .CodePage <> CP_UNKNOWN And .UniCodeRange = "" Then
						MsgBox Replace$(Replace$(MsgList(56),"%s",.LangName),"%d",MsgList(57)),vbOkOnly+vbInformation,MsgList(0)
						Set Dic = Nothing
						Exit Function
					ElseIf .FeatureCodeEnable = 1 And .FeatureCode = "" Then
						MsgBox Replace$(Replace$(MsgList(56),"%s",.LangName),"%d",MsgList(57)),vbOkOnly+vbInformation,MsgList(0)
						Set Dic = Nothing
						Exit Function
					ElseIf IsNumeric(Abs(.LangID)) = False Then
						MsgBox Replace$(Replace$(MsgList(56),"%s",.LangName),"%d",MsgList(20)),vbOkOnly+vbInformation,MsgList(0)
						Set Dic = Nothing
						Exit Function
					ElseIf IsNumeric(.CodePage) = False Then
						MsgBox Replace$(Replace$(MsgList(56),"%s",.LangName),"%d",MsgList(54)),vbOkOnly+vbInformation,MsgList(0)
						Set Dic = Nothing
						Exit Function
					ElseIf Dic.Exists(.LangID) Then
						Temp = UniLangList(Dic.Item(.LangID)).LangName
						MsgBox Replace$(Replace$(MsgList(52),"%s",.LangName),"%d",Temp),vbOkOnly+vbInformation,MsgList(0)
						Set Dic = Nothing
						Exit Function
					End If
					If .UniCodeRange <> "" Then
						If InStr(.UniCodeRange,"\") Then
							MsgBox Replace$(Replace$(MsgList(56),"%s",.LangName),"%d",MsgList(14)),vbOkOnly+vbInformation,MsgList(0)
							Set Dic = Nothing
							Exit Function
						ElseIf (Len(Replace$(Replace$(.UniCodeRange,",",""),"-","")) Mod 4) <> 0 Then
							MsgBox Replace$(Replace$(MsgList(56),"%s",.LangName),"%d",MsgList(15)),vbOkOnly+vbInformation,MsgList(0)
							Set Dic = Nothing
							Exit Function
						ElseIf CheckStrRegExp(Replace$(Replace$(.UniCodeRange,",",""),"-",""),CheckSkipStr(6),0,1,True) = False Then
							MsgBox Replace$(Replace$(MsgList(56),"%s",.LangName),"%d",MsgList(18)),vbOkOnly+vbInformation,MsgList(0)
							Set Dic = Nothing
							Exit Function
						ElseIf CheckStrRegExp(.UniCodeRange,"[0-9a-f]{4}([-,][0-9a-f]{4})*",0,5,True) = False Then
							MsgBox Replace$(Replace$(MsgList(56),"%s",.LangName),"%d",MsgList(59)),vbOkOnly+vbInformation,MsgList(0)
							Set Dic = Nothing
							Exit Function
						End If
					End If
					If .FeatureCode <> "" Then
						If InStr(.FeatureCode,"\") Then
							MsgBox Replace$(Replace$(MsgList(56),"%s",.LangName),"%d",MsgList(14)),vbOkOnly+vbInformation,MsgList(0)
							Set Dic = Nothing
							Exit Function
						ElseIf (Len(Replace$(Replace$(.FeatureCode,",",""),"-","")) Mod 4) <> 0 Then
							MsgBox Replace$(Replace$(MsgList(56),"%s",.LangName),"%d",MsgList(15)),vbOkOnly+vbInformation,MsgList(0)
							Set Dic = Nothing
							Exit Function
						ElseIf CheckStrRegExp(Replace$(Replace$(.FeatureCode,",",""),"-",""),CheckSkipStr(6),0,1,True) = False Then
							MsgBox Replace$(Replace$(MsgList(56),"%s",.LangName),"%d",MsgList(18)),vbOkOnly+vbInformation,MsgList(0)
							Set Dic = Nothing
							Exit Function
						ElseIf CheckStrRegExp(.FeatureCode,"[0-9a-f]{4}([-,][0-9a-f]{4})*",0,5,True) = False Then
							MsgBox Replace$(Replace$(MsgList(56),"%s",.LangName),"%d",MsgList(59)),vbOkOnly+vbInformation,MsgList(0)
							Set Dic = Nothing
							Exit Function
						End If
					End If
					Dic.Add(.LangID,i)
				End With
			Next i
			Set Dic = Nothing
			'更新代码页字典
			LangIDIndexDic.RemoveAll
			For i = 0 To UBound(UniLangList)
				If Not LangIDIndexDic.Exists(UniLangList(i).LangID) Then
					LangIDIndexDic.Add(UniLangList(i).LangID,i)
				End If
			Next i
			'更新来源文件包含的代码页数据
			For i = 0 To UBound(AllLangList)
				With AllLangList(i)
					If LangIDIndexDic.Exists(.LangID) Then
						j = LangIDIndexDic.Item(.LangID)
						.UniCodeRange = UniLangList(j).UniCodeRange
						.UniCodeRegExpPattern = UniLangList(j).UniCodeRegExpPattern
						.UniCodeByteRange = UniLangList(j).UniCodeByteRange
						.FeatureCode = UniLangList(j).FeatureCode
						.FeatureCodeRegExpPattern = UniLangList(j).FeatureCodeRegExpPattern
						.FeatureCodeByteRange = UniLangList(j).FeatureCodeByteRange
						.FeatureCodeEnable = UniLangList(j).FeatureCodeEnable
					End If
				End With
			Next i
			'更新正在使用的代码页数据
			For i = 0 To UBound(UseLangList)
				With UseLangList(i)
					If LangIDIndexDic.Exists(.LangID) Then
						j = LangIDIndexDic.Item(.LangID)
						.UniCodeRange = UniLangList(j).UniCodeRange
						.UniCodeRegExpPattern = UniLangList(j).UniCodeRegExpPattern
						.UniCodeByteRange = UniLangList(j).UniCodeByteRange
						.FeatureCode = UniLangList(j).FeatureCode
						.FeatureCodeRegExpPattern = UniLangList(j).FeatureCodeRegExpPattern
						.FeatureCodeByteRange = UniLangList(j).FeatureCodeByteRange
						.FeatureCodeEnable = UniLangList(j).FeatureCodeEnable
					End If
				End With
			Next i
			'更新备份
			SelectedBak = Selected
			UpdateSetBak = UpdateSet
			StrTypeListBak = StrTypeList
			RefTypeListBak = RefTypeList
			UniLangListBak = UniLangList
			LFListBak = LFList
			'写入所有配置
			If WriteSettings("Sets") = False Then
				MsgBox Replace$(MsgList(4),"%s",RegKey),vbOkOnly+vbInformation,MsgList(0)
				Exit Function
			End If
			SettingsDlgFunc = False
			Exit Function
		End Select

		Select Case DlgValue("MenuList")
		Case 0
			Select Case DlgItem$
			Case "LevelButton"
				TempList = GetStrTypeNameList(StrTypeList)
				If SetLevel(TempList,DlgValue("StrTypeNameList"),MsgList(24)) = False Then Exit Function
				Temp = DlgText("StrTypeNameList")
				DlgListBoxArray "StrTypeNameList",TempList()
				DlgText "StrTypeNameList",Temp
				Set Dic = CreateObject("Scripting.Dictionary")
				For i = 0 To UBound(StrTypeList)
					If Not Dic.Exists(StrTypeList(i).sName) Then
						Dic.Add(StrTypeList(i).sName,i)
					End If
				Next i
				TempData = StrTypeList
				For i = 0 To UBound(TempList)
					If Dic.Exists(TempList(i)) Then
						TempData(n) = StrTypeList(Dic.Item(TempList(i)))
						n = n + 1
					End If
				Next i
				StrTypeList = TempData
				Set Dic = Nothing
				DlgItem$ = "StrTypeNameList"
			Case "AddButton"
				TempList = GetStrTypeNameList(StrTypeList)
				Temp = AddSet(TempList)
				If Temp = "" Then Exit Function
				HeaderID = UBound(StrTypeList) + 1
				ReDim Preserve TempList(HeaderID) As String,StrTypeList(HeaderID) As STRING_TYPE
				TempList(HeaderID) = Temp
				StrTypeList(HeaderID).sName = Temp
				DlgListBoxArray "StrTypeNameList",TempList()
				DlgValue "StrTypeNameList",HeaderID
				DlgItem$ = "StrTypeNameList"
			Case "ChangeButton"
				HeaderID = DlgValue("StrTypeNameList")
				If HeaderID < 0 Then Exit Function
				For i = 0 To UBound(OrgStrTypeList)
					If OrgStrTypeList(i).sName = StrTypeList(HeaderID).sName Then
						Set Dic = CreateObject("Scripting.Dictionary")
						For j = 0 To UBound(StrTypeList)
							Temp = StrTypeToString(StrTypeList,j)
							If Not Dic.Exists(Temp) Then Dic.Add(Temp,j)
						Next j
						If Not Dic.Exists(StrTypeToString(OrgStrTypeList,i)) Then n = i + 1
						Set Dic = Nothing
						Exit For
					End If
				Next i
				TempList = GetStrTypeNameList(StrTypeList)
				Temp = EditSet(TempList,HeaderID)
				If Temp = "" Then Exit Function
				If n > 0 Then
					i = HeaderID
					HeaderID = UBound(StrTypeList) + 1
					ReDim Preserve TempList(HeaderID) As String,StrTypeList(HeaderID) As STRING_TYPE
					TempList(HeaderID) = Temp
					StrTypeList(HeaderID) = StrTypeList(i)
					StrTypeList(HeaderID).sName = Temp
					StrTypeList(i) = OrgStrTypeList(n - 1)
					DlgListBoxArray "StrTypeNameList",TempList()
					DlgValue "StrTypeNameList",HeaderID
					DlgItem$ = "StrTypeNameList"
				Else
					TempList(HeaderID) = Temp
					StrTypeList(HeaderID).sName = Temp
					DlgListBoxArray "StrTypeNameList",TempList()
					DlgValue "StrTypeNameList",HeaderID
					Exit Function
				End If
			Case "DelButton"
				HeaderID = DlgValue("StrTypeNameList")
				If HeaderID < 0 Then Exit Function
				If MsgBox(Replace(MsgList(13),"%s",DlgText("StrTypeNameList")),vbYesNo+vbInformation,MsgList(12)) = vbNo Then
					Exit Function
				End If
				Call DelStrTypeArray(StrTypeList,HeaderID)
				TempList = GetStrTypeNameList(StrTypeList)
				If HeaderID = UBound(TempList) + 1 Then HeaderID = HeaderID - 1
				DlgListBoxArray "StrTypeNameList",TempList()
				DlgValue "StrTypeNameList",HeaderID
				DlgItem$ = "StrTypeNameList"
			Case "ResetButton"
				HeaderID = DlgValue("StrTypeNameList")
				If HeaderID < 0 Then Exit Function
				ReDim TempArray(UBound(StrTypeList)) As String
				TempArray(0) = MsgList(2)
				For i = LBound(StrTypeList) To UBound(StrTypeList)
					If i <> HeaderID Then
						n = n + 1
						TempArray(n) = MsgList(11) & " - " & StrTypeList(i).sName
					End If
				Next i
				ReDim Preserve TempArray(n) As String
				n = ShowPopupMenu(TempArray,vbPopupUseRightButton)
				If n < 0 Then Exit Function
				If n = 0 Then
					Temp = DlgText("StrTypeNameList")
					For i = LBound(StrTypeListBak) To UBound(StrTypeListBak)
						If StrTypeListBak(i).sName = Temp Then
							StrTypeList(HeaderID) = StrTypeListBak(i)
							StrTypeList(HeaderID).sName = Temp
							Stemp = True
							Exit For
						End If
					Next i
				Else
					Temp = Mid$(TempArray(n),InStr(TempArray(n),"-") + 2)
					For i = LBound(StrTypeList) To UBound(StrTypeList)
						If StrTypeList(i).sName = Temp Then
							StrTypeList(HeaderID) = StrTypeList(i)
							StrTypeList(HeaderID).sName = DlgText("StrTypeNameList")
							Stemp = True
							Exit For
						End If
					Next i
				End If
				If Stemp = False Then Exit Function
				DlgItem$ = "StrTypeNameList"
			Case "CleanButton"
				HeaderID = DlgValue("StrTypeNameList")
				If HeaderID < 0 Then Exit Function
				DlgValue "FristCodePosList",0
				DlgValue "CPCodePosList",1
				DlgValue "CPCodeSizeList",0
				DlgValue "LengthCodePosList",1
				DlgValue "LengthCodeSizeList",0
				DlgValue "LengthReviseNameList",0
				DlgText "ByteLengthReviseValList","0"
				DlgText "CharLengthReviseValList","0"
				DlgValue "LengthModeList",0
				DlgValue "StartCodePosList",1
				DlgText "StartCodeStrBox",""
				DlgText "EndCodeStrBox",""
				DlgValue "RefFristCodePosList",0
				DlgValue "RefCPCodePosList",1
				DlgValue "RefCPCodeSizeList",0
				DlgValue "RefLengthCodePosList",1
				DlgValue "RefLengthCodeSizeList",0
				DlgValue "RefLengthReviseNameList",0
				DlgText "RefByteLengthReviseValList","0"
				DlgText "RefCharLengthReviseValList","0"
				DlgValue "RefLengthModeList",0
				DlgText "RefCPCodeBefStrBox",""
				DlgText "RefLengthCodeBefStrBox",""
				DlgValue "RefCodeBefPosList",1
				DlgText "RefCodeBefStrBox",""
				With StrTypeList(HeaderID)
					.FristCodePos = 0
					.CPCodePos = 0
					.CPCodeSize = 0
					.CPCodeStartString = ""
					.CPCodeStartLength = 0
					.CPCodeStartByte = HexStr2Bytes(.CPCodeStartString)
					.LengthCodePos = 0
					.LengthCodeSize = 0
					.ByteLengthReviseVal = 0
					.CharLengthReviseVal = 0
					.LengthReviseVal = 0
					.LengthMode = 0
					.LengthCodeStartString = ""
					.LengthCodeStartLength = 0
					.LengthCodeStartByte = HexStr2Bytes(.LengthCodeStartString)
					.StartCodePos = 0
					.StartCodeString = ""
					.StartCodeLength = 0
					.StartCodeByte = HexStr2Bytes(.StartCodeString)
					.EndCodeString = ""
					.EndCodeLength = 0
					.EndCodeByte = HexStr2Bytes(.EndCodeString)
					.RefCodeStartPos = 0
					.RefCodeStartString = ""
					.RefCodeStartLength = 0
					.RefCodeStartByte = HexStr2Bytes(.RefCodeStartString)
				End With
				Exit Function
			Case "FristCodePosList", "RefFristCodePosList"
				HeaderID = DlgValue("StrTypeNameList")
				If HeaderID < 0 Then Exit Function
				With StrTypeList(HeaderID)
					If DlgItem$ = "FristCodePosList" Then
						If Abs(.CPCodePos) + Abs(.LengthCodePos) + Abs(.StartCodePos) > 0 Then
							i = StrToLong(DlgText("FristCodePosList"))
							ReDim intList(2) As Long
							intList(0) = IIf(.CPCodePos < 0,0,.CPCodePos)
							intList(1) = IIf(.LengthCodePos < 0,0,.LengthCodePos)
							intList(2) = IIf(.StartCodePos < 0,.StartCodeLength,.StartCodePos)
							Call SortNumArray(intList,0,2,True)
							n = IIf(.CPCodePos = 0,0,IIf(.CPCodeSize = 0,2,.CPCodeSize)) + _
								IIf(.LengthCodePos = 0,0,IIf(.LengthCodeSize = 0,1,.LengthCodeSize)) + _
								IIf(.StartCodePos = 0,0,IIf(.StartCodePos > 0,.StartCodePos,.StartCodeLength))
							If intList(0) > n Then n = intList(0)
							If .LengthCodePos <> 0 Then
								If .LengthMode = 5 Or .LengthMode = 6 Or .LengthMode = 9 Then
									n = n + IIf(.LengthCodePos < 0 And .LengthCodeSize = 0,3,4): Temp = "1-4"
								ElseIf .LengthMode = 7 Or .LengthMode = 8 Or (.LengthMode = 0 And .LengthCodeSize < 1) Then
									n = n + IIf(.LengthCodePos < 0 And .LengthCodeSize = 0,7,8): Temp = "2-8"
								End If
							End If
							If i < n Then
								If .LengthMode > 4 Then
									MsgBox Replace$(Replace$(MsgList(31),"%s",CStr(n)),"%d",Temp),vbOkOnly+vbInformation,MsgList(0)
									DlgText "FristCodePosList",CStr(.FristCodePos)
									Exit Function
								ElseIf .LengthMode = 0 And .LengthCodeSize < 1 Then
									If MsgBox(Replace$(Replace$(MsgList(32),"%s",CStr(n)),"%d",Temp),vbYesNo+vbInformation,MsgList(12)) = vbNo Then
										DlgText "FristCodePosList",CStr(.FristCodePos)
										Exit Function
									End If
								Else
									MsgBox Replace$(MsgList(19),"%s",CStr(n)),vbOkOnly+vbInformation,MsgList(0)
									DlgText "FristCodePosList",CStr(.FristCodePos)
									Exit Function
								End If
							End If
						End If
						.FristCodePos = StrToLong(DlgText("FristCodePosList"))
					Else
						If Abs(.CPCodePos) + Abs(.LengthCodePos) + Abs(.RefCodeStartPos) > 0 Then
							i = StrToLong(DlgText("RefFristCodePosList"))
							If .CodeLoc = 1 Then
								ReDim intList(2) As Long
								intList(0) = IIf(.CPCodePos < 0,0,.CPCodePos)
								intList(1) = IIf(.LengthCodePos < 0,0,.LengthCodePos)
								intList(2) = IIf(.RefCodeStartPos < 0,.RefCodeStartLength,.RefCodeStartPos)
								Call SortNumArray(intList,0,2,True)
								n = .CPCodeStartLength + .LengthCodeStartLength + _
									IIf(.CPCodePos = 0,0,IIf(.CPCodeSize = 0,2,.CPCodeSize)) + _
									IIf(.LengthCodePos = 0,0,IIf(.LengthCodeSize = 0,1,.LengthCodeSize)) + _
									IIf(.RefCodeStartPos = 0,0,IIf(.RefCodeStartPos > 0,.RefCodeStartPos,.RefCodeStartLength))
								If intList(0) > n Then n = intList(0)
								If i < n Then
									MsgBox Replace$(MsgList(19),"%s",CStr(n)),vbOkOnly+vbInformation,MsgList(0)
									DlgText "RefFristCodePosList",CStr(.FristCodePos)
									Exit Function
								End If
							Else
								n = .CPCodeStartLength + .LengthCodeStartLength + _
									IIf(.CPCodePos = 0,0,IIf(.CPCodeSize = 0,2,.CPCodeSize)) + _
									IIf(.LengthCodePos = 0,0,IIf(.LengthCodeSize = 0,1,.LengthCodeSize)) + _
									IIf(.RefCodeStartPos = 0,0,.RefCodeStartLength)
								j = IIf(.RefCodeStartPos = 0,0,IIf(.RefCodeStartPos > 0,.RefCodeStartPos + .RefCodeStartLength,.RefCodeStartLength))
								If j > n Then n = j
								If i < n Then
									MsgBox Replace$(MsgList(68),"%s",CStr(n)),vbOkOnly+vbInformation,MsgList(0)
									DlgText "RefFristCodePosList",CStr(.FristCodePos)
									Exit Function
								End If
							End If
						End If
						.FristCodePos = StrToLong(DlgText("RefFristCodePosList"))
					End If
				End With
				Exit Function
			Case "LengthCodePosList", "RefLengthCodePosList"
				HeaderID = DlgValue("StrTypeNameList")
				If HeaderID < 0 Then Exit Function
				If DlgItem$ = "LengthCodePosList" Then
					If DlgValue("LengthModeList") > 4 Then
						If DlgValue("LengthCodePosList") > 0 Then
							MsgBox MsgList(33),vbOkOnly+vbInformation,MsgList(30)
							DlgValue "LengthCodePosList",0
						End If
					End If
				ElseIf DlgValue("RefLengthModeList") > 4 Then
					If DlgValue("RefLengthCodePosList") > 0 Then
						MsgBox MsgList(33),vbOkOnly+vbInformation,MsgList(30)
						DlgValue "RefLengthCodePosList",0
					End If
				End If
			Case "LengthCodeSizeList", "RefLengthCodeSizeList"
				HeaderID = DlgValue("StrTypeNameList")
				If HeaderID < 0 Then Exit Function
				If DlgItem$ = "LengthCodeSizeList" Then
					If DlgValue("LengthModeList") > 4 Then
						If DlgValue("LengthCodeSizeList") > 0 Then
							MsgBox MsgList(34),vbOkOnly+vbInformation,MsgList(30)
							DlgValue "LengthCodeSizeList",0
						End If
					End If
				ElseIf DlgValue("RefLengthModeList") > 4 Then
					If DlgValue("RefLengthCodeSizeList") > 0 Then
						MsgBox MsgList(34),vbOkOnly+vbInformation,MsgList(30)
						DlgValue "RefLengthCodeSizeList",0
					End If
				End If
			Case "LengthModeList", "RefLengthModeList"
				HeaderID = DlgValue("StrTypeNameList")
				If HeaderID < 0 Then Exit Function
				If DlgItem$ = "LengthModeList" Then
					If DlgValue("LengthModeList") > 4 Then
						If DlgValue("LengthCodePosList") > 0 Or DlgValue("LengthCodeSizeList") > 0 Then
							If MsgBox(MsgList(35),vbYesNo+vbInformation,MsgList(12)) = vbYes Then
								DlgValue "LengthCodePosList",0
								DlgValue "LengthCodeSizeList",0
							Else
								DlgValue "LengthModeList",StrTypeList(HeaderID).LengthMode
								Exit Function
							End If
						End If
					End If
					If DlgValue("LengthModeList") = 1 Or DlgValue("LengthModeList") = 5 Then
						If DlgText("CharLengthReviseValList") <> "0" Then
							If MsgBox(MsgList(42),vbYesNo+vbInformation,MsgList(12)) = vbYes Then
								DlgText "CharLengthReviseValList","0"
								DlgValue "LengthReviseNameList",1
								DlgVisible "ByteLengthReviseValList",False
								DlgVisible "CharLengthReviseValList",True
							Else
								DlgValue "LengthModeList",StrTypeList(HeaderID).LengthMode
								Exit Function
							End If
						End If
					ElseIf DlgValue("LengthModeList") = 2 Or DlgValue("LengthModeList") = 6 Then
						If DlgText("ByteLengthReviseValList") <> "0" Then
							If MsgBox(MsgList(43),vbYesNo+vbInformation,MsgList(12)) = vbYes Then
								DlgText "ByteLengthReviseValList","0"
								DlgValue "LengthReviseNameList",0
								DlgVisible "ByteLengthReviseValList",True
								DlgVisible "CharLengthReviseValList",False
							Else
								DlgValue "LengthModeList",StrTypeList(HeaderID).LengthMode
								Exit Function
							End If
						End If
					End If
				Else
					If DlgValue("RefLengthModeList") > 4 Then
						If DlgValue("RefLengthCodePosList") > 0 Or DlgValue("RefLengthCodeSizeList") > 0 Then
							If MsgBox(MsgList(35),vbYesNo+vbInformation,MsgList(12)) = vbYes Then
								DlgValue "RefLengthCodePosList",0
								DlgValue "RefLengthCodeSizeList",0
							Else
								DlgValue "RefLengthModeList",StrTypeList(HeaderID).LengthMode
								Exit Function
							End If
						End If
					End If
					If DlgValue("RefLengthModeList") = 1 Or DlgValue("RefLengthModeList") = 5 Then
						If DlgText("RefCharLengthReviseValList") <> "0" Then
							If MsgBox(MsgList(42),vbYesNo+vbInformation,MsgList(12)) = vbYes Then
								DlgText "RefCharLengthReviseValList","0"
								DlgValue "RefLengthReviseNameList",1
								DlgVisible "RefByteLengthReviseValList",False
								DlgVisible "RefCharLengthReviseValList",True
							Else
								DlgValue "RefLengthModeList",StrTypeList(HeaderID).LengthMode
								Exit Function
							End If
						End If
					ElseIf DlgValue("RefLengthModeList") = 2 Or DlgValue("RefLengthModeList") = 6 Then
						If DlgText("RefByteLengthReviseValList") <> "0" Then
							If MsgBox(MsgList(43),vbYesNo+vbInformation,MsgList(12)) = vbYes Then
								DlgText "RefCharLengthReviseValList","0"
								DlgValue "RefLengthReviseNameList",0
								DlgVisible "RefByteLengthReviseValList",True
								DlgVisible "RefCharLengthReviseValList",False
							Else
								DlgValue "RefLengthModeList",StrTypeList(HeaderID).LengthMode
								Exit Function
							End If
						End If
					End If
				End If
			Case "EndCodeStrButton"
				HeaderID = DlgValue("StrTypeNameList")
				If HeaderID < 0 Then Exit Function
				TempArray = ReSplit(MsgList(39),ItemJoinStr)
				n = ShowPopupMenu(TempArray,vbPopupUseRightButton)
				If n < 0 Then Exit Function
				DlgText "EndCodeStrBox","00"
				With StrTypeList(HeaderID)
					.EndCodeString = "00"
					.EndCodeLength = 1
					.EndCodeByte = HexStr2Bytes(.StartCodeString)
				End With
			Case "LengthReviseNameList", "RefLengthReviseNameList"
				HeaderID = DlgValue("StrTypeNameList")
				If HeaderID < 0 Then Exit Function
				With StrTypeList(HeaderID)
					If DlgItem$ = "LengthReviseNameList" Then
						If DlgValue("LengthReviseNameList") = 0 Then
							DlgText "ByteLengthReviseValList",CStr(.ByteLengthReviseVal)
							DlgVisible "ByteLengthReviseValList",True
							DlgVisible "CharLengthReviseValList",False
						Else
							DlgText "CharLengthReviseValList",CStr(.CharLengthReviseVal)
							DlgVisible "ByteLengthReviseValList",False
							DlgVisible "CharLengthReviseValList",True
						End If
					Else
						If DlgValue("RefLengthReviseNameList") = 0 Then
							DlgText "RefByteLengthReviseValList",CStr(.ByteLengthReviseVal)
							DlgVisible "RefByteLengthReviseValList",True
							DlgVisible "RefCharLengthReviseValList",False
						Else
							DlgText "RefCharLengthReviseValList",CStr(.CharLengthReviseVal)
							DlgVisible "RefByteLengthReviseValList",False
							DlgVisible "RefCharLengthReviseValList",True
						End If
					End If
				End With
			End Select

			HeaderID = DlgValue("StrTypeNameList")
			If HeaderID < 0 Then Exit Function
			Select Case DlgItem$
			Case "StrTypeNameList", "CodeLoc"
				With StrTypeList(HeaderID)
					If DlgItem$ = "StrTypeNameList" Then
						DlgValue "CodeLoc",.CodeLoc
					Else
						.CodeLoc = DlgValue("CodeLoc")
					End If
					If .CodeLoc = 0 Then
						DlgText "FristCodePosList",CStr(.FristCodePos)
						If DlgValue("FristCodePosList") < 0 Then
							DlgValue "FristCodePosList",DlgListBoxArray("FristCodePosList") - 1
						End If
						If .CPCodePos < 0 Then
							DlgValue "CPCodePosList",0
						Else
							DlgText "CPCodePosList",CStr(.CPCodePos)
							If DlgValue("CPCodePosList") < 0 Then
								DlgValue "CPCodePosList",DlgListBoxArray("CPCodePosList") - 1
							End If
						End If
						If .CPCodeSize = 0 Then
							DlgValue "CPCodeSizeList",0
						Else
							DlgText "CPCodeSizeList",CStr(.CPCodeSize)
						End If
						If .LengthCodePos < 0 Then
							DlgValue "LengthCodePosList",0
						Else
							DlgText "LengthCodePosList",CStr(.LengthCodePos)
							If DlgValue("LengthCodePosList") < 0 Then
								DlgValue "LengthCodePosList",DlgListBoxArray("LengthCodePosList") - 1
							End If
						End If
						If .LengthCodeSize = 0 Then
							DlgValue "LengthCodeSizeList",0
						Else
							DlgText "LengthCodeSizeList",CStr(.LengthCodeSize)
						End If
						DlgValue "LengthReviseNameList",IIf(.LengthMode = 2 Or .LengthMode = 6,1,0)
						DlgText "ByteLengthReviseValList",CStr(.ByteLengthReviseVal)
						DlgText "CharLengthReviseValList",CStr(.CharLengthReviseVal)
						DlgValue "LengthModeList",.LengthMode
						If .StartCodePos < 0 Then
							DlgValue "StartCodePosList",0
						Else
							DlgText "StartCodePosList",CStr(.StartCodePos)
							If DlgValue("StartCodePosList") < 0 Then
								DlgValue "StartCodePosList",DlgListBoxArray("StartCodePosList") - 1
							End If
						End If
						DlgText "StartCodeStrBox",.StartCodeString
						DlgText "EndCodeStrBox",.EndCodeString
					Else
						DlgText "RefFristCodePosList",CStr(.FristCodePos)
						If DlgValue("RefFristCodePosList") < 0 Then
							DlgValue "RefFristCodePosList",DlgListBoxArray("RefFristCodePosList") - 1
						End If
						If .CPCodePos < 0 Then
							DlgValue "RefCPCodePosList",0
						Else
							DlgText "RefCPCodePosList",CStr(.CPCodePos)
							If DlgValue("RefCPCodePosList") < 0 Then
								DlgValue "RefCPCodePosList",DlgListBoxArray("RefCPCodePosList") - 1
							End If
						End If
						If .CPCodeSize = 0 Then
							DlgValue "RefCPCodeSizeList",0
						Else
							DlgText "RefCPCodeSizeList",CStr(.CPCodeSize)
						End If
						DlgText "RefCPCodeBefStrBox",.CPCodeStartString
						If .LengthCodePos < 0 Then
							DlgValue "RefLengthCodePosList",0
						Else
							DlgText "RefLengthCodePosList",CStr(.LengthCodePos)
							If DlgValue("RefLengthCodePosList") < 0 Then
								DlgValue "RefLengthCodePosList",DlgListBoxArray("RefLengthCodePosList") - 1
							End If
						End If
						If .LengthCodeSize = 0 Then
							DlgValue "RefLengthCodeSizeList",0
						Else
							DlgText "RefLengthCodeSizeList",CStr(.LengthCodeSize)
						End If
						DlgValue "RefLengthReviseNameList",IIf(.LengthMode = 2 Or .LengthMode = 6,1,0)
						DlgText "RefByteLengthReviseValList",CStr(.ByteLengthReviseVal)
						DlgText "RefCharLengthReviseValList",CStr(.CharLengthReviseVal)
						DlgValue "RefLengthModeList",.LengthMode
						DlgText "RefLengthCodeBefStrBox",.LengthCodeStartString
						If .RefCodeStartPos < 0 Then
							DlgValue "RefCodeBefPosList",0
						Else
							DlgText "RefCodeBefPosList",CStr(.RefCodeStartPos)
							If DlgValue("RefCodeBefPosList") < 0 Then
								DlgValue "RefCodeBefPosList",DlgListBoxArray("RefCodeBefPosList") - 1
							End If
						End If
						DlgText "RefCodeBefStrBox",.RefCodeStartString
					End If
				End With
				If DlgValue("CodeLoc") = 0 Then
					DlgVisible "StrTypeText",True
					DlgVisible "FristCodeGroup",True
					DlgVisible "FristCodePosText",True
					DlgVisible "FristCodePosList",True
					DlgVisible "CPCodeGroup",True
					DlgVisible "CPCodePosText",True
					DlgVisible "CPCodeSizeText",True
					DlgVisible "CPCodePosList",True
					DlgVisible "CPCodeSizeList",True
					DlgVisible "LengthCodeGroup",True
					DlgVisible "LengthCodePosText",True
					DlgVisible "LengthCodeSizeText",True
					DlgVisible "LengthReviseValText",True
					DlgVisible "LengthModeText",True
					DlgVisible "LengthCodePosList",True
					DlgVisible "LengthCodeSizeList",True
					DlgVisible "LengthReviseNameList",True
					If DlgValue("LengthReviseNameList") = 0 Then
						DlgVisible "ByteLengthReviseValList",True
						DlgVisible "CharLengthReviseValList",False
					Else
						DlgVisible "ByteLengthReviseValList",False
						DlgVisible "CharLengthReviseValList",True
					End If
					DlgVisible "LengthModeList",True
					DlgVisible "StartCodeGroup",True
					DlgVisible "StartCodePosText",True
					DlgVisible "StartCodeStrText",True
					DlgVisible "StartCodePosList",True
					DlgVisible "StartCodeStrBox",True
					DlgVisible "EndCodeGroup",True
					DlgVisible "EndCodeStrText",True
					DlgVisible "EndCodeStrBox",True
					DlgVisible "EndCodeStrButton",True

					DlgVisible "RefStrTypeText",False
					DlgVisible "RefFristCodeGroup",False
					DlgVisible "RefAfterCodeGroup",False
					DlgVisible "RefAddBeforeFristCodePosText",False
					DlgVisible "RefAddAfterFristCodePosText",False
					DlgVisible "RefFristCodePosList",False
					DlgVisible "RefCPCodeGroup",False
					DlgVisible "RefAddBeforeCPCodePosText",False
					DlgVisible "RefAddAfterCPCodePosText",False
					DlgVisible "RefCPCodeSizeText",False
					DlgVisible "RefCPCodeBefStrText",False
					DlgVisible "RefCPCodePosList",False
					DlgVisible "RefCPCodeSizeList",False
					DlgVisible "RefCPCodeBefStrBox",False
					DlgVisible "RefLengthCodeGroup",False
					DlgVisible "RefAddBeforeLengthCodePosText",False
					DlgVisible "RefAddAfterLengthCodePosText",False
					DlgVisible "RefLengthCodeSizeText",False
					DlgVisible "RefLengthReviseNameList",False
					DlgVisible "RefLengthReviseValText",False
					DlgVisible "RefLengthModeText",False
					DlgVisible "RefLengthCodeBefStrText",False
					DlgVisible "RefLengthCodePosList",False
					DlgVisible "RefLengthCodeSizeList",False
					DlgVisible "RefLengthReviseNameList",False
					DlgVisible "RefByteLengthReviseValList",False
					DlgVisible "RefCharLengthReviseValList",False
					DlgVisible "RefLengthModeList",False
					DlgVisible "RefLengthCodeBefStrBox",False
					DlgVisible "RefCodeBefGroup",False
					DlgVisible "RefAddBeforeCodeBefPosText",False
					DlgVisible "RefAddAfterCodeBefPosText",False
					DlgVisible "RefCodeBefStrText",False
					DlgVisible "RefCodeBefPosList",False
					DlgVisible "RefCodeBefStrBox",False
				Else
					DlgVisible "StrTypeText",False
					DlgVisible "FristCodeGroup",False
					DlgVisible "FristCodePosText",False
					DlgVisible "FristCodePosList",False
					DlgVisible "CPCodeGroup",False
					DlgVisible "CPCodePosText",False
					DlgVisible "CPCodeSizeText",False
					DlgVisible "CPCodePosList",False
					DlgVisible "CPCodeSizeList",False
					DlgVisible "LengthCodeGroup",False
					DlgVisible "LengthCodePosText",False
					DlgVisible "LengthCodeSizeText",False
					DlgVisible "LengthReviseValText",False
					DlgVisible "LengthModeText",False
					DlgVisible "LengthCodePosList",False
					DlgVisible "LengthCodeSizeList",False
					DlgVisible "LengthReviseNameList",False
					DlgVisible "ByteLengthReviseValList",False
					DlgVisible "CharLengthReviseValList",False
					DlgVisible "LengthModeList",False
					DlgVisible "StartCodeGroup",False
					DlgVisible "StartCodePosText",False
					DlgVisible "StartCodeStrText",False
					DlgVisible "StartCodePosList",False
					DlgVisible "StartCodeStrBox",False
					DlgVisible "EndCodeGroup",False
					DlgVisible "EndCodeStrText",False
					DlgVisible "EndCodeStrBox",False
					DlgVisible "EndCodeStrButton",False
					
					DlgVisible "RefStrTypeText",True

					If DlgValue("CodeLoc") = 1 Then
						DlgVisible "RefFristCodeGroup",True
						DlgVisible "RefAddBeforeFristCodePosText",True
						DlgVisible "RefAfterCodeGroup",False
						DlgVisible "RefAddAfterFristCodePosText",False
					Else
						DlgVisible "RefFristCodeGroup",False
						DlgVisible "RefAddBeforeFristCodePosText",False
						DlgVisible "RefAfterCodeGroup",True
						DlgVisible "RefAddAfterFristCodePosText",True
					End If
					DlgVisible "RefFristCodePosList",True
					DlgVisible "RefCPCodeGroup",True
					If DlgValue("CodeLoc") = 1 Then
						DlgVisible "RefAddBeforeCPCodePosText",True
						DlgVisible "RefAddAfterCPCodePosText",False
					Else
						DlgVisible "RefAddBeforeCPCodePosText",False
						DlgVisible "RefAddAfterCPCodePosText",True
					End If
					DlgVisible "RefCPCodeSizeText",True
					DlgVisible "RefCPCodeBefStrText",True
					DlgVisible "RefCPCodePosList",True
					DlgVisible "RefCPCodeSizeList",True
					DlgVisible "RefCPCodeBefStrBox",True
					DlgVisible "RefLengthCodeGroup",True
					If DlgValue("CodeLoc") = 1 Then
						DlgVisible "RefAddBeforeLengthCodePosText",True
						DlgVisible "RefAddAfterLengthCodePosText",False
					Else
						DlgVisible "RefAddBeforeLengthCodePosText",False
						DlgVisible "RefAddAfterLengthCodePosText",True
					End If
					DlgVisible "RefLengthCodeSizeText",True
					DlgVisible "RefLengthReviseNameList",True
					DlgVisible "RefLengthReviseValText",True
					DlgVisible "RefLengthModeText",True
					DlgVisible "RefLengthCodeBefStrText",True
					DlgVisible "RefLengthCodePosList",True
					DlgVisible "RefLengthCodeSizeList",True
					DlgVisible "RefLengthReviseNameList",True
					If DlgValue("RefLengthReviseNameList") = 0 Then
						DlgVisible "RefByteLengthReviseValList",True
						DlgVisible "RefCharLengthReviseValList",False
					Else
						DlgVisible "RefByteLengthReviseValList",False
						DlgVisible "RefCharLengthReviseValList",True
					End If
					DlgVisible "RefLengthModeList",True
					DlgVisible "RefLengthCodeBefStrBox",True
					DlgVisible "RefCodeBefGroup",True
					If DlgValue("CodeLoc") = 1 Then
						DlgVisible "RefAddBeforeCodeBefPosText",True
						DlgVisible "RefAddAfterCodeBefPosText",False
					Else
						DlgVisible "RefAddBeforeCodeBefPosText",False
						DlgVisible "RefAddAfterCodeBefPosText",True
					End If
					DlgVisible "RefCodeBefStrText",True
					DlgVisible "RefCodeBefPosList",True
					DlgVisible "RefCodeBefStrBox",True
				End If
			Case Else
				With StrTypeList(HeaderID)
					.CodeLoc = DlgValue("CodeLoc")
					If .CodeLoc = 0 Then
						.FristCodePos = StrToLong(DlgText("FristCodePosList"))
						.CPCodePos = IIf(DlgValue("CPCodePosList") = 0,-1,StrToLong(DlgText("CPCodePosList")))
						.CPCodeSize = IIf(DlgValue("CPCodeSizeList") = 0,0,StrToLong(DlgText("CPCodeSizeList")))
						.LengthCodePos = IIf(DlgValue("LengthCodePosList") = 0,-1,StrToLong(DlgText("LengthCodePosList")))
						.LengthCodeSize = IIf(DlgValue("LengthCodeSizeList") = 0,0,StrToLong(DlgText("LengthCodeSizeList")))
						.ByteLengthReviseVal = StrToLong(DlgText("ByteLengthReviseValList"))
						.CharLengthReviseVal = StrToLong(DlgText("CharLengthReviseValList"))
						.LengthMode = DlgValue("LengthModeList")
						.StartCodePos = IIf(DlgValue("StartCodePosList") = 0,-1,StrToLong(DlgText("StartCodePosList")))
						.RefCodeStartPos = 0
					Else
						.FristCodePos = StrToLong(DlgText("RefFristCodePosList"))
						.CPCodePos = IIf(DlgValue("RefCPCodePosList") = 0,-1,StrToLong(DlgText("RefCPCodePosList")))
						.CPCodeSize = IIf(DlgValue("RefCPCodeSizeList") = 0,0,StrToLong(DlgText("RefCPCodeSizeList")))
						.LengthCodePos = IIf(DlgValue("RefLengthCodePosList") = 0,-1,StrToLong(DlgText("RefLengthCodePosList")))
						.LengthCodeSize = IIf(DlgValue("RefLengthCodeSizeList") = 0,0,StrToLong(DlgText("RefLengthCodeSizeList")))
						.ByteLengthReviseVal = StrToLong(DlgText("RefByteLengthReviseValList"))
						.CharLengthReviseVal = StrToLong(DlgText("RefCharLengthReviseValList"))
						.LengthMode = DlgValue("RefLengthModeList")
						.StartCodePos = 0
						.RefCodeStartPos = IIf(DlgValue("RefCodeBefPosList") = 0,-1,StrToLong(DlgText("RefCodeBefPosList")))
					End If
					If .LengthMode = 1 Or .LengthMode = 5 Then
						.CharLengthReviseVal = 0
					ElseIf .LengthMode = 2 Or .LengthMode = 6 Then
						.ByteLengthReviseVal = 0
					End If
					.LengthReviseVal = .ByteLengthReviseVal + .CharLengthReviseVal
				End With
			End Select
			If UBound(StrTypeList) = 0 Then
				DlgEnable "DelButton",False
				DlgEnable "AddButton",CheckStrTypeArray(StrTypeList)
			Else
				DlgEnable "DelButton",True
			End If
			Exit Function
		Case 1
			Select Case DlgItem$
			Case "RefAddButton"
				TempList = GetRefTypeNameList(RefTypeList)
				Temp = AddSet(TempList)
				If Temp = "" Then Exit Function
				If CheckRefTypeArray(RefTypeList) = True Then
					HeaderID = UBound(RefTypeList) + 1
				End If
				ReDim Preserve TempList(HeaderID) As String,RefTypeList(HeaderID) As REF_TYPE
				TempList(HeaderID) = Temp
				RefTypeList(HeaderID).sName = Temp
				DlgListBoxArray "RefTypeNameList",TempList()
				DlgValue "RefTypeNameList",HeaderID
				DlgItem$ = "RefTypeNameList"
			Case "RefChangeButton"
				HeaderID = DlgValue("RefTypeNameList")
				If HeaderID < 0 Then Exit Function
				TempList = GetRefTypeNameList(RefTypeList)
				Temp = EditSet(TempList,HeaderID)
				If Temp = "" Then Exit Function
				TempList(HeaderID) = Temp
				RefTypeList(HeaderID).sName = Temp
				DlgListBoxArray "RefTypeNameList",TempList()
				DlgValue "RefTypeNameList",HeaderID
				Exit Function
			Case "RefDelButton"
				HeaderID = DlgValue("RefTypeNameList")
				If HeaderID < 0 Then Exit Function
				If MsgBox(Replace(MsgList(13),"%s",DlgText("RefTypeNameList")),vbYesNo+vbInformation,MsgList(12)) = vbNo Then
					Exit Function
				End If
				Call DelRefTypeArray(RefTypeList,HeaderID)
				TempList = GetRefTypeNameList(RefTypeList)
				If HeaderID = UBound(TempList) + 1 Then HeaderID = HeaderID - 1
				DlgListBoxArray "RefTypeNameList",TempList()
				DlgValue "RefTypeNameList",HeaderID
				DlgItem$ = "RefTypeNameList"
			Case "ResetButton"
				HeaderID = DlgValue("RefTypeNameList")
				If HeaderID < 0 Then Exit Function
				ReDim TempArray(UBound(RefTypeList)) As String
				TempArray(0) = MsgList(2)
				For i = 0 To UBound(RefTypeList)
					If i <> HeaderID Then
						n = n + 1
						TempArray(n) = MsgList(11) & " - " & RefTypeList(i).sName
					End If
				Next i
				ReDim Preserve TempArray(n) As String
				n = ShowPopupMenu(TempArray,vbPopupUseRightButton)
				If n < 0 Then Exit Function
				If n = 0 Then
					Temp = DlgText("RefTypeNameList")
					For i = 0 To UBound(RefTypeListBak)
						If RefTypeListBak(i).sName = Temp Then
							RefTypeList(HeaderID) = RefTypeListBak(i)
							RefTypeList(HeaderID).sName = Temp
							Stemp = True
							Exit For
						End If
					Next i
				Else
					Temp = Mid$(TempArray(n),InStr(TempArray(n),"-") + 2)
					For i = 0 To UBound(RefTypeList)
						If RefTypeList(i).sName = Temp Then
							RefTypeList(HeaderID) = RefTypeList(i)
							RefTypeList(HeaderID).sName = DlgText("RefTypeNameList")
							Stemp = True
							Exit For
						End If
					Next i
				End If
				If Stemp = False Then Exit Function
				DlgItem$ = "RefTypeNameList"
			Case "CleanButton"
				HeaderID = DlgValue("RefTypeNameList")
				If HeaderID < 0 Then Exit Function
				DlgText "RefAlgorithmBox",""
				DlgText "StrAddAlgorithmBox",""
				DlgText "RefCodeLengthBox",""
				DlgValue "RefCodeByteSequenceList",0
				DlgText "RefCodePrefixByteBox",""
				DlgText "RefCodePrefixLengthBox",""
				With RefTypeList(HeaderID)
					.Algorithm = ""
					.ByteLength = 0
					.ByteOrder = 0
					.FileMagic = ""
					.PrefixByte = ""
					.PrefixLength = 0
					.StrAddAlgorithm = ""
					.Template = ""
				End With
				Exit Function
			Case "RefAlgorithmButton"
				HeaderID = DlgValue("RefTypeNameList")
				If HeaderID < 0 Then Exit Function
				TempList = ReSplit(MsgList(70),ItemJoinStr)
				i = ShowPopupMenu(TempList,vbPopupUseRightButton)
				If i < 0 Then Exit Function
				DlgFocus("RefAlgorithmBox")  '设置焦点到文本框
				DlgText "RefAlgorithmBox",InsertStr(GetFocus(),DlgText("RefAlgorithmBox"),Mid(TempList(i),InStr(TempList(i),"{")))
			Case "StrAddAlgorithmButton"
				HeaderID = DlgValue("RefTypeNameList")
				If HeaderID < 0 Then Exit Function
				TempList = ReSplit(MsgList(83),ItemJoinStr)
				i = ShowPopupMenu(TempList,vbPopupUseRightButton)
				If i < 0 Then Exit Function
				DlgFocus("StrAddAlgorithmBox")  '设置焦点到文本框
				DlgText "StrAddAlgorithmBox",InsertStr(GetFocus(),DlgText("StrAddAlgorithmBox"),Mid(TempList(i),InStr(TempList(i),"{")))
			End Select

			HeaderID = DlgValue("RefTypeNameList")
			If HeaderID < 0 Then Exit Function
			With RefTypeList(HeaderID)
				If DlgItem$ = "RefTypeNameList" Then
					DlgText "RefAlgorithmBox",.Algorithm
					DlgText "RefCodeLengthBox",CStr(.ByteLength)
					DlgValue "RefCodeByteSequenceList",.ByteOrder
					DlgText "RefCodePrefixByteBox",.PrefixByte
					DlgText "RefCodePrefixLengthBox",CStr(.PrefixLength)
					DlgText "StrAddAlgorithmBox",.StrAddAlgorithm
				Else
					.Algorithm = DlgText("RefAlgorithmBox")
					.ByteLength = StrToLong(DlgText("RefCodeLengthBox"))
					.ByteOrder = DlgValue("RefCodeByteSequenceList")
					.PrefixByte = DlgText("RefCodePrefixByteBox")
					.PrefixLength = StrToLong(DlgText("RefCodePrefixLengthBox"))
					.StrAddAlgorithm = DlgText("StrAddAlgorithmBox")
					If InStr(LCase(.Algorithm),"{refstartaddress}") Then
						.FileMagic = "NotPE64"
					ElseIf InStr(LCase(.Algorithm),"{strstartaddress}") Then
						.FileMagic = "NotPE32"
					Else
						.FileMagic = ""
					End If
					.Template = RefTypeToString(RefTypeList,HeaderID)
				End If
			End With
			If UBound(RefTypeList) = 0 Then
				DlgEnable "RefDelButton",False
				DlgEnable "RefAddButton",CheckRefTypeArray(RefTypeList)
			Else
				DlgEnable "RefDelButton",True
			End If
			Exit Function
		Case 2
			Select Case DlgItem$
			Case "LngAddButton"
				TempList = GetLangStrList(UniLangList,0)
				Temp = AddSet(TempList)
				If Temp = "" Then Exit Function
				HeaderID = DlgListBoxArray("LngNameList")
				ReDim Preserve TempList(HeaderID) As String,UniLangList(HeaderID) As LANG_PROPERTIE
				TempList(HeaderID) = Temp
				DlgListBoxArray "LngNameList",TempList()
				DlgValue "LngNameList",HeaderID
				DlgValue "CPNameList",0
				DlgValue "CPValList",0
				UniLangList(HeaderID).LangName = Temp
				UniLangList(HeaderID).CPName = Trim$(ReSplit(DlgText("CPNameList")," - ",2)(1))
				UniLangList(HeaderID).CodePage = StrToLong(DlgText("CPValList"))
				UniLangList(HeaderID).dwFlags = True
				DlgItem$ = "LngNameList"
			Case "LngChangeButton"
				HeaderID = DlgValue("LngNameList")
				If HeaderID < 0 Then Exit Function
				TempList = GetLangStrList(UniLangList,0)
				Temp = EditSet(TempList,HeaderID)
				If Temp = "" Then Exit Function
				TempList(HeaderID) = Temp
				UniLangList(HeaderID).LangName = Temp
				DlgListBoxArray "LngNameList",TempList()
				DlgValue "LngNameList",HeaderID
				Exit Function
			Case "LngDelButton"
				HeaderID = DlgValue("LngNameList")
				If HeaderID < 0 Then Exit Function
				If MsgBox(Replace$(MsgList(13),"%s",DlgText("LngNameList")),vbYesNo+vbInformation,MsgList(12)) = vbNo Then
					Exit Function
				End If
				Call DelLangArray(UniLangList,HeaderID)
				TempList = GetLangStrList(UniLangList,0)
				If HeaderID = UBound(TempList) + 1 Then HeaderID = HeaderID - 1
				DlgListBoxArray "LngNameList",TempList()
				DlgValue "LngNameList",HeaderID
				DlgItem$ = "LngNameList"
			Case "CPNameList"
				HeaderID = DlgValue("LngNameList")
				If HeaderID < 0 Then Exit Function
				If DlgValue("CPNameList") = 0 Then
					'i = PSL.GetDefaultCodePage(UniLangList(HeaderID).LangID)
					i = StrToLong(GetLCIDInfo(UniLangList(HeaderID).LangID,LOCALE_IDEFAULTANSICODEPAGE),CP_UNKNOWN)
					If i < 2 Then i = CP_UNKNOWN
					DlgText "CPValList",CStr$(i)
					If DlgValue("CPValList") < 0 Then
						DlgValue "CPValList",HeaderID
						Exit Function
					End If
					DlgValue "CPNameList",DlgValue("CPValList")
				Else
					DlgValue "CPValList",DlgValue("CPNameList")
				End If
				UniLangList(HeaderID).CPName = Trim$(ReSplit(DlgText("CPNameList")," - ",2)(1))
				UniLangList(HeaderID).CodePage = StrToLong(DlgText("CPValList"))
				Exit Function
			Case "CPMenuButton"
				HeaderID = DlgValue("CPNameList")
				If HeaderID < 0 Then Exit Function
				If HeaderID > 14 Then
					ReDim TempArray(2) As String
					TempArray(0) = DlgText("LngAddButton")
					TempArray(1) = DlgText("LngChangeButton")
					TempArray(2) = DlgText("LngDelButton")
				Else
					ReDim TempArray(0) As String
					TempArray(0) = DlgText("LngAddButton")
				End If
				n = DlgListBoxArray("CPNameList") - 1
				ReDim TempList(n) As String
				For i = 0 To n
					DlgValue "CPNameList",i
					TempList(i) = ReSplit(DlgText("CPNameList")," - ",2)(1) & vbNullChar & ReSplit(DlgText("CPNameList")," - ",2)(0)
				Next i
				DlgValue "CPNameList",HeaderID
				j = StrToLong(DlgText("CPValList"))
				Select Case ShowPopupMenu(TempArray,vbPopupUseRightButton)
				Case Is < 0
					Exit Function
				Case 0
					Do
						Temp = SetLang(TempList,-1,vbNullChar)
						If Temp = "" Then Exit Function
						TempArray = ReSplit(Temp,vbNullChar)
						If CheckStrRegExp(TempArray(1),"[0-9]",0,1) = True Then Exit Do
						MsgBox MsgList(54),vbOkOnly+vbInformation,MsgList(0)
					Loop
					HeaderID = n + 1
					ReDim Preserve TempList(HeaderID) As String
					TempList(HeaderID) = Temp
				Case 1
					n = DlgValue("LngNameList")
					For i = 0 To UBound(UniLangList)
						If i <> n Then
							If UniLangList(i).CodePage = j Then
								MsgBox Replace$(MsgList(58),"%s",UniLangList(i).LangName),vbOkOnly+vbInformation,MsgList(30)
								Exit Function
							End If
						End If
					Next i
					Do
						Temp = SetLang(TempList,HeaderID,vbNullChar)
						If Temp = "" Then Exit Function
						TempArray = ReSplit(Temp,vbNullChar)
						If CheckStrRegExp(TempArray(1),"[0-9]",0,1) = True Then Exit Do
						MsgBox MsgList(54),vbOkOnly+vbInformation,MsgList(0)
					Loop
					TempList(HeaderID) = Temp
				Case 2
					n = DlgValue("LngNameList")
					For i = 0 To UBound(UniLangList)
						If i <> n Then
							If UniLangList(i).CodePage = j Then
								MsgBox Replace$(MsgList(58),"%s",UniLangList(i).LangName),vbOkOnly+vbInformation,MsgList(30)
								Exit Function
							End If
						End If
					Next i
					If MsgBox(Replace(MsgList(13),"%s",DlgText("CPNameList")),vbYesNo+vbInformation,MsgList(12)) = vbNo Then
						Exit Function
					End If
					Call DelArray(TempList,HeaderID)
					If HeaderID = n Then HeaderID = n - 1
				End Select
				TempArray = TempList
				For i = 0 To UBound(TempList)
					TempArray(i) = ReSplit(TempList(i),vbNullChar)(1)
					TempList(i) = ReSplit(TempList(i),vbNullChar)(1) & " - " & ReSplit(TempList(i),vbNullChar)(0)
				Next i
				DlgListBoxArray "CPNameList",TempList()
				DlgListBoxArray "CPValList",TempArray()
				DlgValue "CPValList",HeaderID
				DlgValue "CPNameList",DlgValue("CPValList")
				Exit Function
			Case "ResetButton"
				HeaderID = DlgValue("LngNameList")
				If HeaderID < 0 Then Exit Function
				ReDim TempArray(2) As String
				If DlgValue("CPNameList") > 0 And DlgValue("CPNameList") < 15 Then TempArray(0) = MsgList(1)
				If HeaderID <= UBound(UniLangListBak) Then TempArray(1) = MsgList(2)
				TempArray(2) = MsgList(11)
				Select Case ShowPopupMenu(TempArray,vbPopupUseRightButton)
				Case Is < 0
					Exit Function
				Case 0
					Stemp = UniLangList(HeaderID).dwFlags
					If Stemp = False Then
						n = StrToLong(GetLCIDInfo(UniLangList(HeaderID).LangID,LOCALE_IDEFAULTANSICODEPAGE),CP_UNKNOWN)
						DlgText "CPValList",CStr$(n)
						DlgValue "CPNameList",DlgValue("CPValList")
					End If
					n = DlgValue("CPNameList")
					If StrToLong(GetLCIDInfo(UniLangList(HeaderID).LangID,LOCALE_IDEFAULTCODEPAGE),CP_UNKNOWN) = CP_IBM850 Then
						UniLangList(HeaderID) = GetOEMCPList(6,6)(0)
						UniLangList(HeaderID).CPName = Trim$(ReSplit(DlgText("CPNameList")," - ",2)(1))
						UniLangList(HeaderID).CodePage = StrToLong(DlgText("CPValList"))
					Else
						UniLangList(HeaderID) = GetWinCPList(n,n)(0)
					End If
					UniLangList(HeaderID).LangName = DlgText("LngNameList")
					UniLangList(HeaderID).LangID = StrToLong(DlgText("LngIDTextBox"))
					UniLangList(HeaderID).dwFlags = Stemp
					Stemp = True
				Case 1
					j = StrToLong(DlgText("LngIDTextBox"))
					For i = 0 To UBound(UniLangListBak)
						If UniLangListBak(i).LangID = j Then
							UniLangList(HeaderID) = UniLangListBak(i)
							UniLangList(HeaderID).LangName = DlgText("LngNameList")
							UniLangList(HeaderID).LangID = StrToLong(DlgText("LngIDTextBox"))
							Stemp = True
							Exit For
						End If
					Next i
				Case Else
					ReDim TempArray(UBound(UniLangList) - 1) As String
					n = 0
					For i = 1 To UBound(UniLangList)
						If i <> HeaderID Then
							TempArray(n) = MsgList(11) & " - " & UniLangList(i).LangName
							n = n + 1
						End If
					Next i
					If n = 0 Then Exit Function
					n = ShowPopupMenu(TempArray,vbPopupUseRightButton)
					If n < 0 Then Exit Function
					Temp = Trim$(ReSplit(TempArray(n)," - ",2)(1))
					For i = 1 To UBound(UniLangList)
						If UniLangList(i).LangName = Temp Then
							UniLangList(HeaderID) = UniLangList(i)
							UniLangList(HeaderID).LangName = DlgText("LngNameList")
							UniLangList(HeaderID).LangID = StrToLong(DlgText("LngIDTextBox"))
							Stemp = True
							Exit For
						End If
					Next i
				End Select
				If Stemp = False Then Exit Function
				DlgItem$ = "LngNameList"
			Case "CleanButton"
				HeaderID = DlgValue("LngNameList")
				If HeaderID < 0 Then Exit Function
				With UniLangList(HeaderID)
					.UniCodeRange = ""
					.UniCodeRegExpPattern = ""
					.UniCodeByteRange = ""
					.FeatureCode = ""
					.FeatureCodeRegExpPattern = ""
					.FeatureCodeByteRange = ""
					.FeatureCodeEnable = 0
				End With
				DlgItem$ = "LngNameList"
			Case "FeatureCodeEnableCheckBox"
				HeaderID = DlgValue("LngNameList")
				If HeaderID < 0 Then Exit Function
				UniLangList(HeaderID).FeatureCodeEnable = DlgValue("FeatureCodeEnableCheckBox")
				Exit Function
			End Select

			HeaderID = DlgValue("LngNameList")
			If HeaderID < 0 Then Exit Function
			If DlgItem$ = "LngNameList" Then
				With UniLangList(HeaderID)
					DlgText "LngIDTextBox",CStr(.LangID)
					DlgText "CPValList",CStr(.CodePage)
					If DlgValue("CPValList") < 0 Then
						DlgValue "CPValList",0
						DlgValue "CPNameList",DlgValue("CPValList")
						DlgText "UniCodeRangeTextBox",""
						DlgText "FeatureCodeTextBox",""
						DlgValue "FeatureCodeEnableCheckBox",0
						DlgEnable "FeatureCodeEnableCheckBox",False
					Else
						DlgValue "CPNameList",DlgValue("CPValList")
						DlgText "UniCodeRangeTextBox",.UniCodeRange
						DlgText "FeatureCodeTextBox",.FeatureCode
						DlgValue "FeatureCodeEnableCheckBox",.FeatureCodeEnable
						DlgEnable "FeatureCodeEnableCheckBox",IIf(.FeatureCode = "",False,True)
					End If
				End With
			End If
			If UniLangList(HeaderID).dwFlags = False Then
				DlgEnable "LngIDTextBox",False
				DlgEnable "LngChangeButton",False
				DlgEnable "LngDelButton",False
			Else
				DlgEnable "LngIDTextBox",True
				DlgEnable "LngChangeButton",True
				DlgEnable "LngDelButton",True
			End If
			Exit Function
		Case 3
			Select Case DlgItem$
			Case "ViewAddSectionEndFreeByteButton"
				'定义使用的文件
				TempList = GetToolNameList(Tools,0)
				j = ShowPopupMenu(TempList,vbPopupUseRightButton)
				If j < 0 Then Exit Function
				Dim File As FILE_PROPERTIE,tmpFreeByte() As FREE_BTYE_SPACE
				File = TargetFile
				ReDim tmpFreeByte(File.MaxSecIndex - 1) As FREE_BTYE_SPACE
				For i = 0 To File.MaxSecIndex - 1
					tmpFreeByte(i).inSectionID = i
				Next i
				i = AddSectionSize(File,tmpFreeByte,3,StrToLong(Selected(1)))
				If i > 0 Then
					i = InStrRev(LCase$(TargetFile.FilePath),".bak")
					If i > 1 Then
						If Mid$(LCase$(TargetFile.FilePath),i) = ".bak" Then
							File.FilePath = Left$(TargetFile.FilePath,i - 1)
						End If
					End If
					Call FileInfoView(File,tmpFreeByte,j,2,StrToLong(Selected(16)))
				ElseIf i = 0 Then
					MsgBox MsgList(25),vbOkOnly+vbInformation,MsgList(0)
				Else
					MsgBox MsgList(26),vbOkOnly+vbInformation,MsgList(0)
				End If
				Exit Function
			Case "StrFreeByteCheckBox"
				If DlgValue("StrFreeByteCheckBox") = 1 Then
					DlgValue "AddLastSectionEndCheckBox",0
					DlgValue "NewSectionCheckBox",0
				End If
			Case "StrFreeByteMacthLoopsList"
				If DlgValue("StrFreeByteMacthLoopsList") < 0 Then Exit Function
			Case "NotStrFreeByteCheckBox"
				If DlgValue("NotStrFreeByteCheckBox") = 1 Then
					DlgValue "AddLastSectionEndCheckBox",0
					DlgValue "NewSectionCheckBox",0
				End If
			Case "SectionEndFreeByteCheckBox"
				If DlgValue("SectionEndFreeByteCheckBox") = 1 Then
					DlgValue "AddLastSectionEndCheckBox",0
					DlgValue "NewSectionCheckBox",0
				End If
			Case "AddSectionEndFreeByteCheckBox"
				If DlgValue("AddSectionEndFreeByteCheckBox") = 1 Then
					DlgValue "NewSectionCheckBox",0
					DlgValue "AddLastSectionEndCheckBox",0
				End If
			Case "AddLastSectionEndCheckBox"
				If DlgValue("AddLastSectionEndCheckBox") = 1 Then
					DlgValue "StrFreeByteCheckBox",0
					DlgValue "NotStrFreeByteCheckBox",0
					DlgValue "SectionEndFreeByteCheckBox",0
					DlgValue "AddSectionEndFreeByteCheckBox",0
					DlgValue "NewSectionCheckBox",0
				End If
			Case "NewSectionCheckBox"
				If DlgValue("NewSectionCheckBox") = 1 Then
					DlgValue "StrFreeByteCheckBox",0
					DlgValue "NotStrFreeByteCheckBox",0
					DlgValue "SectionEndFreeByteCheckBox",0
					DlgValue "AddSectionEndFreeByteCheckBox",0
					DlgValue "AddLastSectionEndCheckBox",0
				End If
			Case "WriteOrderButton"
				TempArray = ReSplit(MsgList(27),";")
				n = UBound(TempArray)
				ReDim TempList(n) As String
				For i = 0 To n
					TempList(i) = TempArray(StrToLong(Mid$(Selected(11),i + 1,1)) - 1)
				Next i
				If SetLevel(TempList,0,MsgList(28)) = True Then
					DlgText "WriteOrderTextBox",StrListJoin(TempList,ItemJoinStr)
					For i = 0 To UBound(TempList)
						If TempList(i) = TempArray(0) Then
							TempList(i) = "1"
						ElseIf TempList(i) = TempArray(1) Then
							TempList(i) = "2"
						ElseIf TempList(i) = TempArray(2) Then
							TempList(i) = "3"
						ElseIf TempList(i) = TempArray(3) Then
							TempList(i) = "4"
						End If
					Next i
					Selected(11) = StrListJoin(TempList,"")
				End If
				Exit Function
			Case "WriteLogFileCheckBox"
				If DlgValue("WriteLogFileCheckBox") = 0 Then
					DlgValue "OpenLogFileCheckBox",0
				End If
			Case "OpenLogFileCheckBox"
				If DlgValue("OpenLogFileCheckBox") = 1 Then
					DlgValue "WriteLogFileCheckBox",1
				End If
			Case "ResetButton"
				ReDim TempArray(1) As String
				TempArray(0) = MsgList(1)
				TempArray(1) = MsgList(2)
				Select Case ShowPopupMenu(TempArray,vbPopupUseRightButton)
				Case Is < 0
					Exit Function
				Case 0
					TempArray = ReSplit(MsgList(27),";")
					n = UBound(TempArray)
					ReDim TempList(n) As String
					For i = 0 To n
						TempList(i) = TempArray(StrToLong(Mid$("4132",i + 1,1)) - 1)
					Next i
					DlgValue "StrFreeByteCheckBox",1
					DlgValue "NotStrFreeByteCheckBox",0
					DlgText "NoMarkPEFreeByteTextBox","10"
					DlgValue "SectionEndFreeByteCheckBox",0
					DlgValue "AddSectionEndFreeByteCheckBox",1
					DlgValue "AddLastSectionEndCheckBox",0
					DlgValue "NewSectionCheckBox",0
					DlgText "WriteOrderTextBox",StrListJoin(TempList,ItemJoinStr)
					DlgValue "OrgFreeByteCheckBox",0
					DlgValue "FileAlignCheckBox",1
					DlgValue "WriteLogFileCheckBox",0
					DlgValue "OpenLogFileCheckBox",0
					DlgValue "TranStrOnlyMsgCheckBox",1
					DlgValue "StrFreeByteMacthLoopsList",1
					Selected(11) = "4132"
				Case Else
					TempArray = ReSplit(MsgList(27),";")
					n = UBound(TempArray)
					ReDim TempList(n) As String
					For i = 0 To n
						TempList(i) = TempArray(StrToLong(Mid$(SelectedBak(11),i + 1,1)) - 1)
					Next i
					DlgValue "StrFreeByteCheckBox",StrToLong(SelectedBak(2))
					DlgValue "NotStrFreeByteCheckBox",StrToLong(SelectedBak(3))
					DlgText "NoMarkPEFreeByteTextBox",SelectedBak(9)
					DlgValue "SectionEndFreeByteCheckBox",StrToLong(SelectedBak(4))
					DlgValue "AddSectionEndFreeByteCheckBox",StrToLong(SelectedBak(5))
					DlgValue "AddLastSectionEndCheckBox",StrToLong(SelectedBak(6))
					DlgValue "NewSectionCheckBox",StrToLong(SelectedBak(7))
					DlgText "WriteOrderTextBox",StrListJoin(TempList,ItemJoinStr)
					DlgValue "OrgFreeByteCheckBox",StrToLong(SelectedBak(10))
					DlgValue "FileAlignCheckBox",StrToLong(SelectedBak(12))
					DlgValue "WriteLogFileCheckBox",StrToLong(SelectedBak(13))
					DlgValue "OpenLogFileCheckBox",StrToLong(SelectedBak(14))
					DlgValue "TranStrOnlyMsgCheckBox",StrToLong(SelectedBak(15))
					DlgText "StrFreeByteMacthLoopsList",SelectedBak(18)
					Selected(11) = SelectedBak(11)
				End Select
			Case "CleanButton"
				DlgValue "StrFreeByteCheckBox",0
				DlgValue "NotStrFreeByteCheckBox",0
				DlgText "NoMarkPEFreeByteTextBox",""
				DlgValue "SectionEndFreeByteCheckBox",0
				DlgValue "AddSectionEndFreeByteCheckBox",0
				DlgValue "AddLastSectionEndCheckBox",0
				DlgValue "NewSectionCheckBox",0
				DlgText "WriteOrderTextBox",""
				DlgValue "OrgFreeByteCheckBox",0
				DlgValue "FileAlignCheckBox",0
				DlgValue "WriteLogFileCheckBox",0
				DlgValue "OpenLogFileCheckBox",0
				DlgValue "TranStrOnlyMsgCheckBox",0
				DlgValue "StrFreeByteMacthLoopsList",1
			End Select
			Selected(2) = CStr(DlgValue("StrFreeByteCheckBox"))
			Selected(3) = CStr(DlgValue("NotStrFreeByteCheckBox"))
			Selected(4) = CStr(DlgValue("SectionEndFreeByteCheckBox"))
			Selected(5) = CStr(DlgValue("AddSectionEndFreeByteCheckBox"))
			Selected(6) = CStr(DlgValue("AddLastSectionEndCheckBox"))
			Selected(7) = CStr(DlgValue("NewSectionCheckBox"))
			Selected(8) = CStr(CInt(Selected(2)) Or CInt(Selected(3)) Or CInt(Selected(4)) Or _
							CInt(Selected(5)) Or CInt(Selected(6)) Or CInt(Selected(7)))
			Selected(9) = DlgText("NoMarkPEFreeByteTextBox")
			Selected(10) = CStr(DlgValue("OrgFreeByteCheckBox"))
			'Selected(11) = DlgText("WriteOrderTextBox")
			Selected(12) = CStr(DlgValue("FileAlignCheckBox"))
			Selected(13) = CStr(DlgValue("WriteLogFileCheckBox"))
			Selected(14) = CStr(DlgValue("OpenLogFileCheckBox"))
			Selected(15) = CStr(DlgValue("TranStrOnlyMsgCheckBox"))
			Selected(18) = DlgText("StrFreeByteMacthLoopsList")
			Exit Function
		Case 4
			Select Case DlgItem$
			Case "ResetButton"
				ReDim TempArray(1) As String
				TempArray(0) = MsgList(1)
				TempArray(1) = MsgList(2)
				Select Case ShowPopupMenu(TempArray,vbPopupUseRightButton)
				Case Is < 0
					Exit Function
				Case 0
					DlgValue "OpenFileModeOption",1
					DlgValue "GetStringVoiceCheckBox",1
					DlgValue "ImportSrcVoiceCheckBox",1
					DlgValue "ImportTrnVoiceCheckBox",1
					DlgValue "ParseStrDataVoiceCheckBox",1
					DlgValue "GetStrTypeVoiceCheckBox",1
					DlgValue "MoveStringVoiceCheckBox",1
					DlgValue "AddAndDelFilterVoiceCheckBox",1
					DlgValue "AddAndDelReserveVoiceCheckBox",1
					DlgValue "WriteStringVoiceCheckBox",1
				Case Else
					DlgValue "OpenFileModeOption",StrToLong(SelectedBak(1)) + 1
					DlgValue "GetStringVoiceCheckBox",StrToLong(SelectedBak(21))
					DlgValue "ImportSrcVoiceCheckBox",StrToLong(SelectedBak(22))
					DlgValue "ImportTrnVoiceCheckBox",StrToLong(SelectedBak(23))
					DlgValue "ParseStrDataVoiceCheckBox",StrToLong(SelectedBak(24))
					DlgValue "GetStrTypeVoiceCheckBox",StrToLong(SelectedBak(25))
					DlgValue "MoveStringVoiceCheckBox",StrToLong(SelectedBak(26))
					DlgValue "AddAndDelFilterVoiceCheckBox",StrToLong(SelectedBak(27))
					DlgValue "AddAndDelReserveVoiceCheckBox",StrToLong(SelectedBak(28))
					DlgValue "WriteStringVoiceCheckBox",StrToLong(SelectedBak(29))
				End Select
			Case "CleanButton"
				DlgValue "OpenFileModeOption",0
				DlgValue "GetStringVoiceCheckBox",0
				DlgValue "ImportSrcVoiceCheckBox",0
				DlgValue "ImportTrnVoiceCheckBox",0
				DlgValue "ParseStrDataVoiceCheckBox",0
				DlgValue "GetStrTypeVoiceCheckBox",0
				DlgValue "MoveStringVoiceCheckBox",0
				DlgValue "AddAndDelFilterVoiceCheckBox",0
				DlgValue "AddAndDelReserveVoiceCheckBox",0
				DlgValue "WriteStringVoiceCheckBox",0
			End Select
			Selected(1) = CStr(DlgValue("OpenFileModeOption") - 1)
			Selected(21) = CStr(DlgValue("GetStringVoiceCheckBox"))
			Selected(22) = CStr(DlgValue("ImportSrcVoiceCheckBox"))
			Selected(23) = CStr(DlgValue("ImportTrnVoiceCheckBox"))
			Selected(24) = CStr(DlgValue("ParseStrDataVoiceCheckBox"))
			Selected(25) = CStr(DlgValue("GetStrTypeVoiceCheckBox"))
			Selected(26) = CStr(DlgValue("MoveStringVoiceCheckBox"))
			Selected(27) = CStr(DlgValue("AddAndDelFilterVoiceCheckBox"))
			Selected(28) = CStr(DlgValue("AddAndDelReserveVoiceCheckBox"))
			Selected(29) = CStr(DlgValue("WriteStringVoiceCheckBox"))
		Case 5
			Select Case DlgItem$
			Case "ExeBrowseButton"
				If PSL.SelectFile(Temp,True,MsgList(6),MsgList(5)) = False Then Exit Function
				DlgText "CmdPathBox",Temp
				If InStr(LCase$(Temp),"winrar.exe") Then
					DlgText "ArgumentBox","e -ibck ""%1"" %2 ""%3"""
				ElseIf InStr(LCase$(Temp),"winzip.exe") Then
					DlgText "CmdPathBox",strReplace(Temp,"WinZip.exe","WzunZip.exe")
					DlgText "ArgumentBox"," ""%1"" %2 ""%3"""
				ElseIf InStr(LCase$(Temp),"wzunzip.exe") Then
					DlgText "ArgumentBox"," ""%1"" %2 ""%3"""
				ElseIf InStr(LCase$(Temp),"7z.exe") Then
					DlgText "ArgumentBox","e -r ""%1"" -o""%3"" %2"
				ElseIf InStr(LCase$(Temp),"7zfm.exe") Then
					DlgText "CmdPathBox",strReplace(Temp,"7zFM.exe","7z.exe")
					DlgText "ArgumentBox","e -r ""%1"" -o""%3"" %2"
				ElseIf InStr(LCase$(Temp),"haozip.exe") Then
					DlgText "CmdPathBox",strReplace(Temp,"HaoZip.exe","HaoZipC.exe")
					DlgText "ArgumentBox","e ""%1"" -r -o""%3"" %2"
				ElseIf InStr(LCase$(Temp),"haozipc.exe") Then
					DlgText "ArgumentBox","e ""%1"" -r -o""%3"" %2"
				End If
			Case "ArgumentButton"
				ReDim TempArray(2) As String
				TempArray(0) = MsgList(8)
				TempArray(1) = MsgList(9)
				TempArray(2) = MsgList(10)
				Select Case ShowPopupMenu(TempArray,vbPopupUseRightButton)
				Case Is < 0
					Exit Function
				Case 0
					DlgText "ArgumentBox",DlgText("ArgumentBox")  & " " & """%1"""
				Case 1
					DlgText "ArgumentBox",DlgText("ArgumentBox")  & " " & """%2"""
				Case Else
					DlgText "ArgumentBox",DlgText("ArgumentBox")  & " " & """%3"""
				End Select
			Case "ResetButton"
				ReDim TempArray(1) As String
				TempArray(0) = MsgList(1)
				TempArray(1) = MsgList(2)
				Select Case ShowPopupMenu(TempArray,vbPopupUseRightButton)
				Case Is < 0
					Exit Function
				Case 0
					DlgValue "UpdateSet",1
					DlgText "WebSiteBox",updateMainUrl & vbCrLf & updateMinorUrl
					TempList = ReSplit(getCMDPath(".rar","",""),JoinStr)
					DlgText "CmdPathBox",TempList(0)
					DlgText "ArgumentBox",TempList(1)
					DlgText "UpdateCycleBox","7"
				Case Else
					DlgValue "UpdateSet",StrToLong(UpdateSetBak(0))
					DlgText "WebSiteBox",UpdateSetBak(1)
					DlgText "CmdPathBox",UpdateSetBak(2)
					DlgText "ArgumentBox",UpdateSetBak(3)
					DlgText "UpdateCycleBox",UpdateSetBak(4)
				End Select
			Case "CleanButton"
				DlgText "WebSiteBox",""
				DlgText "CmdPathBox",""
				DlgText "ArgumentBox",""
			Case "CheckButton"
				If DlgText("CmdPathBox") = "" Or DlgText("ArgumentBox") = "" Then
					MsgBox MsgList(7),vbOkOnly+vbInformation,MsgList(0)
					Exit Function
				End If
				i = Download(UpdateSet,DlgText("WebSiteBox"),3,-2)
				If i > 0 Then
					Stemp = False
					If UpdateSet(5) < Format(Date,"yyyy-MM-dd") Then
						Stemp = True
					ElseIf i = 3 And ArrayComp(UpdateSet,UpdateSetBak) = False Then
						Stemp = True
					End If
					If Stemp = True Then
						DlgText "UpdateDateBox",Format(Date,"yyyy-MM-dd")
						UpdateSet(5) = DlgText("UpdateDateBox")
						If WriteSettings("Update") = False Then
							MsgBox Replace$(MsgList(4),"%s",RegKey),vbOkOnly+vbInformation,MsgList(0)
							Exit Function
						Else
							UpdateSetBak(5) = UpdateSet(5)
						End If
					End If
					If i = 3 Then Call ExitMacro(1)
				End If
			Case "TestButton"
				If DlgText("CmdPathBox") = "" Or DlgText("ArgumentBox") = "" Then
	    			MsgBox MsgList(7),vbOkOnly+vbInformation,MsgList(0)
					Exit Function
	    		End If
	    		Download(UpdateSet,DlgText("WebSiteBox"),4,-2)
	    	End Select
			UpdateSet(0) = CStr(DlgValue("UpdateSet"))
			UpdateSet(1) = DlgText("WebSiteBox")
			UpdateSet(2) = DlgText("CmdPathBox")
			UpdateSet(3) = DlgText("ArgumentBox")
			UpdateSet(4) = DlgText("UpdateCycleBox")
			UpdateSet(5) = DlgText("UpdateDateBox")
			If UpdateSet(5) = MsgList(3) Then UpdateSet(5) = ""
		Case 6
			Select Case DlgItem$
			Case "UILangList"
				HeaderID = DlgValue("UILangList")
				If HeaderID < 0 Then Exit Function
				If HeaderID > 1 Then
					If LCase$(Selected(0)) = LCase$(UIFileList(HeaderID - 2).LangID) Then Exit Function
				Else
					If Selected(0) = CStr$(HeaderID) Then Exit Function
				End If
			Case "EditUILangButton"
				ReDim FileDataList(UBound(UIFileList)) As String
				For i = 0 To UBound(UIFileList)
					FileDataList(i) = UIFileList(i).FilePath & JoinStr & "unicodeFFFE"
				Next i
				If EditFile(LangFile,FileDataList,True) = False Then Exit Function
				If GetUIList(MacroDir & "\Data\",UIFileList) = False Then Exit Function
				HeaderID = DlgValue("UILangList")
			Case "MainFontButton","SrcStrFontButton","TrnStrFontButton"
				HeaderID = CLng(DlgText("SuppValueBox"))
				Select Case DlgItem$
				Case "MainFontButton"
					i = 0
				Case "SrcStrFontButton"
					i = 1
				Case "TrnStrFontButton"
					i = 2
				End Select
				ReDim TempArray(2) As String
				TempArray(0) = MsgList(1)
				TempArray(1) = MsgList(2)
				TempArray(2) = MsgList(50)
				Select Case ShowPopupMenu(TempArray,vbPopupUseRightButton)
				Case Is < 0
					Exit Function
				Case 0	'默认字体
					If CheckFont(LFList(i)) = False Then Exit Function
					ReDim tmpLFList(0) As LOG_FONT
					LFList(i) = tmpLFList(0)
				Case 1	'原值字体
					If FontComp(LFList(i),LFListBak(i)) = False Then Exit Function
					LFList(i) = LFListBak(i)
				Case 2	'自定义字体
					If SelectFont(HeaderID,LFList(i)) = 0 Then Exit Function
				End Select
				DlgText Replace$(DlgItem$,"Button","Box"),GetFontText(HeaderID,LFList(i))
				If DlgItem$ <> "MainFontButton" Then Exit Function
				'创建字体并应用到对话框
				j = CreateFont(HeaderID,LFList(0))
				If j = 0 Then Exit Function
				For i = 0 To DlgCount() - 1
					n = GetDlgItem(HeaderID,DlgControlId(DlgName(i)))
					SendMessageLNG(n,WM_SETFONT,j,0)
				Next i
				DrawWindow(HeaderID,j)
				Exit Function
			Case "NumDisplayFormatGroup"
				Selected(16) = CStr(DlgValue("NumDisplayFormatGroup"))
				Exit Function
			Case "MsgOutputGroup"
				Selected(17) = CStr(IIf(DlgValue("MsgOutputGroup") = 0,-1,1))
				Exit Function
			Case "SpaceWithPointCheckBox"
				Selected(19) = CStr(DlgValue("SpaceWithPointCheckBox"))
			Case "FilterDisplayAtStartupBox"
				Selected(20) = CStr(DlgValue("FilterDisplayAtStartupBox"))
			Case Else
				Exit Function
			End Select

			If HeaderID > 1 Then
				Temp = UIFileList(HeaderID - 2).FilePath
			Else
				If HeaderID = 0 Then
					n = Val("&H" & OSLanguage)
				Else
					n = PSL.Option(pslOptionSystemLanguage)
				End If
				For i = 0 To UBound(UIFileList)
					TempArray = ReSplit(LCase$(UIFileList(i).LangID),ItemJoinStr)
					For j = 0 To UBound(TempArray)
						If Val("&H" & TempArray(j)) = n Then
							Temp = UIFileList(i).FilePath
							Exit For
						End If
					Next j
					If Temp <> "" Then Exit For
				Next i
			End If
			If Temp = "" Then Exit Function
			If Dir$(Temp) = "" Then Exit Function
			If getINIFile(UIDataList,Temp,"unicodeFFFE",0) = False Then Exit Function
			If DlgItem$ = "UILangList" Then
				If HeaderID < 2 Then
					Selected(0) = CStr(HeaderID)
				Else
					Selected(0) = CStr(UIFileList(HeaderID - 2).LangID)
				End If
			End If
			LangFile = Temp

			'重置字符编码和代码页列表
			CodeList = getCodePageList(0,49)
			UniLangList = UpdateCPName(UniLangList)
			UniLangListBak = UpdateCPName(UniLangListBak)
			TempList = GetLangStrList(UniLangList,3)
			i = DlgValue("CPNameList")
			DlgListBoxArray "CPNameList",TempList()
			DlgValue "CPNameList",i

			'重置编辑程序菜单
			If getMsgList(UIDataList,MsgList,"Main",1) = True Then
				Tools(0).sName = MsgList(3)
				Tools(1).sName = MsgList(4)
				Tools(2).sName = MsgList(5)
				Tools(3).sName = MsgList(6)
				'停止按钮按下时的显示对话框上的消息
				StopTitle = MsgList(12)
				StopMsg = MsgList(13)
			End If

			'重置设置对话框字串
			If getMsgList(UIDataList,MsgList,"Settings",1) = True Then
				DlgText -1,MsgList(0)
				DlgText "MainText",MsgList(1)
				ReDim TempList(7) As String
				TempList(0) = MsgList(28)
				TempList(1) = MsgList(98)
				TempList(2) = MsgList(77)
				TempList(3) = MsgList(53)
				TempList(4) = MsgList(106)
				TempList(5) = MsgList(8)
				TempList(6) = MsgList(22)
				TempList(7) = MsgList(118)
				i = DlgValue("MenuList")
				DlgListBoxArray "MenuList",TempList()
				DlgValue "MenuList",i

				DlgText "StrTypeText",MsgList(29)
				DlgText "RefStrTypeText",MsgList(30)
				DlgText "StrTypeListGroup",MsgList(31)
				DlgText "LevelButton",MsgList(2)
				DlgText "AddButton",MsgList(32)
				DlgText "ChangeButton",MsgList(33)
				DlgText "DelButton",MsgList(34)

				DlgText "CodeLocGroup",MsgList(35)
				DlgText "StrAddBefore",MsgList(36)
				DlgText "RefAddBefore",MsgList(37)
				DlgText "RefAddAfter",MsgList(96)

				DlgText "FristCodeGroup",MsgList(38)
				DlgText "FristCodePosText",MsgList(44)

				DlgText "CPCodeGroup",MsgList(39)
				DlgText "CPCodePosText",MsgList(44)
				DlgText "CPCodeSizeText",MsgList(47)

				DlgText "LengthCodeGroup",MsgList(40)
				DlgText "LengthCodePosText",MsgList(44)
				DlgText "LengthCodeSizeText",MsgList(47)
				DlgText "LengthReviseValText",MsgList(48)
				DlgText "LengthModeText",MsgList(49)

				DlgText "StartCodeGroup",MsgList(41)
				DlgText "StartCodePosText",MsgList(46)
				DlgText "StartCodeStrText",MsgList(50)

				DlgText "EndCodeGroup",MsgList(42)
				DlgText "EndCodeStrText",MsgList(50)
				DlgText "EndCodeStrButton",MsgList(3)

				DlgText "RefFristCodeGroup",MsgList(38)
				DlgText "RefAfterCodeGroup",MsgList(76)
				DlgText "RefAddBeforeFristCodePosText",MsgList(45)
				DlgText "RefAddAfterFristCodePosText",MsgList(97)

				DlgText "RefCPCodeGroup",MsgList(39)
				DlgText "RefAddBeforeCPCodePosText",MsgList(45)
				DlgText "RefAddAfterCPCodePosText",MsgList(97)
				DlgText "RefCPCodeSizeText",MsgList(47)
				DlgText "RefCPCodeBefStrText",MsgList(51)

				DlgText "RefLengthCodeGroup",MsgList(40)
				DlgText "RefAddBeforeLengthCodePosText",MsgList(45)
				DlgText "RefAddAfterLengthCodePosText",MsgList(97)
				DlgText "RefLengthCodeSizeText",MsgList(47)
				DlgText "RefLengthReviseValText",MsgList(48)
				DlgText "RefLengthModeText",MsgList(49)
				DlgText "RefLengthCodeBefStrText",MsgList(51)

				DlgText "RefCodeBefGroup",MsgList(43)
				DlgText "RefAddBeforeCodeBefPosText",MsgList(45)
				DlgText "RefAddAfterCodeBefPosText",MsgList(97)
				DlgText "RefCodeBefStrText",MsgList(52)

				DlgText "LngGroup",MsgList(77)
				DlgText "LngAddButton",MsgList(32)
				DlgText "LngChangeButton",MsgList(33)
				DlgText "LngDelButton",MsgList(34)
				DlgText "LngIDText",MsgList(78)
				DlgText "CPNameText",MsgList(79)
				DlgText "CPMenuButton",MsgList(3)
				DlgText "UniCodeRangeText",MsgList(80)
				DlgText "FeatureCodeText",MsgList(81)
				DlgText "FeatureCodeEnableCheckBox",MsgList(82)
				DlgText "CPTipText",MsgList(83)

				DlgText "FreeByteGroup",MsgList(58)
				DlgText "StrFreeByteCheckBox",MsgList(59)
				DlgText "NotStrFreeByteCheckBox",MsgList(60)
				DlgText "NoMarkPEFreeByteText",MsgList(61)
				DlgText "SectionEndFreeByteCheckBox",MsgList(62)
				DlgText "AddSectionEndFreeByteCheckBox",MsgList(63)
				DlgText "ViewAddSectionEndFreeByteButton",MsgList(64)
				DlgText "AddLastSectionEndCheckBox",MsgList(65)
				DlgText "NewSectionCheckBox",MsgList(66)
				DlgText "WriteOrderText",MsgList(67)
				DlgText "WriteOrderButton",MsgList(2)
				DlgText "OrgFreeByteCheckBox",MsgList(68)
				DlgText "FileAlignText",MsgList(69)
				DlgText "FileAlignCheckBox",MsgList(70)
				DlgText "FreeByteTipText",MsgList(71)
				DlgText "AllWriteMsgGroup",MsgList(72)
				DlgText "WriteLogFileCheckBox",MsgList(73)
				DlgText "OpenLogFileCheckBox",MsgList(74)
				DlgText "TranStrOnlyMsgCheckBox",MsgList(75)

				DlgText "UpdateSetGroup",MsgList(9)
				DlgText "AutoButton",MsgList(10)
				DlgText "ManualButton",MsgList(11)
				DlgText "OffButton",MsgList(12)
				DlgText "CheckGroup",MsgList(13)
				DlgText "UpdateCycleText",MsgList(14)
				DlgText "UpdateDatesText",MsgList(15)
				DlgText "UpdateDateText",MsgList(16)
				DlgText "CheckButton",MsgList(21)
				DlgText "WebSiteGroup",MsgList(17)
				DlgText "CmdGroup",MsgList(18)
				DlgText "CmdPathBoxText",MsgList(19)
				DlgText "ArgumentBoxText",MsgList(20)
				DlgText "ExeBrowseButton",MsgList(2)
				DlgText "ArgumentButton",MsgList(3)

				DlgText "UILangSetGroup",MsgList(23)
				DlgText "UILangSetText1",MsgList(24)
				DlgText "UILangSetText2",MsgList(25)

				DlgText "UIFontSetGroup",MsgList(84)
				DlgText "MainFontText",MsgList(85)
				DlgText "SrcStrFontText",MsgList(86)
				DlgText "TrnStrFontText",MsgList(87)
				DlgText "MainFontButton",MsgList(3)
				DlgText "SrcStrFontButton",MsgList(3)
				DlgText "TrnStrFontButton",MsgList(3)

				DlgText "NumDisplayFormatText",MsgList(26)
				DlgText "DecDisplayFormatButton",MsgList(88)
				DlgText "HexDisplayFormatButton",MsgList(89)
				DlgText "MsgOutputGroupText",MsgList(90)
				DlgText "PSLOutputButton",MsgList(91)
				DlgText "HCSOutputButton",MsgList(92)
				DlgText "OtherGroup",MsgList(93)
				DlgText "SpaceWithPointCheckBox",MsgList(94)
				DlgText "FilterDisplayAtStartupBox",MsgList(95)

				DlgText "RefTypeText",MsgList(99)
				DlgText "RefTypeListGroup",MsgList(100)
				DlgText "RefAddButton",MsgList(32)
				DlgText "RefChangeButton",MsgList(33)
				DlgText "RefDelButton",MsgList(34)
				DlgText "RefAlgorithmText",MsgList(101)
				DlgText "RefAlgorithmButton",MsgList(3)
				DlgText "RefCodeLengthText",MsgList(102)
				DlgText "RefCodeByteSequenceText",MsgList(103)
				DlgText "RefCodePrefixByteText",MsgList(104)
				DlgText "RefCodePrefixLengthText",MsgList(105)
				DlgText "StrAddAlgorithmText",MsgList(117)
				DlgText "StrAddAlgorithmButton",MsgList(3)

				DlgText "OpenFileModeGroup",MsgList(54)
				DlgText "StreamModeButton",MsgList(55)
				DlgText "ByteModeButton",MsgList(56)
				DlgText "MapFileButton",MsgList(57)

				DlgText "VoiceGroup",MsgList(107)
				DlgText "GetStringVoiceCheckBox",MsgList(108)
				DlgText "ImportSrcVoiceCheckBox",MsgList(109)
				DlgText "ImportTrnVoiceCheckBox",MsgList(110)
				DlgText "ParseStrDataVoiceCheckBox",MsgList(111)
				DlgText "GetStrTypeVoiceCheckBox",MsgList(112)
				DlgText "MoveStringVoiceCheckBox",MsgList(113)
				DlgText "AddAndDelFilterVoiceCheckBox",MsgList(114)
				DlgText "AddAndDelReserveVoiceCheckBox",MsgList(115)
				DlgText "WriteStringVoiceCheckBox",MsgList(116)

				DlgText "HelpSystemGroup",MsgList(118)
				DlgText "HelpSystemText",MsgList(119)
				DlgText "TextHelpSystemButton",MsgList(120)
				DlgText "CHMHelpSystemButton",MsgList(121)

				DlgText "HelpButton",MsgList(4)
				DlgText "ResetButton",MsgList(7)
				DlgText "TestButton",MsgList(5)
				DlgText "CleanButton",MsgList(6)
				DlgText "EditUILangButton",MsgList(27)
			End If

			'重置设置对话框字串
			If getMsgList(UIDataList,MsgList,"SettingsDlgFunc",1) = True Then
				'重置对话框项目名称
				TempArray = ReSplit(MsgList(27),";")
				n = UBound(TempArray)
				ReDim TempList(n) As String
				For i = 0 To n
					TempList(i) = TempArray(StrToLong(Mid$(Selected(11),i + 1,1)) - 1)
				Next i
				DlgText "WriteOrderTextBox",StrListJoin(TempList,ItemJoinStr)

				ReDim TempList(UBound(UIFileList) + 2) As String
				For i = 0 To UBound(UIFileList) + 2
					If i = 0 Then
						TempList(i) = MsgList(44)
					ElseIf i = 1 Then
						TempList(i) = MsgList(51)
					Else
						TempList(i) = UIFileList(i - 2).LangName
					End If
				Next i
				DlgListBoxArray "UILangList",TempList()
				DlgValue "UILangList",HeaderID

				If CheckStrTypeArray(StrTypeList) = False Then
					ReDim TempList(0) As String
					TempList(0) = MsgList(45)
					StrTypeList(0).sName = TempList(0)
					i = DlgValue("StrTypeNameList")
					DlgListBoxArray "StrTypeNameList",TempList()
					DlgValue "StrTypeNameList",i
				End If

				TempList = ReSplit(MsgList(46),";")
				i = DlgValue("LengthModeList")
		  		DlgListBoxArray "LengthModeList",TempList()
				DlgValue "LengthModeList",i

				TempList = ReSplit(MsgList(47),";")
				i = DlgValue("RefLengthModeList")
				DlgListBoxArray "RefLengthModeList",TempList()
				DlgValue "RefLengthModeList",i

		  		TempList = ReSplit(MsgList(48) & ",1,2,4,8",",")
				i = DlgValue("CPCodeSizeList")
				DlgListBoxArray "CPCodeSizeList",TempList()
				DlgValue "CPCodeSizeList",i
				i = DlgValue("LengthCodeSizeList")
				DlgListBoxArray "LengthCodeSizeList",TempList()
				DlgValue "LengthCodeSizeList",i
				i = DlgValue("RefCPCodeSizeList")
				DlgListBoxArray "RefCPCodeSizeList",TempList()
				DlgValue "RefCPCodeSizeList",i
				i = DlgValue("RefLengthCodeSizeList")
				DlgListBoxArray "RefLengthCodeSizeList",TempList()
				DlgValue "RefLengthCodeSizeList",i

		  		TempList = ReSplit(MsgList(48) & ",0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16",",")
				i = DlgValue("CPCodePosList")
				DlgListBoxArray "CPCodePosList",TempList()
				DlgValue "CPCodePosList",i
				i = DlgValue("LengthCodePosList")
				DlgListBoxArray "LengthCodePosList",TempList()
				DlgValue "LengthCodePosList",i
				i = DlgValue("StartCodePosList")
				DlgListBoxArray "StartCodePosList",TempList()
				DlgValue "StartCodePosList",i
				i = DlgValue("RefCPCodePosList")
				DlgListBoxArray "RefCPCodePosList",TempList()
				DlgValue "RefCPCodePosList",i
				i = DlgValue("RefLengthCodePosList")
				DlgListBoxArray "RefLengthCodePosList",TempList()
				DlgValue "RefLengthCodePosList",i
				i = DlgValue("RefCodeBefPosList")
				DlgListBoxArray "RefCodeBefPosList",TempList()
				DlgValue "RefCodeBefPosList",i

				TempList = ReSplit(MsgList(49),";")
				i = DlgValue("LengthReviseNameList")
				DlgListBoxArray "LengthReviseNameList",TempList()
				DlgValue "LengthReviseNameList",i
				i = DlgValue("RefLengthReviseNameList")
				DlgListBoxArray "RefLengthReviseNameList",TempList()
				DlgValue "RefLengthReviseNameList",i

				TempList = ReSplit(MsgList(76),";")
				i = DlgValue("RefCodeByteSequenceList")
				DlgListBoxArray "RefCodeByteSequenceList",TempList()
				DlgValue "RefCodeByteSequenceList",i
			End If
		Case 7
			Select Case DlgItem$
			Case "HelpSystemOption"
				Selected(30) = DlgValue("HelpSystemOption")
			Case "ResetButton"
				ReDim TempArray(1) As String
				TempArray(0) = MsgList(1)
				TempArray(1) = MsgList(2)
				Select Case ShowPopupMenu(TempArray,vbPopupUseRightButton)
				Case Is < 0
					Exit Function
				Case 0
					DlgValue "HelpSystemOption",1
				Case Else
					DlgValue "HelpSystemOption",StrToLong(SelectedBak(30))
				End Select
			End Select
		End Select
	Case 3 ' 文本框或者组合框文本被更改
		If getMsgList(UIDataList,MsgList,"SettingsDlgFunc",1) = False Then Exit Function
		Select Case DlgValue("MenuList")
		Case 0
			HeaderID = DlgValue("StrTypeNameList")
			If HeaderID < 0 Then Exit Function
			With StrTypeList(HeaderID)
				Select Case DlgItem$
				Case "StartCodeStrBox"
					DlgText "StartCodeStrBox",UCase$(Replace$(DlgText("StartCodeStrBox")," ",""))
					Temp = UCase$(DlgText("StartCodeStrBox"))
					If Temp = .StartCodeString Then Exit Function
				Case "EndCodeStrBox"
					DlgText "EndCodeStrBox",UCase$(Replace$(DlgText("EndCodeStrBox")," ",""))
					Temp = UCase$(DlgText("EndCodeStrBox"))
					If Temp = .EndCodeString Then Exit Function
				Case "RefCPCodeBefStrBox"
					DlgText "RefCPCodeBefStrBox",UCase$(Replace$(DlgText("RefCPCodeBefStrBox")," ",""))
					Temp = UCase$(DlgText("RefCPCodeBefStrBox"))
					If Temp = .CPCodeStartString Then Exit Function
				Case "RefLengthCodeBefStrBox"
					DlgText "RefLengthCodeBefStrBox",UCase$(Replace$(DlgText("RefLengthCodeBefStrBox")," ",""))
					Temp = UCase$(DlgText("RefLengthCodeBefStrBox"))
					If Temp = .LengthCodeStartString Then Exit Function
				Case "RefCodeBefStrBox"
					DlgText "RefCodeBefStrBox",UCase$(Replace$(DlgText("RefCodeBefStrBox")," ",""))
					Temp = UCase$(DlgText("RefCodeBefStrBox"))
					If Temp = .RefCodeStartString Then Exit Function
				Case Else
					Exit Function
				End Select
				If Temp <> "" Then
					If InStr(Temp,"\") Then
						MsgBox MsgList(14),vbInformation+vbOkOnly,MsgList(0)
						Temp = ""
					ElseIf (Len(Temp) Mod 2) <> 0 Then
						MsgBox MsgList(15),vbInformation+vbOkOnly,MsgList(0)
						Temp = ""
					ElseIf Temp = "00" Then
						If .LengthMode <> 0 And .LengthMode < 5 Then
							MsgBox MsgList(16),vbInformation+vbOkOnly,MsgList(0)
							Temp = ""
						End If
					ElseIf Left$(Temp,2) = "00" Then
						MsgBox MsgList(17),vbInformation+vbOkOnly,MsgList(0)
						Temp = ""
					ElseIf CheckStrRegExp(Temp,CheckSkipStr(6),0,1,True) = False Then
						MsgBox MsgList(18),vbInformation+vbOkOnly,MsgList(0)
						Temp = ""
					End If
					If Temp = "" Then
						Select Case DlgItem$
						Case "StartCodeStrBox"
							DlgText "StartCodeStrBox",.StartCodeString
						Case "EndCodeStrBox"
							DlgText "EndCodeStrBox",.EndCodeString
						Case "RefCPCodeBefStrBox"
							DlgText "RefCPCodeBefStrBox",.CPCodeStartString
						Case "RefLengthCodeBefStrBox"
							DlgText "RefLengthCodeBefStrBox",.LengthCodeStartString
						Case "RefCodeBefStrBox"
							DlgText "RefCodeBefStrBox",.RefCodeStartString
						End Select
						Exit Function
					End If
				End If
				Select Case DlgItem$
				Case "StartCodeStrBox"
					.StartCodeString = Temp
					.StartCodeLength = Len(Temp) \ 2
					.StartCodeByte = HexStr2Bytes(Temp)
				Case "EndCodeStrBox"
					.EndCodeString = Temp
					.EndCodeLength = Len(Temp) \ 2
					.EndCodeByte = HexStr2Bytes(Temp)
				Case "RefCPCodeBefStrBox"
					.CPCodeStartString = Temp
					.CPCodeStartLength = Len(Temp) \ 2
					.CPCodeStartByte = HexStr2Bytes(Temp)
				Case "RefLengthCodeBefStrBox"
					.LengthCodeStartString = Temp
					.LengthCodeStartLength = Len(Temp) \ 2
					.LengthCodeStartByte = HexStr2Bytes(Temp)
				Case "RefCodeBefStrBox"
					.RefCodeStartString = Temp
					.RefCodeStartLength = Len(Temp) \ 2
					.RefCodeStartByte = HexStr2Bytes(Temp)
				End Select
			End With
		Case 1
			HeaderID = DlgValue("RefTypeNameList")
			If HeaderID < 0 Then Exit Function
			With RefTypeList(HeaderID)
				Select Case DlgItem$
				Case "RefAlgorithmBox"
					DlgText "RefAlgorithmBox",Trim$(DlgText("RefAlgorithmBox"))
					If Replace$(DlgText("RefAlgorithmBox")," ","") = "" Then
						MsgBox MsgList(72),vbOkOnly+vbInformation,MsgList(0)
						Exit Function
					ElseIf CheckStrRegExp(DlgText("RefAlgorithmBox"),"[0-9\{\}StrAdesfTypLngth\+\-\x20]",0,1,True) = False Then
						MsgBox MsgList(73),vbOkOnly+vbInformation,MsgList(0)
						Exit Function
					End If
					.Algorithm = DlgText("RefAlgorithmBox")
					If InStr(LCase(.Algorithm),"{refstartaddress}") Then
						.FileMagic = "NotPE64"
					ElseIf InStr(LCase(.Algorithm),"{strstartaddress}") Then
						.FileMagic = "NotPE32"
					Else
						.FileMagic = ""
					End If
					.Template = RefTypeToString(RefTypeList,HeaderID)
				Case "RefCodeLengthBox"
					If DlgText("RefAlgorithmBox") <> "" Then
						DlgText "RefCodeLengthBox",Trim$(DlgText("RefCodeLengthBox"))
						If StrToLong(DlgText("RefCodeLengthBox")) < 1 Then
							MsgBox MsgList(74),vbOkOnly+vbInformation,MsgList(0)
							Exit Function
						ElseIf (StrToLong(DlgText("RefCodeLengthBox")) Mod 2) <> 0 Then
							MsgBox MsgList(82),vbOkOnly+vbInformation,MsgList(0)
							Exit Function
						End If
					End If
					.ByteLength = StrToLong(DlgText("RefCodeLengthBox"))
					.Template = RefTypeToString(RefTypeList,HeaderID)
				Case "RefCodePrefixByteBox"
					If DlgText("RefCodePrefixByteBox") <> "" Then
						DlgText "RefCodePrefixByteBox",Trim$(DlgText("RefCodePrefixByteBox"))
						If CheckRegExp(RegExp,DlgText("RefCodePrefixByteBox")) = False Then
							MsgBox MsgList(77),vbOkOnly+vbInformation,MsgList(0)
							Exit Function
						End If
					End If
					.PrefixByte = DlgText("RefCodePrefixByteBox")
				Case "RefCodePrefixLengthBox"
					If DlgText("RefCodePrefixByteBox") <> "" Then
						DlgText "RefCodePrefixLengthBox",Trim$(DlgText("RefCodePrefixLengthBox"))
						If StrToLong(DlgText("RefCodePrefixLengthBox")) < 1 Then
							MsgBox MsgList(74),vbOkOnly+vbInformation,MsgList(0)
							Exit Function
						End If
					End If
					.PrefixLength = StrToLong(DlgText("RefCodePrefixLengthBox"))
					.Template = RefTypeToString(RefTypeList,HeaderID)
				Case "StrAddAlgorithmBox"
					If DlgText("StrAddAlgorithmBox") <> "" Then
						DlgText "StrAddAlgorithmBox",Trim$(DlgText("StrAddAlgorithmBox"))
						If CheckStrRegExp(DlgText("StrAddAlgorithmBox"),"[0-9\{\}RefCodStrAdsTypLngth\+\-\x20]",0,1,True) = False Then
							MsgBox MsgList(84),vbOkOnly+vbInformation,MsgList(0)
							Exit Function
						End If
					End If
					.StrAddAlgorithm = DlgText("StrAddAlgorithmBox")
					.Template = RefTypeToString(RefTypeList,HeaderID)
				End Select
			End With
		Case 2
			HeaderID = DlgValue("LngNameList")
			If HeaderID < 0 Then Exit Function
			With UniLangList(HeaderID)
				Select Case DlgItem$
				Case "LngIDTextBox"
					DlgText "LngIDTextBox",Trim$(DlgText("LngIDTextBox"))
					Temp = DlgText("LngIDTextBox")
					If Temp = CStr$(.LangID) Then Exit Function
				Case "UniCodeRangeTextBox"
					DlgText "UniCodeRangeTextBox",UCase$(Trim$(DlgText("UniCodeRangeTextBox")))
					Temp = UCase$(DlgText("UniCodeRangeTextBox"))
					If Temp = CStr$(.UniCodeRange) Then Exit Function
				Case "FeatureCodeTextBox"
					DlgText "FeatureCodeTextBox",UCase$(Trim$(DlgText("FeatureCodeTextBox")))
					Temp = UCase$(DlgText("FeatureCodeTextBox"))
					If Temp = CStr$(.FeatureCode) Then Exit Function
				Case Else
					Exit Function
				End Select
				If Temp = "" Then MsgBox MsgList(55),vbInformation+vbOkOnly,MsgList(0)
				Do
					If Temp = "" Then
						Select Case DlgItem$
						Case "LngIDTextBox"
							DlgText "LngIDTextBox",CStr(.LangID)
						Case "UniCodeRangeTextBox"
							DlgText "UniCodeRangeTextBox",.UniCodeRange
						Case "FeatureCodeTextBox"
							DlgText "FeatureCodeTextBox",.FeatureCode
						End Select
						Exit Function
					End If
					If DlgItem$ = "LngIDTextBox" Then
						If IsNumeric(Temp) = False Then
							MsgBox MsgList(20),vbInformation+vbOkOnly,MsgList(0)
							Temp = ""
						ElseIf LangIDIndexDic.Exists(StrToLong(Temp)) Then
							MsgBox MsgList(53),vbInformation+vbOkOnly,MsgList(0)
							Temp = ""
						End If
					ElseIf InStr(Temp,"\") Then
						MsgBox MsgList(14),vbInformation+vbOkOnly,MsgList(0)
						Temp = ""
					ElseIf (Len(Replace$(Replace$(Temp,",",""),"-","")) Mod 4) <> 0 Then
						MsgBox MsgList(15),vbInformation+vbOkOnly,MsgList(0)
						Temp = ""
					ElseIf CheckStrRegExp(Replace$(Replace$(Temp,",",""),"-",""),CheckSkipStr(6),0,1,True) = False Then
						MsgBox MsgList(18),vbInformation+vbOkOnly,MsgList(0)
						Temp = ""
					ElseIf CheckStrRegExp(Temp,"[0-9a-f]{4}([-,][0-9a-f]{4})*",0,5,True) = False Then
						MsgBox MsgList(59),vbInformation+vbOkOnly,MsgList(0)
						Temp = ""
					End If
					If Temp <> "" Then Exit Do
				Loop
				Select Case DlgItem$
				Case "LngIDTextBox"
					If LangIDIndexDic.Exists(.LangID) Then LangIDIndexDic.Key(.LangID) = StrToLong(Temp)
					.LangID = StrToLong(Temp)
					'i = PSL.GetDefaultCodePage(.LangID)
					i = StrToLong(GetLCIDInfo(.LangID,LOCALE_IDEFAULTANSICODEPAGE),CP_UNKNOWN)
					If i = 0 Then i = CP_UNKNOWN
					DlgText "CPValList",CStr$(i)
					DlgValue "CPNameList",DlgValue("CPValList")
					.CPName = Trim$(ReSplit(DlgText("CPNameList")," - ",2)(1))
					.CodePage = i
				Case "UniCodeRangeTextBox"
					.UniCodeRange = Temp
				Case "FeatureCodeTextBox"
					.FeatureCode = Temp
				End Select
				.UniCodeRegExpPattern = "[\u" & Replace$(Replace$(.UniCodeRange,"-","-\u"),",","\u") & "]"
				.UniCodeByteRange = Convert(.UniCodeRegExpPattern)
				.FeatureCodeRegExpPattern = "[\u" & Replace$(Replace$(.FeatureCode,"-","-\u"),",","\u") & "]"
				.FeatureCodeByteRange = Convert(.FeatureCodeRegExpPattern)
				.FeatureCodeEnable = IIf(.FeatureCode = "",0,.FeatureCodeEnable)
				If .FeatureCode = "" Then
					DlgValue "FeatureCodeEnableCheckBox",0
					DlgEnable "FeatureCodeEnableCheckBox",False
				Else
					DlgEnable "FeatureCodeEnableCheckBox",True
				End If
			End With
		Case 3
			If DlgItem$ <> "NoMarkPEFreeByteTextBox" Then Exit Function
			DlgText "NoMarkPEFreeByteTextBox",Trim$(DlgText("NoMarkPEFreeByteTextBox"))
			Temp = DlgText("NoMarkPEFreeByteTextBox")
			If Temp = "" Then Exit Function
			If IsNumeric(Temp) = False Then
				MsgBox MsgList(23),vbInformation+vbOkOnly,MsgList(0)
				DlgText "NoMarkPEFreeByteTextBox",Selected(9)
				Exit Function
			ElseIf CLng(Temp) < FreeByteMinLength Then
				MsgBox MsgList(29),vbInformation+vbOkOnly,MsgList(0)
				DlgText "NoMarkPEFreeByteTextBox",CStr(FreeByteMinLength)
				Exit Function
			End If
			Selected(9) = Temp
		Case 5
			Select Case DlgItem$
			Case "CmdPathBox"
				If DlgText("CmdPathBox") = "" Then
					MsgBox MsgList(7),vbInformation+vbOkOnly,MsgList(0)
					Exit Function
				ElseIf Dir$(DlgText("CmdPathBox")) = "" Then
					MsgBox MsgList(61),vbInformation+vbOkOnly,MsgList(0)
					Exit Function
				End If
				Temp = Trim(DlgText("CmdPathBox"))
				If InStr(LCase$(Temp),"winrar.exe") Then
					DlgText "ArgumentBox","e -ibck ""%1"" %2 ""%3"""
				ElseIf InStr(LCase$(Temp),"winzip.exe") Then
					DlgText "CmdPathBox",strReplace(Temp,"WinZip.exe","WzunZip.exe")
					DlgText "ArgumentBox"," ""%1"" %2 ""%3"""
				ElseIf InStr(LCase$(Temp),"wzunzip.exe") Then
					DlgText "ArgumentBox"," ""%1"" %2 ""%3"""
				ElseIf InStr(LCase$(Temp),"7z.exe") Then
					DlgText "ArgumentBox","e -r ""%1"" -o""%3"" %2"
				ElseIf InStr(LCase$(Temp),"7zfm.exe") Then
					DlgText "ArgumentBox",strReplace(Temp,"7zFM.exe","7z.exe")
					DlgText "ArgumentBox","e -r ""%1"" -o""%3"" %2"
				ElseIf InStr(LCase$(Temp),"haozip.exe") Then
					DlgText "CmdPathBox",strReplace(Temp,"HaoZip.exe","HaoZipC.exe")
					DlgText "ArgumentBox","e ""%1"" -r -o""%3"" %2"
				ElseIf InStr(LCase$(Temp),"haozipc.exe") Then
					DlgText "ArgumentBox","e ""%1"" -r -o""%3"" %2"
				End If
				UpdateSet(2) = Temp
			Case "ArgumentBox"
				If DlgText("ArgumentBox") = "" Then
					MsgBox MsgList(7),vbInformation+vbOkOnly,MsgList(0)
					Exit Function
				End If
				UpdateSet(3) = DlgText("ArgumentBox")
			Case Else
				UpdateSet(0) = DlgValue("UpdateSet")
				UpdateSet(1) = DlgText("WebSiteBox")
				UpdateSet(4) = DlgText("UpdateCycleBox")
				UpdateSet(5) = DlgText("UpdateDateBox")
				If UpdateSet(5) = MsgList(3) Then UpdateSet(5) = ""
			End Select
		End Select
	Case 6 ' 函数快捷键
		If SuppValue = 1 Then
			Select Case DlgValue("MenuList")
			Case 0
				If StrToLong(Selected(30)) = 1 Then
					If OpenCHM(CLng(DlgText("SuppValueBox")),1012,Selected(0),OSLanguage,UIFileList) = True Then Exit Function
				End If
				Call Help("StrTypeSetHelp")
			Case 1
				If StrToLong(Selected(30)) = 1 Then
					If OpenCHM(CLng(DlgText("SuppValueBox")),1021,Selected(0),OSLanguage,UIFileList) = True Then Exit Function
				End If
				Call Help("RefTypeSetHelp")
			Case 2
				If StrToLong(Selected(30)) = 1 Then
					If OpenCHM(CLng(DlgText("SuppValueBox")),1005,Selected(0),OSLanguage,UIFileList) = True Then Exit Function
				End If
				Call Help("EncodeRangeSetHelp")
			Case 3
				If StrToLong(Selected(30)) = 1 Then
					If OpenCHM(CLng(DlgText("SuppValueBox")),1026,Selected(0),OSLanguage,UIFileList) = True Then Exit Function
				End If
				Call Help("WriteSetHelp")
			Case 4
				If StrToLong(Selected(30)) = 1 Then
					If OpenCHM(CLng(DlgText("SuppValueBox")),1013,Selected(0),OSLanguage,UIFileList) = True Then Exit Function
				End If
				Call Help("FileReadWriteAndVoiceSetHelp")
			Case 5
				If StrToLong(Selected(30)) = 1 Then
					If OpenCHM(CLng(DlgText("SuppValueBox")),1003,Selected(0),OSLanguage,UIFileList) = True Then Exit Function
				End If
				Call Help("UpdateSetHelp")
			Case 6
				If StrToLong(Selected(30)) = 1 Then
					If OpenCHM(CLng(DlgText("SuppValueBox")),1027,Selected(0),OSLanguage,UIFileList) = True Then Exit Function
				End If
				Call Help("UILangSetHelp")
			Case 7
				If StrToLong(Selected(30)) = 1 Then
					If OpenCHM(CLng(DlgText("SuppValueBox")),1028,Selected(0),OSLanguage,UIFileList) = True Then Exit Function
				End If
				Call Help("HelpSystemSetHelp")
			End Select
		End If
	End Select
End Function


'添加或编辑语言对
Private Function SetLang(DataArr() As String,ByVal HeaderID As Long,ByVal SplitChar As String) As String
	Dim i As Long,MsgList() As String,LangPairList() As String
	Dim LangName As String,SrcCode As String
	On Error GoTo ExitFunction
	If getMsgList(UIDataList,MsgList,"SetLang",1) = False Then Exit Function
	If HeaderID > -1 Then
		LangPairList = ReSplit(DataArr(HeaderID),SplitChar)
		LangName = LangPairList(0)
		SrcCode = LangPairList(1)
	End If
	Begin Dialog UserDialog 390,168,IIf(LangName = "",MsgList(0),MsgList(1)),.CommonDlgFunc ' %GRID:10,7,1,1
		Text 10,14,370,14,MsgList(2),.LangText
		TextBox 10,35,370,21,.LangName
		Text 10,77,370,14,MsgList(3),.CodeText
		TextBox 10,98,370,21,.SrcCode
		OKButton 90,140,80,21,.OKButton
		CancelButton 220,140,80,21,.CancelButton
	End Dialog
    Dim dlg As UserDialog
    dlg.LangName = LangName
    dlg.SrcCode = SrcCode
    DataInPutDlg:
    If Dialog(dlg) = 0 Then Exit Function
	If dlg.LangName & dlg.SrcCode = "" Then
		MsgBox MsgList(5),vbOkOnly+vbInformation,MsgList(4)
		GoTo DataInPutDlg
	End If
	If dlg.LangName = "" Or dlg.SrcCode = "" Then
		MsgBox MsgList(6),vbOkOnly+vbInformation,MsgList(4)
		GoTo DataInPutDlg
	End If
	If dlg.LangName = LangName And dlg.SrcCode = SrcCode Then Exit Function
	For i = LBound(DataArr) To UBound(DataArr)
		If i <> HeaderID Then
			LangPairList = ReSplit(LCase$(DataArr(i)),SplitChar)
			If LCase$(dlg.LangName) = LangPairList(0) Then
				MsgBox MsgList(7),vbOkOnly+vbInformation,MsgList(4)
				GoTo DataInPutDlg
			ElseIf LCase$(dlg.SrcCode) = LangPairList(1) Then
				MsgBox MsgList(8),vbOkOnly+vbInformation,MsgList(4)
				GoTo DataInPutDlg
			End If
		End If
	Next i
	SetLang = dlg.LangName & SplitChar & dlg.SrcCode
	ExitFunction:
End Function


'更改配置优先级
Private Function SetLevel(LevelList() As String,ByVal ID As Long,ByVal Msg As String) As Boolean
	Dim MsgList() As String
	If getMsgList(UIDataList,MsgList,"SetLevel",1) = False Then Exit Function
	UseStrList = LevelList
	AllStrList = LevelList
	Begin Dialog UserDialog 480,322,MsgList(0),.SetLevelDlgFunc ' %GRID:10,7,1,1
		Text 10,7,460,105,Msg
		ListBox 10,119,360,161,LevelList(),.LevelList
		PushButton 380,119,90,21,MsgList(1),.UpButton
		PushButton 380,147,90,21,MsgList(2),.DownButton
		PushButton 380,175,90,21,MsgList(3),.ResetButton
		OKButton 130,294,80,21,.OKButton
		CancelButton 280,294,80,21,.CancelButton
	End Dialog
	Dim dlg As UserDialog
	dlg.LevelList = ID
	If Dialog(dlg) = 0 Then Exit Function
	If ArrayComp(UseStrList,AllStrList) = True Then
		SetLevel = True
		LevelList = UseStrList
	End If
	Erase UseStrList,AllStrList
End Function


'更改配置优先级对话框函数
Private Function SetLevelDlgFunc(DlgItem$, Action%, SuppValue&) As Boolean
	Dim i As Long,j As Long,Temp As String
	Select Case Action%
	Case 1 ' 对话框窗口初始化
		If UBound(UseStrList) = 0 Then
			DlgEnable "UpButton",False
			DlgEnable "DownButton",False
		Else
			Select Case DlgValue("LevelList")
			Case Is < 0
				DlgEnable "UpButton",False
				DlgEnable "DownButton",False
			Case 0
				DlgEnable "UpButton",False
			Case DlgListBoxArray("LevelList") - 1
				DlgEnable "DownButton",False
			Case Else
				DlgEnable "DownButton",True
			End Select
		End If
		DlgEnable "ResetButton",False
		'设置当前对话框字体
		If CheckFont(LFList(0)) = True Then
			j = CreateFont(0,LFList(0))
			If j = 0 Then Exit Function
			For i = 0 To DlgCount() - 1
				SendMessageLNG(GetDlgItem(SuppValue,DlgControlId(DlgName(i))),WM_SETFONT,j,0)
			Next i
		End If
	Case 2 ' 数值更改或者按下了按钮
		SetLevelDlgFunc = True '防止按下按钮关闭对话框窗口
		Select Case DlgItem$
		Case "CancelButton","OKButton"
			SetLevelDlgFunc = False
			Exit Function
		Case "UpButton"
			i = DlgValue("LevelList")
			If i = 0 Then Exit Function
			Temp = UseStrList(i)
			UseStrList(i) = UseStrList(i - 1)
			UseStrList(i - 1) = Temp
			DlgListBoxArray "LevelList",UseStrList()
			DlgValue "LevelList",i - 1
		Case "DownButton"
			i = DlgValue("LevelList")
			If i = UBound(UseStrList) Then Exit Function
			Temp = UseStrList(i)
			UseStrList(i) = UseStrList(i + 1)
			UseStrList(i + 1) = Temp
			DlgListBoxArray "LevelList",UseStrList()
			DlgValue "LevelList",i + 1
		Case "ResetButton"
			UseStrList = AllStrList
			DlgListBoxArray "LevelList",UseStrList()
			DlgValue "LevelList",0
		End Select
		If UBound(UseStrList) = 0 Then
			DlgEnable "UpButton",False
			DlgEnable "DownButton",False
		Else
			Select Case DlgValue("LevelList")
			Case Is < 0
				DlgEnable "UpButton",False
				DlgEnable "DownButton",False
			Case 0
				DlgEnable "UpButton",False
				DlgEnable "DownButton",True
			Case DlgListBoxArray("LevelList") - 1
				DlgEnable "UpButton",True
				DlgEnable "DownButton",False
			Case Else
				DlgEnable "UpButton",True
				DlgEnable "DownButton",True
			End Select
		End If
		DlgEnable "ResetButton",ArrayComp(UseStrList,AllStrList)
	End Select
End Function


'获取设置
Private Function GetSettings(ByVal SelSet As String) As Long
	Dim i As Long,j As Long,k As Long,n As Long,x As Long
	Dim Temp As String,OldVersion As String
	Dim TempList() As String,TempArray() As String,TempByte() As Byte
	On Error GoTo ExitFunction
	OldVersion = GetSetting(AppName,"Option","Version","")
	'获取界面语言设置
	If SelSet = "" Or SelSet = "Option" Then
		Selected(0) = GetSetting(AppName,"Option","UILanguageID",0)
		Selected(1) = GetSetting(AppName,"Option","OpenFileMode",0)
		Selected(2) = GetSetting(AppName,"Option","MoveToStrFreeByte",1)
		Selected(3) = GetSetting(AppName,"Option","MoveToNotStrFreeByte",0)
		Selected(4) = GetSetting(AppName,"Option","MoveToSectionEndFreeByte",0)
		Selected(5) = GetSetting(AppName,"Option","MoveToAddSectionEndFreeByte",1)
		Selected(6) = GetSetting(AppName,"Option","MoveToAddLastSectionEnd",0)
		Selected(7) = GetSetting(AppName,"Option","MoveToNewSection",0)
		Selected(8) = GetSetting(AppName,"Option","MoveOnOff",1)
		Selected(9) = GetSetting(AppName,"Option","NoMarkPEFreeByteMinLength",10)
		'Selected(10) = GetSetting(AppName,"Option","StringEndOriginalFreeByte",0)	'全局是否写入原有空位，已保存到字串设置中
		Selected(11) = GetSetting(AppName,"Option","WriteOrder","4132")
		Selected(12) = GetSetting(AppName,"Option","OptimizateFileSize",1)
		Selected(13) = GetSetting(AppName,"Option","WriteLogFile",0)
		Selected(14) = GetSetting(AppName,"Option","OpenLogFile",0)
		Selected(15) = GetSetting(AppName,"Option","TranStrOnlyMsgShow",1)
		Selected(16) = GetSetting(AppName,"Option","StrAddDisplayFormat",0)
		Selected(17) = GetSetting(AppName,"Option","MsgOutputWindows",1)	'<0 PSL 中显示，=0 不显示，>0 宏窗口中显示
		Selected(18) = GetSetting(AppName,"Option","StrFreeByteMatchLoops",2)
		Selected(19) = GetSetting(AppName,"Option","SpaceWithPointCheckBox",0)
		Selected(20) = GetSetting(AppName,"Option","FilterDisplayAtStartupBox",0)
		Selected(21) = GetSetting(AppName,"Option","GetStringVoiceCheckBox",1)
		Selected(22) = GetSetting(AppName,"Option","ImportSrcVoiceCheckBox",1)
		Selected(23) = GetSetting(AppName,"Option","ImportTrnVoiceCheckBox",1)
		Selected(24) = GetSetting(AppName,"Option","ParseStrDataVoiceCheckBox",1)
		Selected(25) = GetSetting(AppName,"Option","GetStrTypeVoiceCheckBox",1)
		Selected(26) = GetSetting(AppName,"Option","MoveStringVoiceCheckBox",1)
		Selected(27) = GetSetting(AppName,"Option","AddAndDelFilterVoiceCheckBox",1)
		Selected(28) = GetSetting(AppName,"Option","AddAndDelReserveVoiceCheckBox",1)
		Selected(29) = GetSetting(AppName,"Option","WriteStringVoiceCheckBox",1)
		Selected(30) = GetSetting(AppName,"Option","HelpSystemOption",1)
		If SelSet = "Option" Then
			If CheckArray(Selected) = True Then GetSettings = 1
			Exit Function
		End If
	End If
	'获取字串提取选项
	If SelSet = "" Or SelSet = "GetString" Then
		ExtractSet(0) = GetSetting(AppName,"GetString","ExtractModeOption",1)
		ExtractSet(1) = GetSetting(AppName,"GetString","ANSICheckBox",1)
		ExtractSet(2) = GetSetting(AppName,"GetString","UnicodeCheckBox",1)
		ExtractSet(3) = GetSetting(AppName,"GetString","UTF8CheckBox",0)
		ExtractSet(4) = GetSetting(AppName,"GetString","CharEncodeOrder","2100000")
		ExtractSet(11) = GetSetting(AppName,"GetString","ReferenceCheckBox",0)
		ExtractSet(12) = GetSetting(AppName,"GetString","NullStrCheckBox",1)
		ExtractSet(13) = GetSetting(AppName,"GetString","ControlStrCheckBox",1)
		ExtractSet(14) = GetSetting(AppName,"GetString","AllSymbolCheckBox",1)
		ExtractSet(15) = GetSetting(AppName,"GetString","AllUCaseCheckBox",1)
		ExtractSet(16) = GetSetting(AppName,"GetString","AllLCaseCheckBox",1)
		ExtractSet(17) = GetSetting(AppName,"GetString","AllULCaseCheckBox",1)
		ExtractSet(18) = GetSetting(AppName,"GetString","ContinuousCheckBox",1)
		ExtractSet(19) = GetSetting(AppName,"GetString","OtherStrCheckBox",1)
		ExtractSet(20) = GetSetting(AppName,"GetString","IncludeStrCheckBox",1)
		ExtractSet(21) = GetSetting(AppName,"GetString","FilterStrCheckBox",1)
		ExtractSet(22) = GetSetting(AppName,"GetString","IgnoreFilterAccKeyCheckBox",1)
		ExtractSet(23) = GetSetting(AppName,"GetString","KeepStrCheckBox",1)
		ExtractSet(24) = GetSetting(AppName,"GetString","IgnoreKeepAccKeyCheckBox",1)
		'ExtractSet(23) = GetSetting(AppName,"GetString","ExcludeStrCheckBox",1)
		'ExtractSet(24) = GetSetting(AppName,"GetString","IgnoreAccKeyCheckBox",1)
		ExtractSet(25) = GetSetting(AppName,"GetString","OutputMsgCheckBox",0)
		ExtractSet(26) = GetSetting(AppName,"GetString","LogingMsgCheckBox",0)
		ExtractSet(27) = GetSetting(AppName,"GetString","MinStrLengthTextBox",2)
		ExtractSet(28) = GetSetting(AppName,"GetString","ContinuousTextBox",3)
		ExtractSet(29) = GetSetting(AppName,"GetString","OtherStrTextBox",SkipStr)
		ExtractSet(30) = GetSetting(AppName,"GetString","IncludeStrTextBox",SkipHexStr)
		ExtractSet(31) = ConvertStrEndCharSet(GetSetting(AppName,"GetString","EndCharOfString",EndCharOfString),False)
		ExtractSet(32) = Str2RegExpPattern(Convert(ExtractSet(29)))
		ExtractSet(33) = Str2RegExpPattern(Convert(ExtractSet(30)))
		ExtractSet(42) = GetSetting(AppName,"GetString","OtherStrMatchMode",0)
		ExtractSet(43) = GetSetting(AppName,"GetString","OtherStrMatchCaseCheckBox",1)
		ExtractSet(44) = GetSetting(AppName,"GetString","IgnoreOtherAccKeyCheckBox",0)
		ExtractSet(45) = GetSetting(AppName,"GetString","OtherStrForWildcardTextBox","")
		ExtractSet(46) = GetSetting(AppName,"GetString","OtherStrForRegExpTextBox",NoVowelsRegExp)
		ExtractSet(47) = Convert(ExtractSet(45))
		ExtractSet(48) = "1"
		ExtractSet(49) = GetSetting(AppName,"GetString","RangeCheckBox",0)
		ExtractSet(51) = GetSetting(AppName,"GetString","BeFilterOnlyCheckBox",0)
		ExtractSet(52) = GetSetting(AppName,"GetString","MaxStrLengthCheckBox",0)
		ExtractSet(53) = GetSetting(AppName,"GetString","MaxStrLengthTextBox","10000")
		'第三项提取法已取消
		If ExtractSet(0) = "2" Then ExtractSet(0) = "1"
		'旧版本补位
		ExtractSet(4) = Left$(ExtractSet(4) & String$(6,"0"),7)
		If SelSet = "GetString" Then
			If CheckArray(ExtractSet) = True Then GetSettings = 2
			Exit Function
		End If
	End If
	'获取自动更新设置
	If SelSet = "" Or SelSet = "Update" Then
		UpdateSet(0) = GetSetting(AppName,"Update","UpdateMode",1)
		Temp = GetSetting(AppName,"Update","Count","")
		If Temp <> "" Then
			For i = 0 To StrToLong(Temp)
				Temp = GetSetting(AppName,"Update",CStr(i),"")
				If Temp <> "" Then
					If UpdateSet(1) <> "" Then
						UpdateSet(1) = UpdateSet(1) & vbCrLf & Temp
					Else
						UpdateSet(1) = Temp
					End If
				End If
			Next i
		End If
		UpdateSet(2) = GetSetting(AppName,"Update","Path","")
		UpdateSet(3) = GetSetting(AppName,"Update","Argument","")
		UpdateSet(4) = GetSetting(AppName,"Update","UpdateCycle",7)
		UpdateSet(5) = GetSetting(AppName,"Update","UpdateDate","")
		If SelSet = "Update" Then
			If CheckArray(UpdateSet) = True Then GetSettings = 3
			Exit Function
		End If
	End If
	'获取自定义字串类型
	If SelSet = "" Or SelSet = "Sets" Then
		Temp = GetSetting(AppName,"Option","StringTypeCount","")
		If Temp <> "" Then
			k = StrComp(ToUpdateStrTypeVersion,OldVersion)
			j = StrToLong(Temp): x = 0
			ReDim StrTypeList(j) As STRING_TYPE
			For i = 0 To j
				With StrTypeList(x)
					.sName = GetSetting(AppName,"StringType_" & CStr$(i),"Name","")
					If .sName <> "" Then
						.CodeLoc = GetSetting(AppName,"StringType_" & CStr$(i),"CodeLocation",0)
						.FristCodePos = GetSetting(AppName,"StringType_" & CStr$(i),"FristCodePos",0)
						.CPCodePos = GetSetting(AppName,"StringType_" & CStr$(i),"CodePageCodePos",0)
						.CPCodeSize = GetSetting(AppName,"StringType_" & CStr$(i),"CodePageCodeSize",0)
						.CPCodeStartString = GetSetting(AppName,"StringType_" & CStr$(i),"CodePageCodeStartString","")
						.LengthCodePos = GetSetting(AppName,"StringType_" & CStr$(i),"LengthCodePos",0)
						.LengthCodeSize = GetSetting(AppName,"StringType_" & CStr$(i),"LengthCodeSize",0)
						.LengthMode = GetSetting(AppName,"StringType_" & CStr$(i),"LengthMode",0)
						.LengthReviseVal = GetSetting(AppName,"StringType_" & CStr$(i),"LengthReviseVal",0)
						.ByteLengthReviseVal = GetSetting(AppName,"StringType_" & CStr$(i),"ByteLengthReviseVal",0)
						.CharLengthReviseVal = GetSetting(AppName,"StringType_" & CStr$(i),"CharLengthReviseVal",0)
						If k > 1 Then
							If .ByteLengthReviseVal = 0 Then .ByteLengthReviseVal = .LengthReviseVal
							If .CharLengthReviseVal = 0 Then .CharLengthReviseVal = .LengthReviseVal
						End If
						If .LengthMode = 1 Or .LengthMode = 5 Then
							.CharLengthReviseVal = 0
						ElseIf .LengthMode = 2 Or .LengthMode = 6 Then
							.ByteLengthReviseVal = 0
						End If
						.LengthMode = GetSetting(AppName,"StringType_" & CStr$(i),"LengthMode",0)
						.LengthCodeStartString = GetSetting(AppName,"StringType_" & CStr$(i),"LengthCodeStartString","")
						.StartCodePos = GetSetting(AppName,"StringType_" & CStr$(i),"StartCodePos",0)
						.StartCodeString = GetSetting(AppName,"StringType_" & CStr$(i),"StartCodeString","")
						.EndCodeString = GetSetting(AppName,"StringType_" & CStr$(i),"EndCodeString","")
						.RefCodeStartPos = GetSetting(AppName,"StringType_" & CStr$(i),"RefCodeStartPos",0)
						.RefCodeStartString = GetSetting(AppName,"StringType_" & CStr$(i),"RefCodeStartString","")
						.StartCodeLength = IIf(.CodeLoc > 0,0,Len(.StartCodeString) \ 2)
						.CPCodeStartLength = IIf(.CodeLoc = 0,0,Len(.CPCodeStartString) \ 2)
						.LengthCodeStartLength = IIf(.CodeLoc = 0,0,Len(.LengthCodeStartString) \ 2)
						.EndCodeLength = IIf(.CodeLoc > 0,0,Len(.EndCodeString) \ 2)
						.RefCodeStartLength = IIf(.CodeLoc = 0,0,Len(.RefCodeStartString) \ 2)
						.StartCodeByte = HexStr2Bytes(.StartCodeString)
						.EndCodeByte = HexStr2Bytes(.EndCodeString)
						.CPCodeStartByte = HexStr2Bytes(.CPCodeStartString)
						.LengthCodeStartByte = HexStr2Bytes(.LengthCodeStartString)
						.RefCodeStartByte = HexStr2Bytes(.RefCodeStartString)
						x = x + 1
					End If
				End With
			Next i
			If x > 0 Then x = x - 1
			ReDim Preserve StrTypeList(x) As STRING_TYPE
			'转换自定义字串类型为正则表达式模板
			Call StrType2RegExpPattern(StrTypeList)
			If x = j Then GetSettings = 4
		End If
		If SelSet = "Sets" Then Exit Function
	End If
	'获取自定义引用算法
	If SelSet = "" Or SelSet = "Ref" Then
		Temp = GetSetting(AppName,"Option","RefAlgorithmCount","")
		If Temp <> "" Then
			j = StrToLong(Temp): x = 0
			ReDim RefTypeList(j) As REF_TYPE
			For i = 0 To j
				With RefTypeList(x)
					.sName = GetSetting(AppName,"RefAlgorithm_" & CStr$(i),"Name","")
					If .sName <> "" Then
						.Algorithm = GetSetting(AppName,"RefAlgorithm_" & CStr$(i),"Algorithm","")
						.ByteLength = GetSetting(AppName,"RefAlgorithm_" & CStr$(i),"ByteLength",0)
						.ByteOrder = GetSetting(AppName,"RefAlgorithm_" & CStr$(i),"ByteOrder",0)
						.PrefixByte = GetSetting(AppName,"RefAlgorithm_" & CStr$(i),"PrefixByteRegExp","")
						.PrefixLength = GetSetting(AppName,"RefAlgorithm_" & CStr$(i),"PrefixByteLength",0)
						.StrAddAlgorithm = GetSetting(AppName,"RefAlgorithm_" & CStr$(i),"StrAddAlgorithm","")
						If InStr(LCase(.Algorithm),"{refstartaddress}") Then
							.FileMagic = "NotPE64"
						ElseIf InStr(LCase(.Algorithm),"{strstartaddress}") Then
							.FileMagic = "NotPE32"
						Else
							.FileMagic = ""
						End If
						.Template = RefTypeToString(RefTypeList,x)
						x = x + 1
					End If
				End With
			Next i
			If x > 0 Then x = x - 1
			ReDim Preserve RefTypeList(x) As REF_TYPE
			If x = j Then GetSettings = 10
		End If
		If SelSet = "Sets" Then Exit Function
	End If
	'获取自定义工具
	If SelSet = "" Or SelSet = "Tools" Then
		Temp = GetSetting(AppName,"Tools","Count","")
		If Temp <> "" Then
			j = StrToLong(Temp): x = 4
			ReDim Tools(j + x) As TOOLS_PROPERTIE
			For i = 0 To j
				Tools(x).sName = GetSetting(AppName,"Tools",CStr$(i) & "_Name","")
				Tools(x).FilePath = GetSetting(AppName,"Tools",CStr$(i) & "_Path","")
				Tools(x).Argument = GetSetting(AppName,"Tools",CStr$(i) & "_Argument","")
				If Tools(x).sName <> "" And Tools(x).FilePath <> "" Then
					x = x + 1
				End If
			Next i
			If x > 4 Then x = x - 1
			ReDim Preserve Tools(x) As TOOLS_PROPERTIE
			If x - 4 = j Then GetSettings = 5
		End If
		If SelSet = "Tools" Then Exit Function
	End If
	'获取自定义代码页
	If SelSet = "" Or SelSet = "CodePage" Then
		On Error Resume Next
		ReDim UniLangList(0) As LANG_PROPERTIE
		UniLangList(0).LangID = -2
		UniLangList(0).CodePage = -2
		TempList = GetAllSettings(AppName,"Languages")
		If CheckArrEmpty(TempList) = True Then
			j = UBound(TempList): x = -1
			ReDim Preserve UniLangList(j) As LANG_PROPERTIE
			For i = 0 To j
	 			TempArray = ReSplit(TempList(i,0),"_",2)
	 			If UBound(TempArray) > 0 Then
	 				x = StrToLong(TempArray(0))
					With UniLangList(x)
	 					Select Case TempArray(1)
	 					Case "LanguageID"
	 						.LangID = StrToLong(TempList(i,1))
	 					Case "CodePage"
							.CodePage = StrToLong(TempList(i,1),-1)
						Case "LanguageName"
							.LangName = TempList(i,1)
						Case "CodePageName"
							.CPName = TempList(i,1)
						Case "UniCodeRange"
							.UniCodeRange = TempList(i,1)
							.UniCodeRegExpPattern = "[\u" & Replace$(Replace$(.UniCodeRange,"-","-\u"),",","\u") & "]"
							.UniCodeByteRange = Convert(.UniCodeRegExpPattern)
						Case "FeatureCodeRange"
							.FeatureCode = TempList(i,1)
							.FeatureCodeRegExpPattern = "[\u" & Replace$(Replace$(.FeatureCode,"-","-\u"),",","\u") & "]"
							.FeatureCodeByteRange = Convert(.FeatureCodeRegExpPattern)
						Case "FeatureCodeEnable"
							.FeatureCodeEnable = StrToLong(TempList(i,1),0)
						End Select
						If .LangName <> "" Then .dwFlags = True
					End With
				End If
			Next i
			If x = j Then GetSettings = 6
			If x = -1 Then x = 0
			ReDim Preserve UniLangList(x) As LANG_PROPERTIE
		Else
			Temp = GetSetting(AppName,"Option","CodePageCount","")
			If Temp <> "" Then
				j = StrToLong(Temp)
				ReDim Preserve UniLangList(j) As LANG_PROPERTIE
				For i = 0 To j
	 				With UniLangList(i)
						.CodePage = GetSetting(AppName,"CodePage_" & CStr$(i),"CodePage",-1)
						.CPName = GetSetting(AppName,"CodePage_" & CStr$(i),"Name","")
						.UniCodeRange = GetSetting(AppName,"CodePage_" & CStr$(i),"UniCodeRange","")
						.UniCodeRegExpPattern = "[\u" & Replace$(Replace$(.UniCodeRange,"-","-\u"),",","\u") & "]"
						.UniCodeByteRange = Convert(.UniCodeRegExpPattern)
						.FeatureCode = GetSetting(AppName,"CodePage_" & CStr$(i),"FeatureCodeRange","")
						.FeatureCodeRegExpPattern = "[\u" & Replace$(Replace$(.FeatureCode,"-","-\u"),",","\u") & "]"
						.FeatureCodeByteRange = Convert(.FeatureCodeRegExpPattern)
						.FeatureCodeEnable = GetSetting(AppName,"CodePage_" & CStr$(i),"FeatureCodeEnable","0")
					End With
				Next i
				If SelSet = "CodePage" Then GetSettings = 6
			End If
		End If
		If SelSet = "CodePage" Then Exit Function
		On Error GoTo ExitFunction
	End If
	'获取过滤字串列表设置
	If SelSet = "" Or SelSet = "FilterStrDic" Then
		ExtractSet(34) = GetSetting(AppName,"GetString","UseMatchFilterListFile","1")
		ExtractSet(39) = GetSetting(AppName,"GetString","FilterListFileSelect","0")
		ExtractSet(35) = ""
		If ExtractSet(34) = "1" Then
			If SourceFile.FileName <> "" Then
				If InStr(SourceFile.FileName,".") > 1 Then
					Temp = LCase$(Left$(SourceFile.FileName,InStrRev(SourceFile.FileName,".") - 1)) & "*"
				Else
					Temp = LCase$(SourceFile.FileName) & "*"
				End If
				ReDim FileList(0) As FILE_LIST
				Select Case ExtractSet(39)
				Case "0"
					TempList = GetFiles(FileList,MacroLoc & "\Data\",SourceFile.FileName & ".sfl","*.sfl",True)
				Case "1"
					TempList = GetFiles(FileList,PSL.ActiveProject.Location & "\",SourceFile.FileName & ".sfl","*.sfl",True)
				Case Else
					ExtractSet(35) = GetSetting(AppName,"GetString","FilterListFolder","")
					If ExtractSet(35) = "" Then
						TempList = GetFiles(FileList,MacroLoc & "\Data\",SourceFile.FileName & ".sfl","*.sfl",True)
					ElseIf Dir$(ExtractSet(35),vbDirectory) = "" Then
						TempList = GetFiles(FileList,MacroLoc & "\Data\",SourceFile.FileName & ".sfl","*.sfl",True)
					Else
						TempList = GetFiles(FileList,ExtractSet(35) & "\",SourceFile.FileName & ".sfl","*.sfl",True)
					End If
					ExtractSet(35) = ""
				End Select
				For i = 0 To UBound(TempList)
					If (LCase$(TempList(i)) Like Temp) Then
						ExtractSet(35) = FileList(i).FilePath
						Exit For
					End If
				Next i
			End If
		End If
		If ExtractSet(35) = "" Then
			Select Case ExtractSet(39)
			Case "0"
				ExtractSet(35) = GetSetting(AppName,"GetString","FilterListFile",MacroLoc & "\Data\" & FilterFile)
				If InStr(ExtractSet(35),"\") = 0 Then ExtractSet(35) = MacroLoc & "\Data\" & ExtractSet(35)
				If Dir$(ExtractSet(35)) = "" Then ExtractSet(35) = MacroLoc & "\Data\" & FilterFile
			Case "1"
				ExtractSet(35) = GetSetting(AppName,"GetString","FilterListFile",PSL.ActiveProject.Location & "\" & SourceFile.FileName & ".sfl")
				If InStr(ExtractSet(35),"\") = 0 Then ExtractSet(35) = PSL.ActiveProject.Location & "\" & ExtractSet(35)
				If Dir$(ExtractSet(35)) = "" Then
					ExtractSet(35) = MacroLoc & "\Data\" & FilterFile
					ExtractSet(39) = "0"
				End If
			Case Else
				ExtractSet(35) = GetSetting(AppName,"GetString","FilterListFolder","")
				If ExtractSet(35) = "" Then
					ExtractSet(35) = MacroLoc & "\Data\" & FilterFile
					ExtractSet(39) = "0"
				ElseIf Dir$(ExtractSet(35),vbDirectory) = "" Then
					ExtractSet(35) = MacroLoc & "\Data\" & FilterFile
					ExtractSet(39) = "0"
				Else
					ExtractSet(35) = ExtractSet(35) & "\" & GetSetting(AppName,"GetString","FilterListFile",SourceFile.FileName & ".sfl")
					If Dir$(ExtractSet(35)) = "" Then
						ExtractSet(35) = MacroLoc & "\Data\" & FilterFile
						ExtractSet(39) = "0"
					End If
				End If
			End Select
		End If
		If SelSet = "FilterStrDic" Then
			If ExtractSet(35) <> "" Then GetSettings = 7
			Exit Function
		End If
	End If
	'获取保留字串列表设置
	If SelSet = "" Or SelSet = "ReserveStrDic" Then
		ExtractSet(36) = GetSetting(AppName,"GetString","UseMatchReserveListFile","0")
		ExtractSet(40) = GetSetting(AppName,"GetString","ReserveListFileSelect","0")
		ExtractSet(37) = ""
		If ExtractSet(36) = "1" Then
			If SourceFile.FileName <> "" Then
				If InStr(SourceFile.FileName,".") > 1 Then
					Temp = LCase$(Left$(SourceFile.FileName,InStrRev(SourceFile.FileName,".") - 1)) & ".*"
				Else
					Temp = LCase$(SourceFile.FileName) & ".*"
				End If
				ReDim FileList(0) As FILE_LIST
				Select Case ExtractSet(40)
				Case "0"
					TempList = GetFiles(FileList,MacroLoc & "\Data\",SourceFile.FileName & ".srl","*.srl",True)
				Case "1"
					TempList = GetFiles(FileList,PSL.ActiveProject.Location & "\",SourceFile.FileName & ".srl","*.srl",True)
				Case Else
					ExtractSet(37) = GetSetting(AppName,"GetString","ReserveListFolder","")
					If ExtractSet(37) = "" Then
						TempList = GetFiles(FileList,MacroLoc & "\Data\",SourceFile.FileName & ".srl","*.srl",True)
					ElseIf Dir$(ExtractSet(37),vbDirectory) = "" Then
						TempList = GetFiles(FileList,MacroLoc & "\Data\",SourceFile.FileName & ".srl","*.srl",True)
					Else
						TempList = GetFiles(FileList,ExtractSet(37) & "\",SourceFile.FileName & ".srl","*.srl",True)
					End If
					ExtractSet(37) = ""
				End Select
				For i = 0 To UBound(TempList)
					If (LCase$(TempList(i)) Like "*" & Temp) Then
						ExtractSet(37) = FileList(i).FilePath
						Exit For
					End If
				Next i
			End If
		End If
		If ExtractSet(37) = "" Then
			Select Case ExtractSet(40)
			Case "0"
				ExtractSet(37) = GetSetting(AppName,"GetString","ReserveListFile",MacroLoc & "\Data\" & ReserveFile)
				If InStr(ExtractSet(37),"\") = 0 Then ExtractSet(37) = MacroLoc & "\Data\" & ExtractSet(37)
				If Dir$(ExtractSet(37)) = "" Then ExtractSet(37) = MacroLoc & "\Data\" & ReserveFile
			Case "1"
				ExtractSet(37) = GetSetting(AppName,"GetString","ReserveListFile",PSL.ActiveProject.Location & "\" & SourceFile.FileName & ".srl")
				If InStr(ExtractSet(37),"\") = 0 Then ExtractSet(37) = PSL.ActiveProject.Location & "\" & ExtractSet(37)
				If Dir$(ExtractSet(37)) = "" Then
					ExtractSet(37) = MacroLoc & "\Data\" & ReserveFile
					ExtractSet(40) = "0"
				End If
			Case Else
				ExtractSet(37) = GetSetting(AppName,"GetString","ReserveListFolder","")
				If ExtractSet(37) = "" Then
					ExtractSet(37) = MacroLoc & "\Data\" & ReserveFile
					ExtractSet(40) = "0"
				ElseIf Dir$(ExtractSet(37),vbDirectory) = "" Then
					ExtractSet(37) = MacroLoc & "\Data\" & ReserveFile
					ExtractSet(40) = "0"
				Else
					ExtractSet(37) = ExtractSet(37) & "\" & GetSetting(AppName,"GetString","ReserveListFile",SourceFile.FileName & ".srl")
					If Dir$(ExtractSet(37)) = "" Then
						ExtractSet(37) = MacroLoc & "\Data\" & ReserveFile
						ExtractSet(40) = "0"
					End If
				End If
			End Select
		End If
		If SelSet = "ReserveStrDic" Then
			If ExtractSet(37) <> "" Then GetSettings = 8
			Exit Function
		End If
	End If
	'获取对话框字体设置
	If SelSet = "" Or InStr(";DlgFont;MainFont;SrcStrFont;TrnStrFont;",";" & SelSet & ";") Then
		Temp = IIf(SelSet = "DlgFont","_",SelSet & "_")
		TempList = GetAllSettings(AppName,"DlgFonts")
		x = 0
		For i = LBound(TempList) To UBound(TempList)
			TempArray = ReSplit(TempList(i,0),"_",2)
			If UBound(TempArray) > 0 Then
				Select Case TempArray(0)
				Case "MainFont"
					j = 0
				Case "SrcStrFont"
					j = 1
				Case "TrnStrFont"
					j = 2
				End Select
				With LFList(j)
					Select Case TempArray(1)
					Case "lfCharSet"
						.lfCharSet = StrToLong(TempList(i,1))
					Case "lfClipPrecision"
						.lfClipPrecision = StrToLong(TempList(i,1))
					Case "lfEscapement"
						.lfEscapement = StrToLong(TempList(i,1))
					Case "lfFaceName"
						TempByte = StrConv(TempList(i,1),vbFromUnicode)
						ReDim Preserve TempByte(31) As Byte
						CopyMemory .lfFaceName(0),TempByte(0),UBound(.lfFaceName) + 1
					Case "lfHeight"
						.lfHeight = StrToLong(TempList(i,1))
					Case "lfItalic"
						.lfItalic = StrToLong(TempList(i,1))
					Case "lfOrientation"
						.lfOrientation = StrToLong(TempList(i,1))
					Case "lfOutPrecision"
						.lfOutPrecision = StrToLong(TempList(i,1))
					Case "lfPitchAndFamily"
						.lfPitchAndFamily = StrToLong(TempList(i,1))
					Case "lfQuality"
						.lfQuality = StrToLong(TempList(i,1))
					Case "lfStrikeOut"
						.lfStrikeOut = StrToLong(TempList(i,1))
					Case "lfUnderline"
						.lfUnderline = StrToLong(TempList(i,1))
					Case "lfWeight"
						.lfWeight = StrToLong(TempList(i,1))
					Case "lfWidth"
						.lfWidth = StrToLong(TempList(i,1))
					Case "lfColor"
						.lfColor = StrToLong(TempList(i,1))
					End Select
					x = x + 1
				End With
			End If
		Next i
		If SelSet <> "" Then
			If x > 0 Then GetSettings = 9
			Exit Function
		End If
	End If
	ExitFunction:
End Function


'获取语言文件列表
Private Function GetUIList(ByVal UIDir As String,UIList() As UI_FILE) As Boolean
	Dim i As Long,j As Long,m As Long,n As Long
	Dim File As String,Header As String,TempArray() As String
	Dim tmpUIFile As UI_FILE,FN As Variant,readByte() As Byte
	ReDim UIList(0) As UI_FILE
	On Error Resume Next
	With tmpUIFile
		File = Dir$(UIDir & AppName & "_*.lng")
		Do While File <> ""
			If LCase$(Mid$(File,InStrRev(File,".") + 1)) = "lng" Then
				.FilePath = UIDir & File
				i = FileLen(.FilePath)
				ReDim readByte(i) As Byte
				FN = FreeFile
				Open .FilePath For Binary Access Read Lock Write As #FN
				Get #FN,,readByte
				Close #FN
				TempArray = ReSplit(readByte,vbCrLf)
				j = 0: Header$ = ""
				For i = 0 To UBound(TempArray)
					TempArray(i) = Trim(TempArray(i))
					If TempArray(i) Like "[[]*]" Then
						Header$ = Trim$(Mid$(TempArray(i),2,Len(TempArray(i)) - 2))
						If j > 0 Then
							If Header$ <> "Option" Then Exit For
							j = 0
						End If
					ElseIf Header$ = "Option" Then
						j = InStr(TempArray(i),"=")
						If j > 0 Then
							Select Case Trim$(Left$(TempArray(i),j - 1))
							Case "AppName"
								.AppName = RemoveBackslash(Mid$(TempArray(i),j + 1),"""","""",1)
							Case "Version"
								.Version = RemoveBackslash(Mid$(TempArray(i),j + 1),"""","""",1)
							Case "LanguageName"
								.LangName = RemoveBackslash(Mid$(TempArray(i),j + 1),"""","""",1)
							Case "LanguageID"
								.LangID = RemoveBackslash(Mid$(TempArray(i),j + 1),"""","""",1)
							Case "Encoding"
								.Encoding = RemoveBackslash(Mid$(TempArray(i),j + 1),"""","""",1)
							End Select
						End If
						j = 1
					End If
				Next i
				If LCase$(.AppName) = LCase$(AppName) Then
					If .Version = Version And .LangName <> "" Then
						If n > m Then
							m = n * 10
							ReDim Preserve UIList(m) As UI_FILE
						End If
						UIList(n) = tmpUIFile
						n = n + 1
					End If
					.AppName = "": .Version = "": .LangName = "": .LangID = "": .Encoding = ""
				End If
			End If
			File = Dir$()
		Loop
	End With
	If n > 0 Then
		GetUIList = True
		n = n - 1
	End If
	ReDim Preserve UIList(n) As UI_FILE
End Function


'读取界面语言字串
Private Function GetUI(ByVal UIDir As String,ByVal UISet As String,ByVal OSLng As String,UIData() As INIFILE_DATA,UIFiles() As UI_FILE,LngFile As String) As Boolean
	Dim i As Long,j As Long,n As Long
	Dim TempList() As String,TempArray() As String
	If GetUIList(UIDir,UIFiles) = True Then
		Select Case UISet
		Case "","0"
			UISet = OSLng
		Case "1"
			UISet = Right$("0" & Hex$(PSL.Option(pslOptionSystemLanguage)),4)
		End Select
		UISet = LCase$(UISet)
		TempList = ReSplit(UISet,";")
		For i = 0 To UBound(UIFiles)
			If LCase$(UIFiles(i).LangID) = UISet Then
				LngFile = UIFiles(i).FilePath
				Exit For
			End If
			TempArray = ReSplit(LCase$(UIFiles(i).LangID),";")
			For j = 0 To UBound(TempList)
				For n = 0 To UBound(TempArray)
					If TempList(j) = TempArray(n) Then
						LngFile = UIFiles(i).FilePath
						Exit For
					End If
				Next n
				If LngFile <> "" Then Exit For
			Next j
			If LngFile <> "" Then Exit For
		Next i
	End If
	If LngFile = "" Then LngFile = UIDir & AppName & "_" & OSLng & ".lng"
	If Dir$(LngFile) = "" Then
		For i = 0 To 2
			If i = 0 Then
				LngFile = UIDir & AppName & "_0804.lng"
			ElseIf i = 1 Then
				LngFile = UIDir & AppName & "_0404.lng"
			Else
				LngFile = UIFiles(0).FilePath
			End If
			If Dir$(LngFile) <> "" Then Exit For
			LngFile = ""
		Next i
		If LngFile = "" Then Err.Raise(1,"NotExitFile",UIDir & AppName & "_*.lng")
	End If
	GetUI = getINIFile(UIData,LngFile,"unicodeFFFE",0)
End Function


'自动添加和删除 Passolo 注释
Private Sub AutoComment(ByVal Index As Long,ByVal SplitMode As Integer,MsgList() As String)
	Dim i As Long,IDList() As Integer,TempList() As String,hcsTrn As PslTransList
	For i = 1 To trn.Project.SourceLists.Count
		If trn.Project.SourceLists(i).SourceFile = SourceFile.hcsFile.FilePath Then
			Set hcsTrn = trn.Project.TransLists(trn.Project.SourceLists(i),trn.Language.LangID)
			If hcsTrn.IsOpen = False Then Exit Sub
			If hcsTrn.SourceList.LastChange > hcsTrn.LastUpdate Then hcsTrn.Update
			Exit For
		End If
	Next i
	If hcsTrn Is Nothing Then Exit Sub
	With AllStrDataList(Index)
		If .Trans.lReferenceNum > 0 Then
			If .SplitState > -1 Then
				If .Trans.lReferenceNum <> .Source.lReferenceNum Then
					TempList = RefList2StrList(.Trans,0)
					IDList = GetChangeIndexList(TempList,RefList2StrList(.Source,0))
					For i = 0 To UBound(IDList)
						TempList(i) = CStr$(IDList(i) + 1)
					Next i
					Select Case SplitMode
					Case 0,2
						AddComment hcsTrn,Index,Replace$(MsgList(123),"%s",Join$(TempList,ValJoinStr)),MsgList(125),MsgList(123) & TextJoinStr & MsgList(124)
					Case -1,1,3
						AddComment hcsTrn,Index,Replace$(MsgList(124),"%s",Join$(TempList,ValJoinStr)),MsgList(125),MsgList(123) & TextJoinStr & MsgList(124)
					End Select
				Else
					AddComment hcsTrn,Index,"",MsgList(125),MsgList(123) & TextJoinStr & MsgList(124)
				End If
			Else
				Index = StrIDIndexDic.Item(-.SplitState)
				TempList = RefList2StrList(AllStrDataList(Index).Trans,0)
				IDList = GetChangeIndexList(TempList,RefList2StrList(AllStrDataList(Index).Source,0))
				For i = 0 To UBound(IDList)
					TempList(i) = CStr$(IDList(i) + 1)
				Next i
				AddComment hcsTrn,Index,Replace$(MsgList(124),"%s",Join$(TempList,ValJoinStr)),MsgList(125),MsgList(123) & TextJoinStr & MsgList(124)
			End If
		Else
			If .SplitState > -1 Then
				AddComment hcsTrn,Index,"",MsgList(125),MsgList(123) & TextJoinStr & MsgList(124)
			Else
				Index = StrIDIndexDic.Item(-.SplitState)
				TempList = RefList2StrList(AllStrDataList(Index).Trans,0)
				IDList = GetChangeIndexList(TempList,RefList2StrList(AllStrDataList(Index).Source,0))
				For i = 0 To UBound(IDList)
					TempList(i) = CStr$(IDList(i) + 1)
				Next i
				AddComment hcsTrn,Index,Replace$(MsgList(124),"%s",Join$(TempList,ValJoinStr)),MsgList(125),MsgList(123) & TextJoinStr & MsgList(124)
			End If
		End If
	End With
End Sub


'添加和删除 Passolo 注释
Private Sub AddComment(hcsTrn As PslTransList,ByVal TextID As Long,ByVal NewComment As String,ByVal Pattern As String,Optional ByVal DefaultComment As String)
	Dim i As Long,j As Long,n As Long,StrCountDiff As Long,Matches As Object
	StrCountDiff = Abs(UBound(AllStrDataList) - hcsTrn.StringCount + 1)
	n = IIf(TextID - StrCountDiff + 1 < 1,1,TextID - StrCountDiff + 1)
	For i = n To IIf(TextID + 1 > hcsTrn.StringCount,hcsTrn.StringCount,TextID + 1)
		If hcsTrn.String(i).SourceText = AllStrDataList(TextID).Source.sString Then
			If Trim$(hcsTrn.String(i).TransComment) = "" Then
				hcsTrn.String(i).TransComment = NewComment
			ElseIf InStr(DefaultComment,TextJoinStr) Then
				RegExp.Global = True
				RegExp.IgnoreCase = True
				ReDim TempList(0) As String
				TempList = ReSplit(DefaultComment,TextJoinStr)
				For j = 0 To UBound(TempList)
					RegExp.Pattern = Replace$(TempList(j)," %s ",Pattern)
					If RegExp.Pattern = TempList(j) Then
						RegExp.Pattern = Replace$(TempList(j),"%s",Pattern)
					End If
					Set Matches = RegExp.Execute(hcsTrn.String(i).TransComment)
					If Matches.Count > 0 Then
						ReDim TempList(0) As String
						TempList(0) = hcsTrn.String(i).TransComment
						For n = 0 To Matches.Count - 1
							TempList(0) = Replace(TempList(0),Matches(n).Value,NewComment)
						Next n
						hcsTrn.String(i).TransComment = Join$(TempList,"")
						Exit For
					End If
				Next j
			ElseIf DefaultComment = "" Then
				hcsTrn.String(i).TransComment = NewComment
			End If
			Exit For
		End If
	Next i
End Sub


'添加和删除 Passolo 注释对话框
Private Function EditComment(ByVal Source As String,ByVal TextID As Long,ByVal MaxStrCount As Long) As Boolean
	Dim i As Long,MsgList() As String,hcsTrn As PslTransList
	If getMsgList(UIDataList,MsgList,"EditComment",1) = False Then Exit Function
	'查找翻译 HCS 对应的翻译列表
	For i = 1 To trn.Project.SourceLists.Count
		If trn.Project.SourceLists(i).SourceFile = SourceFile.hcsFile.FilePath Then
			Set hcsTrn = trn.Project.TransLists(trn.Project.SourceLists(i),trn.Language.LangID)
			If hcsTrn.SourceList.LastChange > hcsTrn.LastUpdate Then hcsTrn.Update
			Exit For
		End If
	Next i
	If hcsTrn Is Nothing Then Exit Function
	'获取翻译列表中和选定字串对应的字串
	i = MaxStrCount - hcsTrn.StringCount
	If i < 0 Then
		MsgBox MsgList(7),vbOkOnly+vbInformation,MsgList(6)
		Exit Function
	End If
	With hcsTrn
		MaxStrCount = IIf(TextID + 1 > .StringCount,.StringCount,TextID + 1)
		TextID = IIf(TextID - i + 1 < 1,1,TextID - i + 1)
		For i = TextID To MaxStrCount
			If .String(i).SourceText = Source Then
				i = -i
				Exit For
			End If
		Next i
	End With
	If i > 0 Then
		MsgBox MsgList(8),vbOkOnly+vbInformation,MsgList(6)
		Exit Function
	End If
	'打开对话框
	Begin Dialog UserDialog 650,252,MsgList(0),.EditCommentDlgFunc ' %GRID:10,7,1,1
		Text 10,7,630,14,MsgList(1),.SourceText
		TextBox 10,28,630,49,.SourceTextBox,1
		Text 10,84,630,14,MsgList(2),.CommentText
		TextBox 10,105,630,91,.CommentTextBox,1
		TextBox 10,105,630,91,.CommentTextBoxBak,1
		Text 10,203,630,14,MsgList(3),.Text1
		PushButton 10,224,100,21,MsgList(4),.ResetButton
		PushButton 130,224,100,21,MsgList(5),.CleanButton
		OKButton 420,224,100,21,.OKButton
		CancelButton 540,224,100,21,.CancelButton
	End Dialog
	Dim dlg As UserDialog
	dlg.SourceTextBox = Source
	dlg.CommentTextBox = hcsTrn.String(-i).TransComment
	dlg.CommentTextBoxBak = dlg.CommentTextBox
	If Dialog(dlg) = 0 Then Exit Function
	If dlg.CommentTextBoxBak = dlg.CommentTextBox Then Exit Function
	'打开翻译列表，以便写入注释
	If hcsTrn.IsOpen = False Then
		If hcsTrn.Open = False Then Exit Function
		EditComment = True
	End If
	hcsTrn.String(-i).TransComment = dlg.CommentTextBox
	'关闭自动打开的翻译列表
	If EditComment = True Then hcsTrn.Close
	EditComment = True
End Function


'选择翻译对话框函数
Private Function EditCommentDlgFunc(DlgItem$, Action%, SuppValue&) As Boolean
	Dim i As Long,j As Long
	Select Case Action%
	Case 1 ' 对话框窗口初始化
		DlgVisible "CommentTextBoxBak",False
		DlgEnable "SourceTextBox",False
		'设置当前对话框字体
		If CheckFont(LFList(0)) = True Then
			j = CreateFont(0,LFList(0))
			If j = 0 Then Exit Function
			For i = 0 To DlgCount() - 1
				SendMessageLNG(GetDlgItem(SuppValue,DlgControlId(DlgName(i))),WM_SETFONT,j,0)
			Next i
		End If
	Case 2 ' 数值更改或者按下按钮时
		EditCommentDlgFunc = True ' 防止按下按钮时关闭对话框窗口
		Select Case DlgItem$
		Case "OKButton","CancelButton"
			EditCommentDlgFunc = False
			Exit Function
		Case "ResetButton"
			DlgText "CommentTextBox",DlgText("CommentTextBoxBak")
		Case "CleanButton"
			DlgText "CommentTextBox",""
		End Select
	End Select
End Function


'显示或取消取消进程按钮
Private Sub ShowButton(ByVal ButtonHwnd As Long,ByVal KeyHwnd As Long,ByVal Mode As Boolean)
	If Mode = True Then
		'显示取消操作按钮
		ShowWindow ButtonHwnd, SW_SHOW
		'禁用 Esc 键，因主对话框会响应而退出
		EnableWindow KeyHwnd,False
		'清除按键记录，因为 GetAsyncKeyState 会记录最近一次
		GetAsyncKeyState KeyHwnd
	Else
		'隐藏取消操作按钮
		ShowWindow ButtonHwnd, SW_HIDE
		'启用 Esc 键，因主对话框会响应而被禁用
		EnableWindow KeyHwnd, True
	End If
End Sub


'取消进程确认
Private Function StopProcess(ByVal ButtonHwnd As Long,ByVal KeyHwnd As Long) As Boolean
	If GetAsyncKeyState(KeyHwnd) < 0 Then
		'SendMessageLNG(ButtonHwnd,BM_SETSTATE,True,0)
		If MsgBox(StopMsg,vbYesNo+vbInformation,StopTitle) = vbNo Then Exit Function
	ElseIf SendMessageLNG(ButtonHwnd,BM_GETSTATE,0,0) = WM_MBUTTONUP Then
		'SendMessageLNG(ButtonHwnd,BM_SETSTATE,True,0)
		If MsgBox(StopMsg,vbYesNo+vbInformation,StopTitle) = vbNo Then Exit Function
	Else
		Exit Function
	End If
	'隐藏取消操作按钮
	ShowWindow ButtonHwnd, SW_HIDE
	'禁用 Esc 键，因主对话框会响应而退出
	EnableWindow KeyHwnd, False
	StopProcess = True
End Function


'检查并对齐节表的偏移和虚拟大小，以便正确获取节的结尾地址
'Mode = 0 检查并对齐节表的偏移大小
'Mode = 1 检查并对齐节表的虚拟大小
'Mode > 1 检查并对齐节表的偏移和虚拟大小
Private Sub CheckSection(File As FILE_PROPERTIE,ByVal Mode As Long)
	Dim i As Integer,j As Long,k As Long
	If File.Magic = "" Then Exit Sub
	With File
		If Mode = 0 Or Mode > 1 Then
			For i = 0 To .MaxSecIndex - 1
				If .SecList(i).lSizeOfRawData <> 0 And .SecList(i).lPointerToRawData <> 0 Then
					j = GetSectionID(File,i,-1,False)
					If j > i Then
						k = .SecList(i).lPointerToRawData + .SecList(i).lSizeOfRawData
						If .SecList(j).lPointerToRawData <> k Then
							.SecList(i).lSizeOfRawData = .SecList(j).lPointerToRawData - .SecList(i).lPointerToRawData
						End If
					End If
				End If
			Next i
		End If
		If Mode > 0 Then
			For i = 0 To .MaxSecIndex - 1
				If .SecList(i).lVirtualSize <> 0 And .SecList(i).lVirtualAddress <> 0 Then
					j = GetSectionID(File,i,-1,True)
					If j > i Then
						k = .SecList(i).lVirtualAddress + .SecList(i).lVirtualSize
						If .SecList(j).lVirtualAddress <> k Then
							.SecList(i).lVirtualSize = .SecList(j).lVirtualAddress - .SecList(i).lVirtualAddress
						End If
					End If
				End If
			Next i
		End If
	End With
End Sub


'增加文件节长度
'fType = 0 获取可增加的字节数，修改原始文件头不写入
'fType = 1 写入指定长度对齐后的字节数，不修改原始文件头仅写入
'fType = 2 写入指定长度对齐后的字节数，修改原始文件头
'fType = 3 不修改不写入，仅获取可增加值(AddSecSize(x).Length 为偏移大小，AddSecSize(x).Address 为虚拟大小)
'AddSecSize(x).Length = 0，按可增加的最大值增加，否则按 AddSecSize(x).Length 对齐值增加
Private Function AddSectionSize(trnFile As FILE_PROPERTIE,AddSecSize() As FREE_BTYE_SPACE,ByVal fType As Long,ByVal Mode As Long) As Long
	Select Case trnFile.Magic
	Case "PE32","NET32","PE64","NET64"
		AddSectionSize = AddPESectionSize(trnFile,AddSecSize,fType,Mode)
	Case "MAC32","MAC64"
		AddSectionSize = AddMacSectionSize(trnFile,AddSecSize,fType,Mode)
	Case "NotPE32","NotPE64"
		AddSectionSize = AddPESectionSize(trnFile,AddSecSize,fType,Mode)
	End Select
End Function


'在文件尾部增加一个文件节
'fType = 0 只修改文件节数据不写入
'fType = 1 不修改文件节数据但写入
'fType = 2 既修改文件节数据又写入
Private Function AddSection(trnFile As FILE_PROPERTIE,AddSecSize As FREE_BTYE_SPACE,ByVal fType As Long,ByVal Mode As Long) As Long
	Select Case trnFile.Magic
	Case "PE32","NET32","PE64","NET64"
		AddSection = AddPESection(trnFile,AddSecSize,NewPESecName,fType,Mode)
	Case "MAC32","MAC64"
		AddSection = AddMacSection(trnFile,AddSecSize,NewMacSecName,fType,Mode)
	Case "NotPE32","NotPE64"
		ReDim AddSecSizes(0) As FREE_BTYE_SPACE
		AddSecSizes(0) = AddSecSize
		AddSection = AddPESectionSize(trnFile,AddSecSizes,fType,Mode)
	End Select
End Function


'获取指定地址的引用代码、所在区段并检查引用前的字串类型
Private Sub GetRefFromRefAdd(File As FILE_PROPERTIE,FN As FILE_IMAGE,strData As STRING_SUB_PROPERTIE, _
		TypeList() As STRING_TYPE,ByVal TagType As Integer,ByVal RefAdds As String,ByVal Mode As Long,ByVal fType As Integer)
	On Error GoTo ExitSub
	If RefAdds = "" Then
		ReDim RefList(0) As REFERENCE_PROPERTIE
		strData.lReferenceNum = 0
		strData.GetRefState = IIf(fType = -1,0,1)
		strData.Reference = RefList
		Exit Sub
	ElseIf RefAdds = "0" Then
		ReDim RefList(0) As REFERENCE_PROPERTIE
		strData.lReferenceNum = 0
		strData.GetRefState = 0
		strData.Reference = RefList
		Exit Sub
	End If
	Dim i As Long
	ReDim TempList(0) As String
	TempList = ReSplit(Trim$(RefAdds),RefJoinStr)
	With strData
		.lReferenceNum = UBound(TempList) + 1
		.GetRefState = 1
		ReDim RefList(.lReferenceNum - 1) As REFERENCE_PROPERTIE
		.Reference = RefList
		If InStr(File.Magic,"NotPE") = 0 Then
			For i = 0 To .lReferenceNum - 1
				.Reference(i).lAddress = StrToLong(TempList(i))
				.Reference(i).inSecID = SkipSection(File,.Reference(i).lAddress,0,0)
				.Reference(i).sCode = Byte2Hex(GetBytes(FN,4,.Reference(i).lAddress,Mode),0,3)
				If TagType > 1 Then
					Call GetCustomStrTypeRegExp(FN,strData,TypeList,Mode,-1)
				End If
			Next i
		Else
			For i = 0 To .lReferenceNum - 1
				.Reference(i).lAddress = StrToLong(TempList(i))
				.Reference(i).inSecID = SkipSection(File,.Reference(i).lAddress,0,0)
				.Reference(i).sCode = Byte2Hex(GetBytes(FN,UseRefTypeList(0).ByteLength,.Reference(i).lAddress,Mode),0,UseRefTypeList(0).ByteLength - 1)
				If TagType > 1 Then
					Call GetCustomStrTypeRegExp(FN,strData,TypeList,Mode,-1)
				End If
			Next i
		End If
	End With
	Exit Sub
	ExitSub:
	ReDim RefList(0) As REFERENCE_PROPERTIE
	strData.lReferenceNum = 0
	strData.GetRefState = 0
	strData.Reference = RefList
End Sub


'获取自定义引用算法列表
'获取自定义引用算法列表
'FileName = "" 直接退出
'返回 AddRefTypeList = True 表示有新增类型
Private Function AddRefTypeList(TypeList() As REF_TYPE,ByVal FileName As String,ByVal Data As String,ByVal Mode As Long) As Boolean
	Dim i As Long,n As Long,Stemp As Boolean
	Dim TempList() As String,RuleDic As Object,NameDic As Object
	If FileName = "" Then Exit Function
	If Data = "" Then Exit Function
	If Mode > 0 Then Exit Function
	Mode = IIf(Mode = 0,0,1)
	TempList = ReSplit(Data,ValJoinStr)
	If Mode = 0 Then
		If CheckRefTypeArray(RefTypeList) = True Then
			Set RuleDic = CreateObject("Scripting.Dictionary")
			Set NameDic = CreateObject("Scripting.Dictionary")
			n = UBound(RefTypeList)
			For i = 0 To n
				If Not RuleDic.Exists(RefTypeList(i).Template) Then
					RuleDic.Add(RefTypeList(i).Template,i)
				End If
				If Not NameDic.Exists(RefTypeList(i).sName) Then
					NameDic.Add(RefTypeList(i).sName,i)
				End If
			Next i
			Stemp = True
		End If
		ReDim Preserve RefTypeList(n + 1) As REF_TYPE
	End If
	With TypeList(Mode)
		.Algorithm = Trim$(TempList(0))
		.ByteLength = StrToLong(TempList(1))
		.ByteOrder = StrToLong(TempList(2))
		Select Case UBound(TempList)
		Case Is > 4
			.PrefixByte = Trim$(TempList(3))
			.PrefixLength = StrToLong(TempList(4))
			.StrAddAlgorithm = Trim$(TempList(5))
		Case Is > 2
			.PrefixByte = Trim$(TempList(3))
			.PrefixLength = StrToLong(TempList(4))
		End Select
		If InStr(LCase(.Algorithm),"{refstartaddress}") Then
			.FileMagic = "NotPE64"
		ElseIf InStr(LCase(.Algorithm),"{strstartaddress}") Then
			.FileMagic = "NotPE32"
		Else
			.FileMagic = ""
		End If
		.Template = RefTypeToString(TypeList,Mode)
		If Mode = 0 Then
			If Stemp = True Then
				If Not RuleDic.Exists(.Template) Then
					i = 0
					Do
						.sName = FileName & IIf(i = 0,"","_" & CStr$(i))
						If Not NameDic.Exists(.sName) Then Exit Do
						i = i + 1
					Loop
					n = n + 1
					RefTypeList(n) = TypeList(Mode)
					AddRefTypeList = True
				Else
					.sName = RefTypeList(RuleDic.Item(.Template)).sName
				End If
			Else
				.sName = FileName
				RefTypeList(n) = TypeList(Mode)
				AddRefTypeList = True
			End If
		End If
		.Algorithm = LCase$(.Algorithm)
		.StrAddAlgorithm = LCase$(.StrAddAlgorithm)
	End With
	If Mode = 0 Then ReDim Preserve RefTypeList(n) As REF_TYPE
	Set RuleDic = Nothing
	Set NameDic = Nothing
End Function


'转换自定义引用类型为字串
Private Function RefTypeToString(TypeList() As REF_TYPE,ByVal Index As Long) As String
	Dim i As Long,Min As Long,Max As Long,List(5) As String
	If CheckRefTypeArray(TypeList) = False Then Exit Function
	If Index > -1 Then
		Min = Index: Max = Index
		ReDim TempList(0) As String
	Else
		Min = LBound(TypeList): Max = UBound(TypeList)
		ReDim TempList(Min To Max) As String
	End If
	For i = Min To Max
		With TypeList(i)
			List(0) = .Algorithm
			List(1) = CStr(.ByteLength)
			List(2) = CStr(.ByteOrder)
			List(3) = .PrefixByte
			List(4) = CStr(.PrefixLength)
			List(5) = .StrAddAlgorithm
			If Index > -1 Then
				TempList(0) = StrListJoin(List,ValJoinStr)
			Else
				TempList(i) = StrListJoin(List,ValJoinStr)
			End If
		End With
	Next i
	RefTypeToString = StrListJoin(TempList,ItemJoinStr)
End Function


'获取工具数据数组的工具名称列表
Public Function GetRefTypeNameList(DataList() As REF_TYPE) As String()
	Dim i As Long
	ReDim TempList(UBound(DataList)) As String
	For i = 0 To UBound(DataList)
		TempList(i) = DataList(i).sName
	Next i
	GetRefTypeNameList = TempList
End Function


'删除自定义类型数组项目
Private Sub DelRefTypeArray(DataList() As REF_TYPE,ByVal IDList As Variant)
	Dim i As Long,n As Long
	If IsArray(IDList) Then
		If UBound(DataList) = UBound(IDList) Then
			ReDim DataList(0) As REF_TYPE
			Exit Sub
		End If
		ReDim Stemp(UBound(DataList)) As Long
		For i = LBound(IDList) To UBound(IDList)
			If IDList(i) > -1 Then Stemp(IDList(i)) = 1
		Next i
		n = IDList(LBound(IDList))
		For i = IDList(LBound(IDList)) To UBound(DataList)
			If Stemp(i) = 0 Then
				DataList(n) = DataList(i)
				n = n + 1
			End If
		Next i
	ElseIf IsNumeric(IDList) Then
		n = IDList
		For i = IDList + 1 To UBound(DataList)
			DataList(n) = DataList(i)
			n = n + 1
		Next i
	ElseIf IDList <> "" Then
		For i = LBound(DataList) To UBound(DataList)
			If DataList(i).sName <> IDList Then
				DataList(n) = DataList(i)
				n = n + 1
			End If
		Next i
	Else
		Exit Sub
	End If
	If n > 0 Then
		ReDim Preserve DataList(n - 1) As REF_TYPE
	Else
		ReDim DataList(0) As REF_TYPE
	End If
End Sub


'获取文件及子文件的数据结构信息
Private Function GetHeaders(ByVal strFilePath As String,File As FILE_PROPERTIE,ByVal Mode As Long,FileType As Integer) As Boolean
	Select Case GetFileFormat(File.FilePath,Mode,FileType)
	Case "PE","NET",""
		GetHeaders = GetPEHeaders(File.FilePath,File,Mode)
	Case "MAC"
		GetHeaders = GetMacHeaders(File.FilePath,File,Mode)
	End Select
End Function


'获取原址内移位的字串引用
Private Function GetVARefForMoveMode2(trnFile As FILE_PROPERTIE,strData As STRING_PROPERTIE) As STRING_PROPERTIE
	Dim VAList() As String
	GetVARefForMoveMode2 = strData
	With strData
		If .Source.MoveLength + .Trans.MoveLength = 0 Then Exit Function
		If .Moveable > 0 Then Exit Function
		If .Source.lReferenceNum = 0 Then Exit Function
		If .WriteType > 2 Then Exit Function
		GetVARefForMoveMode2.Trans.Reference = .Source.Reference
		GetVARefForMoveMode2.Trans.lReferenceNum = .Source.lReferenceNum
		VAList = ChangeList(RefList2StrList(.Source,0),RefList2StrList(.Trans,0))
		Call GetVARefList(trnFile,"",GetVARefForMoveMode2.Trans,OrgStrTypeList,.TagType,.Moveable,StrListJoin(VAList,RefJoinStr),2,0,0)
	End With
End Function
